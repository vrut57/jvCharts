(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";

var html = "<!--Top title bar of edit popup-->\n<div class='title'>\n    <div class=\"jv-inline\">\n        <b>Edit Options<div id=\"edit-option-element\" class=\"jv-inline\" style=\"visibility: hidden;\"></div>:</b>\n    </div>\n\n    <div id='exitEditMode' class='jv-pull-right jv-pointer'>\n        <i class='fa fa-times'></i>\n    </div>\n</div>\n\n<!--Line dividing top bar with form options below-->\n<hr style='margin:3px 0 3px 0;'/>\n\n<!--Form Options-->\n<div id=\"form'+chart.config.name+'\">\n\n    <!--Number formatting options-->\n    <div class=\"jv-full-width editable-num-format\" style=\"display: none;\">\n        <div class=\"jv-edit-mode-input\">Number Format:\n            <select id=\"editable-num-format\">\n                <option value=\"\">--Select Option--</option>\n                <option value=\"currency\">Currency</option>\n                <option value=\"fixedCurrency\">Fixed Point Currency</option>\n                <option value=\"percent\">Percent</option>\n                <option value=\"millions\">Millions</option>\n                <option value=\"commas\">Commas</option>\n                <option value=\"none\">None</option>\n            </select>\n        </div>\n        <br/>\n    </div>\n\n    <!--Text formatting options-->\n    <div class=\"editable-text-size-buttons jv-center topBarOption increasefont jv-pointer\" style=\"display: none;\">\n        <button id='decreaseFontSize' title='Decrease the font size' class='topbar-button font jv-button jv-pointer'><i class='fa fa-font'></i><i class='fa fa-long-arrow-down'></i></button>\n        <button id='increaseFontSize' title='Increase the font size' class='topbar-button font jv-button jv-pointer'><i class='fa fa-font'></i><i class='fa fa-long-arrow-up'></i></button>\n    </div>\n\n\n    <div class=\"jv-full-width editable-text-color\" style=\"display: none;\">\n        <div class=\"jv-edit-mode-input\">Text Color:\n            <input type=\"color\" id=\"editable-text-color\" value=\"#000000\">\n        </div>\n        <br/>\n    </div>\n\n    <div class=\"jv-full-width editable-text-size\" style=\"display: none;\">\n        <div class=\"jv-edit-mode-input\">Text Size:\n            <input type=\"number\" id=\"editable-text-size\" min=\"0\" max=\"30\" value=\"12\">\n        </div>\n        <br/>\n    </div>\n\n    <div class=\"jv-full-width editable-content\" style=\"display: none;\">\n        <div class=\"jv-edit-mode-input\">Text:\n            <input type=\"text\" id=\"editable-content\" placeholder=\"Enter text here\">\n        </div>\n        <br/>\n    </div>\n\n    <!--bar chart formatting-->\n    <div class=\"jv-full-width editable-bar\" style=\"display: none;\">\n        <div class=\"jv-edit-mode-input\">Bar Color:\n            <input type=\"color\" id=\"editable-bar\" value=\"#aaaaaa\">\n        </div>\n        <br/>\n    </div>\n\n    <!--pie chart formatting-->\n    <div class=\"jv-full-width editable-pie\" style=\"display: none;\">\n        <div class=\"jv-edit-mode-input\">Pie Slice Color:\n            <input type=\"color\" id=\"editable-pie\" value=\"#aaaaaa\">\n        </div>\n        <br/>\n    </div>\n\n    <!--scatter plot formatting-->\n    <div class=\"jv-full-width editable-scatter\" style=\"display: none;\">\n        <div class=\"jv-edit-mode-input\">Scatter Circle Color:\n            <input type=\"color\" id=\"editable-scatter\" value=\"#aaaaaa\">\n        </div>\n        <br/>\n    </div>\n\n    <!--bubble chart formatting-->\n    <div class=\"jv-full-width editable-bubble\" style=\"display: none;\">\n        <div class=\"jv-edit-mode-input\">Bubble Color:\n            <input type=\"color\" id=\"editable-bubble\" value=\"#aaaaaa\">\n        </div>\n        <br/>\n    </div>\n\n    <!--box and whisker plot formatting-->\n    <div class=\"jv-full-width editable-box\" style=\"display: none;\">\n        <div class=\"jv-edit-mode-input\">Box Color:\n            <input type=\"color\" id=\"editable-box\" value=\"#aaaaaa\">\n        </div>\n        <br/>\n    </div>\n\n    <!--Submit button-->\n    <div class=\"editable-default-and-apply\">\n        <button id=\"submitEditModeDefault\" class=\"jv-button jv-pull-left\">Default</button>\n        <button id=\"submitEditMode\" class=\"jv-button jv-button-green jv-pull-right\">Apply</button>\n    </div>\n</div>";

module.exports = html;

},{}],2:[function(require,module,exports){
'use strict';
//add all required files

require('./jvVars.js');
require('./jvEvents.js');
require('./jvTip.js');
require('./jvBrush.js');
require('./jvComment.js');
require('./jvEdit.js');
require('./visuals/jvBar.js');
require('./visuals/jvPie.js');
require('./visuals/jvLine.js');
require('./visuals/jvScatter.js');
require('./visuals/jvArea.js');
require('./visuals/jvGantt.js');
require('./visuals/jvHeatmap.js');
require('./visuals/jvPack.js');
require('./visuals/jvRadial.js');
require('./visuals/jvSankey.js');
require('./visuals/jvSingleAxis.js');
require('./visuals/jvSunburst.js');
require('./visuals/jvTreemap.js');
require('./visuals/jvWordCloud.js');
require('./visuals/jvBoxWhisker.js');
require('./visuals/jvBubble.js');
require('./visuals/jvClustergram.js');

//attach jv charts objects to the window
var jvCharts = require('./jvCharts.js');
var jvBrush = require('./jvBrush.js');
var jvComment = require('./jvComment.js');
var jvEdit = require('./jvEdit.js');
var jvSelect = require('./jvSelect');
// var jvDoodle = require('./jvDoodle.js');

//Comment out to remove from window object - if you are not using jvCharts as a minified file
window.jvCharts = jvCharts;
window.jvBrush = jvBrush;
window.jvComment = jvComment;
window.jvEdit = jvEdit;
window.jvSelect = jvSelect;

//add polyfill for Object.assign() if unsupported
if (typeof Object.assign !== 'function') {
    Object.assign = function (target) {
        //.length of function is 2
        'use strict';

        if (target == null) {
            //TypeError if undefined or null
            throw new TypeError('Cannot convert undefined or null to object');
        }
        var to = Object(target);
        for (var index = 1; index < arguments.length; index++) {
            var nextSource = arguments[index];

            if (nextSource != null) {
                //Skip over if undefined or null
                for (var nextKey in nextSource) {
                    //Avoid bugs when hasOwnProperty is shadowed
                    if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
                        to[nextKey] = nextSource[nextKey];
                    }
                }
            }
        }
        return to;
    };
}

},{"./jvBrush.js":3,"./jvCharts.js":4,"./jvComment.js":5,"./jvEdit.js":6,"./jvEvents.js":7,"./jvSelect":8,"./jvTip.js":9,"./jvVars.js":10,"./visuals/jvArea.js":11,"./visuals/jvBar.js":12,"./visuals/jvBoxWhisker.js":13,"./visuals/jvBubble.js":14,"./visuals/jvClustergram.js":15,"./visuals/jvGantt.js":16,"./visuals/jvHeatmap.js":17,"./visuals/jvLine.js":18,"./visuals/jvPack.js":19,"./visuals/jvPie.js":20,"./visuals/jvRadial.js":21,"./visuals/jvSankey.js":22,"./visuals/jvScatter.js":23,"./visuals/jvSingleAxis.js":24,"./visuals/jvSunburst.js":25,"./visuals/jvTreemap.js":26,"./visuals/jvWordCloud.js":27}],3:[function(require,module,exports){
'use strict';
/***  jvBrush ***/
'use-strict';

/**jv Brush Flow
*
*  1. create new jvBrush object with a config object containing the specific jvChart and an onBrushCallback
*  2. jvBrush exposes startBrush and removeBrush functions
*  3. if startBrush is called with a d3.event, brush will assume that a force click event should be fired at the location of the d3.event
*  4. if a d3.event is not given to startBrush(), a brush lisener will be added to the visual to listen for the user to brush
*  5. After the user finishs brushing an area of the chart, brushEnd() is calle.
*  6. brushEnd() will create a data object for the brushed area in the format:
*      {'label1': ['value1','value2']}
*      Example
*      {'Movie_Genre': ['Drama','Documentary','Action']}
*  7. brushEnd will then call the onBrushCallback function with the above data object
*  8. brushEnd will finally call the removeBrush() function
*/

/**
* @name jvBrush
* @desc Constructor for JV Brush - creates brush mode for a jv visualization and executes a callback for the visual to be filtered
* @param {object} configObj - constructor object containing the jvChart and other options
* @return {undefined} - no return
*/

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var jvBrush = function () {
    function jvBrush(configObj) {
        _classCallCheck(this, jvBrush);

        var brushObj = this;
        brushObj.chartDiv = configObj.jvChart.chartDiv;
        brushObj.jvChart = configObj.jvChart;
        brushObj.onBrushCallback = configObj.onBrushCallback;
    }

    /**
    * @name removeBrush
    * @desc removes the brush area from the visual
    * @return {undefined} - no return
    */


    _createClass(jvBrush, [{
        key: 'removeBrush',
        value: function removeBrush() {
            var brushObj = this;
            brushObj.jvChart.chartDiv.selectAll('.brusharea').remove();
        }

        /**
        * @name startBrush
        * @desc removes the brush area from the visual
        * @param {object} event - optional event to start brush immediately with a new mousedown
        * @return {undefined} - no return
        */

    }, {
        key: 'startBrush',
        value: function startBrush() {
            var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

            var brushObj = this,
                height = brushObj.jvChart.config.container.height,
                width = brushObj.jvChart.config.container.width,
                svg = brushObj.jvChart.svg;

            if (brushObj.jvChart.config.type === 'singleaxis') {
                brushObj.brushType = 'x';
                svg.append('g').attr('class', 'brusharea').style('height', height + 'px').style('width', width + 'px').call(d3.brushX().extent([[0, 0], [width, height]]).on('end', brushEnd.bind(brushObj)));
            } else if (brushObj.jvChart.config.type === 'clustergram') {
                brushObj.brushType = 'xy';
                svg.append('g').attr('class', 'brusharea').attr('transform', 'translate(' + brushObj.jvChart._vars.leftTreeWidth + ', ' + brushObj.jvChart._vars.topTreeHeight + ')').style('height', height + 'px').style('width', width + 'px').call(d3.brush().extent([[0, 0], [width, height]]).on('end', brushEnd.bind(brushObj)));
            } else {
                brushObj.brushType = 'xy';
                svg.append('g').attr('class', 'brusharea').style('height', height + 'px').style('width', width + 'px').call(d3.brush().extent([[0, 0], [width, height]]).on('end', brushEnd.bind(brushObj)));
            }

            if (event) {
                //dispatch mousedown to start a brush at the event coordinates
                var brushElement = svg.select('.brusharea').node(),
                    newEvent = new Event('mousedown');
                newEvent.pageX = event.pageX;
                newEvent.clientX = event.clientX;
                newEvent.pageY = event.pageY;
                newEvent.clientY = event.clientY;
                newEvent.view = event.view;
                brushElement.__data__ = { type: 'overlay' };
                brushElement.dispatchEvent(newEvent);
            }
        }
    }]);

    return jvBrush;
}();

/**
* @name brushEnd
* @desc called at the end of the user brushing which calls the onBrush callback
* @return {undefined} - no return
*/


function brushEnd() {
    var brushObj = this,
        xScale = brushObj.jvChart.currentData.xAxisScale,
        yScale = brushObj.jvChart.currentData.yAxisScale,
        filteredXAxisLabels = [],
        filteredYAxisLabels = [],
        shouldReset = false,
        e = d3.event.selection,
        returnObj,
        filteredLabels = [],
        filteredConcepts = {},
        index,
        filterCol,
        filteredLabelsX,
        filteredLabelsY,
        cleanDataFlag = true;

    if (e) {
        if (brushObj.brushType === 'xy') {
            if (xScale && typeof xScale.invert !== 'function') {
                //means that the scale is ordinal and not linear
                returnObj = calculateBrushAreaOrdinal(e[0][0], e[1][0], xScale);
                filteredXAxisLabels = returnObj.filteredAxisLabels;
                shouldReset = returnObj.shouldReset;
            } else if (xScale) {
                //calculate labels for linear scale
                returnObj = calculateBrushAreaLinear(e[0][0], e[1][0], xScale, brushObj.jvChart.currentData, brushObj.jvChart.config.type, 'x');
                filteredXAxisLabels = returnObj.filteredAxisLabels;
                shouldReset = returnObj.shouldReset;
            }

            if (yScale && typeof yScale.invert !== 'function') {
                //means that the scale is oridnal and not linear
                returnObj = calculateBrushAreaOrdinal(e[0][1], e[1][1], yScale);
                filteredYAxisLabels = returnObj.filteredAxisLabels;
                if (returnObj.shouldReset) {
                    shouldReset = true;
                }
            } else if (yScale) {
                //calculate labels for linear scale
                returnObj = calculateBrushAreaLinear(e[0][1], e[1][1], yScale, brushObj.jvChart.currentData, brushObj.jvChart.config.type, 'y');
                filteredYAxisLabels = returnObj.filteredAxisLabels;
                if (returnObj.shouldReset) {
                    shouldReset = true;
                }
            } else if (brushObj.jvChart.config.type === 'heatmap') {
                returnObj = calculateHeatmapBrush(e, brushObj.jvChart.currentData, brushObj.jvChart);
                filteredLabelsX = returnObj.filteredXAxisLabels;
                filteredLabelsY = returnObj.filteredYAxisLabels;
                if (returnObj.shouldReset) {
                    shouldReset = true;
                }
            } else if (brushObj.jvChart.config.type === 'clustergram') {
                returnObj = calculateClustergramBrush(e, brushObj.jvChart.currentData, brushObj.jvChart);
                filteredLabelsX = returnObj.filteredXAxisLabels;
                filteredLabelsY = returnObj.filteredYAxisLabels;
                if (returnObj.shouldReset) {
                    shouldReset = true;
                }
            }
        } else if (brushObj.brushType === 'x') {
            returnObj = calculateBrushAreaLinear(e[0], e[1], xScale, brushObj.jvChart.currentData, brushObj.jvChart.config.type, 'x');
            filteredXAxisLabels = returnObj.filteredAxisLabels;
            if (returnObj.shouldReset) {
                shouldReset = true;
            }
        }
    } else {
        shouldReset = true;
    }

    if (filteredXAxisLabels.length > 0 && filteredYAxisLabels.length > 0) {
        //merge axisLabels
        for (var j = 0; j < filteredXAxisLabels.length; j++) {
            index = filteredYAxisLabels.indexOf(filteredXAxisLabels[j]);
            if (index > -1) {
                filteredLabels.push(filteredXAxisLabels[j]);
            }
        }
    } else if (filteredXAxisLabels.length > 0) {
        filteredLabels = filteredXAxisLabels;
    } else if (filteredYAxisLabels.length > 0) {
        filteredLabels = filteredYAxisLabels;
    }

    if (brushObj.jvChart.config.type === 'heatmap') {
        if (!shouldReset) {
            var filterColX = brushObj.jvChart.currentData.dataTable.x,
                filterColY = brushObj.jvChart.currentData.dataTable.y;
            if (filteredLabelsX.length > 0) {
                filteredConcepts[filterColX] = filteredLabelsX;
            }
            if (filteredLabelsY.length > 0) {
                filteredConcepts[filterColY] = filteredLabelsY;
            }
        }
    } else if (brushObj.jvChart.config.type === 'clustergram') {
        if (!shouldReset) {
            var xLength = Object.keys(filteredLabelsX).length,
                yLength = Object.keys(filteredLabelsY).length;

            for (var i = 0; i < xLength; i++) {
                var _filterColX = brushObj.jvChart.currentData.dataTable['x_category ' + (xLength - i)];
                filteredConcepts[_filterColX] = filteredLabelsX[i];
            }
            for (var _i = 0; _i < yLength; _i++) {
                var _filterColY = brushObj.jvChart.currentData.dataTable['y_category ' + (yLength - _i)];
                filteredConcepts[_filterColY] = filteredLabelsY[_i];
            }
        }
        cleanDataFlag = false;
    } else {
        if (brushObj.jvChart.config.type === 'gantt') {
            filterCol = brushObj.jvChart.currentData.dataTable.group;
        } else {
            filterCol = brushObj.jvChart.currentData.dataTable.label;
        }
        filteredConcepts[filterCol] = filteredLabels;
    }

    //calls back to update data with brushed data
    brushObj.onBrushCallback({
        data: filteredConcepts,
        reset: shouldReset,
        clean: cleanDataFlag
    });
    brushObj.removeBrush();
}

/**
* @name calculateBrushAreaOrdinal
* @desc calculates the ordinal values that are in the brushed area
* @param {number} mousePosMin - lower bound mouse position
* @param {number} mousePosMax - upper bound mouse position
* @param {object} scale - d3 axis scale
* @return {Object} - object of filtered values
*/
function calculateBrushAreaOrdinal(mousePosMin, mousePosMax, scale) {
    var domain = scale.domain(),
        padding = scale.padding(),
        step = scale.step(),
        minIndex = void 0,
        maxIndex = void 0,
        paddingDistance = padding * step / 2,
        filteredAxisLabels = void 0;

    //determine min index
    if (mousePosMin % step > step - paddingDistance) {
        //don't include on min side
        minIndex = Math.floor(mousePosMin / step) + 1;
    } else {
        //include on min side
        minIndex = Math.floor(mousePosMin / step);
    }

    //determine max index
    if (mousePosMax % step < paddingDistance) {
        //don't include on max side
        maxIndex = Math.floor(mousePosMax / step) - 1;
    } else {
        //include on max side
        maxIndex = Math.floor(mousePosMax / step);
        if (maxIndex === domain.length) {
            maxIndex -= 1;
        }
    }
    filteredAxisLabels = domain.slice(minIndex, maxIndex + 1);
    return { filteredAxisLabels: filteredAxisLabels, shouldReset: filteredAxisLabels.length === 0 };
}

/**
* @name calculateBrushAreaLinear
* @desc calculates the linear values that are in the brushed area
* @param {number} mousePosMin - lower bound mouse position
* @param {number} mousePosMax - upper bound mouse position
* @param {object} scale - d3 axis scale
* @param {object} data - chartData
* @param {string} type - visual type
* @param {string} axis - x / y / z
* @return {Object} - object of filtered values
*/
function calculateBrushAreaLinear(mousePosMin, mousePosMax, scale, data, type, axis) {
    var filteredAxisLabels = [],
        min = void 0,
        max = void 0,
        axisLabel = void 0;

    //switch min and max if scale is y due to svg drawing (y axis increases up the screen while mousePos decreases)
    if (axis === 'y') {
        max = scale.invert(mousePosMin);
        min = scale.invert(mousePosMax);
    } else {
        min = scale.invert(mousePosMin);
        max = scale.invert(mousePosMax);
    }

    if (type === 'bar') {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = data.legendData[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                axisLabel = _step.value;
                var _iteratorNormalCompletion2 = true;
                var _didIteratorError2 = false;
                var _iteratorError2 = undefined;

                try {
                    for (var _iterator2 = data.chartData[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                        var dataElement = _step2.value;

                        if (dataElement[axisLabel] >= min) {
                            filteredAxisLabels.push(dataElement[data.dataTable.label]);
                        }
                    }
                } catch (err) {
                    _didIteratorError2 = true;
                    _iteratorError2 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion2 && _iterator2.return) {
                            _iterator2.return();
                        }
                    } finally {
                        if (_didIteratorError2) {
                            throw _iteratorError2;
                        }
                    }
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                    _iterator.return();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
    } else if (type === 'gantt') {
        max = new Date(max);
        min = new Date(min);
        for (var i = 0; i < data.legendData.length; i++) {
            var count = i + 1,
                startDate = void 0,
                endDate = void 0;
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
                for (var _iterator3 = data.chartData[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                    var _dataElement = _step3.value;

                    startDate = new Date(_dataElement[data.dataTable['start ' + count]]);
                    endDate = new Date(_dataElement[data.dataTable['end ' + count]]);
                    if (startDate <= max && startDate >= min || endDate <= max && endDate >= min || startDate <= min && endDate >= max) {
                        filteredAxisLabels.push(_dataElement[data.dataTable.group]);
                    }
                }
            } catch (err) {
                _didIteratorError3 = true;
                _iteratorError3 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion3 && _iterator3.return) {
                        _iterator3.return();
                    }
                } finally {
                    if (_didIteratorError3) {
                        throw _iteratorError3;
                    }
                }
            }
        }
    } else if (type === 'line' || type === 'area' || type === 'singleaxis') {
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
            for (var _iterator4 = data.legendData[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                axisLabel = _step4.value;
                var _iteratorNormalCompletion5 = true;
                var _didIteratorError5 = false;
                var _iteratorError5 = undefined;

                try {
                    for (var _iterator5 = data.chartData[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                        var _dataElement2 = _step5.value;

                        if (_dataElement2[axisLabel] <= max && _dataElement2[axisLabel] >= min) {
                            filteredAxisLabels.push(_dataElement2[data.dataTable.label]);
                        }
                    }
                } catch (err) {
                    _didIteratorError5 = true;
                    _iteratorError5 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion5 && _iterator5.return) {
                            _iterator5.return();
                        }
                    } finally {
                        if (_didIteratorError5) {
                            throw _iteratorError5;
                        }
                    }
                }
            }
        } catch (err) {
            _didIteratorError4 = true;
            _iteratorError4 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion4 && _iterator4.return) {
                    _iterator4.return();
                }
            } finally {
                if (_didIteratorError4) {
                    throw _iteratorError4;
                }
            }
        }
    } else if (type === 'scatterplot') {
        axisLabel = data.dataTable[axis];
        var _iteratorNormalCompletion6 = true;
        var _didIteratorError6 = false;
        var _iteratorError6 = undefined;

        try {
            for (var _iterator6 = data.chartData[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
                var _dataElement3 = _step6.value;

                if (_dataElement3[axisLabel] <= max && _dataElement3[axisLabel] >= min) {
                    filteredAxisLabels.push(_dataElement3[data.dataTable.label]);
                }
            }
        } catch (err) {
            _didIteratorError6 = true;
            _iteratorError6 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion6 && _iterator6.return) {
                    _iterator6.return();
                }
            } finally {
                if (_didIteratorError6) {
                    throw _iteratorError6;
                }
            }
        }
    } else if (type === 'boxwhisker') {
        if (axis === 'y') {
            axisLabel = data.dataTable.value;
        } else {
            axisLabel = data.dataTable.label;
        }

        var _iteratorNormalCompletion7 = true;
        var _didIteratorError7 = false;
        var _iteratorError7 = undefined;

        try {
            for (var _iterator7 = data.chartData[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
                var _dataElement4 = _step7.value;

                if (_dataElement4[axisLabel] <= max && _dataElement4[axisLabel] >= min) {
                    filteredAxisLabels.push(_dataElement4[data.dataTable.label]);
                }
            }
        } catch (err) {
            _didIteratorError7 = true;
            _iteratorError7 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion7 && _iterator7.return) {
                    _iterator7.return();
                }
            } finally {
                if (_didIteratorError7) {
                    throw _iteratorError7;
                }
            }
        }
    } else if (type === 'heatmap') {
        axisLabel = data.dataTable[axis];
        var _iteratorNormalCompletion8 = true;
        var _didIteratorError8 = false;
        var _iteratorError8 = undefined;

        try {
            for (var _iterator8 = data.chartData[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
                var _dataElement5 = _step8.value;

                if (_dataElement5[axisLabel] <= max && _dataElement5[axisLabel] >= min) {
                    filteredAxisLabels.push(_dataElement5[data.dataTable.label]);
                }
            }
        } catch (err) {
            _didIteratorError8 = true;
            _iteratorError8 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion8 && _iterator8.return) {
                    _iterator8.return();
                }
            } finally {
                if (_didIteratorError8) {
                    throw _iteratorError8;
                }
            }
        }
    }
    return { filteredAxisLabels: filteredAxisLabels, shouldReset: filteredAxisLabels.length === 0 };
}

/**
* @name calculateHeatmapBrush
* @desc calculates values inside of brushed area of a heatmap
* @param {array} e - mouse extent for location of brushed area
* @param {array} data - chart data
* @param {array} chart - jvChart
* @return {object} - filtered data
*/
function calculateHeatmapBrush(e, data, chart) {
    var mouseXmin = e[0][0],
        mouseYmin = e[0][1],
        mouseXmax = e[1][0],
        mouseYmax = e[1][1],
        filteredXAxisLabels = [],
        filteredYAxisLabels = [],
        reset = true,
        xBucketMax = Math.floor(mouseXmax / chart._vars.heatGridSize) + 1,
        yBucketMax = Math.floor(mouseYmax / chart._vars.heatGridSize) + 1,
        xBucketMin = Math.floor(mouseXmin / chart._vars.heatGridSize),
        yBucketMin = Math.floor(mouseYmin / chart._vars.heatGridSize);

    for (var i = 0; i < xBucketMax; i++) {
        if (i >= xBucketMin) {
            filteredXAxisLabels.push(data.xAxisData.values[i]);
            reset = false;
        }
    }
    for (var _i2 = 0; _i2 < yBucketMax; _i2++) {
        if (_i2 >= yBucketMin) {
            filteredYAxisLabels.push(data.yAxisData.values[_i2]);
            reset = false;
        }
    }

    return { filteredXAxisLabels: filteredXAxisLabels, filteredYAxisLabels: filteredYAxisLabels, shouldReset: reset };
}

/**
* @name calculateClustergramBrush
* @desc calculates values inside of brushed area of a clustergram
* @param {array} e - mouse extent for location of brushed area
* @param {array} data - chart data
* @param {array} chart - jvChart
* @return {object} - filtered data
*/
function calculateClustergramBrush(e, data, chart) {
    var mouseXmin = e[0][0],
        mouseYmin = e[0][1],
        mouseXmax = e[1][0],
        mouseYmax = e[1][1],
        filteredXAxisLabels = [],
        filteredYAxisLabels = [],
        reset = true,
        xBucketMax = Math.floor(mouseXmax / chart._vars.clustergramGridWidth) + 1,
        yBucketMax = Math.floor(mouseYmax / chart._vars.clustergramGridHeight) + 1,
        xBucketMin = Math.floor(mouseXmin / chart._vars.clustergramGridWidth),
        yBucketMin = Math.floor(mouseYmin / chart._vars.clustergramGridHeight),
        xLevels = {},
        yLevels = {};

    for (var i = 0; i < xBucketMax; i++) {
        if (i >= xBucketMin) {
            filteredXAxisLabels.push(data.xAxisData[i]);
            reset = false;
        }
    }
    for (var _i3 = 0; _i3 < yBucketMax; _i3++) {
        if (_i3 >= yBucketMin) {
            filteredYAxisLabels.push(data.yAxisData[_i3]);
            reset = false;
        }
    }

    //X Axis
    //Dynamically create arrays for each level of the hierarchy
    if (filteredXAxisLabels[0]) {
        var parentCountX = (filteredXAxisLabels[0].match(/\./g) || []).length;
        for (var _i4 = 0; _i4 < parentCountX + 1; _i4++) {
            xLevels[_i4] = [];
        }

        //Populate the hierarchy arrays with the labels of that respective hierarchy
        for (var _i5 = 0; _i5 < filteredXAxisLabels.length; _i5++) {
            if (filteredXAxisLabels[_i5]) {
                var xFields = filteredXAxisLabels[_i5].split('.');
                for (var k = 0; k < xFields.length; k++) {
                    if (xLevels[k].indexOf(xFields[k]) === -1) {
                        xLevels[k].push(xFields[k]);
                    }
                }
            }
        }
    }

    //Y Axis
    //Dynamically create arrays for each level of the hierarchy
    if (filteredYAxisLabels[0]) {
        var parentCountY = (filteredYAxisLabels[0].match(/\./g) || []).length;
        for (var _i6 = 0; _i6 < parentCountY + 1; _i6++) {
            yLevels[_i6] = [];
        }

        //Populate the hierarchy arrays with the labels of that respective hierarchy
        for (var _i7 = 0; _i7 < filteredYAxisLabels.length; _i7++) {
            if (filteredYAxisLabels[_i7]) {
                var yFields = filteredYAxisLabels[_i7].split('.');
                for (var _k = 0; _k < yFields.length; _k++) {
                    if (yLevels[_k].indexOf(yFields[_k]) === -1) {
                        yLevels[_k].push(yFields[_k]);
                    }
                }
            }
        }
    }

    return { filteredXAxisLabels: xLevels, filteredYAxisLabels: yLevels, shouldReset: reset };
}

module.exports = jvBrush;

},{}],4:[function(require,module,exports){
'use strict';
/***  jvCharts ***/

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var jvTip = require('./jvTip.js');

/**Create a jvCharts object
 * @constructor
 * @param {Object} configObj - Configuration object passed into jvCharts constructor
 * @param {string} configObj.type - The type of chart
 * @param {string} configObj.name - The name of the chart
 * @param {Object} configObj.container - The container of the chart
 * @param {Object} configObj.userOptions - UI options for the chart
 * @param {Object} configObj.tipConfig - Configuration object for jvTooltip
 * @param {Object} configObj.chartDiv - A div wrapper for the chart and other jv features
 */

var jvCharts = function () {
    function jvCharts(configObj) {
        _classCallCheck(this, jvCharts);

        var chart = this;
        configObj.type = configObj.type.toLowerCase();
        chart.chartDiv = configObj.chartDiv;
        configObj.options = cleanToolData(configObj.options, configObj.editOptions);
        chart._vars = chart.getDefaultOptions(configObj.options);
        chart.mode = configObj.mode || 'default-mode';

        //remove pieces from config that have been copied somewhere else
        delete configObj.chartDiv;
        delete configObj.options;
        delete configObj.mode;

        chart.config = configObj;

        //Start painting the jv Chart
        chart.createTooltip();
        chart.setData();
        chart.paint();
    }

    _createClass(jvCharts, [{
        key: 'createTooltip',
        value: function createTooltip() {
            var chart = this;
            chart.tip = new jvTip({
                config: chart.config.tipConfig,
                chartDiv: chart.chartDiv
            });
        }
    }, {
        key: 'setData',
        value: function setData() {
            var chart = this;
            if (chart.config.setData) {
                chart.data = chart.config.setData;
                //refer to main data as chartData to keep naming separate and understandable
                chart.data.chartData = chart.config.setData.data;
                delete chart.data.data;
                if (chart.data.dataTableKeys) {
                    chart.cleanDataTableKeys();
                }

                if (chart.data.headers) {
                    chart.setAlignAndKeys();
                }

                chart.colors = chart.config.setData.colors;
                chart[chart.config.type].setData.call(chart);
            }
        }

        /**
        * @name updateDataTableAlign
        * @param {array} currentKeys - array of objects to describe how to build the visual
        * @return {object} dataTableAlign - key:value mapping of current alignment
        */

    }, {
        key: 'setAlignAndKeys',
        value: function setAlignAndKeys() {
            var chart = this,
                dataTableAlign = {},
                i,
                len,
                keyMapping = {},
                keys = chart.data.headers;

            //iterate over current keys to create new object with key:value mapping instead of key:array mapping
            for (i = 0, len = keys.length; i < len; i++) {
                if (!keyMapping.hasOwnProperty(keys[i].model)) {
                    keyMapping[keys[i].model] = 0;
                    dataTableAlign[keys[i].model] = keys[i].name;
                } else {
                    dataTableAlign[keys[i].model + ' ' + i] = keys[i].name;
                }
            }
            chart.data.dataTableKeys = chart.data.headers;
            chart.data.dataTable = dataTableAlign;
        }
    }, {
        key: 'cleanDataTableKeys',
        value: function cleanDataTableKeys() {
            var chart = this,
                newKeys = [];
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = chart.data.dataTableKeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var key = _step.value;

                    newKeys.push({
                        name: key.varKey || key.alias || key.name,
                        model: key.vizType || key.model,
                        type: key.type
                    });
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }

            chart.data.dataTableKeys = newKeys;
        }
    }, {
        key: 'checkDimensions',
        value: function checkDimensions() {
            var chart = this,
                dimensions = chart.chartDiv.node().getBoundingClientRect();
            if (dimensions.height > 50 && dimensions.width > 120) {
                return true;
            }
            console.log('Chart container is too small to paint');
            return false;
        }
    }, {
        key: 'paint',
        value: function paint(annimation) {
            var chart = this;
            if (chart.checkDimensions()) {
                if (chart.data && _typeof(chart[chart.config.type]) === 'object' && typeof chart[chart.config.type].paint === 'function') {
                    chart[chart.config.type].paint.call(chart, annimation);
                    chart.initializeModes();

                    if (chart._vars.highlight) {
                        chart[chart.config.type].highlightFromEventData.call(chart, chart._vars.highlight);
                    }
                } else {
                    console.log('no paint function for: ' + chart.config.type);
                }
            }
        }
    }, {
        key: 'setAxisData',
        value: function setAxisData(axis, data, keys) {
            var chart = this,
                axisData = [],
                chartData = data.chartData,
                label = '',
                maxStack = 0,
                dataTableKeys = data.dataTableKeys,
                dataType = void 0;

            if (!dataTableKeys) {
                dataTableKeys = keys;
            }

            //Step 1: find out what the label is for the axis
            if (axis === 'x') {
                if (data.dataTable) {
                    if (data.dataTable.hasOwnProperty('label')) {
                        label = data.dataTable.label;
                    } else {
                        console.error("Label doesn't exist in dataTable");
                    }
                } else {
                    console.log('DataTable does not exist');
                }

                dataType = 'STRING';

                //Replace underscores with spaces
                label = label.replace(/_/g, ' ');

                //loop through data to populate axisData
                var _iteratorNormalCompletion2 = true;
                var _didIteratorError2 = false;
                var _iteratorError2 = undefined;

                try {
                    for (var _iterator2 = chartData[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                        var chartEle = _step2.value;

                        if (chartEle[label] === null) {
                            axisData.push('NULL_VALUE');
                        } else if (chartEle[label] === '') {
                            axisData.push('EMPTY_STRING');
                        } else if (chartEle[label] || chartEle[label] === 0) {
                            axisData.push(chartEle[label]);
                        }
                    }
                } catch (err) {
                    _didIteratorError2 = true;
                    _iteratorError2 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion2 && _iterator2.return) {
                            _iterator2.return();
                        }
                    } finally {
                        if (_didIteratorError2) {
                            throw _iteratorError2;
                        }
                    }
                }
            } else {
                if (dataTableKeys === undefined) {
                    console.error('dataTableKeys do not exist');
                }
                //Find the max value for Y Data
                var count = 0;

                var _iteratorNormalCompletion3 = true;
                var _didIteratorError3 = false;
                var _iteratorError3 = undefined;

                try {
                    for (var _iterator3 = dataTableKeys[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                        var key = _step3.value;

                        if (key.model !== 'label' && key.model !== 'tooltip' && key.model !== 'series') {
                            label = key.name;
                            count++;
                        }
                    }
                } catch (err) {
                    _didIteratorError3 = true;
                    _iteratorError3 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion3 && _iterator3.return) {
                            _iterator3.return();
                        }
                    } finally {
                        if (_didIteratorError3) {
                            throw _iteratorError3;
                        }
                    }
                }

                dataType = getDataTypeFromKeys(label, dataTableKeys, 'NUMBER');

                //Add all values that are on yaxis to axis data
                var _iteratorNormalCompletion4 = true;
                var _didIteratorError4 = false;
                var _iteratorError4 = undefined;

                try {
                    for (var _iterator4 = chartData[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                        var _chartEle = _step4.value;

                        var stack = 0; //Keeps track of the maximum size of stacked data so that axis can be scaled to fit max size
                        for (var k in data.dataTable) {
                            if (_chartEle.hasOwnProperty(data.dataTable[k]) && k !== 'label' && k.indexOf('tooltip') === -1 && k !== 'series') {
                                stack += _chartEle[data.dataTable[k]];
                                axisData.push(_chartEle[data.dataTable[k]]);
                            }
                        }
                        if (stack > maxStack) {
                            maxStack = stack;
                        }
                    }

                    //If there are multiple values on the yAxis, don't specify a label
                } catch (err) {
                    _didIteratorError4 = true;
                    _iteratorError4 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion4 && _iterator4.return) {
                            _iterator4.return();
                        }
                    } finally {
                        if (_didIteratorError4) {
                            throw _iteratorError4;
                        }
                    }
                }

                if (count > 1) {
                    label = '';
                }
                label = label.replace(/_/g, ' ');
            }

            //Find the min and max of numeric data for building axes and add it to the returned object
            if (dataType === 'NUMBER') {
                var max = void 0,
                    min = void 0,
                    temp = void 0,
                    tempMin = void 0,
                    tempMax = void 0;
                if (chart._vars.stackToggle) {
                    max = maxStack;
                } else {
                    max = Math.max.apply(null, axisData);
                }

                min = Math.min.apply(null, axisData);
                min = Math.min(0, min);

                //Check if there's an axis min/max set
                if (axis === 'x') {
                    if (chart._vars.xMin != null && chart._vars.xMin !== 'none') {
                        min = chart._vars.xMin;
                    }
                    if (chart._vars.xMax != null && chart._vars.xMax !== 'none') {
                        max = chart._vars.xMax;
                    }
                } else if (axis === 'y') {
                    if (chart._vars.yMin != null && chart._vars.yMin !== 'none') {
                        min = chart._vars.yMin;
                    }
                    if (chart._vars.yMax != null && chart._vars.yMax !== 'none') {
                        max = chart._vars.yMax;
                    }
                }

                if (dataType === 'NUMBER' && axisData.length === 1) {
                    if (axisData[0] >= 0) {
                        axisData.unshift(0);
                    } else {
                        axisData.push(0);
                    }
                }

                tempMin = parseInt(min, 10);
                tempMax = parseInt(max, 10);
                //Make sure that axis min and max don't get flipped
                if (tempMin > tempMax) {
                    temp = min;
                    min = max;
                    max = temp;
                }

                return {
                    'label': label,
                    'values': axisData,
                    'dataType': dataType,
                    'min': min,
                    'max': max
                };
            }

            return {
                'label': label,
                'values': axisData,
                'dataType': dataType
            };
        }

        /**setFlippedSeries
         *  flips series and returns flipped data
         *
         * @params chartData, dataTable, dataLabel
         * @returns Object of data and table for flipped series
         */

    }, {
        key: 'setFlippedSeries',
        value: function setFlippedSeries(dataTableKeys) {
            var chart = this,
                chartData = chart.data.chartData,
                dataTable = chart.data.dataTable,
                dataLabel = chart.data.xAxisData.label,
                flippedData = [],
                flippedDataTable = {},
                valueCount = 1,
                filteredDataTableArray = [];

            for (var k in dataTable) {
                if (dataTable.hasOwnProperty(k)) {
                    var flippedObject = {};
                    if (dataTable[k] !== dataLabel) {
                        flippedObject[dataLabel] = dataTable[k];
                        var _iteratorNormalCompletion5 = true;
                        var _didIteratorError5 = false;
                        var _iteratorError5 = undefined;

                        try {
                            for (var _iterator5 = chartData[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                                var chartEle = _step5.value;

                                flippedObject[chartEle[dataLabel]] = chartEle[dataTable[k]];
                                if (filteredDataTableArray.indexOf(chartEle[dataLabel]) === -1) {
                                    flippedDataTable['value ' + valueCount] = chartEle[dataLabel];
                                    valueCount++;
                                    filteredDataTableArray.push(chartEle[dataLabel]);
                                }
                            }
                        } catch (err) {
                            _didIteratorError5 = true;
                            _iteratorError5 = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion5 && _iterator5.return) {
                                    _iterator5.return();
                                }
                            } finally {
                                if (_didIteratorError5) {
                                    throw _iteratorError5;
                                }
                            }
                        }

                        flippedData.push(flippedObject);
                    }
                }
            }
            flippedDataTable.label = dataLabel;
            chart.flippedData = { chartData: flippedData, dataTable: flippedDataTable };

            if (chart.config.type === 'bar' || chart.config.type === 'line' || chart.config.type === 'area') {
                chart.flippedData.xAxisData = chart.setAxisData('x', chart.flippedData, dataTableKeys);
                chart.flippedData.yAxisData = chart.setAxisData('y', chart.flippedData, dataTableKeys);
                chart.flippedData.legendData = setBarLineLegendData(chart.flippedData);
            } else {
                console.log('Add additional chart type to set flipped series');
            }
        }

        /**organizeChartData
         *  reorders all data based on the sortLabel and sortType
         *  -Only for chartData, does not work with flipped data
         *
         * @params sortLabel , sortType
         * @returns [] sorted data
         */

    }, {
        key: 'organizeChartData',
        value: function organizeChartData(sortParam, sortType) {
            var chart = this,
                organizedData = void 0,
                dataType = void 0,
                dataTableKeys = chart.data.dataTableKeys,
                sortLabel = sortParam;

            //If sortLabel doesn't exist, sort on the x axis label by default
            if (sortLabel === 'none') {
                var _iteratorNormalCompletion6 = true;
                var _didIteratorError6 = false;
                var _iteratorError6 = undefined;

                try {
                    for (var _iterator6 = dataTableKeys[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
                        var key = _step6.value;

                        if (key.model === 'label') {
                            sortLabel = key.name;
                            break;
                        }
                    }
                } catch (err) {
                    _didIteratorError6 = true;
                    _iteratorError6 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion6 && _iterator6.return) {
                            _iterator6.return();
                        }
                    } finally {
                        if (_didIteratorError6) {
                            throw _iteratorError6;
                        }
                    }
                }
            }

            //Remove underscores from sortLabel
            if (sortLabel) {
                sortLabel = sortLabel.replace(/_/g, ' ');
            }

            if (!chart.data.chartData[0][sortLabel]) {
                //Check if the sort label is a calculatedBy field
                var isValidSortLabel = false;
                var _iteratorNormalCompletion7 = true;
                var _didIteratorError7 = false;
                var _iteratorError7 = undefined;

                try {
                    for (var _iterator7 = dataTableKeys[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
                        var _key = _step7.value;

                        if (_key.operation.hasOwnProperty('calculatedBy') && _key.operation.calculatedBy[0] === sortLabel) {
                            sortLabel = _key.name.replace(/_/g, ' ');
                            isValidSortLabel = true;
                            break;
                        }
                    }
                    //If it's not a valid sort label, return and don't sort the data
                } catch (err) {
                    _didIteratorError7 = true;
                    _iteratorError7 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion7 && _iterator7.return) {
                            _iterator7.return();
                        }
                    } finally {
                        if (_didIteratorError7) {
                            throw _iteratorError7;
                        }
                    }
                }

                if (!isValidSortLabel) {
                    console.error('Not a valid sort');
                    //throw new Error('Not a valid sort');
                }
            }

            //Check the data type to determine which logic to flow through
            var _iteratorNormalCompletion8 = true;
            var _didIteratorError8 = false;
            var _iteratorError8 = undefined;

            try {
                for (var _iterator8 = dataTableKeys[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
                    var _key2 = _step8.value;

                    //Loop through dataTableKeys to find sortLabel
                    if (_key2.name.replace(/_/g, ' ') === sortLabel) {
                        dataType = _key2.type;
                        break;
                    }
                }

                //Date sorting
            } catch (err) {
                _didIteratorError8 = true;
                _iteratorError8 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion8 && _iterator8.return) {
                        _iterator8.return();
                    }
                } finally {
                    if (_didIteratorError8) {
                        throw _iteratorError8;
                    }
                }
            }

            if (dataType != null && dataType === 'DATE') {
                organizedData = chart.data.chartData.sort(function (a, b) {
                    return new Date(a[sortLabel]) - new Date(b[sortLabel]);
                });
            } else if (dataType != null && dataType === 'NUMBER') {
                organizedData = chart.data.chartData.sort(function (a, b) {
                    if (!isNaN(a[sortLabel]) && !isNaN(b[sortLabel])) {
                        return a[sortLabel] - b[sortLabel];
                    }
                });
            } else {
                organizedData = chart.data.chartData.sort(function (a, b) {
                    if (!isNaN(a[sortLabel]) && !isNaN(b[sortLabel])) {
                        if (parseFloat(a[sortLabel]) < parseFloat(b[sortLabel])) {
                            //sort string ascending
                            return -1;
                        }
                        if (parseFloat(a[sortLabel]) > parseFloat(b[sortLabel])) {
                            return 1;
                        }
                        return 0;
                    }
                    if (a[sortLabel].toLowerCase() < b[sortLabel].toLowerCase()) {
                        //sort string ascending
                        return -1;
                    }
                    if (a[sortLabel].toLowerCase() > b[sortLabel].toLowerCase()) {
                        return 1;
                    }
                    return 0;
                });
            }

            switch (sortType) {
                case 'sortAscending':
                case 'ascending':
                    chart.data.chartData = organizedData;
                    break;
                case 'sortDescending':
                case 'descending':
                    chart.data.chartData = organizedData.reverse();
                    break;
                default:
                    chart.data.chartData = organizedData;
            }
        }

        /**setTipData
         *
         * creates data object to display in tooltip
         * @params
         * @returns {{}}
         */

    }, {
        key: 'setTipData',
        value: function setTipData(d, i) {
            var chart = this,
                data = chart.currentData.chartData,

            //Get Color from chartData and add to object
            color = chart._vars.color,
                title = d[chart.data.dataTable.label],
                dataTable = {};

            if (chart.config.type === 'treemap') {
                for (var item in d) {
                    if (item !== chart.data.dataTable.label && item !== 'Parent') {
                        dataTable[item] = d[item];
                    }
                }
            } else if (chart.config.type === 'bar' || chart.config.type === 'line' || chart.config.type === 'area') {
                title = data[i][chart.data.dataTable.label];
                for (var _item in data[i]) {
                    if (_item !== chart.data.dataTable.label) {
                        dataTable[_item] = data[i][_item];
                    } else {
                        continue;
                    }
                }
            } else if (chart.config.type === 'gantt') {
                //Calculate length of dates
                for (var _item2 in data[i]) {
                    if (data[i].hasOwnProperty(_item2) && _item2 !== chart.data.dataTable.group) {
                        dataTable[_item2] = data[i][_item2];
                    }
                }

                var start = void 0,
                    end = void 0,
                    difference = void 0,

                //Calculting duration of date ranges to add to tooltip
                numPairs = Math.floor(Object.keys(chart.data.dataTable).length / 2);

                for (var j = 1; j <= numPairs; j++) {
                    start = new Date(data[i][chart.data.dataTable['start ' + j]]);
                    end = new Date(data[i][chart.data.dataTable['end ' + j]]);
                    difference = end.getTime() - start.getTime();
                    dataTable['Duration ' + j] = Math.ceil(difference / (1000 * 60 * 60 * 24)) + ' days';
                }

                title = data[i][chart.data.dataTable.group];
            } else if (chart.config.type === 'pie' || chart.config.type === 'radial') {
                title = d.label;
                for (var _item3 in d) {
                    if (_item3 !== 'label') {
                        dataTable[_item3] = d[_item3];
                    } else {
                        continue;
                    }
                }
                delete dataTable.outerRadius;
            } else if (chart.config.type === 'circlepack' || chart.config.type === 'sunburst') {
                title = d.data.name;
                dataTable[chart.data.dataTable.value] = d.value;
            } else if (chart.config.type === 'cloud') {
                title = d[chart.data.dataTable.label];
                dataTable[chart.data.dataTable.value] = d[chart.data.dataTable.value];
                if (typeof d[chart.data.dataTable['tooltip 1']] !== 'undefined') {
                    dataTable[chart.data.dataTable['tooltip 1']] = d[chart.data.dataTable['tooltip 1']];
                }
            } else if (chart.config.type === 'heatmap') {
                title = d.yAxisName + ' to ' + d.xAxisName;
                if (d.hasOwnProperty('value')) {
                    dataTable.value = d.value;
                }
                for (var tooltip in d) {
                    if (tooltip.indexOf('tooltip') > -1) {
                        dataTable[chart.data.dataTable[tooltip]] = d[tooltip];
                    }
                }
            } else if (chart.config.type === 'clustergram') {
                //title = d.y_path.replace(/\./g, '→') + '</br>' + d.x_path.replace(/\./g, '→');
                //Build strings for tooltip
                var yTemp = d.y_path.split('.'),
                    yTempString = '',
                    xTemp = d.x_path.split('.'),
                    xTempString = '';

                for (var k = 0; k < yTemp.length; k++) {
                    if (chart.data.dataTable['y_category ' + (k + 1)]) {
                        yTempString += yTemp[k] += ' (' + chart.data.dataTable['y_category ' + (k + 1)] + ')';
                    } else {
                        yTempString += yTemp[k] += ' (' + chart.data.dataTable.y_category + ')';
                    }

                    if (k !== yTemp.length - 1) {
                        yTempString += ' → ';
                    }
                }
                for (var _k = 0; _k < xTemp.length; _k++) {
                    if (chart.data.dataTable['x_category ' + (_k + 1)]) {
                        xTempString += xTemp[_k] += ' (' + chart.data.dataTable['x_category ' + (_k + 1)] + ')';
                    } else {
                        xTempString += xTemp[_k] += ' (' + chart.data.dataTable.x_category + ')';
                    }

                    if (_k !== xTemp.length - 1) {
                        xTempString += ' → ';
                    }
                }

                title = 'Y > ' + yTempString + '<br>' + 'X > ' + xTempString;
                if (d.hasOwnProperty('value')) {
                    dataTable.value = d.value;
                }
                for (var _tooltip in d) {
                    if (_tooltip.indexOf('tooltip') > -1) {
                        dataTable[chart.data.dataTable[_tooltip]] = d[_tooltip];
                    }
                }
            } else if (chart.config.type === 'sankey') {
                title = d.source.name.slice(0, -2) + ' to ' + d.target.name.slice(0, -2);

                if (d.hasOwnProperty('value')) {
                    dataTable.value = d.value;
                }
            } else if (chart.config.type === 'singleaxis') {
                title = d.data[chart.data.dataTable.label];

                for (var _item4 in chart.data.dataTable) {
                    if (_item4 !== 'label') {
                        dataTable[chart.data.dataTable[_item4]] = d.data[chart.data.dataTable[_item4]];
                    }
                }
            } else {
                for (var _item5 in d) {
                    if (_item5 !== chart.data.dataTable.label) {
                        dataTable[_item5] = d[_item5];
                    } else {
                        continue;
                    }
                }
            }

            return { 'data': d, 'tipData': dataTable, 'index': i, 'title': title, 'color': color, 'viz': chart.config.type };
        }

        /************************************************ Draw functions ******************************************************/

        /**generateSVG
         *creates an SVG element on the panel
         *
         * @params container, margin, name
         *
         */

    }, {
        key: 'generateSVG',
        value: function generateSVG(legendData, customMarginParam, customSizeParam) {
            var chart = this,
                margin = {},
                container = {},
                dimensions = chart.chartDiv.node().getBoundingClientRect(),
                customMargins = customMarginParam,
                customSize = customSizeParam,
                textWidth = void 0;

            if (chart._vars.customMargins) {
                customMargins = chart._vars.customMargins;
            }

            //set margins
            if (!customMargins) {
                //declare margins if they arent passed in
                margin = {
                    top: 55,
                    right: 50,
                    left: 100,
                    bottom: 70
                };
                if (legendData != null) {
                    if (legendData.length <= 3) {
                        margin.bottom = 70;
                    } else if (legendData.length <= 6) {
                        margin.bottom = 85;
                    } else {
                        margin.bottom = 130;
                    }
                }
            } else {
                margin = customMargins;
            }

            //reduce margins if legend is toggled off
            //TODO make this better
            if (chart._vars.toggleLegend === false) {
                if (chart.config.type === 'pie' || chart.config.type === 'radial' || chart.config.type === 'circlepack' || chart.config.type === 'heatmap') {
                    margin.left = 40;
                } else if (chart.config.type === 'treemap' || chart.config.type === 'bar' || chart.config.type === 'gantt' || chart.config.type === 'scatter' || chart.config.type === 'line') {
                    margin.bottom = 40;
                }
            }

            if (chart.config.type === 'clustergram') {
                textWidth = getMaxWidthForAxisData('y', chart.leftLabels, chart._vars, dimensions, margin, chart.chartDiv, chart.config.type);
                margin.left = Math.ceil(textWidth);
                if (margin.left < 30) {
                    margin.left = 30;
                }

                textWidth = getMaxWidthForAxisData('y', chart.rightLabels, chart._vars, dimensions, margin, chart.chartDiv, chart.config.type);
                margin.top = Math.ceil(textWidth);
                if (margin.top < 30) {
                    margin.top = 30;
                }
            }

            //set yAxis margins
            if (chart.currentData && chart.currentData.yAxisData) {
                textWidth = getMaxWidthForAxisData('y', chart.currentData.yAxisData, chart._vars, dimensions, margin, chart.chartDiv, chart.config.type);
                if (textWidth > 100 && chart.config.type === 'heatmap') {
                    textWidth = 100;
                }
                chart._vars.heatmapYmargin = textWidth;
                margin.left = Math.ceil(textWidth) + 30;
            }

            //set xAxis top margins
            if (chart.config.type === 'heatmap' && chart.currentData && chart.currentData.xAxisData) {
                textWidth = getMaxWidthForAxisData('x', chart.currentData.xAxisData, chart._vars, dimensions, margin, chart.chartDiv, chart.config.type);
                //subtract space for tilt
                textWidth = Math.ceil(textWidth);
                if (textWidth > 100) {
                    textWidth = 100;
                }
                //specific to heatmap
                //if (chart.config.type === 'heatmap') {
                if (textWidth > 100) {
                    textWidth = 100;
                } else if (textWidth < 80) {
                    textWidth = 80;
                }
                //}
                chart._vars.heatmapXmargin = textWidth;
                margin.top = textWidth;
                customSize = {};
                //set container
                customSize.width = chart.currentData.xAxisData.values.length * 20;
                customSize.height = chart.currentData.yAxisData.values.length * 20;

                if (!chart._vars.toggleLegend) {
                    var dummyObj = {};
                    dummyObj.values = chart.data.heatData;
                    dummyObj.values.sort(function (a, b) {
                        return a - b;
                    });
                    dummyObj.label = '';
                    dummyObj.min = dummyObj.values[0];
                    dummyObj.max = dummyObj.values[dummyObj.values.length - 1];

                    textWidth = getMaxWidthForAxisData('y', dummyObj, chart._vars, dimensions, margin, chart.chartDiv, chart.config.type);
                    chart.config.heatWidth = Math.ceil(textWidth) + 30;
                    margin.left = margin.left + chart.config.heatWidth;
                }

                if (customSize.width + margin.left + margin.right < dimensions.width) {
                    margin.right = parseInt(dimensions.width, 10) - margin.left - customSize.width - 20;
                }
                if (customSize.height + margin.top + margin.bottom < dimensions.height) {
                    margin.bottom = parseInt(dimensions.height, 10) - margin.top - customSize.height - 10;
                }
                customSize.width += margin.right + margin.left;
                customSize.height += margin.top + margin.bottom;
            }

            //set container attributes
            //Set svg size based on calculation margins or custom size if specified
            if (customSize && customSize.hasOwnProperty('height')) {
                container.height = customSize.height - margin.top - margin.bottom;
            } else {
                container.height = parseInt(dimensions.height, 10) - margin.top - margin.bottom;
                if (container.height <= 50) {
                    margin.top = 10;
                    margin.bottom = 10;
                    container.height = parseInt(dimensions.height, 10) - margin.top - margin.bottom;
                    chart._vars.xLabelFontSize = 0;
                }
            }

            if (customSize && customSize.hasOwnProperty('width')) {
                container.width = customSize.width - margin.left - margin.right;
            } else {
                container.width = parseInt(dimensions.width, 10) - margin.left - margin.right;
            }

            //add margin and container to chart config object
            chart.config.margin = margin;
            chart.config.container = container;

            //remove old svg if it exists
            chart.svg = chart.chartDiv.select('svg').remove();

            //svg layer
            if (chart.config.type === 'heatmap' || chart.config.type === 'singleaxis') {
                chart.svg = chart.chartDiv.append('svg').attr('class', 'editable-svg').attr('width', container.width + margin.left + margin.right).attr('height', container.height + margin.top + margin.bottom).append('g').attr('class', 'container').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
            } else if (chart.config.type === 'clustergram') {
                var sizeWidth = chart.rightLeaves.length * 20;
                if (sizeWidth < container.width) {
                    sizeWidth = container.width;
                }

                var sizeHeight = chart.leftLeaves.length * 20;
                if (sizeHeight < container.height) {
                    sizeHeight = container.height;
                }

                chart.svg = chart.chartDiv.append('svg').attr('class', 'editable-svg').attr('width', sizeWidth + margin.left + margin.right).attr('height', sizeHeight + margin.top + margin.bottom).append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
            } else {
                chart.svg = chart.chartDiv.append('svg').attr('class', 'editable-svg').attr('width', container.width + margin.left + margin.right).attr('height', container.height + margin.top + margin.bottom).append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
            }

            //TODO move to edit mode
            if (chart._vars.backgroundColor !== 'none') {
                chart.colorBackground(chart._vars.backgroundColor);
            }
        }

        /**generateXAxis
         * creates x axis on the svg
         *
         * @params xAxisData
         */

    }, {
        key: 'generateXAxis',
        value: function generateXAxis(xAxisData, ticks) {
            //declare variables
            var chart = this,
                xAxis = void 0,

            //Need to getXAxisScale each time so that axis updates on resize
            xAxisScale = jvCharts.getAxisScale('x', xAxisData, chart.config.container, chart._vars),
                containerHeight = chart.config.container.height,
                containerWidth = chart.config.container.width,
                xAxisClass = 'xAxisLabels editable editable-xAxis editable-text',
                tickSize = 0,
                axisHeight = containerHeight,
                xContent = void 0,
                xAxisGroup = void 0,
                formatValueType = void 0;

            //assign css class for edit mode
            //if the axis is numbers add editable-num
            if (xAxisData.dataType === 'NUMBER') {
                xAxisClass += ' editable-num';
            }

            //remove previous xAxis container if its there
            chart.svg.selectAll('.xAxisContainer').remove();

            //Save the axis scale to chart object
            chart.currentData.xAxisScale = xAxisScale;

            if (chart.currentData.xAxisData.dataType === 'NUMBER') {
                tickSize = 5;
            }

            //create xAxis drawing function
            if (chart.config.type === 'singleaxis') {
                xAxis = d3.axisTop(xAxisScale).tickSize(tickSize);
            } else {
                xAxis = d3.axisBottom(xAxisScale).tickSize(tickSize);
            }

            if (ticks) {
                xAxis.ticks(ticks);
            }

            if (chart.config.type === 'singleaxis') {
                //For any axes that are on top of the data
                axisHeight = 0;
            }

            xContent = chart.svg.append('g').attr('class', 'xAxisContainer').attr('transform', 'translate(0,' + axisHeight + ')');

            xAxisGroup = xContent.append('g').attr('class', 'xAxis').call(xAxis);

            formatValueType = jvFormatValueType(xAxisData.values);

            //Styling the axis
            xAxisGroup.select('path').attr('stroke', chart._vars.axisColor).attr('stroke-width', chart._vars.strokeWidth);

            //Styling for ticks
            xAxisGroup.selectAll('line').attr('stroke', chart._vars.axisColor).attr('stroke-width', chart._vars.stroke);

            //Styling the labels for each piece of data
            xAxisGroup.selectAll('text').attr('fill', chart._vars.fontColor) //Customize the color of axis labels
            .attr('class', xAxisClass).style('text-anchor', 'middle').attr('font-size', chart._vars.fontSize).attr('transform', 'translate(0, 3)').text(function (d) {
                if (xAxisData.dataType === 'NUMBER' || chart._vars.rotateAxis) {
                    return jvFormatValue(d, formatValueType);
                }
                return d;
            });

            //Styling the label for the entire axis
            xContent.append('g').attr('class', 'xLabel').append('text').attr('class', 'xLabel editable editable-text editable-content').attr('text-anchor', 'middle').attr('font-size', chart._vars.fontSize).text(function () {
                if (xAxisData.dataType === 'DATE') {
                    return '';
                }
                return xAxisData.label;
            }).attr('transform', 'translate(' + containerWidth / 2 + ', 33)');
        }

        /**FormatXAxisLabels
         *
         * If x-axis labels are too long/overlapping, they will be hidden/shortened
         */

    }, {
        key: 'formatXAxisLabels',
        value: function formatXAxisLabels(dataLength, recursion) {
            var chart = this,
                showAxisLabels = true,
                xAxisLength = chart.config.container.width,
                textWidth = [],
                formatValueType = null,
                dataType = chart.currentData.xAxisData.dataType,
                axisValues = chart.currentData.xAxisData.values;

            if (dataType === 'NUMBER') {
                formatValueType = jvFormatValueType(axisValues);
            }

            //create dummy text to determine computed text length for the axis labels
            //necessary to do this because axis labels getBBox() is returning 0 since they do not seem to be drawn yet
            chart.svg.append('g').selectAll('.dummyText').data(axisValues).enter().append('text').attr('font-family', 'sans-serif').attr('font-size', chart._vars.fontSize).text(function (d) {
                var returnVal = d;
                if (dataType === 'NUMBER') {
                    returnVal = jvFormatValue(d, formatValueType);
                }
                return returnVal;
            }).each(function () {
                //adding 10px buffer
                var thisWidth = this.getComputedTextLength() + 10;
                textWidth.push(thisWidth);
                this.remove(); //remove them just after displaying them
            });

            var _iteratorNormalCompletion9 = true;
            var _didIteratorError9 = false;
            var _iteratorError9 = undefined;

            try {
                for (var _iterator9 = textWidth[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
                    var textEle = _step9.value;

                    if (textEle > xAxisLength / dataLength) {
                        showAxisLabels = false;
                    }
                }
            } catch (err) {
                _didIteratorError9 = true;
                _iteratorError9 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion9 && _iterator9.return) {
                        _iterator9.return();
                    }
                } finally {
                    if (_didIteratorError9) {
                        throw _iteratorError9;
                    }
                }
            }

            if (showAxisLabels) {
                if (recursion) {
                    chart.generateXAxis(chart.currentData.xAxisData, dataLength);
                }
                chart.svg.selectAll('.xAxisLabels').style('display', 'block');
            } else if (dataLength > 1 && chart.currentData.xAxisData.dataType === 'NUMBER') {
                //recursively keep decreasing to figure out ticks length to repaint the xAxis if its numeric
                chart.formatXAxisLabels(dataLength - 1, true);
            } else {
                chart.svg.selectAll('.xAxis').selectAll('text').style('display', 'none');
            }
        }

        /**generateYAxis
         * creates y axis on the svg
         *
         * @params generateYAxis
         */

    }, {
        key: 'generateYAxis',
        value: function generateYAxis(yAxisData) {
            var chart = this,
                yAxisScale = jvCharts.getAxisScale('y', yAxisData, chart.config.container, chart._vars),
                yAxisClass = 'yAxisLabels editable editable-yAxis editable-text',
                maxYAxisLabelWidth = void 0,
                numberOfTicks = Math.floor(chart.config.container.height / 14),
                yAxis = void 0,
                yContent = void 0,
                yAxisGroup = void 0,
                forceFormatTypeTo = null,
                ylabel = '';

            //assign css class for edit mode
            //if the axis is numbers add editable-num
            if (yAxisData.dataType === 'NUMBER') {
                yAxisClass += ' editable-num';
            }

            //Save y axis scale to chart object
            chart.currentData.yAxisScale = yAxisScale;

            //remove previous svg elements
            chart.svg.selectAll('.yAxisContainer').remove();
            chart.svg.selectAll('text.yLabel').remove();

            if (numberOfTicks > 10) {
                if (numberOfTicks < 20) {
                    numberOfTicks = 10;
                } else if (numberOfTicks < 30) {
                    numberOfTicks /= 2;
                } else {
                    numberOfTicks = 15;
                }
            }

            //If all y-axis values are the same, only show a tick for that value. If value is 1, don't show any decimal places
            if (yAxisData.values.length > 0 && !!yAxisData.values.reduce(function (a, b) {
                return a === b ? a : NaN;
            })) {
                numberOfTicks = 1;
                if (yAxisData.values[0] === 1) {
                    forceFormatTypeTo = 'nodecimals';
                }
            }
            yAxis = d3.axisLeft().ticks(numberOfTicks) //Link to D3.svg.axis options: https://github.com/mbostock/d3/wiki/SVG-Axes
            .scale(yAxisScale) //Sets the scale to use in the axis
            .tickSize(5) //Sets the thickness of the axis line
            .tickPadding(5);

            //Hide Axis values if necessary
            if (yAxisData.hideValues) {
                yAxis.tickFormat('');
            }
            if (chart._vars.displayYAxisLabel) {
                ylabel = yAxisData.label;
            }

            yContent = chart.svg.append('g').attr('class', 'yAxisContainer');

            yContent.append('g').attr('class', 'yLabel').append('text').attr('class', 'yLabel editable editable-text editable-content').attr('text-anchor', 'start').attr('font-size', chart._vars.fontSize).attr('x', 0).attr('y', 0).attr('transform', 'translate(' + (-chart.config.margin.left + 10) + ', -10)').text(ylabel).attr('fill-opacity', 1);

            yAxisGroup = yContent.append('g').attr('class', 'yAxis');

            yAxisGroup.call(yAxis);

            //Styling for Axis
            yAxisGroup.select('path').attr('stroke', chart._vars.axisColor).attr('stroke-width', chart._vars.strokeWidth);

            maxYAxisLabelWidth = 0;

            if (yAxisData.hideValues) {
                //Styling for ticks
                yAxisGroup.selectAll('line').attr('stroke-width', 0);
            } else {
                var formatValueType = jvFormatValueType(yAxisData.values);
                //Styling for ticks
                yAxisGroup.selectAll('line').attr('stroke', chart._vars.axisColor).attr('stroke-width', chart._vars.stroke);
                //Styling for data labels on axis
                yAxisGroup.selectAll('text').attr('fill', chart._vars.fontColor) //Customize the color of axis labels
                .attr('class', yAxisClass).attr('transform', 'rotate(0)') //Add logic to rotate axis based on size of title
                .attr('font-size', chart._vars.fontSize).append('svg:title');

                yAxisGroup.selectAll('text').text(function (d) {
                    if (chart._vars.rotateAxis) {
                        return d;
                    }
                    var maxLength = 13,
                        current = '';
                    if (d.length > maxLength) {
                        current = d.substring(0, maxLength) + '...';
                    } else {
                        current = d;
                    }

                    if (forceFormatTypeTo !== null) {
                        formatValueType = forceFormatTypeTo;
                    }
                    return jvFormatValue(current, formatValueType);
                }).each(function (d, i, j) {
                    if (j[0].getBBox().width > maxYAxisLabelWidth) {
                        maxYAxisLabelWidth = j[0].getBBox().width;
                    }
                });
                if (maxYAxisLabelWidth > 0) {
                    chart._vars.yLabelWidth = Math.ceil(maxYAxisLabelWidth) + 20;
                }
            }
        }
        /************************************************ Legend functions ******************************************************/

    }, {
        key: 'generateLegend',
        value: function generateLegend(legendData, drawFunc) {
            var chart = this,
                svg = chart.svg,
                legendElements = void 0;

            if (!chart._vars.toggleLegend) {
                return;
            }
            svg.selectAll('.legend').remove();

            legendElements = generateLegendElements(chart, legendData, drawFunc);

            //Returns the legend rectangles that are toggled on/off
            if (drawFunc) {
                attachClickEventsToLegend(chart, legendElements, drawFunc, legendData);
            }

            if (chart._vars.thresholds !== 'none' && chart._vars.thesholdLegend === true) {
                if (chart.config.type === 'bar' || chart.config.type === 'area' || chart.config.type === 'line') {
                    if (chart.config.container.height > 300 && chart.config.container.width > 300) {
                        generateThresholdLegend(chart);
                    }
                }
            }
        }

        /**generateVerticalLegend
         *
         * creates and draws a vertical legend on the svg element
         * @params svg, legendData, options, container, chartData, xAxisData, yAxisData, chartType
         * @returns {{}}
         */

    }, {
        key: 'generateVerticalLegend',
        value: function generateVerticalLegend(paintFunc) {
            var chart = this,
                svg = chart.svg,
                legendData = chart.currentData.legendData,
                legendElements = void 0;

            if (!chart._vars.toggleLegend) {
                return;
            }

            svg.selectAll('.legend').remove();
            legendElements = generateVerticalLegendElements(chart, legendData, paintFunc);

            //Returns the legend rectangles that are toggled on/off
            if (paintFunc !== 'generatePack') {
                attachClickEventsToLegend(chart, legendElements, paintFunc, legendData);
            }
        }

        /**
         *
         * Generates a clip path that contains the contents of the chart area to the view of the chart area container
         * i.e - don't want bars going below the x axis
         */

    }, {
        key: 'generateClipPath',
        value: function generateClipPath() {
            var chart = this,
                svg = chart.svg,
                type = chart.config.type,
                containerName = '.' + type + '-container';

            svg.append('clipPath').attr('id', 'clip').append('rect').attr('x', 0).attr('y', 0).attr('width', chart.config.container.width).attr('height', chart.config.container.height);

            //Break this out into logic for all other vizzes that have overflow issues
            svg.select(containerName).attr('clip-path', 'url(#clip)');
        }
    }, {
        key: 'setThreshold',
        value: function setThreshold(data) {
            var chart = this,
                thresholds = chart._vars.thresholds,
                length = thresholds ? Object.keys(thresholds).length : 0;

            if (thresholds !== 'none') {
                for (var i = length - 1; i >= 0; i--) {
                    var threshold = thresholds[i];
                    //console.log(typeof data == "date");
                    if (data >= Number(threshold.threshold)) {
                        return 'rect-' + i;
                    }
                }
            }
            return '';
        }
    }, {
        key: 'generateLineThreshold',
        value: function generateLineThreshold() {
            var chart = this,
                svg = chart.svg,
                width = chart.config.container.width,
                height = chart.config.container.height,
                thresholds = chart._vars.thresholds,
                length = Object.keys(chart._vars.thresholds).length,
                x = chart.currentData.xAxisScale,
                y = chart.currentData.yAxisScale;

            if (thresholds !== 'none') {
                for (var i = 0; i < length; i++) {
                    var threshold = thresholds[i];
                    if (chart._vars.rotateAxis) {
                        svg.append('line').style('stroke', threshold.thresholdColor).attr('x1', x(threshold.threshold)).attr('y1', 0).attr('x2', x(threshold.threshold)).attr('y2', height).attr('stroke-dasharray', '3, 3');
                    } else {
                        svg.append('line').style('stroke', threshold.thresholdColor).attr('x1', 0).attr('y1', y(threshold.threshold)).attr('x2', width).attr('y2', y(threshold.threshold)).attr('stroke-dasharray', '3, 3');
                    }
                }
            }
        }
    }, {
        key: 'colorBackground',
        value: function colorBackground(color) {
            var chart = this;
            chart._vars.backgroundColor = color;
            chart.chartDiv.style('background-color', '' + color);
        }

        /**displayValues
         *
         * toggles data values that are displayed on the specific type of chart on the svg
         * @params svg, barData, options, xAxisData, yAxisData, container
         * @returns {{}}
         */

    }, {
        key: 'displayValues',
        value: function displayValues() {
            var chart = this,
                svg = chart.svg,
                container = chart.config.container,
                chartData = chart.data.chartData,
                xAxisData = chart.currentData.xAxisData,
                yAxisData = chart.currentData.yAxisData,
                legendOptions = chart._vars.legendOptions,
                cleanedChartData = JSON.parse(JSON.stringify(chartData)),
                data = [],
                //Only stores values
            posCalc,
                x,
                y,
                displayValuesGroup;

            //If series is flipped, use flipped data; initialize with the full data set
            if (chart._vars.seriesFlipped) {
                chartData = chart.flippedData.chartData;
                legendOptions = chart._vars.flippedLegendOptions;
            }

            if (chart._vars.displayValues === true) {
                svg.selectAll('.displayValueContainer').remove();
                if (legendOptions) {
                    //Checking which legend elements are toggled on resize
                    var _iteratorNormalCompletion10 = true;
                    var _didIteratorError10 = false;
                    var _iteratorError10 = undefined;

                    try {
                        for (var _iterator10 = cleanedChartData[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
                            var chartEle = _step10.value;
                            var _iteratorNormalCompletion11 = true;
                            var _didIteratorError11 = false;
                            var _iteratorError11 = undefined;

                            try {
                                for (var _iterator11 = legendOptions[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
                                    var legendEle = _step11.value;

                                    if (legendEle.toggle === false) {
                                        delete chartEle[legendEle.element];
                                    }
                                }
                            } catch (err) {
                                _didIteratorError11 = true;
                                _iteratorError11 = err;
                            } finally {
                                try {
                                    if (!_iteratorNormalCompletion11 && _iterator11.return) {
                                        _iterator11.return();
                                    }
                                } finally {
                                    if (_didIteratorError11) {
                                        throw _iteratorError11;
                                    }
                                }
                            }
                        }
                    } catch (err) {
                        _didIteratorError10 = true;
                        _iteratorError10 = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion10 && _iterator10.return) {
                                _iterator10.return();
                            }
                        } finally {
                            if (_didIteratorError10) {
                                throw _iteratorError10;
                            }
                        }
                    }
                }

                var _iteratorNormalCompletion12 = true;
                var _didIteratorError12 = false;
                var _iteratorError12 = undefined;

                try {
                    for (var _iterator12 = cleanedChartData[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
                        var _chartEle2 = _step12.value;

                        var val = getDisplayValuesElement(_chartEle2, chart.currentData.dataTable, chart.config.type);
                        data.push(val);
                    }
                } catch (err) {
                    _didIteratorError12 = true;
                    _iteratorError12 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion12 && _iterator12.return) {
                            _iterator12.return();
                        }
                    } finally {
                        if (_didIteratorError12) {
                            throw _iteratorError12;
                        }
                    }
                }

                posCalc = getPosCalculations(cleanedChartData, chart._vars, xAxisData, yAxisData, container, chart);
                x = jvCharts.getAxisScale('x', xAxisData, container, chart._vars);
                y = jvCharts.getAxisScale('y', yAxisData, container, chart._vars);

                if (chart._vars.rotateAxis) {
                    //Add a container for display values over each bar group
                    displayValuesGroup = svg.append('g').attr('class', 'displayValuesGroup').selectAll('g').data(data).enter().append('g').attr('class', 'displayValuesGroup').attr('transform', function (d, i) {
                        var translate = y.paddingOuter() * y.step() + y.step() * i;
                        return 'translate(0,' + translate + ')';
                    });

                    displayValuesGroup.selectAll('text').data(function (d) {
                        return d;
                    }).enter().append('text').attr('class', 'displayValue').attr('x', function (d, i, j) {
                        //sets the x position of the bar)
                        return posCalc.width(d, i, j) + posCalc.x(d, i, j);
                    }).attr('y', function (d, i, j) {
                        //sets the y position of the bar
                        return posCalc.y(d, i, j) + posCalc.height(d, i, j) / 2;
                    }).attr('dy', '.35em').attr('text-anchor', 'start').attr('fill', chart._vars.fontColor).text(function (d) {
                        var returnText = Math.round(d * 100) / 100; //round to 2 decimals
                        return jvFormatValue(returnText);
                    }).attr('font-size', chart._vars.fontSize);
                } else {
                    //Add a display values container over each bar group
                    displayValuesGroup = svg.append('g').attr('class', 'displayValuesGroup').selectAll('g').data(data).enter().append('g').attr('class', 'displayValuesGroup').attr('transform', function (d, i) {
                        var translate = x.paddingOuter() * x.step() + x.step() * i;
                        return 'translate(' + translate + ',0)';
                    });
                    displayValuesGroup.selectAll('text').data(function (d) {
                        return d;
                    }).enter().append('text').attr('class', 'displayValue').attr('x', function (d, i, j) {
                        //sets the x position of the bar)
                        return Math.round(posCalc.x(d, i, j) + posCalc.width(d, i, j) / 2);
                    }).attr('y', function (d, i, j) {
                        //sets the y position of the bar
                        return Math.round(posCalc.y(d, i, j)) - 3; //+ posCalc.height(d, i, j) - 5);
                    }).attr('text-anchor', 'middle').attr('fill', chart._vars.fontColor).text(function (d, i, j) {
                        if (chart._vars.stackToggle && chart._vars.displayValuesStackAsPercent) {
                            var total = 0;
                            for (var index = 0; index < j.length; index++) {
                                total += j[index].__data__;
                            }
                            return jvFormatValue(d / total, 'percent');
                        }

                        return jvFormatValue(d);
                    }).attr('font-size', chart._vars.fontSize);

                    if (chart._vars.stackToggle && chart._vars.displayValuesStackTotal) {
                        var stackCounter = 0;
                        svg.append('g').attr('class', 'displayStackTotal').selectAll('g').data(data).enter().append('g').attr('transform', function (d, i) {
                            var translate = x.paddingOuter() * x.step() + x.step() * i;
                            return 'translate(' + translate + ',0)';
                        }).selectAll('text').data(function (d) {
                            return d;
                        }).enter().append('text').attr('x', function (d, i, j) {
                            //sets the x position of the bar)
                            return Math.round(posCalc.x(d, i, j) + posCalc.width(d, i, j) / 2);
                        }).attr('y', function (d, i, j) {
                            //sets the y position of the bar
                            return Math.round(posCalc.y(d, i, j)) - 18; //+ posCalc.height(d, i, j) - 5);
                        }).attr('text-anchor', 'middle').attr('fill', chart._vars.fontColor).text(function (d, i, j) {
                            var yLength = chart.currentData.yAxisData.values.length,
                                xLength = chart.currentData.xAxisData.values.length,
                                indexMax = yLength / xLength,
                                stack = 0;
                            if (i + 1 === indexMax) {
                                for (var k = 0; j < indexMax; k++) {
                                    stack += chart.currentData.yAxisData.values[indexMax * stackCounter + k];
                                }
                                stackCounter++;
                                return jvFormatValue(stack);
                            }
                            return '';
                        }).attr('font-size', chart._vars.fontSize);
                    }
                }
            } else {
                svg.selectAll('.displayValueContainer').remove();
            }
        }
    }, {
        key: 'drawGridlines',
        value: function drawGridlines(axisData) {
            var chart = this,
                scaleData = void 0;

            chart.svg.selectAll('g.gridLines').remove();
            chart.svg.append('g').attr('class', 'gridLines');

            //Determine if gridlines are horizontal or vertical based on rotateAxis
            if (chart._vars.rotateAxis === true || chart.config.type === 'gantt' || chart.config.type === 'singleaxis') {
                var gridLineHeight = chart.config.container.height,
                    xAxisScale = jvCharts.getAxisScale('x', axisData, chart.config.container, chart._vars);

                if (axisData.dataType === 'STRING') {
                    scaleData = axisData.values;
                } else if (axisData.dataType === 'NUMBER' || axisData.dataType === 'DATE') {
                    scaleData = xAxisScale.ticks(10);
                }

                chart.svg.select('.gridLines').selectAll('.horizontalGrid').data(scaleData).enter().append('line').attr('class', 'horizontalGrid').attr('x1', function (d, i) {
                    return i > 0 ? xAxisScale(d) : 0;
                }).attr('x2', function (d, i) {
                    return i > 0 ? xAxisScale(d) : 0;
                }).attr('y1', 0).attr('y2', function (d, i) {
                    return i > 0 ? gridLineHeight : 0;
                }).attr('fill', 'none').attr('shape-rendering', 'crispEdges').attr('stroke', chart._vars.axisColor).attr('stroke-width', chart._vars.gridLineStrokeWidth);
            } else {
                var gridLineWidth = chart.config.container.width,
                    yAxisScale = jvCharts.getAxisScale('y', axisData, chart.config.container, chart._vars);

                if (axisData.dataType === 'STRING') {
                    scaleData = axisData.values;
                } else if (axisData.dataType === 'NUMBER' || axisData.dataType === 'DATE') {
                    scaleData = yAxisScale.ticks(10);
                }

                chart.svg.select('.gridLines').selectAll('.horizontalGrid').data(scaleData).enter().append('line').attr('class', 'horizontalGrid').attr('x1', 0).attr('x2', function (d, i) {
                    return i > 0 ? gridLineWidth : 0;
                }).attr('y1', function (d, i) {
                    return i > 0 ? yAxisScale(d) : 0;
                }).attr('y2', function (d, i) {
                    return i > 0 ? yAxisScale(d) : 0;
                }).attr('fill', 'none').attr('shape-rendering', 'crispEdges').attr('stroke', chart._vars.axisColor).attr('stroke-width', chart._vars.gridLineStrokeWidth);
            }
        }

        /**getBarDataFromOptions
        * ^^ not just a bar function, line and area also use it
        *
        * Assigns the correct chart data to current data using the chart.options
        */

    }, {
        key: 'getBarDataFromOptions',
        value: function getBarDataFromOptions() {
            var chart = this,
                dataObj = {},
                data = chart.data;

            //set flipped data if necessary
            if (chart._vars.seriesFlipped) {
                data = chart.flippedData;
            }

            dataObj.chartData = data.chartData;
            dataObj.legendData = data.legendData;
            dataObj.dataTable = data.dataTable;
            chart._vars.color = data.color;
            if (chart._vars.rotateAxis === true) {
                dataObj.xAxisData = data.yAxisData;
                dataObj.yAxisData = data.xAxisData;
            } else {
                dataObj.xAxisData = data.xAxisData;
                dataObj.yAxisData = data.yAxisData;
            }

            return dataObj;
        }

        /************************************************ Utility functions ******************************************************/

        /**highlightItems
         *
         * highlights items on the svg element
         * @params items, svg
         * @returns {{}}
         */

    }, {
        key: 'highlightItem',
        value: function highlightItem(items, tag, highlightIndex, highlightUri) {
            var chart = this,
                svg = chart.svg;

            //TODO remove if statements
            if (highlightIndex >= 0) {
                if (chart.config.type === 'pie') {
                    //set all circles stroke width to 0
                    svg.select('.pie-container').selectAll(tag).attr('stroke', chart._vars.pieBorder).attr('stroke-width', 1);
                    //highlight necessary pie slices
                    svg.select('.pie-container').selectAll(tag).filter('.highlight-class-' + highlightIndex).attr('stroke', chart._vars.highlightBorderColor).attr('stroke-width', chart._vars.highlightBorderWidth);
                }
                if (chart.config.type === 'scatterplot') {
                    //set all circles stroke width to 0
                    svg.select('.scatter-container').selectAll(tag).attr('stroke-width', 0);
                    //highlight necessary scatter dots
                    svg.select('.scatter-container').selectAll(tag).filter('.scatter-circle-' + highlightIndex).attr('stroke', chart._vars.highlightBorderColor).attr('stroke-width', chart._vars.highlightBorderWidth);
                }
            } else if (highlightUri) {
                if (chart.config.type === 'bar') {
                    //set all bars stroke width to 0
                    svg.select('.bar-container').selectAll(tag).attr('stroke', 0).attr('stroke-width', 0);
                    //highlight necessary bars
                    svg.select('.bar-container').selectAll('.highlight-class-' + highlightUri).attr('stroke', chart._vars.highlightBorderColor).attr('stroke-width', chart._vars.highlightBorderWidth);
                }
                if (chart.config.type === 'line' || chart.config.type === 'area') {
                    //set all circles stroke width to 0
                    svg.select('.line-container').selectAll(tag).attr('stroke', 0).attr('stroke-width', 0);
                    //highlight necessary cirlces
                    svg.select('.line-container').selectAll(tag).filter('.highlight-class-' + highlightUri).attr('stroke', chart._vars.highlightBorderColor).attr('stroke-width', chart._vars.highlightBorderWidth);
                }
            } else {
                console.log('need to pass highlight index to highlight item');
            }
        }

        /**
        *@desc Removes highlights that were applied with related insights
        *
        */

    }, {
        key: 'removeHighlight',
        value: function removeHighlight() {
            var chart = this,
                svg = chart.svg;
            if (chart.config.type === 'pie') {
                //set all circles stroke width to 0
                svg.select('.pie-container').selectAll('path').attr('stroke', chart._vars.pieBorder).attr('stroke-width', 0);
            }
            if (chart.config.type === 'scatterplot') {
                svg.select('.scatter-container').selectAll('circle').attr('stroke-width', 0);
            }
            if (chart.config.type === 'bar') {
                svg.select('.bar-container').selectAll('rect').attr('stroke', 0).attr('stroke-width', 0);
            }
            if (chart.config.type === 'line' || chart.config.type === 'area') {
                svg.select('.line-container').selectAll('circle').attr('stroke', 0).attr('stroke-width', 0);
            }
        }
    }]);

    return jvCharts;
}();

function jvFormatValue(val, formatType) {
    if (!isNaN(val)) {
        var formatNumber = d3.format('.0f');

        if (formatType === 'billions') {
            return formatNumber(val / 1e9) + 'B';
        } else if (formatType === 'millions') {
            return formatNumber(val / 1e6) + 'M';
        } else if (formatType === 'thousands') {
            return formatNumber(val / 1e3) + 'K';
        } else if (formatType === 'decimals') {
            formatNumber = d3.format('.2f');
            return formatNumber(val);
        } else if (formatType === 'nodecimals') {
            return formatNumber(val);
        } else if (formatType === 'percent') {
            var p = Math.max(0, d3.precisionFixed(0.05) - 2),
                expression = d3.format('.' + p + '%');
            return expression(val);
        } else if (formatType === '') {
            return val;
        }

        if (val === 0) {
            return 0;
        }

        if (Math.abs(val) >= 1000000000) {
            //Billions
            return formatNumber(val / 1e9) + 'B';
        } else if (Math.abs(val) >= 1000000) {
            //Millions
            return formatNumber(val / 1e6) + 'M';
        } else if (Math.abs(val) >= 1000) {
            //Thousands
            return formatNumber(val / 1e3) + 'K';
        } else if (Math.abs(val) <= 10) {
            //2 decimals
            formatNumber = d3.format('.2f');
        }
        return formatNumber(val);
    }
    return val;
}

/**
 * @param the set of values that you want to format uniformly
 * @return '' the level of formatting for the group of data
 * Problem with jvFormatValue function is that if you pass in values 10, 20... 90, 100, 1120, 120
 * you will get the formats 10.00, 20.00 .... 100, 110, 120 when you want 10, 20, ... 100, 110
 * --Format the value based off of the highest number in the group
 */
function jvFormatValueType(valueArray, dataType) {
    if (valueArray != null && dataType !== 'STRING') {
        var max = Math.max.apply(null, valueArray),

        //After getting the max, check the min
        min = Math.min.apply(null, valueArray),
            range = max - min,
            incrememnt = Math.abs(Math.round(range / 10)); //10 being the number of axis labels to show

        if (Math.abs(incrememnt) >= 1000000000) {
            return 'billions';
        } else if (Math.abs(incrememnt) >= 1000000) {
            return 'millions';
        } else if (Math.abs(incrememnt) >= 1000) {
            return 'thousands';
        } else if (Math.abs(incrememnt) <= 10) {
            return 'decimals';
        } else if (Math.abs(incrememnt) >= 10) {
            return 'nodecimals';
        }
    }
    return '';
}

/**getFormatExpression
 *
 * @desc returns the d3 format expression for a given option
 * @params option
 * @returns string expression
 */
function getFormatExpression(option) {
    var expression = '',
        p = void 0;
    if (option === 'currency') {
        expression = d3.format('$,');
    }
    if (option === 'fixedCurrency') {
        expression = d3.format('($.2f');
    }
    if (option === 'percent') {
        p = Math.max(0, d3.precisionFixed(0.05) - 2);
        expression = d3.format('.' + p + '%');
    }
    if (option === 'millions') {
        p = d3.precisionPrefix(1e5, 1.3e6);
        expression = d3.formatPrefix('.' + p, 1.3e6);
    }
    if (option === 'commas') {
        expression = d3.format(',.0f');
    }
    if (option === 'none' || option === '') {
        expression = d3.format('');
    }
    if (option === 'displayValues') {
        expression = d3.format(',.2f');
    }

    return expression;
}

/**getToggledData
 *
 * Gets the headers of the data to be drawn and filters the data based on that
 * @params chartData, dataHeaders
 */
function getToggledData(data, dataHeaders) {
    var legendToggleArray = getLegendElementToggleArray(dataHeaders, data.legendData),
        newData = JSON.parse(JSON.stringify(data.chartData));
    if (legendToggleArray) {
        for (var i = 0; i < data.chartData.length; i++) {
            var _iteratorNormalCompletion13 = true;
            var _didIteratorError13 = false;
            var _iteratorError13 = undefined;

            try {
                for (var _iterator13 = legendToggleArray[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
                    var toggleKey = _step13.value;

                    if (toggleKey.toggle === false) {
                        delete newData[i][toggleKey.element];
                    }
                }
            } catch (err) {
                _didIteratorError13 = true;
                _iteratorError13 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion13 && _iterator13.return) {
                        _iterator13.return();
                    }
                } finally {
                    if (_didIteratorError13) {
                        throw _iteratorError13;
                    }
                }
            }
        }
    }
    return newData;
}

/**
 * @name getLegendElementToggleArray
 * @desc Gets an array of legend elements with true/false tags for if toggled
 * @param {any} selectedHeaders - headers selected by user
 * @param {any} allHeaders - all available headers in the visual
 * @returns {array} - array of legend elements
 */
function getLegendElementToggleArray(selectedHeaders, allHeaders) {
    var legendToggleArray = [];
    var _iteratorNormalCompletion14 = true;
    var _didIteratorError14 = false;
    var _iteratorError14 = undefined;

    try {
        for (var _iterator14 = allHeaders[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {
            var header = _step14.value;

            legendToggleArray.push({ element: header });
        }
    } catch (err) {
        _didIteratorError14 = true;
        _iteratorError14 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion14 && _iterator14.return) {
                _iterator14.return();
            }
        } finally {
            if (_didIteratorError14) {
                throw _iteratorError14;
            }
        }
    }

    var _iteratorNormalCompletion15 = true;
    var _didIteratorError15 = false;
    var _iteratorError15 = undefined;

    try {
        for (var _iterator15 = legendToggleArray[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {
            var toggleKey = _step15.value;
            var _iteratorNormalCompletion16 = true;
            var _didIteratorError16 = false;
            var _iteratorError16 = undefined;

            try {
                for (var _iterator16 = selectedHeaders[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {
                    var _header = _step16.value;

                    if (toggleKey.element === _header) {
                        toggleKey.toggle = true;
                        continue;
                    }
                }
            } catch (err) {
                _didIteratorError16 = true;
                _iteratorError16 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion16 && _iterator16.return) {
                        _iterator16.return();
                    }
                } finally {
                    if (_didIteratorError16) {
                        throw _iteratorError16;
                    }
                }
            }

            if (toggleKey.toggle !== true) {
                toggleKey.toggle = false;
            }
        }
    } catch (err) {
        _didIteratorError15 = true;
        _iteratorError15 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion15 && _iterator15.return) {
                _iterator15.return();
            }
        } finally {
            if (_didIteratorError15) {
                throw _iteratorError15;
            }
        }
    }

    return legendToggleArray;
}

/**
 * generateLegendElements
 *
 * @param {any} chart - chart object
 * @param {any} legendData -legend data for visual
 * @param {any} drawFunc - redraw function for visual
 * @returns {object} - legend rectangles
 */
function generateLegendElements(chart, legendData, drawFunc) {
    var svg = chart.svg,
        container = chart.config.container,
        legend = void 0,
        legendRow = 0,
        legendColumn = 0,
        legendDataLength = legendData.length,
        legendElementToggleArray = void 0,
        legendRectangles = void 0,
        legendText = void 0;

    if (!chart._vars.legendIndex) {
        chart._vars.legendIndex = 0;
    }

    if (!chart._vars.legendIndexMax) {
        chart._vars.legendIndexMax = Math.floor(legendDataLength / chart._vars.legendMax - 0.01);
    }

    //if legend headers don't exist, set them equal to legend data
    if (!chart._vars.legendHeaders && !chart._vars.seriesFlipped) {
        chart._vars.legendHeaders = JSON.parse(JSON.stringify(legendData));
    } else if (!chart._vars.flippedLegendHeaders && chart._vars.seriesFlipped) {
        chart._vars.flippedLegendHeaders = JSON.parse(JSON.stringify(legendData));
    }
    //Set legend element toggle array based on if series is flipped
    if (!chart._vars.seriesFlipped) {
        legendElementToggleArray = getLegendElementToggleArray(chart._vars.legendHeaders, legendData);
    } else {
        legendElementToggleArray = getLegendElementToggleArray(chart._vars.flippedLegendHeaders, legendData);
    }

    legend = svg.append('g').attr('class', 'legend');

    //Adding colored rectangles to the legend
    legendRectangles = legend.selectAll('rect').data(legendData).enter().append('rect').attr('class', 'legendRect').attr('x', function (d, i) {
        var legendPos = void 0;
        if (i % (chart._vars.legendMax / 3) === 0 && i > 0) {
            legendColumn = 0;
        }
        legendPos = 200 * legendColumn;
        legendColumn++;
        return legendPos;
    }).attr('y', function (d, i) {
        if (i % (chart._vars.legendMax / 3) === 0 && i > 0) {
            legendRow++;
        }
        if (i % chart._vars.legendMax === 0 && i > 0) {
            legendRow = 0;
        }
        return container.height + 10 + 15 * (legendRow + 1) - 5; //Increment row when column limit is reached
    }).attr('width', chart._vars.gridSize).attr('height', chart._vars.gridSize).attr('fill', function (d, i) {
        return getColors(chart._vars.color, i, legendData[i]);
    }).attr('display', function (d, i) {
        if (i >= chart._vars.legendIndex * chart._vars.legendMax && i <= chart._vars.legendIndex * chart._vars.legendMax + (chart._vars.legendMax - 1)) {
            return 'all';
        }
        return 'none';
    }).attr('opacity', function (d, i) {
        if (!legendElementToggleArray) {
            return '1';
        }
        if (legendElementToggleArray[i].toggle === true) {
            return '1';
        }
        return '0.2';
    });

    legendRow = 0;
    legendColumn = 0;

    //Adding text labels for each rectangle in legend
    legendText = legend.selectAll('text').data(legendData).enter().append('text').attr('class', function (d, i) {
        return 'legendText editable editable-text editable-content editable-legend-' + i;
    }).attr('x', function (d, i) {
        if (i % (chart._vars.legendMax / 3) === 0 && i > 0) {
            legendColumn = 0;
        }
        var legendPos = 200 * legendColumn;
        legendColumn++;
        return legendPos + 17;
    }).attr('y', function (d, i) {
        if (i % (chart._vars.legendMax / 3) === 0 && i > 0) {
            legendRow++;
        }
        if (i % chart._vars.legendMax === 0 && i > 0) {
            legendRow = 0;
        }
        return container.height + 10 + 15 * (legendRow + 1); //Increment row when column limit is reached
    }).attr('text-anchor', 'start').attr('dy', '0.35em') //Vertically align with node
    .attr('fill', chart._vars.fontColor).attr('font-size', chart._vars.fontSize).attr('display', function (d, i) {
        if (i >= chart._vars.legendIndex * chart._vars.legendMax && i <= chart._vars.legendIndex * chart._vars.legendMax + (chart._vars.legendMax - 1)) {
            return 'all';
        }
        return 'none';
    }).text(function (d, i) {
        var elementName = legendData[i];
        if (chart.config.type === 'gantt') {
            elementName = legendData[i].slice(0, -5); //Removing last 5 characters of legend label---i.e plannedSTART -> planned
        }
        if (elementName.length > 20) {
            return elementName.substring(0, 19) + '...';
        }
        return elementName;
    });

    //Adding info box to legend elements when hovering over
    legendText.data(legendData).append('svg:title').text(function (d) {
        return d;
    });

    //Only create carousel if the number of elements exceeds one legend "page"
    if (chart._vars.legendIndexMax > 0) {
        createCarousel(chart, legendData, drawFunc);
    }
    //Centers the legend in the panel
    if (legend) {
        var legendWidth = legend.node().getBBox().width;
        legend.attr('transform', 'translate(' + (container.width - legendWidth) / 2 + ', 30)');
    }

    return legendRectangles;
}

/**updateDataFromLegend
 *
 * Returns a list of data headers that should be displayed in viz
 * based off what is toggled on/off in legend
 * @params legendData
 */
function updateDataFromLegend(legendData) {
    var data = [],
        legendElement = legendData[0];
    var _iteratorNormalCompletion17 = true;
    var _didIteratorError17 = false;
    var _iteratorError17 = undefined;

    try {
        for (var _iterator17 = legendElement[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {
            var ele = _step17.value;

            if (ele.attributes.opacity.value !== '0.2') {
                //If not white, add it to the updated data array
                data.push(ele.__data__);
            }
        }
    } catch (err) {
        _didIteratorError17 = true;
        _iteratorError17 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion17 && _iterator17.return) {
                _iterator17.return();
            }
        } finally {
            if (_didIteratorError17) {
                throw _iteratorError17;
            }
        }
    }

    return data;
}

/**createCarousel
 *
 * Draws the horizontal legend carousel
 * @params chart, legendData, drawFunc
 */
function createCarousel(chart, legendData, drawFunc) {
    var svg = chart.svg,
        container = chart.config.container,
        legendPolygon = void 0;

    //Adding carousel to legend
    svg.selectAll('.legend-carousel').remove();
    svg.selectAll('#legend-text-index').remove();

    legendPolygon = svg.append('g').attr('class', 'legend-carousel');

    //Creates left navigation arrow for carousel
    legendPolygon.append('polygon').attr('id', 'leftChevron').attr('class', 'pointer-cursor').style('fill', chart._vars.legendArrowColor).attr('transform', 'translate(0,0)').attr('points', '0,7.5, 15,0, 15,15').on('click', function () {
        if (chart._vars.legendIndex >= 1) {
            chart._vars.legendIndex--;
        }
        svg.selectAll('.legend').remove();
        var legendElements = generateLegendElements(chart, legendData, drawFunc);
        attachClickEventsToLegend(chart, legendElements, drawFunc, legendData);
    }).attr({
        display: function display() {
            if (chart._vars.legendIndex === 0) {
                return 'none';
            }
            return 'all';
        }
    });

    //Creates page number for carousel navigation
    legendPolygon.append('text').attr('id', 'legend-text-index').attr('x', 35).attr('y', 12.5).style('text-anchor', 'start').style('font-size', chart._vars.fontSize).text(function () {
        return chart._vars.legendIndex + 1 + ' / ' + (chart._vars.legendIndexMax + 1);
    }).attr({
        display: function display() {
            if (chart._vars.legendIndexMax === 0) {
                return 'none';
            }
            return 'all';
        }
    });

    //Creates right navigation arrow for carousel
    legendPolygon.append('polygon').attr('id', 'rightChevron').attr('class', 'pointer-cursor').style('fill', chart._vars.legendArrowColor).attr('transform', 'translate(85,0)').attr('points', '15,7.5, 0,0, 0,15').on('click', function () {
        if (chart._vars.legendIndex < chart._vars.legendIndexMax) {
            chart._vars.legendIndex++;
        }
        svg.selectAll('.legend').remove();
        var legendElements = generateLegendElements(chart, legendData, drawFunc);
        attachClickEventsToLegend(chart, legendElements, drawFunc, legendData);
    }).attr({
        display: function display() {
            if (chart._vars.legendIndex === chart._vars.legendIndexMax) {
                return 'none';
            }
            return 'all';
        }
    });

    //Centers the legend polygons in the panel
    if (legendPolygon) {
        var legendPolygonWidth = legendPolygon.node().getBBox().width;
        legendPolygon.attr('transform', 'translate(' + (container.width - legendPolygonWidth) / 2 + ',' + (container.height + 105) + ')');
    }
}

/**getPlotData
 *
 * Returns only data values to be plotted; input is the data object
 * @params objectData, chart
 */
function getPlotData(objectData, chart) {
    var data = [],
        objDataNew = JSON.parse(JSON.stringify(objectData)); //Copy of barData
    var _iteratorNormalCompletion18 = true;
    var _didIteratorError18 = false;
    var _iteratorError18 = undefined;

    try {
        for (var _iterator18 = objDataNew[Symbol.iterator](), _step18; !(_iteratorNormalCompletion18 = (_step18 = _iterator18.next()).done); _iteratorNormalCompletion18 = true) {
            var objEle = _step18.value;

            var group = [];
            var _iteratorNormalCompletion19 = true;
            var _didIteratorError19 = false;
            var _iteratorError19 = undefined;

            try {
                for (var _iterator19 = chart.currentData.legendData[Symbol.iterator](), _step19; !(_iteratorNormalCompletion19 = (_step19 = _iterator19.next()).done); _iteratorNormalCompletion19 = true) {
                    var legendEle = _step19.value;

                    if (typeof objEle[legendEle] !== 'undefined') {
                        group.push(objEle[legendEle]);
                    }
                }
            } catch (err) {
                _didIteratorError19 = true;
                _iteratorError19 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion19 && _iterator19.return) {
                        _iterator19.return();
                    }
                } finally {
                    if (_didIteratorError19) {
                        throw _iteratorError19;
                    }
                }
            }

            data.push(group);
        }
    } catch (err) {
        _didIteratorError18 = true;
        _iteratorError18 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion18 && _iterator18.return) {
                _iterator18.return();
            }
        } finally {
            if (_didIteratorError18) {
                throw _iteratorError18;
            }
        }
    }

    return data;
}

/**getPosCalculations
 *Holds the logic for positioning all bars on a bar chart (depends on toolData)
 *
 * @params svg, chartData, options, xAxisData, yAxisData, container
 * @returns {{}}
 */
function getPosCalculations(chartData, _vars, xAxisData, yAxisData, container, chart) {
    var x = jvCharts.getAxisScale('x', xAxisData, container, _vars),
        y = jvCharts.getAxisScale('y', yAxisData, container, _vars),
        scaleFactor = 1,
        data = [],
        size = 0,
        positionFunctions = {};

    for (var item in chart.currentData.dataTable) {
        if (item !== 'label' && item.indexOf('tooltip') === -1) {
            size++;
        }
    }

    var _iteratorNormalCompletion20 = true;
    var _didIteratorError20 = false;
    var _iteratorError20 = undefined;

    try {
        for (var _iterator20 = chartData[Symbol.iterator](), _step20; !(_iteratorNormalCompletion20 = (_step20 = _iterator20.next()).done); _iteratorNormalCompletion20 = true) {
            var chartEle = _step20.value;

            var val = [];
            for (var key in chartEle) {
                if (chartEle.hasOwnProperty(key)) {
                    val.push(chartEle[key]);
                }
            }
            data.push(val.slice(1, chartEle.length));
        }
    } catch (err) {
        _didIteratorError20 = true;
        _iteratorError20 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion20 && _iterator20.return) {
                _iterator20.return();
            }
        } finally {
            if (_didIteratorError20) {
                throw _iteratorError20;
            }
        }
    }

    if (_vars.rotateAxis === true && _vars.stackToggle === true) {
        positionFunctions.startx = function () {
            return 0;
        };
        positionFunctions.starty = function () {
            return 0;
        };
        positionFunctions.startwidth = function () {
            return 0;
        };
        positionFunctions.startheight = function () {
            return y.bandwidth() * 0.95;
        };
        positionFunctions.x = function (d, i, j) {
            var increment = 0; //Move the x up by the values that come before it
            for (var k = i - 1; k >= 0; k--) {
                if (!isNaN(j[k].__data__)) {
                    increment += j[k].__data__;
                }
            }
            return x(increment) === 0 ? 1 : x(increment);
        };
        positionFunctions.y = function () {
            return 0;
        };
        positionFunctions.width = function (d) {
            return Math.abs(x(0) - x(d));
        };
        positionFunctions.height = function () {
            return y.bandwidth() * 0.95;
        };
    } else if (_vars.rotateAxis === true && _vars.stackToggle === false) {
        positionFunctions.startx = function () {
            return 0;
        };
        positionFunctions.starty = function (d, i) {
            return y.bandwidth() / size * i;
        };
        positionFunctions.startwidth = function () {
            return 0;
        };
        positionFunctions.startheight = function () {
            return y.bandwidth() / size * 0.95 * scaleFactor;
        };
        positionFunctions.x = function (d) {
            return x(0) - x(d) > 0 ? x(d) : x(0);
        };
        positionFunctions.y = function (d, i) {
            return y.bandwidth() / size * i;
        };
        positionFunctions.width = function (d) {
            return Math.abs(x(0) - x(d));
        };
        positionFunctions.height = function () {
            return y.bandwidth() / size * 0.95 * scaleFactor;
        };
    } else if (_vars.rotateAxis === false && _vars.stackToggle === true) {
        positionFunctions.startx = function () {
            return 0;
        };
        positionFunctions.starty = function () {
            return container.height;
        };
        positionFunctions.startwidth = function () {
            return x.bandwidth() * 0.95 * scaleFactor;
        };
        positionFunctions.startheight = function () {
            return 0;
        };
        positionFunctions.x = function () {
            return 0;
        };
        positionFunctions.y = function (d, i, j) {
            var increment = 0; //Move the y up by the values that come before it
            for (var k = i - 1; k >= 0; k--) {
                if (!isNaN(j[k].__data__)) {
                    increment += j[k].__data__;
                }
            }
            return y(parseFloat(d) + increment);
        };
        positionFunctions.width = function () {
            return x.bandwidth() * 0.95 * scaleFactor;
        };
        positionFunctions.height = function (d) {
            return container.height - y(d);
        };
    } else if (_vars.rotateAxis === false && _vars.stackToggle === false) {
        positionFunctions.startx = function (d, i) {
            return x.bandwidth() / size * i;
        };
        positionFunctions.starty = function () {
            return container.height;
        };
        positionFunctions.startwidth = function () {
            return x.bandwidth() / size * 0.95;
        };
        positionFunctions.startheight = function () {
            return 0;
        };
        positionFunctions.x = function (d, i) {
            return x.bandwidth() / size * i;
        };
        positionFunctions.y = function (d) {
            return y(0) - y(d) > 0 ? y(d) : y(0);
        };
        positionFunctions.width = function () {
            return x.bandwidth() / size * 0.95;
        };
        positionFunctions.height = function (d) {
            return Math.abs(y(0) - y(d));
        };
    }
    return positionFunctions;
}

/**getColors
 *
 * gets the colors to apply to the specific chart
 * @params colorObj, index, label
 * @returns {{}}
 */
function getColors(colorObj, paramIndex, label) {
    var index = paramIndex,
        cleanedColors = void 0;

    //logic to return the color if the colorObj passed in
    //is an object with the label being the key
    if (typeof label !== 'undefined' && colorObj.hasOwnProperty(label) && colorObj[label]) {
        return colorObj[label];
    }

    if (!Array.isArray(colorObj)) {
        cleanedColors = [];
        for (var k in colorObj) {
            if (colorObj.hasOwnProperty(k)) {
                if (colorObj[k]) {
                    cleanedColors.push(colorObj[k]);
                }
            }
        }
    } else {
        cleanedColors = colorObj;
    }

    //logic to return a repeating set of colors assuming that
    //the user changed data (ex: flip series on bar chart)
    if (!cleanedColors[index]) {
        while (index > cleanedColors.length - 1) {
            index = index - cleanedColors.length;
        }
    }
    return cleanedColors[index];
}

function getAxisScale(whichAxis, axisData, container, _vars, paddingType) {
    var leftPadding = 0.4,
        rightPadding = 0.2,
        axisScale = void 0,
        axis = void 0,
        minDate = void 0,
        maxDate = void 0;

    if (paddingType === 'no-padding') {
        leftPadding = 0;
        rightPadding = 0;
    }

    whichAxis === 'x' ? axis = container.width : axis = container.height;

    if (axisData.dataType === 'DATE') {
        for (var i = 0; i < axisData.values.length; i++) {
            axisData.values[i] = new Date(axisData.values[i]);
        }

        maxDate = Math.max.apply(null, axisData.values);
        minDate = Math.min.apply(null, axisData.values);

        axisScale = d3.scaleTime().domain([new Date(minDate), new Date(maxDate)]).rangeRound([0, axis]);
    } else if (axisData.dataType === 'STRING') {
        axisScale = d3.scaleBand().domain(axisData.values).range([0, axis]).paddingInner(leftPadding).paddingOuter(rightPadding);
    } else if (axisData.dataType === 'NUMBER') {
        var domain = void 0;
        if (_vars.xReversed || _vars.yReversed) {
            if (_vars.xReversed && whichAxis === 'x' || whichAxis === 'y' && !_vars.yReversed) {
                domain = [axisData.max, axisData.min];
            }
            if (_vars.yReversed && whichAxis === 'y' || whichAxis === 'x' && !_vars.xReversed) {
                domain = [axisData.min, axisData.max];
            }
        } else {
            whichAxis === 'x' ? domain = [axisData.min, axisData.max] : domain = [axisData.max, axisData.min];
        }

        if (_vars.hasOwnProperty('axisType') && _vars.axisType === 'Logarithmic') {
            domain[1] = 0.1;
            axisScale = d3.scaleLog().base(10).domain(domain).rangeRound([0, axis]);
        } else {
            axisScale = d3.scaleLinear().domain(domain).rangeRound([0, axis]);
        }
    } else {
        console.error('Axis is not a valid data type');
        //throw new Error('Axis is not a valid data type');
    }
    return axisScale;
}

/************************************************ Data functions ******************************************************/

/**
 * @function
 * @param {string} label - The field that is checked for type
 * @param {Object} dataTableKeys - Object that contains the data type for each column of data
 */
function getDataTypeFromKeys(label, dataTableKeys) {
    var defaultType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'STRING';

    var type = defaultType;

    var _iteratorNormalCompletion21 = true;
    var _didIteratorError21 = false;
    var _iteratorError21 = undefined;

    try {
        for (var _iterator21 = dataTableKeys[Symbol.iterator](), _step21; !(_iteratorNormalCompletion21 = (_step21 = _iterator21.next()).done); _iteratorNormalCompletion21 = true) {
            var key = _step21.value;

            //Replace underscores with spaces
            if (key.name.replace(/_/g, ' ') === label.replace(/_/g, ' ')) {
                if (key.hasOwnProperty('type')) {
                    type = (key.type + '').toUpperCase();
                    if (type === 'STRING') {
                        type = 'STRING';
                    } else if (type === 'DATE') {
                        type = 'DATE';
                    } else if (type === 'NUMBER') {
                        type = 'NUMBER';
                    } else {
                        type = 'NUMBER';
                    }
                    break;
                }
            }
        }
    } catch (err) {
        _didIteratorError21 = true;
        _iteratorError21 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion21 && _iterator21.return) {
                _iterator21.return();
            }
        } finally {
            if (_didIteratorError21) {
                throw _iteratorError21;
            }
        }
    }

    return type;
}

/**setBarLineLegendData
 *  gets legend info from chart Data
 *
 * @params data, type
 * @returns [] of legend text
 */
function setBarLineLegendData(data) {
    var legendArray = [];
    for (var item in data.dataTable) {
        if (data.dataTable.hasOwnProperty(item)) {
            if (item !== 'label') {
                legendArray.push(data.dataTable[item]);
            }
        }
    }
    return legendArray;
}

/**setChartColors
 *  cleans incoming colors for consistency
 *
 * @params colorArray, legendData
 * @returns object with colors
 */

function setChartColors(toolData, legendData, defaultColorArray) {
    //function handles 3 color inputs
    //toolData as an array in toolData
    //toolData as an object
    //toolData as 'none'
    //any other case will result in using defaultColorArray

    var colors = {},
        usedColors = [],
        unaccountedLegendElements = [],
        toolDataAsArray = void 0;

    //toolData is array
    if (Array.isArray(toolData)) {
        if (toolData.length > 0) {
            colors = createColorsWithDefault(legendData, toolData);
        } else {
            colors = createColorsWithDefault(legendData, defaultColorArray);
        }
    } else if (toolData === Object(toolData)) {
        var _iteratorNormalCompletion22 = true;
        var _didIteratorError22 = false;
        var _iteratorError22 = undefined;

        try {
            for (var _iterator22 = legendData[Symbol.iterator](), _step22; !(_iteratorNormalCompletion22 = (_step22 = _iterator22.next()).done); _iteratorNormalCompletion22 = true) {
                var legendEle = _step22.value;

                if (toolData.hasOwnProperty(legendEle)) {
                    usedColors.push(toolData[legendEle]);
                } else {
                    unaccountedLegendElements.push(legendEle);
                }
            }
            //check if object has desired keys
        } catch (err) {
            _didIteratorError22 = true;
            _iteratorError22 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion22 && _iterator22.return) {
                    _iterator22.return();
                }
            } finally {
                if (_didIteratorError22) {
                    throw _iteratorError22;
                }
            }
        }

        if (usedColors.length === legendData.length) {
            colors = toolData;
        } else if (usedColors.length > 0) {
            toolDataAsArray = Object.values(toolData);
            if (toolDataAsArray.length > legendData.length) {
                colors = createColorsWithDefault(legendData, toolDataAsArray);
            } else {
                colors = createColorsWithDefault(legendData, defaultColorArray);
            }
        } else {
            toolDataAsArray = Object.values(toolData);
            if (toolDataAsArray.length > legendData.length) {
                colors = createColorsWithDefault(legendData, toolDataAsArray);
            } else {
                colors = createColorsWithDefault(legendData, defaultColorArray);
            }
        }
    } else {
        colors = createColorsWithDefault(legendData, defaultColorArray);
    }

    return colors;
}

function createColorsWithDefault(legendData, colors) {
    var mappedColors = {},
        count = 0;
    var _iteratorNormalCompletion23 = true;
    var _didIteratorError23 = false;
    var _iteratorError23 = undefined;

    try {
        for (var _iterator23 = legendData[Symbol.iterator](), _step23; !(_iteratorNormalCompletion23 = (_step23 = _iterator23.next()).done); _iteratorNormalCompletion23 = true) {
            var legendEle = _step23.value;

            if (count > colors.length - 1) {
                count = 0;
            }
            mappedColors[legendEle] = colors[count];
            count++;
        }
    } catch (err) {
        _didIteratorError23 = true;
        _iteratorError23 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion23 && _iterator23.return) {
                _iterator23.return();
            }
        } finally {
            if (_didIteratorError23) {
                throw _iteratorError23;
            }
        }
    }

    return mappedColors;
}

/**cleanToolData
 *  cleans incoming toolData for consistency
 *
 * @param toolData
 * @returns object with tooldata
 */
function cleanToolData() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var editOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var data = options || {};

    if (!data.hasOwnProperty('rotateAxis')) {
        data.rotateAxis = false;
    }
    if (data.hasOwnProperty('stackToggle')) {
        if (data.stackToggle === 'stack-data' || data.stackToggle === true) {
            data.stackToggle = true;
        } else {
            data.stackToggle = false;
        }
    } else {
        data.stackToggle = false;
    }
    if (data.hasOwnProperty('colors')) {
        data.color = data.colors;
    }
    if (!data.hasOwnProperty('thresholds')) {
        data.thresholds = [];
    }

    //These are used in setting dynamic margins on the y Axis in jvCharts
    if (editOptions && editOptions.hasOwnProperty('yAxis') && editOptions.yAxis.hasOwnProperty('editable-text-size')) {
        data.yLabelFontSize = editOptions.yAxis['editable-text-size'];
        data.yLabelFormat = editOptions.yAxis['editable-num-format'];
    }
    return data;
}

function getMaxWidthForAxisData(axis, axisData, _vars, dimensions, margin, chartDiv) {
    var maxAxisText = '',
        formatType = void 0,
        dummySVG = void 0,
        axisDummy = void 0,
        width = void 0;
    //Dynamic left margin for charts with y axis
    if (_vars.rotateAxis) {
        //get length of longest text label and make the axis based off that
        var maxString = '',
            height = parseInt(dimensions.height, 10) - margin.top - margin.bottom;

        //check if labels should be shown
        if (height !== 0 && height / axisData.values.length < parseInt(_vars.fontSize, 10)) {
            axisData.hideValues = true;
        } else {
            var _iteratorNormalCompletion24 = true;
            var _didIteratorError24 = false;
            var _iteratorError24 = undefined;

            try {
                for (var _iterator24 = axisData.values[Symbol.iterator](), _step24; !(_iteratorNormalCompletion24 = (_step24 = _iterator24.next()).done); _iteratorNormalCompletion24 = true) {
                    var axisValue = _step24.value;

                    var currentStr = axisValue.toString();
                    if (currentStr.length > maxString.length) {
                        maxString = currentStr;
                    }
                }
            } catch (err) {
                _didIteratorError24 = true;
                _iteratorError24 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion24 && _iterator24.return) {
                        _iterator24.return();
                    }
                } finally {
                    if (_didIteratorError24) {
                        throw _iteratorError24;
                    }
                }
            }

            maxAxisText = maxString;
        }
    } else if (!!_vars.yLabelFormat || !!_vars.xLabelFormat) {
        var labelFormat = _vars.yLabelFormat,
            expression = void 0;
        if (axis === 'x') {
            labelFormat = _vars.xLabelFormat;
        }

        formatType = jvFormatValueType(axisData.values);
        expression = getFormatExpression(labelFormat);

        if (expression !== '') {
            maxAxisText = expression(axisData.max);
        } else {
            maxAxisText = jvFormatValue(axisData.max);
        }
    } else {
        formatType = jvFormatValueType(axisData.values);
        if (!axisData.hasOwnProperty('max')) {
            var maxLength = 0;
            var _iteratorNormalCompletion25 = true;
            var _didIteratorError25 = false;
            var _iteratorError25 = undefined;

            try {
                for (var _iterator25 = axisData.values[Symbol.iterator](), _step25; !(_iteratorNormalCompletion25 = (_step25 = _iterator25.next()).done); _iteratorNormalCompletion25 = true) {
                    var _axisValue = _step25.value;

                    if (_axisValue && _axisValue.length > maxLength) {
                        maxLength = _axisValue.length;
                        maxAxisText = _axisValue;
                    }
                }
            } catch (err) {
                _didIteratorError25 = true;
                _iteratorError25 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion25 && _iterator25.return) {
                        _iterator25.return();
                    }
                } finally {
                    if (_didIteratorError25) {
                        throw _iteratorError25;
                    }
                }
            }
        } else {
            maxAxisText = jvFormatValue(axisData.max, formatType);
        }
    }

    //if (type === 'heatmap') {
    ////also need to check width of label
    //if (maxAxisText.length < axisData.label.length + 5) {
    ////need added space
    //if (axis === 'x') {
    //maxAxisText = axisData.label;
    //} else {
    //maxAxisText = axisData.label + 'Extra';
    //}
    //}
    //}

    //Create dummy svg to place max sized text element on
    dummySVG = chartDiv.append('svg').attr('class', 'dummy-svg');

    //Create dummy text element
    axisDummy = dummySVG.append('text').attr('font-size', function () {
        if (axis === 'y' && _vars.yLabelFontSize !== 'none') {
            return _vars.yLabelFontSize;
        }
        if (axis === 'x' && _vars.xLabelFontSize !== 'none') {
            return _vars.xLabelFontSize;
        }
        return _vars.fontSize;
    }).attr('x', 0).attr('y', 0).text(maxAxisText);

    //Calculate the width of the dummy text
    width = axisDummy.node().getBBox().width;
    //Remove the svg and text element
    chartDiv.select('.dummy-svg').remove();
    return width;
}

function getDisplayValuesElement(object, dataTableAlign, type) {
    var valuesArray = [];

    if (type === 'bar' || type === 'pie' || type === 'line' || type === 'area') {
        for (var key in dataTableAlign) {
            if (dataTableAlign.hasOwnProperty(key)) {
                if (key.indexOf('value') > -1) {
                    valuesArray.push(object[dataTableAlign[key]]);
                }
            }
        }
    } else {
        for (var _key3 in object) {
            if (object.hasOwnProperty(_key3)) {
                valuesArray.push(object[_key3]);
            }
        }
    }
    return valuesArray;
}

/**getZScale
 *
 * gets the scale for the z axis
 * @params zAxisData, container, padding
 * @returns {{}}
 */
function getZScale(zAxisData, container, _vars) {
    var zAxisScale = d3.scaleLinear().domain([d3.min(zAxisData.values), d3.max(zAxisData.values)]).rangeRound([_vars.NODE_MIN_SIZE, _vars.NODE_MAX_SIZE]).nice();
    return zAxisScale;
}

/**generateEventGroups
 *
 *
 * @params chartContainer, barData, chart
 */
function generateEventGroups(chartContainer, barData, chart) {
    var container = chart.config.container,
        dataToPlot = jvCharts.getPlotData(barData, chart),
        eventGroups = void 0;

    //Invisible rectangles on screen that represent bar groups. Used to show/hide tool tips on hover
    eventGroups = chartContainer.data(dataToPlot).enter().append('rect').attr('class', 'event-rect')
    //sets the x position of the bar
    .attr('x', function (d, i) {
        return chart._vars.rotateAxis ? 0 : container.width / barData.length * i;
    })
    //sets the y position of the bar
    .attr('y', function (d, i) {
        return chart._vars.rotateAxis ? container.height / barData.length * i : 0;
    })
    //sets the width position of the bar
    .attr('width', function () {
        return chart._vars.rotateAxis ? container.width : container.width / barData.length;
    })
    //sets the height position of the bar
    .attr('height', function () {
        return chart._vars.rotateAxis ? container.height / barData.length : container.height;
    }).attr('fill', 'transparent').attr('class', function (d, i) {
        return 'event-rect editable-bar bar-col-' + String(barData[i][chart.currentData.dataTable.label]).replace(/\s/g, '_').replace(/\./g, '_dot_');
    });

    return eventGroups;
}

function generateThresholdLegend(chart) {
    var svg = chart.svg,
        colorLegendData = [],
        gLegend = void 0,
        legend = void 0;
    if (chart._vars.thresholds !== 'none') {
        for (var j = 0; j < Object.keys(chart._vars.thresholds).length; j++) {
            colorLegendData.push(chart._vars.thresholds[j].thresholdName);
        }
    }

    gLegend = svg.append('g').attr('class', 'thresholdLegendContainer');

    legend = gLegend.selectAll('.thresholdLegend').data(colorLegendData).enter().append('g').attr('class', 'thresholdLegend').attr('transform', function (d, i) {
        var height = 19,
            offset = 19 * colorLegendData.length / 2,
            horz = -2 * 12,
            vert = i * height - offset;
        return 'translate(' + horz + ',' + vert + ')';
    });

    legend.append('rect').attr('width', 12).attr('height', 12).style('fill', function (d, i) {
        return chart._vars.thresholds[i].thresholdColor;
    });

    legend.append('text').attr('x', 24).attr('y', 8).attr('font-size', '.75em').text(function (d) {
        return d;
    });

    //Centers the legend in the panel
    if (gLegend) {
        var legendWidth = gLegend.node().getBBox().width;
        gLegend.attr('transform', 'translate(' + (chart.config.container.width - legendWidth) + ',' + 10 * colorLegendData.length + ')');
    }
}

function attachClickEventsToLegend(chart, legendElements, drawFunc) {
    //Adding the click event to legend rectangles for toggling on/off
    legendElements.on('click', function () {
        var selectedRect = d3.select(this),
            dataHeaders = void 0;

        if (selectedRect._groups[0][0].attributes.opacity.value !== '0.2') {
            selectedRect.attr('opacity', '0.2');
        } else {
            selectedRect.attr('opacity', '1');
        }

        //Gets the headers of the data to be drawn
        dataHeaders = updateDataFromLegend(legendElements._groups);
        //Sets the legendData to the updated headers
        if (chart._vars.seriesFlipped) {
            chart._vars.flippedLegendHeaders = dataHeaders;
        } else {
            chart._vars.legendHeaders = dataHeaders;
        }

        //Plots the data
        chart._vars.transitionTime = 800; //Keep transition for toggling legend elements
        if (chart._vars.seriesFlipped) {
            chart[drawFunc](chart.flippedData);
        } else {
            chart[drawFunc](chart.data);
        }
        if (chart.applyEditMode) {
            chart.applyEditMode();
        }
    });
}

/**generateVerticalLegendElements
 *
 * Creates the legend elements--rectangles and labels
 * @params chart, legendData, drawFunc
 */
function generateVerticalLegendElements(chart, legendData, drawFunc) {
    var svg = chart.svg,
        legend = void 0,
        legendDataLength = legendData.length,
        legendElementToggleArray = void 0,
        legendRectangles = void 0,
        legendText = void 0;

    chart._vars.gridSize = 20;

    if (!chart._vars.legendIndex) {
        chart._vars.legendIndex = 0;
    }

    if (!chart._vars.legendIndexMax) {
        chart._vars.legendIndexMax = Math.floor(legendDataLength / chart._vars.legendMax - 0.01);
    }

    //Check to see if legend element toggle array needs to be set
    if (chart._vars.legendIndexMax >= 0) {
        if (!chart._vars.legendHeaders) {
            chart._vars.legendHeaders = JSON.parse(JSON.stringify(legendData));
        }

        legendElementToggleArray = getLegendElementToggleArray(chart._vars.legendHeaders, legendData);
    }

    legend = svg.append('g').attr('class', 'legend').attr('transform', 'translate(' + 18 + ',' + 20 + ')');

    //Adding colored rectangles to the legend
    legendRectangles = legend.selectAll('rect').data(legendData).enter().append('rect').attr('class', 'legendRect').attr('x', '3').attr('y', function (d, i) {
        return chart._vars.gridSize * (i % chart._vars.legendMax) * 1.1;
    }).attr('width', chart._vars.gridSize).attr('height', chart._vars.gridSize).attr('fill', function (d, i) {
        if (!legendElementToggleArray && !chart._vars.seriesFlipped || chart._vars.seriesFlipped && !legendElementToggleArray) {
            return getColors(chart._vars.color, i, legendData[i]);
        }
        if (!chart._vars.seriesFlipped && legendElementToggleArray[i].toggle === true || chart._vars.seriesFlipped && legendElementToggleArray[i].toggle === true) {
            return getColors(chart._vars.color, i, legendData[i]);
        }
        return chart._vars.emptyLegendSquare;
    }).attr('display', function (d, i) {
        if (i >= chart._vars.legendIndex * chart._vars.legendMax && i <= chart._vars.legendIndex * chart._vars.legendMax + (chart._vars.legendMax - 1)) {
            return 'all';
        }
        return 'none';
    }).attr('opacity', '1');

    //Adding text labels for each rectangle in legend
    legendText = legend.selectAll('text').data(legendData).enter().append('text').attr('class', function (d, i) {
        return 'legendText editable editable-text editable-content editable-legend-' + i;
    }).attr('x', chart._vars.gridSize + 7).attr('y', function (d, i) {
        return chart._vars.gridSize * (i % chart._vars.legendMax) * 1.1 + 10;
    }).attr('text-anchor', 'start').attr('dy', '0.35em') //Vertically align with node
    .attr('fill', chart._vars.fontColor).attr('font-size', chart._vars.fontSize).attr('display', function (d, i) {
        if (i >= chart._vars.legendIndex * chart._vars.legendMax && i <= chart._vars.legendIndex * chart._vars.legendMax + (chart._vars.legendMax - 1)) {
            return 'all';
        }
        return 'none';
    }).text(function (d, i) {
        var elementName = legendData[i];
        if (elementName.length > 20) {
            return elementName.substring(0, 19) + '...';
        }
        return elementName;
    });

    //Adding info box to legend elements when hovering over
    legendText.data(legendData).append('svg:title').text(function (d) {
        return d;
    });

    //Only create carousel if the number of elements exceeds one legend "page"
    if (chart._vars.legendIndexMax > 0) {
        createVerticalCarousel(chart, legendData, drawFunc);
    }

    return legendRectangles;
}

/**createVerticalCarousel
 *
 * Draws the vertical legend carousel
 * @params chart, legendData, drawFunc
 */
function createVerticalCarousel(chart, legendData, drawFunc) {
    var svg = chart.svg,
        legendPolygon = void 0;

    //Adding carousel to legend
    svg.selectAll('.legend-carousel').remove();
    svg.selectAll('#legend-text-index').remove();

    legendPolygon = svg.append('g').attr('class', 'legend-carousel');

    //Creates left navigation arrow for carousel
    legendPolygon.append('polygon').attr('id', 'leftChevron').attr('class', 'pointer-cursor').style('fill', chart._vars.legendArrowColor).attr('transform', 'translate(0,' + (chart._vars.legendMax * chart._vars.gridSize + 50) + ')').attr('points', '0,7.5, 15,0, 15,15').on('click', function () {
        if (chart._vars.legendIndex >= 1) {
            chart._vars.legendIndex--;
        }
        svg.selectAll('.legend').remove();
        var legendElements = generateVerticalLegendElements(chart, legendData, drawFunc);
        attachClickEventsToLegend(chart, legendElements, drawFunc, legendData);
    }).attr({
        display: function display() {
            if (chart._vars.legendIndex === 0) {
                return 'none';
            }
            return 'all';
        }
    });

    //Creates page number for carousel navigation
    legendPolygon.append('text').attr('id', 'legend-text-index').attr('x', 35).attr('y', 242.5).style('text-anchor', 'start').style('font-size', chart._vars.fontSize).text(function () {
        return chart._vars.legendIndex + 1 + ' / ' + (chart._vars.legendIndexMax + 1);
    }).attr({
        display: function display() {
            if (chart._vars.legendIndexMax === 0) {
                return 'none';
            }
            return 'all';
        }
    });

    //Creates right navigation arrow for carousel
    legendPolygon.append('polygon').attr('id', 'rightChevron').attr('class', 'pointer-cursor').style('fill', chart._vars.legendArrowColor).attr('transform', 'translate(85,' + (chart._vars.legendMax * chart._vars.gridSize + 50) + ')').attr('points', '15,7.5, 0,0, 0,15').on('click', function () {
        if (chart._vars.legendIndex < chart._vars.legendIndexMax) {
            chart._vars.legendIndex++;
        }
        svg.selectAll('.legend').remove();
        var legendElements = generateVerticalLegendElements(chart, legendData, drawFunc);
        attachClickEventsToLegend(chart, legendElements, drawFunc, legendData);
    }).attr({
        display: function display() {
            if (chart._vars.legendIndex === chart._vars.legendIndexMax) {
                return 'none';
            }
            return 'all';
        }
    });
}

/**convertTableToTree
 *
 * Converts table data to tree structure
 * @params data, dataTable, numericCheck
 */
function convertTableToTree(data, dataTable, lastNodeAsValue) {
    var allHash = {},
        list = [],
        rootMap = {},
        currentMap = {},
        tableHeaders = [],
        count;
    if (dataTable) {
        for (var header in dataTable) {
            if (header !== 'value' && header.indexOf('tooltip') === -1) {
                tableHeaders.push(dataTable[header]);
            }
        }
        if (dataTable.value) {
            tableHeaders.push(dataTable.value);
        }
    }

    var _iteratorNormalCompletion26 = true;
    var _didIteratorError26 = false;
    var _iteratorError26 = undefined;

    try {
        for (var _iterator26 = data[Symbol.iterator](), _step26; !(_iteratorNormalCompletion26 = (_step26 = _iterator26.next()).done); _iteratorNormalCompletion26 = true) {
            var dataEle = _step26.value;
            //all of this is to change it to a tree structure and then call makeTree to structure the data appropriately for this viz
            count = 0;
            var _iteratorNormalCompletion27 = true;
            var _didIteratorError27 = false;
            var _iteratorError27 = undefined;

            try {
                for (var _iterator27 = tableHeaders[Symbol.iterator](), _step27; !(_iteratorNormalCompletion27 = (_step27 = _iterator27.next()).done); _iteratorNormalCompletion27 = true) {
                    var _header2 = _step27.value;

                    if (_header2 !== '') {
                        if (!dataEle[_header2.replace(/[_]/g, ' ')]) {
                            dataEle[_header2.replace(/[_]/g, ' ')] = 'NULL_VALUE';
                        }
                        var currentValue = dataEle[_header2.replace(/[_]/g, ' ')].toString().replace(/["]/g, ''),
                            nextMap = {};

                        if (count === 0) {
                            //will take care of the first level and put into rootmap if it doesnt already exist in rootmap
                            currentMap = rootMap[currentValue];
                            if (!currentMap) {
                                currentMap = {};
                                rootMap[currentValue] = currentMap;
                            }
                            nextMap = currentMap;
                            count++;
                        } else {
                            nextMap = currentMap[currentValue];
                            if (!nextMap) {
                                nextMap = {};
                                currentMap[currentValue] = nextMap;
                            }
                            currentMap = nextMap;
                        }
                    }
                }
            } catch (err) {
                _didIteratorError27 = true;
                _iteratorError27 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion27 && _iterator27.return) {
                        _iterator27.return();
                    }
                } finally {
                    if (_didIteratorError27) {
                        throw _iteratorError27;
                    }
                }
            }
        }
    } catch (err) {
        _didIteratorError26 = true;
        _iteratorError26 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion26 && _iterator26.return) {
                _iterator26.return();
            }
        } finally {
            if (_didIteratorError26) {
                throw _iteratorError26;
            }
        }
    }

    makeTree(rootMap, list, lastNodeAsValue);
    allHash.name = 'root';
    allHash.children = list;
    return allHash;
}

/**makeTree
 *
 * Recurive function to build tree
 * @params map, list, isNumeric
 */
function makeTree(map, list, lastNodeAsValue) {
    var childSet = [];
    for (var key in map) {
        if (map.hasOwnProperty(key)) {
            var childMap = map[key],
                dataMap = {},
                childExists = childMap && Object.getOwnPropertyNames(childMap).length > 0,
                numericCheck = lastNodeAsValue && Object.keys(childMap).length === 1 && !isNaN(Object.keys(childMap)[0]);
            dataMap.name = key;
            if (!childExists || numericCheck) {
                dataMap.value = Object.keys(childMap)[0];
                list.push(dataMap);
            } else {
                dataMap.children = childSet;
                list.push(dataMap);
                makeTree(childMap, childSet, lastNodeAsValue);
                childSet = [];
            }
        }
    }
}

/**convertTableToTreemap
 *
 * Loop through data to organize into treemap form
 * @params data, dataTableAlgin
 */
function convertTableToTreemap(data, dataTableAlign) {
    var _ref;

    var addedHeaderMap = {},
        childrenArray = [],
        seriesIndex;

    var _iteratorNormalCompletion28 = true;
    var _didIteratorError28 = false;
    var _iteratorError28 = undefined;

    try {
        for (var _iterator28 = data[Symbol.iterator](), _step28; !(_iteratorNormalCompletion28 = (_step28 = _iterator28.next()).done); _iteratorNormalCompletion28 = true) {
            var dataEle = _step28.value;

            var series = dataEle[dataTableAlign.series];
            seriesIndex = addedHeaderMap[series];
            dataEle.Parent = series;
            if (seriesIndex) {
                childrenArray[seriesIndex].children.push(dataEle);
            } else {
                var _childrenArray$push;

                addedHeaderMap[series] = childrenArray.length;
                childrenArray.push((_childrenArray$push = {}, _defineProperty(_childrenArray$push, dataTableAlign.series, series), _defineProperty(_childrenArray$push, 'Parent', 'Top Level'), _defineProperty(_childrenArray$push, 'children', [dataEle]), _childrenArray$push));
            }
        }
    } catch (err) {
        _didIteratorError28 = true;
        _iteratorError28 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion28 && _iterator28.return) {
                _iterator28.return();
            }
        } finally {
            if (_didIteratorError28) {
                throw _iteratorError28;
            }
        }
    }

    return _ref = {}, _defineProperty(_ref, dataTableAlign.series, 'Top Level'), _defineProperty(_ref, 'children', childrenArray), _ref;
}

//Bind functions to prototype or jvCharts object
jvCharts.getColors = getColors;
jvCharts.setBarLineLegendData = setBarLineLegendData;
jvCharts.createColorsWithDefault = createColorsWithDefault;
jvCharts.getZScale = getZScale;
jvCharts.getLegendElementToggleArray = getLegendElementToggleArray;
jvCharts.generateLegendElements = generateLegendElements;
jvCharts.updateDataFromLegend = updateDataFromLegend;
jvCharts.createCarousel = createCarousel;
jvCharts.generateThresholdLegend = generateThresholdLegend;
jvCharts.attachClickEventsToLegend = attachClickEventsToLegend;
jvCharts.generateVerticalLegendElements = generateVerticalLegendElements;
jvCharts.createVerticalCarousel = createVerticalCarousel;
jvCharts.getToggledData = getToggledData;
jvCharts.getPlotData = getPlotData;
jvCharts.getPosCalculations = getPosCalculations;
jvCharts.setBarLineLegendData = setBarLineLegendData;
jvCharts.jvFormatValue = jvFormatValue;
jvCharts.getFormatExpression = getFormatExpression;
jvCharts.generateEventGroups = generateEventGroups;
jvCharts.jvFormatValueType = jvFormatValueType;
jvCharts.getAxisScale = getAxisScale;
jvCharts.setChartColors = setChartColors;
jvCharts.getDataTypeFromKeys = getDataTypeFromKeys;
jvCharts.cleanToolData = cleanToolData;
jvCharts.convertTableToTree = convertTableToTree;
jvCharts.convertTableToTreemap = convertTableToTreemap;

module.exports = jvCharts;

},{"./jvTip.js":9}],5:[function(require,module,exports){
'use strict';
/***  jvComment ***/
'use-strict';
/**
* @name jvComment
* @desc Constructor for JV Comment - creates comments for a jv visualization and executes a callback for the comments to be saved
* @param {object} configObj - constructor object containing the jvChart and other options
* @return {undefined} - no return
*/

function jvComment(configObj) {
    'use strict';

    var commentObj = this;
    commentObj.chartDiv = configObj.chartDiv;
    commentObj.showComments = false;
    commentObj.comments = configObj.comments ? configObj.comments : {};
    commentObj.disabled = false;
    commentObj.drawCommentNodes();
    commentObj.onSaveCallback = configObj.onSaveCallback;
    commentObj.getMode = configObj.getMode;
}

jvComment.prototype.createMoveListener = createMoveListener;
jvComment.prototype.updatePosition = updatePosition;
jvComment.prototype.makeComment = makeComment;
jvComment.prototype.removeComment = removeComment;
jvComment.prototype.drawCommentNodes = drawCommentNodes;
jvComment.prototype.drawComment = drawComment;
jvComment.prototype.doubleClick = doubleClick;
jvComment.prototype.overlayDivPosition = overlayDivPosition;

/**
* @name createMoveListener
* @desc creates the mousemove listener to determine if the user moves or resizes a comment
* @param {object} commentNode - comment that the user clicked on
* @return {undefined} - no return
*/
function createMoveListener(commentNode) {
    var commentObj = this,
        timeMouseDown = new Date().getTime();
    commentObj.chartDiv.on('mousemove', function () {
        //mouse move happend too quickly, chrome bug
        var timeMouseMove = new Date().getTime(),
            node = commentNode.node(),
            mouse = d3.mouse(node),
            mouseOnChartDiv = d3.mouse(commentObj.chartDiv.node()),
            resizeNode;
        if (timeMouseDown + 10 > timeMouseMove) {
            return;
        }
        //set the moved node, so we know to do a mouse up event
        commentObj.moved = commentNode;

        //resize in the right corner of the comment
        if (commentNode.select('.comment-padding')._groups[0][0] && (mouse[0] + 15 > node.clientWidth && mouse[1] + 15 > node.clientHeight || commentObj.moved.mouse)) {
            if (!commentObj.moved.mouse) {
                resizeNode = commentNode.select('.comment-padding');
                resizeNode.style('width', 'auto');
                resizeNode.style('height', 'auto');
            }
            //set the mouse event so we can update the location on mouse up
            commentObj.moved.mouse = mouse;
        } else {
            //move the comment node around the visual
            if (commentNode._groups[0][0].nodeName === 'text') {
                commentObj.chartDiv.select('.commentbox-readonly').remove();
            }
            commentNode.style('left', mouseOnChartDiv[0] + 'px').style('top', mouseOnChartDiv[1] + 'px');
            commentNode.attr('x', mouseOnChartDiv[0]).attr('y', mouseOnChartDiv[1]);
        }
    });
}

/**
* @name updatePosition
* @desc determines whether the user dragged a comment on the screen or updated its size and then creates the appropriate save function
* @return {undefined} - no return
*/
function updatePosition() {
    var commentObj = this,
        nodeToUpdate = commentObj.moved._groups[0][0],
        nodeId = nodeToUpdate.id.split('node')[1],
        comment = commentObj.comments.list[nodeId],
        x = void 0,
        y = void 0;
    if (Array.isArray(commentObj.moved.mouse)) {
        comment.binding.width = commentObj.moved.mouse[0];
        comment.binding.height = commentObj.moved.mouse[1];
    } else {
        x = Math.round(nodeToUpdate.getAttribute('x'));
        y = Math.round(nodeToUpdate.getAttribute('y'));
        comment.binding = {
            'x': x,
            'y': y,
            'xChartArea': commentObj.chartDiv._groups[0][0].clientWidth,
            'yChartArea': commentObj.chartDiv._groups[0][0].clientHeight,
            'currentX': x,
            'currentY': y,
            'showAsMarker': comment.binding.showAsMarker,
            'height': comment.binding.height,
            'width': comment.binding.width
        };
    }

    commentObj.onSaveCallback(comment, nodeId, 'edit');
}

/**
* @name makeComment
* @desc creates the comment entry box on the screen and attaches listeners to the save delete and cancel options
* @param {object} event - event that holds the mouse position for where the user wants to place the comment
* @return {undefined} - no return
*/
function makeComment(event) {
    if (this.chartDiv.select('.commentbox')._groups[0][0] || this.chartDiv.select('.commentbox-edit')._groups[0][0]) {
        //dont create new comment
        return;
    }

    var commentObj = this,
        x = parseInt(d3.mouse(event)[0], 10),
        y = parseInt(d3.mouse(event)[1], 10),
        commentHeight = 145,
        commentWidth = 200,

    //calculate position of overlay div
    position = commentObj.overlayDivPosition(commentWidth, commentHeight, x, y),
        commentType = 'svgMain';

    commentObj.chartDiv.selectAll('.commentbox-readonly').remove();

    commentObj.showComments = false;
    commentObj.chartDiv.append('div').attr('class', 'commentbox').attr('id', 'commentbox').style('opacity', 1).html("<div class='title'><b>Add New Comment</b></div>" + "<textarea placeholder='Enter comment...' form='commentform' class='comment-textarea' style='width:155px; height: 90px;' name='comment' id = 'textarea1'></textarea>" + "<br><input type='checkBox' class='commentbox-display' id ='display'> Display as marker" + "<br><button class='commentbox-close' id ='cancel'><i class='fa fa-close'></i></button>" + "<button class='smss-btn commentbox-submit' id = 'submit'>Submit Comment</button>").style('position', 'absolute').style('left', position.x + 'px').style('top', position.y + 'px');

    //Autofocus on the text area
    document.getElementById('textarea1').focus();

    commentObj.chartDiv.selectAll('.commentbox').select('#cancel').on('click.delete', function () {
        commentObj.removeComment();
    });

    commentObj.chartDiv.selectAll('.commentbox').select('#submit').on('click.save', function () {
        var commentText = commentObj.chartDiv.select('#commentbox').select('#textarea1')._groups[0][0].value,
            showAsMarker = commentObj.chartDiv.select('#commentbox').select('#display')._groups[0][0].checked,
            newCommentObj = void 0;

        newCommentObj = {
            'commentText': commentText,
            'groupID': 'group0',
            'type': commentType,
            'binding': {
                'x': x,
                'y': y,
                'xChartArea': commentObj.chartDiv._groups[0][0].clientWidth,
                'yChartArea': commentObj.chartDiv._groups[0][0].clientHeight,
                'currentX': x,
                'currentY': y,
                'showAsMarker': showAsMarker ? 'true' : 'false',
                'height': false,
                'width': false
            }
        };
        commentObj.chartDiv.select('.commentbox').remove();
        if (isNaN(commentObj.comments.maxId)) {
            commentObj.comments.maxId = -1;
        }
        commentObj.onSaveCallback(newCommentObj, ++commentObj.comments.maxId, 'add');
    });
}

/**
* @name removeComment
* @desc function to remove comment entry box
* @return {undefined} - no return
*/
function removeComment() {
    var commentObj = this;
    commentObj.chartDiv.selectAll('.commentbox').remove();
}

/**
* @name drawCommentNodes
* @desc function to draw a all comments on the visual
* @return {undefined} - no return
*/
function drawCommentNodes() {
    var commentObj = this,
        comments = commentObj.comments.list;

    commentObj.chartDiv.selectAll('.min-comment').remove();

    for (var id in comments) {
        if (comments.hasOwnProperty(id)) {
            commentObj.drawComment(comments[id], id);
        }
    }
}

/**
* @name drawComment
* @desc function to draw a single comment on the visual
* @param {object} comment - data used to pain the comment
* @param {number} id - id of the specific comment
* @return {undefined} - no return
*/
function drawComment(comment, id) {
    if (typeof this.chartDiv._groups === 'undefined') {
        console.log('Comment data is in old format, will not display or chart div doesnt exist');
        return;
    }

    if (!comment.binding || !this.chartDiv._groups[0][0]) {
        console.log('Comment data is in old format, will not display or chart div doesnt exist');
        return;
    }

    var commentObj = this,
        chartDiv = commentObj.chartDiv,
        binding = comment.binding,
        chartAreaWidth = chartDiv._groups[0][0].clientWidth,
        chartAreaHeight = chartDiv._groups[0][0].clientHeight,
        x = binding.x / binding.xChartArea * chartAreaWidth,
        y = binding.y / binding.yChartArea * chartAreaHeight,
        styleString = '',
        text = '',
        resize = false;

    binding.currentX = binding.x / binding.xChartArea * chartAreaWidth;
    binding.currentY = binding.y / binding.yChartArea * chartAreaHeight;

    if (comment.binding.showAsMarker === 'false') {
        if (comment.binding.width && comment.binding.height) {
            styleString = "style='width: " + comment.binding.width + 'px; height: ' + comment.binding.height + "px'";
        }
        if (comment.commentText.indexOf('<iframe') > -1 || comment.commentText.indexOf('<img') > -1 || comment.commentText.indexOf('<svg') > -1) {
            //contains elents that should resize
            text = "<div class='comment-padding text'" + styleString + "><div class='user-comment'>" + comment.commentText + '</div></div>';
            resize = true;
        } else {
            text = '<div class="text editable editable-text editable-comment-' + id + '">' + comment.commentText + '<div/>';
        }
        chartDiv.append('div').attr('class', 'min-comment').attr('id', 'node' + id).style('opacity', 1).style('position', 'absolute')
        //.style("border", "1px solid black")
        .html(text).style('left', x + 'px').style('top', y + 'px').on('dblclick.comment', function () {
            //Edit text or delete the comment
            commentObj.doubleClick(this, x, y);
        });
        if (resize) {
            var parent = d3.select('.user-comment');
            rescale(parent, parent.node());
        }
    } else {
        chartDiv.select('svg').append('text').attr('class', 'min-comment').attr('id', 'node' + id).attr('fill', '#e6e6e6').attr('x', x).attr('y', y).attr('font-family', 'FontAwesome').attr('stroke', 'darkgray').attr('font-size', '15px').text('\uF0E5').attr('opacity', 1).on('dblclick.comment', function () {
            //Edit text or delete the comment
            commentObj.doubleClick(this, x, y);
        }).on('mouseenter.comment', function () {
            //Show hover over box when mouse enters node
            if (commentObj.showComments === false) {
                var commentText = '',
                    commentHeight = 80,
                    commentWidth = 185,
                    position = void 0;

                for (var j in commentObj.comments.list) {
                    if (Math.round(commentObj.comments.list[j].binding.currentX) === Math.round(this.x.baseVal[0].value)) {
                        if (Math.round(commentObj.comments.list[j].binding.currentY) === Math.round(this.y.baseVal[0].value)) {
                            commentText = commentObj.comments.list[j].commentText;
                            x = commentObj.comments.list[j].binding.currentX;
                            y = commentObj.comments.list[j].binding.currentY;
                        }
                    }
                }
                position = commentObj.overlayDivPosition(commentWidth, commentHeight, x, y);

                chartDiv.append('div').attr('class', 'commentbox-readonly').style('opacity', 1).style('position', 'absolute').html("<textarea readonly rows='4' cols='27' class='textarea' name='comment'>" + commentText + '</textarea>').style('left', position.x + 'px').style('top', position.y + 'px');
            }
        }).on('mouseout.comment', function () {
            //Remove hover over box when mouse moves away
            if (commentObj.showComments === false) {
                chartDiv.select('.commentbox-readonly').remove();
            }
        });
    }
}

/**
* @name rescale
* @desc sets the children of the ele param to 100 percent height and width
* @param {d3node} ele - node to start recursive function
* @param {htmlNode} commentNode - unused parent node that can be used to calcualte percent height and widths
* @return {undefined} - no return
*/
function rescale(ele, commentNode) {
    var node = ele.node(),
        width = 100,
        height = 100;
    //width = node.clientWidth / commentNode.clientWidth * 100;
    //height = node.clientHeight / commentNode.clientHeight * 100;
    //if (width > 100) {
    //width = 100;
    //}

    //if (height > 100) {
    //height = 100;
    //}

    ele.style('width', width + '%');
    ele.style('height', height + '%');
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = node.childNodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var child = _step.value;

            rescale(d3.select(child), commentNode);
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
}

/**
* @name doubleClick
* @desc click function after the user clicks on an existing comment
* @param {object} commentNode - current comment that the user clicked
* @param {number} x - x position of the click event
* @param {number} y - y position of the click event
* @return {undefined} - no return
*/
function doubleClick(commentNode, x, y) {
    if (this.chartDiv.select('.commentbox-edit')._groups[0][0] || this.getMode() !== 'comment-mode') {
        //dont create new comment
        return;
    }
    var commentObj = this,
        chartDiv = commentObj.chartDiv,
        currentComment = commentNode.id.split('node')[1],
        commentText = commentObj.comments.list[currentComment].commentText,
        commentHeight = 145,
        commentWidth = 200,
        position = commentObj.overlayDivPosition(commentWidth, commentHeight, x, y);

    commentObj.showComments = false;
    chartDiv.selectAll('.commentbox-readonly').remove();
    chartDiv.selectAll('.commentbox-edit').remove();
    chartDiv.selectAll('.commentbox').remove();

    chartDiv.append('div').attr('class', 'commentbox-edit').style('opacity', 1).style('left', position.x + 'px').style('top', position.y + 'px').style('position', 'absolute').html("<div class='title'><b>Edit Comment</b></div>" + "<textarea id='edit' class='comment-textarea' style='width:155px; height: 90px;' name='comment'>" + commentText + '</textarea>' + "<br><input type='checkBox' class='commentbox-display' id ='display'> Display as marker" + "<br><button class='commentbox-close' id ='cancel-edit'><i class='fa fa-close'></i></button>" + "<button class='smss-btn' id ='delete'>Delete</button>" + "<button class='smss-btn' id = 'save'>Save</button>");

    chartDiv.select('.commentbox-edit').select('#display')._groups[0][0].checked = commentObj.comments.list[currentComment].binding.showAsMarker === 'true';

    chartDiv.selectAll('.commentbox-edit').select('#delete').on('click.delete', function () {
        chartDiv.select('.commentbox-edit').remove();
        chartDiv.select('.commentbox-readonly').remove();
        chartDiv.select('#node' + currentComment).attr('display', 'none');
        //redraw comment nodes with new indexes
        commentObj.onSaveCallback(commentObj.comments.list[currentComment], currentComment, 'remove');
    });

    chartDiv.selectAll('.commentbox-edit').select('#save').on('click.save', function () {
        var text = chartDiv.select('.commentbox-edit').select('#edit')._groups[0][0].value,
            showAsMarker = chartDiv.select('.commentbox-edit').select('#display')._groups[0][0].checked;
        commentObj.comments.list[currentComment].commentText = text;
        commentObj.comments.list[currentComment].binding.showAsMarker = showAsMarker ? 'true' : 'false';
        chartDiv.select('.commentbox-readonly').remove();
        chartDiv.select('.commentbox-edit').remove();
        commentObj.onSaveCallback(commentObj.comments.list[currentComment], currentComment, 'edit');
    });

    chartDiv.selectAll('.commentbox-edit').select('#cancel-edit').on('click.cancel-edit', function () {
        chartDiv.select('.commentbox-readonly').remove();
        chartDiv.select('.commentbox-edit').remove();
    });
}

/******************************* Utility functions **********************************************/
/**
* @name overlayDivPosition
* @desc function to determine the placement of the div on the visual
* @param {number} divWidth - width of the comment entry box
* @param {number} divHeight - height of the comment entry box
* @param {number} mouseX - x position of the click event
* @param {number} mouseY - y position of the click event
* @return {object} - position of div
*/
function overlayDivPosition(divWidth, divHeight, mouseX, mouseY) {
    var editObj = this,
        position = {
        x: mouseX,
        y: mouseY + 10
    };
    if (mouseX > parseInt(editObj.chartDiv.style('width'), 10) / 2) {
        position.x = mouseX - divWidth;
    }
    if (mouseY - divHeight - 10 > 0) {
        position.y = mouseY - divHeight - 10;
    }
    return position;
}

module.exports = jvComment;

},{}],6:[function(require,module,exports){
/***  jvEdit ***/
'use strict';

var editTemplate = require('./editOptionsTemplate.js');

/**
* @name jvEdit
* @desc Constructor for JV Edit - creates edits to a jv visualization and executes a callback for the edit options to be saved
* @param {object} configObj - constructor object containing the jvChart and other options
* @return {undefined} - no return
*/
function jvEdit(configObj) {
    var editObj = this;
    editObj.chartDiv = configObj.chartDiv;
    editObj.vizOptions = configObj.vizOptions ? configObj.vizOptions : {};
    editObj.chartDiv.selectAll('.edit-div').remove();
    editObj.editDiv = editObj.chartDiv.append('div').attr('class', 'edit-div');
    editObj.onSaveCallback = configObj.onSaveCallback;
}

jvEdit.prototype.displayEdit = displayEdit;
jvEdit.prototype.changeFontSize = changeFontSize;
jvEdit.prototype.submitEditMode = submitEditMode;
jvEdit.prototype.applyEditMode = applyEditMode;
jvEdit.prototype.applyAllEdits = applyAllEdits;
jvEdit.prototype.removeEdit = removeEdit;
jvEdit.prototype.overlayDivPosition = overlayDivPosition;

/**
* @name displayEdit
* @desc Displays the edit div, grabbing it from the template
* @param {array} mouse - mouse location of the click event, used to place the edit mode div on the visual
* @param {string} options - css class of clicked element, provides the options that are editable by edit mode
* @return {undefined} - no return
*/
function displayEdit(mouse, options) {
    var editObj = this,
        mouseX = mouse[0],
        mouseY = mouse[1],
        optionValues = [],
        itemToChange = '',
        editOptionElement,
        editHeight = parseFloat(editObj.editDiv.style('height')),
        editWidth = parseFloat(editObj.editDiv.style('width')),
        position;

    //return if you click on the same element twice, no need to display a second edit div if the current one is still open
    if (editObj.editOptions === options) {
        return;
    }
    editObj.editDiv.html('');
    editObj.editOptions = options;

    //assign html to editDiv (basically displays the div)
    editObj.editDiv.html(editTemplate);

    //optionValues - an array of strings.
    //String is the id to the element in the editDiv form.
    //This string contains the specific option that is being changed

    //itemToChange
    //String that is the class of the svg element to be changed on the viz itself
    editOptionElement = editObj.editDiv.select('#edit-option-element');

    //if statements to determine which edit options to display
    if (options.indexOf('editable-yAxis') >= 0) {
        editOptionElement.html('&nbsp;for Y Axis');
        editOptionElement.style('visibility', 'visible');
        itemToChange = 'yAxis';
    } else if (options.indexOf('editable-xAxis') >= 0) {
        editOptionElement.html('&nbsp;for X Axis');
        editOptionElement.style('visibility', 'visible');
        itemToChange = 'xAxis';
    } else if (options.indexOf('yLabel') >= 0) {
        editOptionElement.html('&nbsp;for Y Label');
        editOptionElement.style('visibility', 'visible');
        itemToChange = 'yLabel';
    } else if (options.indexOf('xLabel') >= 0) {
        editOptionElement.html('&nbsp;for X Label');
        editOptionElement.style('visibility', 'visible');
        itemToChange = 'xLabel';
    } else if (options.indexOf('legendText') >= 0) {
        editOptionElement.html('&nbsp;for Legend Item');
        editOptionElement.style('visibility', 'visible');
        itemToChange = options.substring(options.indexOf('editable-legend-')).split(' ')[0];
    } else if (options.indexOf('editable-bar') >= 0) {
        editOptionElement.html('&nbsp;for Bar Chart');
        editOptionElement.style('visibility', 'visible');
        editObj.editDiv.select('.editable-bar').style('display', 'block');
        optionValues.push('editable-bar');
        itemToChange = options.substring(options.indexOf('bar-col-')).split(' ')[0];
    } else if (options.indexOf('editable-pie') >= 0) {
        editOptionElement.html('&nbsp;for Pie Slice');
        editOptionElement.style('visibility', 'visible');
        editObj.editDiv.select('.editable-pie').style('display', 'block');
        optionValues.push('editable-pie');
        itemToChange = options.substring(options.indexOf('pie-slice-')).split(' ')[0];
    } else if (options.indexOf('editable-scatter') >= 0) {
        editOptionElement.html('&nbsp;for Scatter Plot');
        editOptionElement.style('visibility', 'visible');
        editObj.editDiv.select('.editable-scatter').style('display', 'block');
        optionValues.push('editable-scatter');
        itemToChange = options.substring(options.indexOf('scatter-circle-')).split(' ')[0];
    } else if (options.indexOf('editable-bubble') >= 0) {
        editOptionElement.html('&nbsp;for Bubble Chart');
        editOptionElement.style('visibility', 'visible');
        editObj.editDiv.select('.editable-bubble').style('display', 'block');
        optionValues.push('editable-bubble');
        itemToChange = options.substring(options.indexOf('bubble-')).split(' ')[0];
    } else if (options.indexOf('editable-box') >= 0) {
        editOptionElement.html('&nbsp;for Box and Whisker Plot');
        editOptionElement.style('visibility', 'visible');
        editObj.editDiv.select('.editable-box').style('display', 'block');
        optionValues.push('editable-box');
        itemToChange = options.substring(options.indexOf('box-')).split(' ')[0];
    } else if (options.indexOf('editable-comment') >= 0) {
        editOptionElement.html('&nbsp;for Comment');
        editOptionElement.style('visibility', 'visible');
        itemToChange = options.substring(options.indexOf('editable-comment-')).split(' ')[0];
    } else if (options.indexOf('editable-svg') >= 0) {
        editOptionElement.html('&nbsp;for All Text');
        editOptionElement.style('visibility', 'visible');
        editObj.editDiv.select('.editable-text-size-buttons').style('display', 'block');
        optionValues.push('editable-text-size');
        itemToChange = 'svg';
    } else {
        console.log('Still need to add option to display edit');
    }

    if (options.indexOf('editable-num') >= 0) {
        editObj.editDiv.select('.editable-num-format').style('display', 'block');
        optionValues.push('editable-num-format');
    }
    if (options.indexOf('editable-text') >= 0) {
        editObj.editDiv.select('.editable-text-color').style('display', 'block');
        optionValues.push('editable-text-color');
        editObj.editDiv.select('.editable-text-size').style('display', 'block');
        optionValues.push('editable-text-size');
    }
    if (options.indexOf('editable-content') >= 0) {
        editObj.editDiv.select('.editable-content').style('display', 'block');
        optionValues.push('editable-content');
    }

    //populate edit div with initial values
    if (editObj.vizOptions[itemToChange]) {
        populateSelectionsEditMode(editObj.editDiv, editObj.vizOptions[itemToChange]);
    }
    editObj.editDiv.style('display', 'block').style('left', 0 + 'px').style('top', 0 + 'px');

    //calculate position of overlay div
    editHeight = parseFloat(editObj.editDiv.style('height'));
    editWidth = parseFloat(editObj.editDiv.style('width'));
    position = editObj.overlayDivPosition(editWidth, editHeight, mouseX, mouseY);

    //show the new edit div
    editObj.editDiv.style('left', position.x + 'px').style('top', position.y + 'px');

    //add submit, default, and exit listeners to the div
    editObj.editDiv.select('#submitEditMode').on('click', function () {
        editObj.submitEditMode(optionValues, itemToChange);
        editObj.removeEdit();
    });
    editObj.editDiv.select('#submitEditModeDefault').on('click', function () {
        editObj.submitEditMode(optionValues, itemToChange, true);
        editObj.removeEdit();
    });
    editObj.editDiv.select('#exitEditMode').on('click', function () {
        editObj.removeEdit();
    });
    editObj.fontSizeIncrement = 0;

    //Click events for increase/decrease font size buttons
    editObj.editDiv.select('#increaseFontSize').on('click', increaseFontSize.bind(editObj));
    editObj.editDiv.select('#decreaseFontSize').on('click', decreaseFontSize.bind(editObj));
}

/**
* @name increaseFontSize
* @desc Increases font size by an increment
* @return {undefined} - no return
*/
function increaseFontSize() {
    var editObj = this,
        fontIncrement = 1,
        maxSize = 28;
    if (editObj.fontSizeIncrement < maxSize) {
        editObj.changeFontSize(fontIncrement);
        editObj.fontSizeIncrement++;
        editObj.vizOptions.text = { 'editable-text-increment': editObj.fontSizeIncrement };
    }
}

/**
* @name decreaseFontSize
* @desc Decreases font size by an increment
* @return {undefined} - no return
*/
function decreaseFontSize() {
    var editObj = this,
        fontDecrement = -1,
        minSize = -12;
    //min size is neg 12 because default size is 12px on our charts
    if (editObj.fontSizeIncrement > minSize) {
        editObj.changeFontSize(fontDecrement);
        editObj.fontSizeIncrement--;
        editObj.vizOptions.text = { 'editable-text-increment': editObj.fontSizeIncrement };
    }
}

/**
* @name changeFontSize
* @desc Increases or decreases font size by a certain increment
* @param {integer} increment - number of increment
* @return {undefined} - no return
*/
function changeFontSize(increment) {
    var editObj = this;
    editObj.chartDiv.selectAll('text').each(function () {
        updateFont(this, increment);
    });
    editObj.chartDiv.selectAll('.text').each(function () {
        updateFont(this, increment);
    });
}

/**
* @name updateFont
* @desc changes the size of the font by a given increment
* @param {htmlNode} thisDiv - node to change font size
* @param {integer} increment - number of increment
* @return {undefined} - no return
*/
function updateFont(thisDiv, increment) {
    var newSize,
        textSize = 12;
    if (thisDiv && thisDiv.getAttribute('font-size')) {
        textSize = thisDiv.getAttribute('font-size');
        newSize = parseInt(textSize, 10) + increment;
        thisDiv.setAttribute('font-size', newSize + 'px');
    } else if (thisDiv) {
        textSize = parseInt(window.getComputedStyle(thisDiv, null).getPropertyValue('font-size'), 10) + increment;
        thisDiv.style.fontSize = textSize + 'px';
    }
}

/**
* @name populateSelectionsEditMode
* @desc Initially populates the editDiv if there are vizOptions
* @param {htmlNode} editDiv - edit mode options div
* @param {object} vizOptions - current user options to apply to the edit div
* @return {undefined} - no return
*/
function populateSelectionsEditMode(editDiv, vizOptions) {
    for (var option in vizOptions) {
        if (vizOptions.hasOwnProperty(option)) {
            var selectedObject = editDiv.select('#' + option)._groups[0][0];
            //default color inputs to gray
            if (vizOptions[option] === 'default') {
                if (selectedObject.type === 'color') {
                    if (selectedObject.id.indexOf('text') > 0) {
                        selectedObject.value = '#000000';
                    } else {
                        selectedObject.value = '#aaaaaa';
                    }
                }
            } else {
                selectedObject.value = vizOptions[option];
            }
        }
    }
}

/**
* @name submitEditMode
* @desc calls save callback on edit mode with edit options
* @param {object} optionValues - new user options to save
* @param {object} possibleItemToChange - item that the user clicked (might not be the actual item to update)
* @param {object} defaultBtnClicked - reset viz option to default
* @return {undefined} - no return
*/
function submitEditMode(optionValues, possibleItemToChange, defaultBtnClicked) {
    var editObj = this,
        optionArray = optionValues,
        selectedEditOptions = {},
        editValue = void 0,
        selectedObj = void 0,
        itemToChange = possibleItemToChange;

    for (var i = 0; i < optionArray.length; i++) {
        if (optionArray[i].indexOf('editable-legend') > 0) {
            //change item to change for legend elements
            itemToChange = optionArray[i];
        }
        selectedObj = editObj.editDiv.select('#' + optionArray[i]);
        //see if selected object exists
        if (selectedObj && selectedObj._groups[0] && selectedObj._groups[0][0]) {
            editValue = selectedObj._groups[0][0].value;
            //get selected option from edit div
            if (optionArray[i] === 'editable-content' && editValue === '') {
                //dont add an empty string to the viz options for editable content
                break;
            }
            selectedEditOptions[optionArray[i]] = editValue;
            if (!selectedEditOptions[optionArray[i]] && optionArray[i].indexOf('content') < 0) {
                selectedEditOptions[optionArray[i]] = 'default';
            }
        }
    }

    if (defaultBtnClicked) {
        if (itemToChange === 'svg') {
            delete editObj.vizOptions.text;
        }
        delete editObj.vizOptions[itemToChange];
    } else {
        editObj.vizOptions[itemToChange] = selectedEditOptions;
    }

    if (itemToChange === 'svg') {
        delete editObj.vizOptions.svg;
    }

    //save vizOptions
    editObj.onSaveCallback(editObj.vizOptions);
}

/**
* @name applyEditMode
* @desc applies individual viz option on the visual
* @param {string} itemToChange - viz option to update
* @param {object} options - viz option properties
* @return {undefined} - no return
*/
function applyEditMode(itemToChange, options) {
    var editObj = this,
        object = editObj.chartDiv.select('.' + itemToChange),
        objectGroups = object._groups,
        objectTagName = objectGroups[0][0] ? objectGroups[0][0].tagName.toLowerCase() : null;

    if (itemToChange === 'text') {
        //do something if it is all the text that is being changed
        object = editObj.chartDiv.selectAll('text');
    }

    //options by tagName
    if (objectTagName === 'g') {
        object = editObj.chartDiv.select('.' + itemToChange).selectAll('text');
    } else if (objectTagName === 'rect') {
        if (options['editable-bar']) {
            object.attr('fill', options['editable-bar']);
        }
        if (options['editable-box']) {
            object.attr('fill', options['editable-box']);
        }
    } else if (objectTagName === 'circle') {
        if (options['editable-scatter']) {
            object.attr('fill', options['editable-scatter']);
        }
        if (options['editable-bubble']) {
            object.attr('fill', options['editable-bubble']);
        }
    } else if (objectTagName === 'path') {
        if (options['editable-pie']) {
            object.attr('fill', options['editable-pie']);
        }
    }

    //standard options
    //If a text increment exists, apply it based on the sign of the variable
    if (options.hasOwnProperty('editable-text-increment')) {
        editObj.changeFontSize(options['editable-text-increment']);
    }

    if (options.hasOwnProperty('editable-text-size')) {
        object.style('font-size', options['editable-text-size'] + 'px');
    }
    if (options.hasOwnProperty('editable-text-color')) {
        object.style('fill', options['editable-text-color']);
        object.style('color', options['editable-text-color']);
    }
    if (options.hasOwnProperty('editable-num-format')) {
        var expression = getFormatExpression(options['editable-num-format']);
        object.transition().text(function (d) {
            if (!isNaN(d) && typeof expression === 'function') {
                return expression(d);
            }
            return d;
        });
    }
    if (options.hasOwnProperty('editable-content')) {
        if (options['editable-content'].length > 0) {
            object.html(options['editable-content']);
        }
    }
    editObj.removeEdit();
}

/**
* @name applyAllEdits
* @desc applies all viz options in the edit mode object
* @return {undefined} - no return
*/
function applyAllEdits() {
    var editObj = this;
    for (var option in editObj.vizOptions) {
        if (editObj.vizOptions.hasOwnProperty(option) && editObj.chartDiv.select(option)) {
            editObj.applyEditMode(option, editObj.vizOptions[option]);
        }
    }
}

/**
* @name removeEdit
* @desc removes edit div from the visual
* @return {undefined} - no return
*/
function removeEdit() {
    var editObj = this;
    if (editObj.editDiv) {
        editObj.editDiv.html('');
        editObj.editDiv.style('display', 'none');
    }
    editObj.editOptions = '';
}

/**
* @name overlayDivPosition
* @desc function to determine the placement of the div on the visual
* @param {number} divWidth - width of the comment entry box
* @param {number} divHeight - height of the comment entry box
* @param {number} mouseX - x position of the click event
* @param {number} mouseY - y position of the click event
* @return {object} - position of div
*/
function overlayDivPosition(divWidth, divHeight, mouseX, mouseY) {
    var editObj = this,
        position = {
        x: mouseX,
        y: mouseY + 10
    };
    if (mouseX > parseInt(editObj.chartDiv.style('width'), 10) / 2) {
        position.x = mouseX - divWidth;
    }
    if (mouseY - divHeight - 10 > 0) {
        position.y = mouseY - divHeight - 10;
    }
    return position;
}

/**
* @name getFormatExpression
* @desc returns the d3 format expression for a given option
* @param {string} option - type of data format
* @return {function} - expression
*/
function getFormatExpression(option) {
    var expression = '',
        p = void 0;
    if (option === 'currency') {
        expression = d3.format('$,');
    } else if (option === 'fixedCurrency') {
        expression = d3.format('($.2f');
    } else if (option === 'percent') {
        p = Math.max(0, d3.precisionFixed(0.05) - 2);
        expression = d3.format('.' + p + '%');
    } else if (option === 'millions') {
        p = d3.precisionPrefix(1e5, 1.3e6);
        expression = d3.formatPrefix('.' + p, 1.3e6);
    } else if (option === 'commas') {
        expression = d3.format(',.0f');
    } else {
        expression = d3.format('');
    }
    return expression;
}

module.exports = jvEdit;

},{"./editOptionsTemplate.js":1}],7:[function(require,module,exports){
/***jvEvents
 * Eventing layer on top of JV Charts to allow custom callbacks to be attached to mouse events
 */
'use strict';

var jvCharts = require('./jvCharts.js'),
    jvComment = require('./jvComment.js'),
    jvEdit = require('./jvEdit.js'),
    jvBrush = require('./jvBrush.js');

jvCharts.prototype.initializeModes = initializeModes;
jvCharts.prototype.createDefaultMode = createDefaultMode;
jvCharts.prototype.createCommentMode = createCommentMode;
jvCharts.prototype.createEditMode = createEditMode;
jvCharts.prototype.createBrushMode = createBrushMode;
jvCharts.prototype.createSelectMode = createSelectMode;
jvCharts.prototype.toggleModes = toggleModes;
jvCharts.prototype.toggleDefaultMode = toggleDefaultMode;
jvCharts.prototype.toggleCommentMode = toggleCommentMode;
jvCharts.prototype.toggleEditMode = toggleEditMode;
jvCharts.prototype.toggleBrushMode = toggleBrushMode;
jvCharts.prototype.toggleSelectMode = toggleSelectMode;
jvCharts.prototype.addBrushEvents = addBrushEvents;

/**
* @name initializeModes
* @desc function that initializes and creates the chart toolbar
* @return {undefined} - no return
*/
function initializeModes() {
    var chart = this,
        callbacks = chart.config.callbacks;

    //check if callbacks are needed
    if (callbacks) {
        for (var mode in callbacks) {
            //loop through all the types of modes to initialize the mode and register the appropriate events
            if (callbacks.hasOwnProperty(mode) && callbacks[mode]) {
                var camelCaseMode = mode.charAt(0).toUpperCase() + mode.slice(1);
                chart[mode] = chart['create' + camelCaseMode]();
            }
        }
        if (chart.editMode) {
            chart.editMode.applyAllEdits();
        }
        chart.toggleModes(chart.mode);
    } else {
        chart.createDefaultMode();
        //user has not defined any other modes, so just use default mode
        chart.toggleDefaultMode('default-mode');
    }
}

/**
* @name createDefaultMode
* @desc function that initializes and creates the default mode
* @return {undefined} - no return
*/
function createDefaultMode() {
    var chart = this;
    if (chart.config.callbacks && chart.config.callbacks.defaultMode.onBrush) {
        chart.brushMode = chart.createBrushMode(chart.config.callbacks.defaultMode.onBrush);
    }
}

/**
* @name createCommentMode
* @desc function that initializes and creates the comment mode
* @return {jvComment} - created comment mode
*/
function createCommentMode() {
    var chart = this;
    return new jvComment({
        chartDiv: chart.chartDiv,
        comments: chart.config.comments || {},
        onSaveCallback: chart.config.callbacks.commentMode.onSave,
        getMode: function getMode() {
            return chart.mode;
        }
    });
}

/**
* @name createEditMode
* @desc function that initializes and creates the edit mode
* @return {jvEdit} - created edit mode object
*/
function createEditMode() {
    var chart = this;
    return new jvEdit({
        chartDiv: chart.chartDiv,
        vizOptions: chart.config.editOptions || {},
        onSaveCallback: chart.config.callbacks.editMode.onSave
    });
}

/**
* @name createBrushMode
* @desc function that initializes and creates the brush mode
* @param {function} callbackParam - function that is an optional callback for brush mode
* @return {jvBrush} - created brush mode object
*/
function createBrushMode(callbackParam) {
    var chart = this,
        callback = callbackParam;
    if (!callback) {
        if (chart.config.callbacks.brushMode && typeof chart.config.callbacks.brushMode.onBrush === 'function') {
            callback = chart.config.callbacks.brushMode.onBrush;
        } else {
            console.log('no brush callback, pass it into the callbacks option');
            return null;
        }
    }
    return new jvBrush({
        chartDiv: chart.chartDiv,
        jvChart: chart,
        onBrushCallback: callback
    });
}

/**
* @name createSelectMode
* @desc function that initializes and creates the select mode
* @return {boolean} - true since the creation of a mode is only called when callbacks for the mode exist
*/
function createSelectMode() {
    return true;
}

/**
* @name toggleModes
* @desc sets the correct events for the specific mode param
* @param {string} mode - specified mode to toggle to
* @return {undefined} - no return
*/
function toggleModes(mode) {
    var chart = this;
    chart.toggleDefaultMode(mode);
    chart.commentMode && chart.toggleCommentMode(mode);
    chart.editMode && chart.toggleEditMode(mode);
    chart.brushMode && chart.toggleBrushMode(mode);
    chart.selectMode && chart.toggleSelectMode(mode);
}

/**
* @name toggleDefaultMode
* @desc updates event listeners for default mode
* @param {string} mode - specified mode to toggle to
* @return {undefined} - no return
*/
function toggleDefaultMode(mode) {
    var chart = this;
    if (mode === 'default-mode') {
        var defaultMode = chart.config.callbacks ? chart.config.callbacks.defaultMode : false,
            entireSvg = chart.chartDiv.select('svg'),
            callbacks = void 0;
        //change cursor and show tooltips
        chart.chartDiv.style('cursor', 'default');
        chart.showToolTip = true;

        //return if no callbacks exist
        if (!defaultMode) {
            return;
        }
        callbacks = {
            onDoubleClick: function onDoubleClick(event, node, mouse) {
                if (typeof defaultMode.onDoubleClick === 'function') {
                    var retrunObj = chart[chart.config.type].getEventData.call(chart, event, mouse);
                    retrunObj.eventType = 'doubleClick';
                    defaultMode.onDoubleClick(retrunObj);
                }
            },
            onClick: function onClick(event, node, mouse) {
                if (typeof defaultMode.onClick === 'function') {
                    var retrunObj = chart[chart.config.type].getEventData.call(chart, event, mouse);
                    retrunObj.eventType = 'click';
                    defaultMode.onClick(retrunObj);
                }
            }
        };

        if (defaultMode.onBrush && chart.brushMode) {
            callbacks.mousedown = addBrushMousedown.bind(chart);
            callbacks.mouseup = function () {
                chart.chartDiv.select('svg').on('mousemove', false);
                chart.chartDiv.select('svg').style('cursor', 'default');
                chart.brushMode.removeBrush();
            };
        }
        registerClickEvents(entireSvg, callbacks);
    } else {
        //remove tooltips and any highlights
        chart.showToolTip = false;
        chart.removeHighlight();
    }
}

/**
* @name toggleCommentMode
* @desc updates event listeners for comment mode
* @param {string} mode - specified mode to toggle to
* @return {undefined} - no return
*/
function toggleCommentMode(mode) {
    var chart = this,
        commentObj = chart.commentMode;
    if (mode === 'comment-mode') {
        var entireSvg = chart.chartDiv.select('svg'),
            callbacks = {
            onDoubleClick: function onDoubleClick(event, node, mouse) {
                commentObj.makeComment(node);
                if (typeof chart.config.callbacks.commentMode.onDoubleClick === 'function') {
                    var retrunObj = chart[chart.config.type].getEventData.call(chart, event, mouse);
                    retrunObj.eventType = 'doubleClick';
                    chart.config.callbacks.commentMode.onDoubleClick(retrunObj);
                }
            },
            onClick: function onClick(event, node, mouse) {
                if (typeof chart.config.callbacks.commentMode.onClick === 'function') {
                    var retrunObj = chart[chart.config.type].getEventData.call(chart, event, mouse);
                    retrunObj.eventType = 'click';
                    chart.config.callbacks.commentMode.onClick(retrunObj);
                }
            }
        };
        registerClickEvents(entireSvg, callbacks);
        //set cursor for comment mode
        chart.chartDiv.style('cursor', 'pointer');
        //add movementlisteners
        chart.chartDiv.selectAll('.min-comment').on('mousedown', function () {
            //logic to move comments
            commentObj.createMoveListener(d3.select(this));
        }).on('mouseup', function () {
            if (commentObj.moved) {
                commentObj.updatePosition(commentObj);
            }
            commentObj.moved = false;
            chart.chartDiv.on('mousemove', false);
        });
    } else {
        commentObj.removeComment();
    }
}

/**
* @name toggleEditMode
* @desc updates event listeners for edit mode
* @param {string} mode - specified mode to toggle to
* @return {undefined} - no return
*/
function toggleEditMode(mode) {
    var chart = this,
        editObj = chart.editMode,
        entireSvg = editObj.chartDiv.select('svg');
    if (mode === 'edit-mode') {
        editObj.chartDiv.style('cursor', 'default');
        entireSvg.selectAll('.event-rect').attr('display', 'none');

        var callbacks = {
            onDoubleClick: function onDoubleClick(event, node, mouse) {
                if (typeof chart.config.callbacks.editMode.onDoubleClick === 'function') {
                    var retrunObj = chart[chart.config.type].getEventData.call(chart, event, mouse);
                    retrunObj.eventType = 'doubleClick';
                    chart.config.callbacks.editMode.onDoubleClick(retrunObj);
                }
            },
            onClick: function onClick(event, node, mouse) {
                //edit mode events
                //going to be mouseover to highlight options for whatever piece you hover over
                var classText = d3.select(event.target).attr('class');
                if (classText) {
                    if (classText.indexOf('editable') >= 0) {
                        editObj.displayEdit(mouse, classText);
                    }
                }

                if (typeof chart.config.callbacks.editMode.onClick === 'function') {
                    var retrunObj = chart[chart.config.type].getEventData.call(chart, event, mouse);
                    retrunObj.eventType = 'click';
                    chart.config.callbacks.editMode.onClick(retrunObj);
                }
            }
        };
        //clear svg listeners
        registerClickEvents(entireSvg);
        //add chart div level listeners
        registerClickEvents(editObj.chartDiv, callbacks);

        editObj.chartDiv.selectAll('.editable').classed('pointer', true);
    } else {
        //clear chart div level listeners
        registerClickEvents(editObj.chartDiv);
        editObj.removeEdit();
        entireSvg.selectAll('.editable').classed('pointer', false);
        entireSvg.selectAll('.event-rect').attr('display', 'block');
    }
}

/**
* @name toggleBrushMode
* @desc updates event listeners for brush mode
* @param {string} mode - specified mode to toggle to
* @return {undefined} - no return
*/
function toggleBrushMode(mode) {
    var chart = this;
    if (mode === 'brush-mode' && chart.config.callbacks.brushMode) {
        chart.addBrushEvents();
    }
}

/**
* @name toggleSelectMode
* @desc updates event listeners for select mode
* @param {string} mode - specified mode to toggle to
* @return {undefined} - no return
*/
function toggleSelectMode(mode) {
    var chart = this;
    if (mode === 'select-mode') {
        var callbacks = {
            onDoubleClick: function onDoubleClick(event, node, mouse) {
                if (typeof chart.config.callbacks.selectMode.onDoubleClick === 'function') {
                    var retrunObj = chart[chart.config.type].getEventData.call(chart, event, mouse);
                    retrunObj.eventType = 'doubleClick';
                    chart.config.callbacks.selectMode.onDoubleClick(retrunObj);
                }
            },
            onClick: function onClick(event, node, mouse) {
                if (typeof chart.config.callbacks.selectMode.onClick === 'function') {
                    var retrunObj = chart[chart.config.type].getEventData.call(chart, event, mouse);
                    retrunObj.eventType = 'click';
                    chart.config.callbacks.selectMode.onClick(retrunObj);
                }
            }
        };
        registerClickEvents(chart.chartDiv.select('svg'), callbacks);
    }
}

/**
* @name addBrushEvents
* @desc registers events for brush mode
* @return {undefined} - no return
*/
function addBrushEvents() {
    var chart = this,
        entireSvg = chart.chartDiv.select('svg'),
        callbacks = {
        mousedown: addBrushMousedown.bind(chart),
        mouseup: function mouseup() {
            chart.chartDiv.select('svg').on('mousemove', false);
            chart.brushMode.removeBrush();
        }
    };
    registerClickEvents(entireSvg, callbacks);
}

/**
* @name addBrushMousedown
* @desc creates mousedown event for brush mode
* @return {undefined} - no return
*/
function addBrushMousedown() {
    var chart = this,
        brushStarted = false,
        brushContainer = chart.chartDiv.select('.' + chart.config.type + '-container').node(),
        entireSvg = chart.chartDiv.select('svg'),
        timeMouseDown = new Date().getTime();
    entireSvg.on('mousemove', function () {
        var timeMouseMove = new Date().getTime();
        if (timeMouseDown > timeMouseMove - 10) {
            //mouse move happend too quickly, chrome bug
            return;
        }
        if (brushStarted) {
            return;
        }
        var containerBox = void 0,
            x = void 0,
            y = void 0,
            mouse = void 0;
        if (brushContainer === undefined) {
            chart.brushMode.startBrush(d3.event);
            brushStarted = true;
        } else {
            containerBox = brushContainer.getBoundingClientRect();
            mouse = d3.mouse(entireSvg.node());
            x = mouse[0];
            y = mouse[1];

            if (x < containerBox.right && y < containerBox.bottom && x > containerBox.left && y > containerBox.top) {
                chart.brushMode.startBrush(d3.event);
                brushStarted = true;
            }
        }
    });
}

/**
* @name registerClickEvents
* @desc register handler for jv events
* @param {d3element} svg - d3 selected element to bind events on
* @param {object} listeners - callbacks to run for each type of click event
* @return {undefined} - no return
*/
function registerClickEvents(svg) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$onClick = _ref.onClick,
        onClick = _ref$onClick === undefined ? null : _ref$onClick,
        _ref$onDoubleClick = _ref.onDoubleClick,
        onDoubleClick = _ref$onDoubleClick === undefined ? null : _ref$onDoubleClick,
        _ref$mousedown = _ref.mousedown,
        mousedown = _ref$mousedown === undefined ? null : _ref$mousedown,
        _ref$mouseup = _ref.mouseup,
        mouseup = _ref$mouseup === undefined ? null : _ref$mouseup;

    //using default parameters to show available parts of the callbacks object
    var down,
        tolerance = 5,
        wait = null;

    svg.on('mousedown', false);
    svg.on('mouseup', false);
    svg.on('mousemove', false);

    svg.on('mousedown', function () {
        down = d3.mouse(svg.node());
        if (typeof mousedown === 'function') {
            mousedown();
        }
    });

    svg.on('mouseup', function () {
        var _this = this;

        if (typeof mouseup === 'function') {
            mouseup();
        }
        if (!onDoubleClick) {
            if (typeof onClick === 'function') {
                onClick(d3.event, this, d3.mouse(this));
            }
            return;
        }
        if (dist(down, d3.mouse(svg.node())) > tolerance) {
            //drag not click so return
            return;
        }
        if (wait) {
            window.clearTimeout(wait);
            wait = null;
            if (typeof onDoubleClick === 'function') {
                onDoubleClick(d3.event, this, d3.mouse(this));
            }
        } else {
            wait = window.setTimeout(function (e, mouse) {
                return function () {
                    if (typeof onClick === 'function') {
                        onClick(e, _this, mouse);
                    }
                    wait = null;
                };
                //d3.event and d3.mouse both lose their scope in a timeout and no longer return the expected value, so binding is necessary
            }(d3.event, d3.mouse(this)), 250);
        }
    });
}

/**
* @name dist
* @desc euclidean distance to determine if the mouse moved in between clicks for double click
* @param {array} a - point a
* @param {array} b - point b
* @return {number} - distance between a and b
*/
function dist(a, b) {
    if (a && b && Array.isArray(a) && Array.isArray(b)) {
        return Math.sqrt(Math.pow(a[0] - b[0], 2), Math.pow(a[1] - b[1], 2));
    }
    return 0;
}

},{"./jvBrush.js":3,"./jvCharts.js":4,"./jvComment.js":5,"./jvEdit.js":6}],8:[function(require,module,exports){
'use strict';

/***  jvEdit ***/
function jvSelect(configObj) {
    'use strict';

    var selectObj = this;
    selectObj.chartDiv = configObj.chartDiv;
    selectObj.jvChart = configObj.jvChart;
    selectObj.singleClickCallback = configObj.singleClickCallback;
    selectObj.doubleClickCallback = configObj.doubleClickCallback;
}

function singleClick(selectObj, event) {
    if (typeof selectObj.singleClickCallback === 'function') {
        selectObj.singleClickCallback(event);
    }
}
function dblclick(selectObj, event) {
    if (typeof selectObj.doubleClickCallback === 'function') {
        selectObj.doubleClickCallback(event);
    }
}

/********************************************* Select Mode Functions **************************************************/

module.exports = jvSelect;

},{}],9:[function(require,module,exports){
'use strict';

/***  jvTip ***/

function jvTip(configObj) {
    'use strict';

    var tip = this,
        defaultConfig = {
        type: 'simple'
    };

    tip.tipConfig = configObj.tipConfig || defaultConfig;
    tip.chartDiv = configObj.chartDiv;

    //Create initial div
    tip.chartDiv.select('.jv-tooltip').remove();

    tip.chartDiv.append('div').attr('class', 'tooltip jv-tooltip').style('pointer-events', 'none');
}

jvTip.prototype.showTip = showTip;
jvTip.prototype.hideTip = hideTip;
jvTip.prototype.generateSimpleTip = generateSimpleTip;

function showTip() {
    var transitionDuration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 50;

    var tip = this,
        left = 'auto',
        top = 'auto',
        mouse = d3.mouse(tip.chartDiv.select('svg').node()),

    //Logic to determine where tooltip will be placed on page
    leftOfMouse = mouse[0] > tip.chartDiv._groups[0][0].clientWidth / 2,
        topOfMouse = mouse[1] < tip.chartDiv._groups[0][0].clientHeight / 2,
        tooltipHeight = tip.toolTip._groups[0][0].clientHeight === 0 ? 75 : tip.toolTip._groups[0][0].clientHeight,
        tooltipWidth = tip.toolTip._groups[0][0].clientWidth,
        t = void 0;

    if (leftOfMouse) {
        if (tooltipWidth === 0) {
            tooltipWidth = 250;
        }
        left = mouse[0] - tooltipWidth;
    } else {
        left = mouse[0];
    }
    if (topOfMouse) {
        top = mouse[1];
    } else {
        if (tooltipHeight === 0) {
            tooltipHeight = 75;
        }
        top = mouse[1] - tooltipHeight;
    }

    if (!leftOfMouse && topOfMouse) {
        left = mouse[0] + 13;
    }

    //COOL CURSOR, a function of the height and width of the container
    //var container = tip.chartDiv.select('.bar-container').node().getBoundingClientRect();
    //svgMouse = d3.mouse(tip.chartDiv.select('.bar-container').node());

    //var tooltipHeight = tip.toolTip._groups[0][0].clientHeight === 0 ? 75 : tip.toolTip._groups[0][0].clientHeight;
    //top = mouse[1] - (tooltipHeight * svgMouse[1] / container.height);

    //var tooltipWidth = tip.toolTip._groups[0][0].clientWidth;
    //left = mouse[0] - (tooltipWidth * svgMouse[0] / container.width);

    //STICKY CURSOR IN THE BOTTOM RIGHT
    //top = mouse[1];
    //left = mouse[0];
    //set max left
    //if(left > container.width - tooltipWidth + container.left) {
    //left = container.width - tooltipWidth + container.left;
    //}

    ////set max top
    //if (top > container.height - tooltipHeight + container.top) {
    //top = container.height - tooltipHeight + container.top;
    //}

    t = d3.transition().duration(transitionDuration).ease(d3.easeLinear);

    tip.toolTip.transition(t).style('left', left + 'px').style('top', top + 'px').style('display', 'block').style('opacity', 1);
}

function hideTip() {
    var tip = this,
        t = d3.transition().duration('100').ease(d3.easeLinear);
    if (tip.toolTip) {
        tip.toolTip.transition(t).style('display', 'none');
    }
}

/************************************************  Declare jv tip components *******************************************************************************/
var jvHr = '<hr style=\'margin:3px 0 3px 0;\'/>';

function getValueContent(item, value, colorTile) {
    var valueString = value ? ': ' + value : '',
        colorTileString = colorTile ? colorTile : '';
    return '<span class=\'jv-tip-content jv-tip-side-margins\'>' + colorTileString + item + valueString + '</span><br/>';
}

function getTitleTemplate(dataObj) {
    return '<div class=\'title jv-top-margin jv-inline\'><b>' + dataObj.title + '</b></div>' + jvHr;
}

function getColorTile(color) {
    if (color) {
        return '<div class=\'d3-tooltip-circle jv-inline jv-tip-side-margins\' style=\'background:' + color + '\'></div>';
    }
    return "<div class='jv-inline jv-tip-side-margins'>";
}

/************************************************* Viz Specific Functions **********************************************************************************/
function generateSimpleTip(dataObj, dataTable) {
    var tip = this,
        tooltipHtml = '';

    if (dataObj.hasOwnProperty('title') && dataObj.title === '') {
        dataObj.title = 'Empty';
    }

    if (dataObj.viz === 'clusters' || dataObj.viz === 'circleviewplot' || dataObj.viz === 'scatterplot' || dataObj.viz === 'treemap' || dataObj.viz === 'singleaxis') {
        tooltipHtml = generateSingleColorHTML(dataObj, dataTable);
    } else if (dataObj.viz === 'radial' || dataObj.viz === 'pie') {
        tooltipHtml = generatePieHTML(dataObj, dataTable);
    } else if (dataObj.viz === 'circlepack' || dataObj.viz === 'sunburst') {
        tooltipHtml = generatePackHTML(dataObj, dataTable);
    } else if (dataObj.viz === 'heatmap' || dataObj.viz === 'cloud') {
        tooltipHtml = generateHeatmapHTML(dataObj, dataTable);
    } else if (dataObj.viz === 'sankey') {
        tooltipHtml = generateSankeyHTML(dataObj, dataTable);
    } else if (dataObj.viz === 'bubble') {
        tooltipHtml = generateBubbleHTML(dataObj);
    } else if (dataObj.viz === 'boxwhisker') {
        tooltipHtml = generateBoxHTML(dataObj);
    } else if (dataObj.viz === 'clustergram') {
        tooltipHtml = generateClustergramHTML(dataObj);
    } else if (dataObj.viz === 'gantt') {
        tooltipHtml = generateGanttHTML(dataObj, dataTable);
    } else {
        tooltipHtml = generateSimpleHTML(dataObj, dataTable);
    }

    //add content to tooltip
    tip.toolTip = tip.chartDiv.select('.tooltip').html(tooltipHtml);

    //paint the tooltip
    tip.showTip(0);

    return tip.tooltip;
}

function generateSimpleHTML(dataObj) {
    var tooltipText = void 0;
    tooltipText = '<div><div class=\'title jv-tip-container jv-tip-side-margins jv-top-margin\'><b>' + dataObj.title + '</b></div>' + jvHr;

    for (var item in dataObj.tipData) {
        tooltipText += getValueContent(item, formatValue(dataObj.tipData[item]), getColorTile(dataObj.color[item]));
    }
    tooltipText += '</div>';
    return tooltipText;
}

function generateSingleColorHTML(dataObj, dataTable) {
    var tooltipText = void 0,
        tooltipColor = void 0,
        showColorCircle = true,
        colorCircle = '';

    if (!!dataObj.color[dataObj.data[dataTable.series]]) {
        tooltipColor = dataObj.color[dataObj.data[dataTable.series]];
    } else if (!!dataObj.color[dataTable.label] && dataObj.viz !== 'singleaxis') {
        tooltipColor = dataObj.color[dataTable.label];
    } else {
        showColorCircle = false;
    }

    if (showColorCircle) {
        colorCircle = getColorTile(tooltipColor);
    } else {
        colorCircle = getColorTile();
    }

    tooltipText = '<div class=\'jv-inline\'>' + colorCircle + '<div class=\'title jv-tip-side-margins jv-inline jv-top-margin\'><b>' + dataObj.title + '</b></div>' + jvHr;

    for (var item in dataObj.tipData) {
        tooltipText += getValueContent(item, formatValue(dataObj.tipData[item]));
    }
    tooltipText += '</div>';
    return tooltipText;
}

function generatePackHTML(dataObj) {
    var tooltipText = void 0;
    tooltipText = '<div class=\'jv-inline\'>\n        ' + getColorTile(dataObj.data.color) + '\n        ' + getTitleTemplate(dataObj);

    for (var item in dataObj.tipData) {
        tooltipText += getValueContent(item, formatValue(dataObj.tipData[item]));
    }
    tooltipText += '</div>';
    return tooltipText;
}

function generateBubbleHTML(dataObj) {
    var tooltipText = void 0;
    tooltipText = '<div class=\'jv-inline\'>\n        ' + getColorTile(dataObj.data.color) + '\n        ' + getTitleTemplate(dataObj);

    for (var item in dataObj.tipData) {
        if (item === 'color') {
            continue;
        }
        tooltipText += getValueContent(item, formatValue(dataObj.tipData[item]));
    }
    tooltipText += '</div>';
    return tooltipText;
}

function generateBoxHTML(dataObj) {
    var tooltipText = void 0;
    tooltipText = '<div class="jv-inline">';

    for (var item in dataObj.tipData) {
        if (dataObj.tipData.hasOwnProperty(item)) {
            tooltipText += getValueContent(item, formatValue(dataObj.tipData[item]));
        }
    }
    tooltipText += '</div>';
    return tooltipText;
}

function generateHeatmapHTML(dataObj) {
    var tooltipText = void 0;
    if (dataObj.xAxisCat) {
        tooltipText = '<div class=\'jv-inline\'>\n            ' + getColorTile(dataObj.color) + "<div class='title jv-top-margin jv-inline'><b>" + dataObj.data.xAxisName + "</b></div><hr style='margin:3px 0 3px 0;'/>";

        tooltipText += "<span class='jv-tip-content jv-tip-side-margins'>" + dataObj.xAxisCat + '</span><br/>';
        tooltipText += '</div>';
        return tooltipText;
    } else if (dataObj.yAxisCat) {
        tooltipText = '<div class=\'jv-inline\'>\n            ' + getColorTile(dataObj.color) + "<div class='title jv-top-margin jv-inline'><b>" + dataObj.data.yAxisName + "</b></div><hr style='margin:3px 0 3px 0;'/>";

        tooltipText += "<span class='jv-tip-content jv-tip-side-margins'>" + dataObj.yAxisCat + '</span><br/>';
        tooltipText += '</div>';
        return tooltipText;
    }
    tooltipText = '<div class=\'jv-inline\'>\n            ' + getColorTile(dataObj.color) + '\n            ' + getTitleTemplate(dataObj);

    for (var item in dataObj.tipData) {
        tooltipText += getValueContent(item, formatValue(dataObj.tipData[item]));
    }
    tooltipText += '</div>';
    return tooltipText;
}

function generateClustergramHTML(dataObj) {
    var tooltipText = void 0;
    dataObj.title = dataObj.title.replace(/_/g, ' ');
    tooltipText = '<div class=\'jv-inline\'>\n    ' + getColorTile(dataObj.color) + '\n    ' + getTitleTemplate(dataObj);

    for (var item in dataObj.tipData) {
        tooltipText += getValueContent(item, formatValue(dataObj.tipData[item]));
    }
    tooltipText += '</div>';

    return tooltipText;
}

function generateGanttHTML(dataObj, dataTable) {
    var tooltipText;

    dataObj.title = dataObj.title.replace(/_/g, " ");

    tooltipText = '<div class=\'jv-inline\'>\n    ' + getTitleTemplate(dataObj);

    for (var i = 1; i <= dataObj.data.length; i++) {
        var startValue = dataObj.tipData[dataTable["start " + i]];
        var endValue = dataObj.tipData[dataTable["end " + i]];
        var durationValue = dataObj.tipData["Duration " + i];
        if (durationValue !== "0 days" && durationValue != null && startValue != null && endValue != null) {
            endValue = endValue.substring(0, 10);
            startValue = startValue.substring(0, 10);
            var item = dataTable["start " + i];
            // if (item.substring(0,6) === "Start ") {
            //     item = item.substring(6);
            // }

            var value = startValue + " to " + endValue;
            tooltipText += getValueContent(item, value, getColorTile(dataObj.color[dataTable["start " + i]]));
            tooltipText += getValueContent("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Duration", durationValue);
        }
    }
    tooltipText += "</div>";

    return tooltipText;
}

function generatePieHTML(dataObj, dataTable) {
    var tooltipText = void 0;
    tooltipText = '<div class=\'jv-inline\'>\n    ' + getColorTile(dataObj.color[dataObj.data.label]) + '\n    ' + getTitleTemplate(dataObj);

    for (var item in dataObj.tipData) {
        tooltipText += getValueContent(dataTable[item], formatValue(dataObj.tipData[item]));
    }
    tooltipText += '</div>';
    return tooltipText;
}

function generateSankeyHTML(dataObj) {
    var tooltipText = void 0;
    tooltipText = '<div class=\'jv-inline\'>' + getTitleTemplate(dataObj);

    for (var item in dataObj.tipData) {
        tooltipText += getValueContent(dataObj.valueName, formatValue(dataObj.tipData[item]));
    }
    tooltipText += '</div>';
    return tooltipText;
}

function formatValue(val) {
    if (!isNaN(val)) {
        var formatNumber = d3.format(',.0f');
        if (val >= 1000000) {
            //millions
            //var p = d3.precisionPrefix(1e5, 1.3e6);
            //formatNumber = d3.formatPrefix("." + p, 1.3e6);
            formatNumber = d3.format(',.2f');
        } else if (val <= 100) {
            //2 decimals
            formatNumber = d3.format(',.2f');
        }
        return formatNumber(val);
    }
    return val;
}

module.exports = jvTip;

},{}],10:[function(require,module,exports){
'use strict';

var jvCharts = require('./jvCharts.js');

jvCharts.prototype.getDefaultOptions = getDefaultOptions;

function getDefaultOptions() {
    var userOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    var _vars = {};

    //General Styles/Attributes
    //CONST variables - try to not use in jvCharts as they do not have much context
    _vars.GRAY = '#cccccc';
    _vars.WHITE = '#FFFFFF';
    _vars.BLACK = '#000000';
    _vars.SMALL_STROKE_WIDTH = '1px';
    _vars.light = '#BBBBBB';
    _vars.strokeWidth = '2px';

    //Action Attributes
    _vars.highlightBorderColor = _vars.BLACK;
    _vars.highlightBorderWidth = '2px';

    //Component Specific Styles/Attributes
    _vars.thresholds = 'none'; //if not none, expected to be an array
    _vars.thresholdLegend = false;
    _vars.backgroundColor = 'none';
    _vars.axisColor = _vars.GRAY;
    _vars.axisWidth = _vars.strokeWidth;
    _vars.gridLineStrokeWidth = _vars.SMALL_STROKE_WIDTH;
    _vars.displayValues = false;
    _vars.toggleLegend = false;

    //_vars.legendArrowColor = 'c2c2d6';
    //_vars.legendArrowColor = '000000';
    _vars.legendArrowColor = 'e7e7e7';

    _vars.legendMax = 9;
    _vars.gridSize = 12;
    _vars.xReversed = false;
    _vars.yReversed = false;

    //font styles
    _vars.fontSize = '12px';
    _vars.fontColor = _vars.BLACK;
    _vars.xLabelFontSize = 'none';
    _vars.yLabelFontSize = 'none';

    //Heatmap Specific Styles/Attributes
    _vars.color = '#ff0000';
    _vars.toggleLegend = false;
    _vars.buckets = '10';
    _vars.opacity = '10';
    _vars.colorLabel = 'none';
    _vars.min = '0';
    _vars.max = '10';
    _vars.domainArray = '';
    _vars.step = '1';
    _vars.quantiles = true;
    _vars.heatLegendSpacing = 2;
    _vars.heatGridSize = 20;
    _vars.colors = ['#fbf2d2', '#fdedb5', '#fee7a0', '#ffda84', '#ffc665', '#feb44e', '#fea743', '#fd9b3f', '#fd8c3c', '#fd7735', '#fd602f', '#fb4b29', '#f43723', '#ea241e', '#e0161c', '#d60b20', '#c80324', '#b10026', '#870025', '#620023'];
    _vars.clusterColors = ['#00009C', '#003399', '#002FA7', '#2A52BE', '#0000FF', '#8C92AC', '#92A1CF', '#C4C3D0', '#CCCCFF', '#F8F8FF', '#FFFAFA', '#F4C2C2', '#FF6961', '#FF5C5C', '#FF1C00', '#FF0800', '#FF0000', '#CD5C5C', '#E34234', '#D73B3E'];

    //pie specific
    _vars.pieBorder = _vars.WHITE;
    _vars.pieBorderWidth = _vars.SMALL_STROKE_WIDTH;
    _vars.pieTextColor = _vars.WHITE;
    _vars.emptyLegendSquare = _vars.WHITE;

    //line specific
    _vars.lineCurveType = 'Linear';

    //bar specific
    _vars.displayValuesStackAsPercent = false;
    _vars.displayValuesStackTotal = false;
    _vars.displayYAxisLabel = true;

    //scatter specific
    _vars.toggleZ = true;
    _vars.lineGuide = true;

    //single axis specific
    _vars.singleAxisFillHoverColor = 'red';

    Object.assign(_vars, userOptions);
    return _vars;
}

},{"./jvCharts.js":4}],11:[function(require,module,exports){
'use strict';

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var jvCharts = require('../visuals/jvLine.js');

jvCharts.prototype.area = {
    paint: paint,
    setData: setData,
    getEventData: getEventData
};

jvCharts.prototype.fillArea = fillArea;

/************************************************ Line functions ******************************************************/

/**setLineData
 *  gets line data and adds it to the chart object
 *
 * @params data, dataTable, colors
 */
function setData() {
    var chart = this;
    //sort chart data if there is a sort type and label in the _vars
    if (chart._vars.sortType) {
        if (chart._vars.sortLabel && chart._vars.sortType !== 'default') {
            chart.organizeChartData(chart._vars.sortLabel, chart._vars.sortType);
        }
    }

    //remove if we add non linear to area chart
    chart._vars.lineCurveType = 'Linear';

    chart.data.legendData = setBarLineLegendData(chart.data);
    chart.data.xAxisData = chart.setAxisData('x', chart.data);
    chart.data.yAxisData = chart.setAxisData('y', chart.data);

    if (chart._vars.seriesFlipped) {
        chart.setFlippedSeries(chart.data.dataTableKeys);
        chart.flippedData.color = jvCharts.setChartColors(chart._vars.color, chart.flippedData.legendData, chart.colors);
    }

    //define color object for chartData
    chart.data.color = jvCharts.setChartColors(chart._vars.color, chart.data.legendData, chart.colors);
}

/**setBarLineLegendData
 *  gets legend info from chart Data
 *
 * @params data, type
 * @returns [] of legend tex
 */
function setBarLineLegendData(data) {
    var legendArray = [];
    for (var item in data.dataTable) {
        if (data.dataTable.hasOwnProperty(item)) {
            if (item !== 'label' && item.indexOf('tooltip') === -1) {
                legendArray.push(data.dataTable[item]);
            }
        }
    }
    return legendArray;
}
/**paintLineChart
 *
 * The initial starting point for line chart, begins the drawing process. Must already have the data stored in the chart
 * object
 */
function paint() {
    var chart = this,

    //Uses the original data and then manipulates it based on any existing options
    dataObj = chart.getBarDataFromOptions();

    //assign current data which is used by all bar chart operations
    chart.currentData = dataObj;

    //Overwrite any pre-existing zoom
    chart.config.zoomEvent = null;

    //generate svg dynamically based on legend data
    chart.generateSVG(dataObj.legendData);
    chart.generateXAxis(dataObj.xAxisData);
    chart.generateYAxis(dataObj.yAxisData);
    chart.generateLegend(dataObj.legendData, 'generateLine');

    if (typeof dataObj.xAxisScale.ticks === 'function') {
        chart.formatXAxisLabels(dataObj.xAxisScale.ticks().length);
    } else {
        chart.formatXAxisLabels(dataObj.xAxisScale.domain().length);
    }

    chart.generateLine(dataObj);
}

function getEventData(event) {
    var chart = this;
    if (event.target.classList.value.split('bar-col-')[1]) {
        return {
            data: _defineProperty({}, chart.currentData.dataTable.label, [event.target.classList.value.split('bar-col-')[1].replace(/_/g, ' ').replace(/_dot_/g, '.')]),
            node: event.target
        };
    } else if (event.target.classList.value.indexOf('area-container') > -1) {
        return {
            data: {}
        };
    }
    return {
        data: false
    };
}

/**
 *
 */
function fillArea(lineData) {
    var chart = this,
        svg = chart.svg,
        xAxisData = chart.currentData.xAxisData,
        yAxisData = chart.currentData.yAxisData,
        legendData = chart.currentData.legendData,
        container = chart.config.container,
        colors = chart._vars.color,
        x = jvCharts.getAxisScale('x', xAxisData, container, chart._vars, 'no-padding'),
        y = jvCharts.getAxisScale('y', yAxisData, container, chart._vars, 'no-padding'),
        area,
        data = {};

    //If a legend element is toggled off, use the new list of headers
    if (chart._vars.hasOwnProperty('legendHeaders')) {
        legendData = chart._vars.legendHeaders;
    }
    //If axis are normal
    if (!chart._vars.rotateAxis) {
        area = d3.area().x(function (d) {
            if (d.x === '') {
                return x('EMPTY_STRING');
            }
            return x(d.x);
        }).y0(container.height).y1(function (d) {
            return y(d.y);
        });
    } else {
        area = d3.area().y(function (d) {
            return y(d.y);
        }).x1(0).x0(function (d) {
            return x(d.x);
        });
    }

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = lineData[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var dataEle = _step.value;
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
                for (var _iterator2 = legendData[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    var legendEle = _step2.value;

                    if (legendEle.toggle === false) {
                        //Don't write anything to data
                        continue;
                    }
                    if (!data[legendEle]) {
                        data[legendEle] = [];
                    }
                    if (!chart._vars.rotateAxis) {
                        data[legendEle].push({
                            'x': dataEle[xAxisData.label],
                            'y': parseFloat(dataEle[legendEle])
                        });
                    } else {
                        data[legendEle].push({
                            'y': dataEle[yAxisData.label],
                            'x': parseFloat(dataEle[legendEle])
                        });
                    }
                }
            } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
                        _iterator2.return();
                    }
                } finally {
                    if (_didIteratorError2) {
                        throw _iteratorError2;
                    }
                }
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    svg.selectAll('.area').remove();
    for (var key in data) {
        if (data.hasOwnProperty(key)) {
            svg.append('path').datum(data[key]).attr('class', function () {
                if (chart._vars.colorLine == true && chart._vars.thresholds != 'none' && chart._vars.colorChart != false) {
                    return 'area area-threshold';
                }
                return 'area';
            }).attr('d', area).attr('fill', jvCharts.getColors(colors, null, key)).attr('opacity', 0.6).attr('transform', function () {
                return chart._vars.rotateAxis ? 'translate(0, ' + container.height / lineData.length / 2 + ')' : 'translate(' + container.width / lineData.length / 2 + ', 0)';
            }).attr('pointer-events', 'none');
        }
    }
}

module.exports = jvCharts;

},{"../visuals/jvLine.js":18}],12:[function(require,module,exports){
'use strict';

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var jvCharts = require('../jvCharts.js');

jvCharts.prototype.bar = {
    paint: paint,
    setData: setData,
    getEventData: getEventData,
    highlightFromEventData: highlightFromEventData
};

jvCharts.prototype.generateBarThreshold = generateBarThreshold;
jvCharts.prototype.generateBars = generateBars;

/**paint
 *
 * The initial starting point for bar chart, begins the drawing process. Must already have the data stored in the chart
 * object
 */
function paint() {
    var transitionTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 800;

    var chart = this,

    //Uses the original data and then manipulates it based on any existing options
    dataObj = chart.getBarDataFromOptions();

    if (transitionTime || transitionTime === 0) {
        chart._vars.transitionTime = transitionTime;
    } else if (!chart._vars.transitionTime) {
        chart._vars.transitionTime = 800;
    }

    //assign current data which is used by all bar chart operations
    chart.currentData = dataObj;

    //generate svg dynamically based on legend data
    chart.generateSVG(dataObj.legendData);
    chart.generateXAxis(dataObj.xAxisData);
    chart.generateYAxis(dataObj.yAxisData);
    chart.generateLegend(dataObj.legendData, 'generateBars');
    chart.generateBars(dataObj);

    if (typeof dataObj.xAxisScale.ticks === 'function') {
        chart.formatXAxisLabels(dataObj.xAxisScale.ticks().length);
    } else {
        chart.formatXAxisLabels(dataObj.xAxisScale.domain().length);
    }
}

/**Sets the data for the bar chart prior to painting
 *  @function
 * @params {Object} data - Data passed into the chart
 * @params {Object} dataTable - Shows which data column is associated with each field in visual panel
 * @params {Object} dataTableKeys - Contains the data type for each column of data
 * @params {Object} colors - Colors object used to color the bars
 */
function setData() {
    var chart = this;
    //sort chart data if there is a sort type and label in the _vars
    if (chart._vars.hasOwnProperty('sortType') && chart._vars.sortType) {
        if (chart._vars.sortLabel && chart._vars.sortType !== 'default') {
            chart.organizeChartData(chart._vars.sortLabel, chart._vars.sortType);
        }
    }
    chart.data.legendData = setBarLineLegendData(chart.data);
    chart.data.xAxisData = chart.setAxisData('x', chart.data);
    chart.data.yAxisData = chart.setAxisData('y', chart.data);
    if (chart._vars.seriesFlipped) {
        chart.setFlippedSeries(chart.data.dataTableKeys);
        chart.flippedData.color = jvCharts.setChartColors(chart._vars.color, chart.flippedData.legendData, chart.colors);
    }

    //define color object for chartData
    chart.data.color = jvCharts.setChartColors(chart._vars.color, chart.data.legendData, chart.colors);
}

function getEventData(event) {
    var chart = this;
    if (event.target.classList.value.split('bar-col-')[1]) {
        return {
            data: _defineProperty({}, chart.currentData.dataTable.label, [event.target.classList.value.split('bar-col-')[1].replace(/_/g, ' ').replace(/_dot_/g, '.')]),
            node: event.target
        };
    } else if (event.target.classList.value.indexOf('bar-container') > -1) {
        return {
            data: {}
        };
    }
    return {
        data: false
    };
}

function highlightFromEventData(event) {
    var chart = this,
        label = event.data[chart.currentData.dataTable.label][0],
        cssClass = '.highlight-class-' + label.replace(/\s/g, '_').replace(/\./g, '_dot_'),
        node = chart.svg.selectAll(cssClass);

    chart.svg.select('.bar-container').selectAll('rect').attr('stroke', 0).attr('stroke-width', 0);
    //highlight necessary bars
    node.attr('stroke', chart._vars.highlightBorderColor).attr('stroke-width', chart._vars.highlightBorderWidth);
}

/**setBarLineLegendData
 *  gets legend info from chart Data
 *
 * @params data, type
 * @returns [] of legend text
 */
function setBarLineLegendData(data) {
    var legendArray = [];
    for (var item in data.dataTable) {
        if (data.dataTable.hasOwnProperty(item)) {
            if (item !== 'label' && item.indexOf('tooltip') === -1) {
                legendArray.push(data.dataTable[item]);
            }
        }
    }
    return legendArray;
}

/************************************************ Bar functions ******************************************************/
function generateBarThreshold() {
    var chart = this,
        svg = chart.svg,
        width = chart.config.container.width,
        height = chart.config.container.height,
        thresholds = chart._vars.thresholds,
        length = thresholds !== 'none' ? Object.keys(thresholds).length : 0,
        x = chart.currentData.xAxisScale,
        y = chart.currentData.yAxisScale;

    if (thresholds !== 'none') {
        var thresholdRects = void 0,
            threshold = void 0;
        for (var i = 0; i < length; i++) {
            threshold = thresholds[i];
            if (!chart._vars.xAxisThreshold) {
                if (chart._vars.rotateAxis) {
                    if (chart._vars.yMin === 'none') {
                        svg.append('line').style('stroke', threshold.thresholdColor).attr('x1', x(threshold.threshold)).attr('y1', 0).attr('x2', x(threshold.threshold)).attr('y2', height).attr('stroke-dasharray', '3, 3');
                    } else if (threshold.threshold > chart._vars.yMin) {
                        svg.append('line').style('stroke', threshold.thresholdColor).attr('x1', x(threshold.threshold)).attr('y1', 0).attr('x2', x(threshold.threshold)).attr('y2', height).attr('stroke-dasharray', '3, 3');
                    }
                } else if (chart._vars.yMin === 'none') {
                    svg.append('line').style('stroke', threshold.thresholdColor).attr('x1', 0).attr('y1', y(threshold.threshold)).attr('x2', width).attr('y2', y(threshold.threshold)).attr('stroke-dasharray', '3, 3');
                } else if (threshold.threshold > chart._vars.yMin) {
                    svg.append('line').style('stroke', threshold.thresholdColor).attr('x1', 0).attr('y1', y(threshold.threshold)).attr('x2', width).attr('y2', y(threshold.threshold)).attr('stroke-dasharray', '3, 3');
                }
            }

            if (chart._vars.colorChart == true) {
                thresholdRects = d3.selectAll('rect.rect-' + i);
                thresholdRects.attr('fill', threshold.thresholdColor);
            }
        }
    }
}

/**generateBars
 *
 * Does the actual painting of bars on the bar chart
 * @params barData
 */

function generateBars(barData) {
    var chart = this,
        svg = chart.svg,


    //Used to draw line that appears when tool tips are visible
    tipLineX = 0,
        tipLineWidth = 0,
        tipLineHeight = 0,
        tipLineY = 0,

    //Add logic to filter bardata
    dataHeaders = barData.legendData,
        bars,
        barDataNew,
        eventGroups;

    //Removes any existing bar containers and creates a new one
    svg.selectAll('g.bar-container').remove();

    bars = svg.append('g').attr('class', 'bar-container').selectAll('g');

    if (chart._vars.seriesFlipped && chart._vars.flippedLegendHeaders) {
        dataHeaders = chart._vars.flippedLegendHeaders;
    } else if (chart._vars.legendHeaders) {
        dataHeaders = chart._vars.legendHeaders;
    }

    chart._vars.legendHeaders = dataHeaders;

    barDataNew = jvCharts.getToggledData(barData, dataHeaders);

    generateBarGroups(bars, barDataNew, chart);

    eventGroups = jvCharts.generateEventGroups(bars, barDataNew, chart);

    //Add listeners

    eventGroups.on('mouseover', function (d, i, j) {
        //Transitions in D3 don't support the 'on' function They only exist on selections. So need to move that event listener above transition and after append
        if (chart.showToolTip) {
            //Get tip data
            var tipData = chart.setTipData(d, i),
                mouseItem = d3.select(this);

            //Draw tip line
            chart.tip.generateSimpleTip(tipData, chart.data.dataTable);
            chart.tip.d = d;
            chart.tip.i = i;
            svg.selectAll('.tip-line').remove();

            tipLineX = mouseItem.node().getBBox().x;
            tipLineWidth = mouseItem.node().getBBox().width;
            tipLineHeight = mouseItem.node().getBBox().height;
            tipLineY = mouseItem.node().getBBox().y;

            //Draw line in center of event-rect
            svg.append('line').attr('class', 'tip-line').attr('x1', function () {
                return chart._vars.rotateAxis ? 0 : tipLineX + tipLineWidth / 2;
            }).attr('x2', function () {
                return chart._vars.rotateAxis ? tipLineWidth : tipLineX + tipLineWidth / 2;
            }).attr('y1', function () {
                return chart._vars.rotateAxis ? tipLineY + tipLineHeight / 2 : 0;
            }).attr('y2', function () {
                return chart._vars.rotateAxis ? tipLineY + tipLineHeight / 2 : tipLineHeight;
            }).attr('fill', 'none').attr('shape-rendering', 'crispEdges').attr('stroke', 'black').attr('stroke-width', '1px');
        }
    }).on('mousemove', function (d, i) {
        if (chart.showToolTip) {
            if (chart.tip.d === d && chart.tip.i === i) {
                chart.tip.showTip();
            } else {
                //Get tip data
                var tipData = chart.setTipData(d, i);
                //Draw tip line
                chart.tip.generateSimpleTip(tipData, chart.data.dataTable);
            }
        }
    }).on('mouseout', function () {
        if (chart.showToolTip) {
            chart.tip.hideTip();
            svg.selectAll('line.tip-line').remove();
        }
    });

    chart.displayValues();
    chart.generateClipPath();
    chart.generateBarThreshold();
}

/**generateBarGroups
 *
 * Paints the groups of the bars
 * @params chartContainer, barData, chart
 */
function generateBarGroups(chartContainer, barData, chart) {
    var container = chart.config.container,
        xAxisData = chart.currentData.xAxisData,
        yAxisData = chart.currentData.yAxisData,
        colors = chart._vars.color,
        x = jvCharts.getAxisScale('x', xAxisData, container, chart._vars),
        y = jvCharts.getAxisScale('y', yAxisData, container, chart._vars),
        posCalc = jvCharts.getPosCalculations(barData, chart._vars, xAxisData, yAxisData, container, chart),
        dataToPlot = jvCharts.getPlotData(barData, chart),
        barGroups,
        externalCounterForJ,
        bars;

    if (xAxisData.dataType === 'STRING' || !xAxisData.hasOwnProperty('min')) {
        //Creates bar groups
        barGroups = chartContainer.data(dataToPlot).enter().append('g').attr('class', 'bar-group')
        //Translate the bar groups by (outer padding * step) and the width of the bars (container.width / barData.length * i)
        .attr('transform', function (d, i) {
            return 'translate(' + (x.paddingOuter() * x.step() + x.step() * i) + ' ,0)';
        });
    } else if (xAxisData.dataType === 'NUMBER') {
        //Creates bar groups
        barGroups = chartContainer.data(dataToPlot).enter().append('g').attr('class', 'bar-group')
        //Translate the bar groups by (outer padding * step) and the width of the bars (container.width / barData.length * i)
        .attr('transform', function (d, i) {
            return 'translate(0, ' + (y.paddingOuter() * y.step() + y.step() * i) + ' )';
        });
    }

    //Creates bars within bar groups
    externalCounterForJ = -1;
    bars = barGroups.selectAll('rect').data(function (d) {
        return d;
    }).enter().append('rect').attr('class', function (d, i) {
        var keys = Object.keys(barData[0]),
            filteredKeys = [],
            label = void 0,
            legendVal = void 0,
            thresholdDir = void 0;

        if (i === 0) {
            externalCounterForJ++;
        }

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = keys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var key = _step.value;

                if (key !== chart.currentData.dataTable.label) {
                    filteredKeys.push(key);
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                    _iterator.return();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }

        label = String(barData[externalCounterForJ][chart.currentData.dataTable.label]).replace(/\s/g, '_').replace(/\./g, '_dot_');
        legendVal = String(filteredKeys[i]).replace(/\s/g, '_').replace(/\./g, '_dot_');
        thresholdDir;

        if (chart._vars.xAxisThreshold) {
            thresholdDir = chart.setThreshold(barData[externalCounterForJ][chart.currentData.dataTable.label]);
        } else {
            thresholdDir = chart.setThreshold(d);
        }

        return 'editable editable-bar bar-col-' + label + '-index-' + legendVal + ' highlight-class-' + label + ' rect ' + thresholdDir;
    }).attr('x', function (d, i) {
        return posCalc.startx(d, i);
    }).attr('y', function (d, i) {
        return posCalc.starty(d, i);
    }).attr('width', function (d, i) {
        return posCalc.startwidth(d, i);
    }).attr('height', function (d, i) {
        return posCalc.startheight(d, i);
    }).attr('fill', function (d, i) {
        if (chart._vars.seriesFlipped) {
            return jvCharts.getColors(colors, i, chart._vars.flippedLegendHeaders[i]);
        }
        return jvCharts.getColors(colors, i, chart._vars.legendHeaders[i]);
    }).attr('rx', 0).attr('ry', 0).attr('opacity', 0.9).attr('clip-path', function (d) {
        return d > 30000000 ? 'url(#clip-above)' : 'url(#clip-below)';
    });
    if (chart._vars.transitionTime > 0) {
        bars.transition().duration(800).ease(d3.easePolyOut).attr('x', function (d, i, j) {
            return posCalc.x(d, i, j);
        }).attr('y', function (d, i, j) {
            return posCalc.y(d, i, j);
        }).attr('width', function (d, i) {
            return posCalc.width(d, i);
        }).attr('height', function (d, i) {
            return posCalc.height(d, i);
        });
    } else {
        bars.attr('x', function (d, i, j) {
            return posCalc.x(d, i, j);
        }).attr('y', function (d, i, j) {
            return posCalc.y(d, i, j);
        }).attr('width', function (d, i) {
            return posCalc.width(d, i);
        }).attr('height', function (d, i) {
            return posCalc.height(d, i);
        });
    }

    return barGroups; //returns the bar containers
}

module.exports = jvCharts;

},{"../jvCharts.js":4}],13:[function(require,module,exports){
'use strict';

var jvCharts = require('../jvCharts.js');

jvCharts.prototype.boxwhisker = {
    paint: paint,
    setData: setData,
    getEventData: getEventData
};

jvCharts.prototype.generateBoxes = generateBoxes;

/**setBoxData
 *  gets cloud data and adds it to the chart object
 *
 * @params data, dataTable, colors
 */
function setData() {
    var chart = this;
    chart.data.xAxisData = chart.setAxisData('x', chart.data, chart._vars);
    chart.data.yAxisData = chart.setAxisData('y', chart.data, chart._vars);
}

/** paintBoxChart
 *
 *  @desc The initial starting point for bar chart, begins the drawing process. Must already have the data stored in the chart object
 */
function paint(transitionTime) {
    var chart = this,
        dataObj,
        axisData;

    if (transitionTime || transitionTime === 0) {
        chart._vars.transitionTime = transitionTime;
    } else if (!chart._vars.transitionTime) {
        chart._vars.transitionTime = 800;
    }

    dataObj = getBoxDataFromOptions(chart);
    axisData = chart.getBarDataFromOptions();
    //assign current data which is used by all bar chart operations
    if (chart._vars.rotateAxis) {
        chart.currentData = dataObj;
    } else {
        chart.currentData = axisData;
    }
    //Overwrite any pre-existing zoom
    chart.config.zoomEvent = null;
    //generate svg dynamically based on legend data
    chart.generateSVG();
    chart.generateXAxis(axisData.xAxisData);
    chart.generateYAxis(axisData.yAxisData);

    chart.generateBoxes(dataObj);
}

function getEventData() {
    return {};
}

/** getBoxDataFromOptions
 *
 *  @desc Assigns the correct chart data to current data using the chart._vars
 */
function getBoxDataFromOptions(chart) {
    //creating these two data variables to avoid having to reference the chart object everytime
    var csv = chart.data.chartData,
        dataTable = chart.data.dataTable,
        min = Infinity,
        max = -Infinity,
        yAxis = [],
        dataObj = {},
        data = {},
        yAxisLabel = dataTable.label,
        xAxisLabel = dataTable.value,
        xAxisData,
        yAxisData,
        keys = csv.map(function (d) {
        return d[yAxisLabel];
    }),
        keys2 = csv.map(function (d) {
        return d[xAxisLabel];
    }),
        unique = keys.filter(function (item, i, ar) {
        return ar.indexOf(item) === i;
    }),
        temp = [];

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        var _loop = function _loop() {
            var uniqueEle = _step.value;

            var tempData = csv.filter(function (d) {
                return d[yAxisLabel] === uniqueEle;
            });
            temp.push([uniqueEle, tempData.map(function (d) {
                return d[xAxisLabel];
            })]);
        };

        for (var _iterator = unique[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            _loop();
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    max = Math.max.apply(Math, keys2);
    min = Math.min.apply(Math, keys2);
    yAxis.push(min);
    yAxis.push(max);

    xAxisData = { 'label': yAxisLabel, 'dataType': 'STRING', 'values': unique };
    yAxisData = { 'label': xAxisLabel, 'dataType': 'NUMBER', 'values': yAxis };

    dataObj.chartData = temp;
    dataObj.dataTable = data.dataTable;
    chart._vars.color = data.color;

    dataObj.xAxisData = xAxisData;
    dataObj.yAxisData = yAxisData;
    data = {
        yAxisData: dataObj.yAxisData,
        xAxisData: dataObj.xAxisData
    };

    if (chart._vars.rotateAxis) {
        dataObj.xAxisData = data.yAxisData;
        dataObj.yAxisData = data.xAxisData;
    } else {
        dataObj.xAxisData = data.xAxisData;
        dataObj.yAxisData = data.yAxisData;
    }

    return dataObj;
}

/** generateBars
 *
 * @desc Does the actual painting of bars on the bar chart
 * @params boxData
 */
function generateBoxes(boxData) {
    var chart = this,
        svg = chart.svg,
        options = chart._vars,
        container = chart.config.container,
        height = container.height,
        width = container.width,
        x,
        boxChart,
        margin = { top: 0, right: 50, bottom: 70, left: 50 };

    if (options.rotateAxis) {
        x = d3.scaleBand().domain(boxData.chartData.map(function (d) {
            return d[0];
        })).rangeRound([0, height]).paddingInner(0.7).paddingOuter(0.3);
        boxChart = box().whiskers(iqr(1.5)).height(width).domain([boxData.xAxisData.values[0], boxData.xAxisData.values[1]]).showLabels(options.displayValues).flipped(options.rotateAxis).duration(options.transitionTime).chart(chart);
    } else {
        x = d3.scaleBand().domain(boxData.chartData.map(function (d) {
            return d[0];
        })).rangeRound([0, width]).paddingInner(0.7).paddingOuter(0.3);
        boxChart = box().whiskers(iqr(1.5)).height(height).domain([boxData.yAxisData.values[0], boxData.yAxisData.values[1]]).showLabels(options.displayValues).flipped(options.rotateAxis).duration(options.transitionTime).chart(chart);
    }
    //draw the boxplots
    svg.attr('class', 'boxwhisker-container').selectAll('.box').data(boxData.chartData).enter().append('g').attr('class', 'box-container').attr('style', 'pointer-events: all;').attr('transform', function (d) {
        return options.rotateAxis ? 'translate(' + margin.top + ', ' + x(d[0]) + ')' : 'translate(' + x(d[0]) + ', ' + margin.top + ')';
    }).call(boxChart.width(x.bandwidth()));

    d3.selectAll('rect.box').attr('class', function (d, i) {
        return 'editable editable-box box-' + i + ' highlight-class-' + i + 'box';
    });
    hideLabelsOnOverlap(x, width, svg);
}

/**
 * @name hideLabelsOnOverlap
 * @desc determines if text on graph should be displayed or not
 */
function hideLabelsOnOverlap(x, width, svg) {
    var numSpacesBetween = x.domain().length - 1,
        totalBoxWidth = x.bandwidth() * x.domain().length,
        widthOfSpaces = (width - totalBoxWidth) / numSpacesBetween,
        xAxisLabelLengthLimit = x.bandwidth() + widthOfSpaces,
        ticks = svg.selectAll('.xAxis text');

    ticks.each(function () {
        if (this.getBBox().width > xAxisLabelLengthLimit) {
            svg.selectAll('.xAxis text').attr('style', 'display:none');
            svg.selectAll('text.box').attr('style', 'display:none');
            svg.selectAll('text.whisker').attr('style', 'display:none');
        }
    });
}

/**
 * @name iqr
 * @desc Returns a function to compute the interquartile range.
 */
function iqr(k) {
    return function (d, i) {
        var q1 = d.quartiles[0],
            q3 = d.quartiles[2],
            iqr = (q3 - q1) * k,
            i = -1,
            j = d.length;
        while (d[++i] < q1 - iqr) {}
        while (d[--j] > q3 + iqr) {}
        return [i, j];
    };
}

//Inspired by http://informationandvisualization.de/blog/box-plot
var box = function box() {
    var width = 1,
        height = 1,
        duration = 0,
        domain = null,
        value = Number,
        whiskers = boxWhiskers,
        quartiles = boxQuartiles,
        showLabels = true,
        //whether or not to show text labels
    numBars = 4,
        curBar = 1,
        tickFormat = null,
        chart = {},
        flipped = false;

    //For each small multiple…
    function box(g) {
        g.each(function (data, i) {
            var d = data[1].sort(d3.ascending);
            var g = d3.select(this),
                n = d.length,
                min = d[0],
                max = d[n - 1],
                outlierLabel = data[0];

            //Compute quartiles. Must return exactly 3 elements.
            var quartileData = d.quartiles = quartiles(d);

            //Compute whiskers. Must return exactly 2 elements, or null.
            var whiskerIndices = whiskers && whiskers.call(this, d, i),
                whiskerData = whiskerIndices && whiskerIndices.map(function (i) {
                return d[i];
            });

            //Compute outliers. If no whiskers are specified, all data are 'outliers'.
            //We compute the outliers as indices, so that we can join across transitions!
            var outlierIndices = whiskerIndices ? d3.range(0, whiskerIndices[0]).concat(d3.range(whiskerIndices[1] + 1, n)) : d3.range(n);

            //Compute the new x-scale.
            if (flipped) {
                var x1 = d3.scaleLinear().domain(domain && domain.call(this, d, i) || [min, max]).range([0, height]);
            } else {
                var x1 = d3.scaleLinear().domain(domain && domain.call(this, d, i) || [min, max]).range([height, 0]);
            }

            //Retrieve the old x-scale, if this is an update.
            var x0 = this.__chart__ || d3.scaleLinear().domain([0, Infinity])
            //.domain([0, max])
            .range(x1.range());

            //Stash the new scale.
            this.__chart__ = x1;

            //Note: the box, median, and box tick elements are fixed in number,
            //so we only have to handle enter and update. In contrast, the outliers
            //and other elements are variable, so we need to exit them! Variable
            //elements also fade in and out.

            //Update outliers.
            var outlier = g.selectAll('circle.outlier').data(outlierIndices, Number);

            outlier = outlier.enter().append('g');

            if (flipped) {
                outlier.insert('circle', 'text').attr('class', 'outlier').attr('fill', 'white').attr('r', function () {
                    if (width > 10) {
                        return 5;
                    }

                    return width / 2;
                }).attr('cy', width / 2).attr('cx', function (i) {
                    return x0(d[i]);
                }).style('opacity', 1e-6).transition().duration(duration).attr('cx', function (i) {
                    return x1(d[i]);
                }).style('opacity', 1);

                outlier.append('text').text(function (i) {
                    return d[i];
                }).attr('y', width / 2 + 7).attr('x', function (i) {
                    return x1(d[i]) + 4;
                }).attr('class', 'outlier-label').attr('font-size', '10px').attr('style', function () {
                    if (!showLabels) {
                        return 'display:none;';
                    }

                    return '';
                });
                outlier.exit().transition().duration(duration).attr('cx', function (i) {
                    return x1(d[i]);
                }).style('opacity', 1e-6).remove();
            } else {
                outlier.insert('circle', 'text').attr('class', 'outlier').attr('fill', 'white').attr('r', function () {
                    if (width > 10) {
                        return 5;
                    }

                    return width / 2;
                }).attr('cx', width / 2).attr('cy', function (i) {
                    return x0(d[i]);
                }).style('opacity', 1e-6).transition().duration(duration).attr('cy', function (i) {
                    return x1(d[i]);
                }).style('opacity', 1);

                outlier.append('text').text(function (i) {
                    return d[i];
                }).attr('x', width / 2 + 7).attr('y', function (i) {
                    return x1(d[i]) + 4;
                }).attr('class', 'outlier-label').attr('font-size', '10px').attr('style', function () {
                    if (!showLabels) {
                        return 'display:none;';
                    }

                    return '';
                });

                outlier.transition().duration(duration).attr('cy', function (i) {
                    return x1(d[i]);
                }).style('opacity', 1);

                outlier.exit().transition().duration(duration).attr('cy', function (i) {
                    return x1(d[i]);
                }).style('opacity', 1e-6).remove();
            }

            outlier.on('mouseover', function (i) {
                if (chart.showToolTip) {
                    var _outlier = [d[i]];
                    var _data = { Outlier: _outlier, Label: outlierLabel };
                    var tipData = chart.setTipData(_data, i);

                    chart.tip.generateSimpleTip(tipData, _data);
                    chart.tip.d = d.data;
                    chart.tip.i = i;
                }
            }).on('mousemove', function (i) {
                if (chart.showToolTip) {
                    var _outlier2 = [d[i]];
                    var _data2 = { Outlier: _outlier2, Label: outlierLabel };
                    var tipData = chart.setTipData(_data2, i);

                    chart.tip.generateSimpleTip(tipData, _data2);
                    chart.tip.d = d.data;
                    chart.tip.i = i;
                }
            }).on('mouseout', function () {
                if (chart.showToolTip) {
                    chart.tip.hideTip();
                }
            });

            //set separate tooltips for quartiles and whiskers
            g = g.append('g').attr('class', 'inner-box-container').on('mouseover', function (label) {
                if (chart.showToolTip) {
                    var _data3 = {
                        Quartiles: d.quartiles,
                        Whiskers: whiskerData,
                        Label: label[0]
                    };
                    var tipData = chart.setTipData(_data3, i);

                    chart.tip.generateSimpleTip(tipData, _data3);
                    chart.tip.d = d.data;
                    chart.tip.i = i;
                }
            }).on('mousemove', function (label) {
                if (chart.showToolTip) {
                    var _data4 = {
                        Quartiles: d.quartiles,
                        Whiskers: whiskerData,
                        Label: label[0]
                    };
                    var tipData = chart.setTipData(_data4, i);

                    chart.tip.generateSimpleTip(tipData, _data4);
                    chart.tip.d = d.data;
                    chart.tip.i = i;
                }
            }).on('mouseleave', function () {
                if (chart.showToolTip) {
                    chart.tip.hideTip();
                }
            });

            //Update center line: the vertical line spanning the whiskers.
            var center = g.selectAll('line.center').data(whiskerData ? [whiskerData] : []);
            //vertical line
            if (flipped) {
                center.enter().insert('line', 'rect').attr('class', 'center').attr('y1', width / 2).attr('x1', function (d) {
                    return x0(d[0]);
                }).attr('y2', width / 2).attr('x2', function (d) {
                    return x0(d[1]);
                }).style('opacity', 1e-6).transition().duration(duration).style('opacity', 1).attr('x1', function (d) {
                    return x1(d[0]);
                }).attr('x2', function (d) {
                    return x1(d[1]);
                });

                center.transition().duration(duration).style('opacity', 1).attr('x1', function (d) {
                    return x1(d[0]);
                }).attr('x2', function (d) {
                    return x1(d[1]);
                });

                center.exit().transition().duration(duration).style('opacity', 1e-6).attr('x1', function (d) {
                    return x1(d[0]);
                }).attr('x2', function (d) {
                    return x1(d[1]);
                }).remove();
            } else {
                center.enter().insert('line', 'rect').attr('class', 'center').attr('x1', width / 2).attr('y1', function (d) {
                    return x0(d[0]);
                }).attr('x2', width / 2).attr('y2', function (d) {
                    return x0(d[1]);
                }).style('opacity', 1e-6).transition().duration(duration).style('opacity', 1).attr('y1', function (d) {
                    return x1(d[0]);
                }).attr('y2', function (d) {
                    return x1(d[1]);
                });

                center.transition().duration(duration).style('opacity', 1).attr('y1', function (d) {
                    return x1(d[0]);
                }).attr('y2', function (d) {
                    return x1(d[1]);
                });

                center.exit().transition().duration(duration).style('opacity', 1e-6).attr('y1', function (d) {
                    return x1(d[0]);
                }).attr('y2', function (d) {
                    return x1(d[1]);
                }).remove();
            }

            var hoverArea = g.selectAll('line.hover-area').data(whiskerData ? [whiskerData] : []);
            //vertical line
            if (flipped) {
                hoverArea.enter().insert('line', 'rect').attr('class', 'hover-area').attr('y1', width / 2).attr('x1', function (d) {
                    return x0(d[0]);
                }).attr('y2', width / 2).attr('x2', function (d) {
                    return x0(d[1]);
                }).style('opacity', 0).style('stroke-width', width).transition().duration(duration).style('opacity', 0).attr('x1', function (d) {
                    return x1(d[0]);
                }).attr('x2', function (d) {
                    return x1(d[1]);
                });

                hoverArea.transition().duration(duration).style('opacity', 0).attr('x1', function (d) {
                    return x1(d[0]);
                }).attr('x2', function (d) {
                    return x1(d[1]);
                });

                hoverArea.exit().transition().duration(duration).style('opacity', 0).attr('x1', function (d) {
                    return x1(d[0]);
                }).attr('x2', function (d) {
                    return x1(d[1]);
                }).remove();
            } else {
                hoverArea.enter().insert('line', 'rect').attr('class', 'hover-area').attr('x1', width / 2).attr('y1', function (d) {
                    return x0(d[0]);
                }).attr('x2', width / 2).attr('y2', function (d) {
                    return x0(d[1]);
                }).style('opacity', 0).style('stroke-width', width).transition().duration(duration).style('opacity', 0).attr('y1', function (d) {
                    return x1(d[0]);
                }).attr('y2', function (d) {
                    return x1(d[1]);
                });

                hoverArea.transition().duration(duration).style('opacity', 0).attr('y1', function (d) {
                    return x1(d[0]);
                }).attr('y2', function (d) {
                    return x1(d[1]);
                });

                hoverArea.exit().transition().duration(duration).style('opacity', 0).attr('y1', function (d) {
                    return x1(d[0]);
                }).attr('y2', function (d) {
                    return x1(d[1]);
                }).remove();
            }
            //Update innerquartile box.
            var box = g.selectAll('rect.box').data([quartileData]);
            if (flipped) {
                box.enter().append('rect').attr('fill', 'steelblue').attr('class', 'box').attr('y', 0).attr('x', function (d) {
                    return x0(d[2]) - Math.abs(x0(d[0]) - x0(d[2]));
                }).attr('height', width).attr('width', function (d) {
                    return Math.abs(x0(d[0]) - x0(d[2]));
                }).transition().duration(duration).attr('x', function (d) {
                    return x1(d[2]) - Math.abs(x1(d[0]) - x1(d[2]));
                }).attr('width', function (d) {
                    return Math.abs(x1(d[0]) - x1(d[2]));
                });

                box.transition().duration(duration).attr('x', function (d) {
                    return x1(d[2]) - Math.abs(x1(d[0]) - x1(d[2]));
                }).attr('width', function (d) {
                    return Math.abs(x1(d[0]) - x1(d[2]));
                });
            } else {
                box.enter().append('rect').attr('fill', 'steelblue').attr('class', 'box').attr('x', 0).attr('y', function (d) {
                    return x0(d[2]);
                }).attr('width', width).attr('height', function (d) {
                    return x0(d[0]) - x0(d[2]);
                }).transition().duration(duration).attr('y', function (d) {
                    return x1(d[2]);
                }).attr('height', function (d) {
                    return x1(d[0]) - x1(d[2]);
                });

                box.transition().duration(duration).attr('y', function (d) {
                    return x1(d[2]);
                }).attr('height', function (d) {
                    return x1(d[0]) - x1(d[2]);
                });
            }
            //Update median line.
            var medianLine = g.selectAll('line.median').data([quartileData[1]]);
            if (flipped) {
                medianLine.enter().append('line').attr('class', 'median').attr('y1', 0).attr('x1', x0).attr('y2', width).attr('x2', x0).transition().duration(duration).attr('x1', x1).attr('x2', x1);

                medianLine.transition().duration(duration).attr('x1', x1).attr('x2', x1);
            } else {
                medianLine.enter().append('line').attr('class', 'median').attr('x1', 0).attr('y1', x0).attr('x2', width).attr('y2', x0).transition().duration(duration).attr('y1', x1).attr('y2', x1);

                medianLine.transition().duration(duration).attr('y1', x1).attr('y2', x1);
            }
            //Update whiskers.
            var whisker = g.selectAll('line.whisker').data(whiskerData || []);
            if (flipped) {
                whisker.enter().insert('line', 'circle, text').attr('class', 'whisker').attr('y1', 0).attr('x1', x0).attr('y2', 0 + width).attr('x2', x0).style('opacity', 1e-6).transition().duration(duration).attr('x1', x1).attr('x2', x1).style('opacity', 1);

                whisker.transition().duration(duration).attr('x1', x1).attr('x2', x1).style('opacity', 1);

                whisker.exit().transition().duration(duration).attr('x1', x1).attr('x2', x1).style('opacity', 1e-6).remove();
            } else {
                whisker.enter().insert('line', 'circle, text').attr('class', 'whisker').attr('x1', 0).attr('y1', x0).attr('x2', 0 + width).attr('y2', x0).style('opacity', 1e-6).transition().duration(duration).attr('y1', x1).attr('y2', x1).style('opacity', 1);

                whisker.transition().duration(duration).attr('y1', x1).attr('y2', x1).style('opacity', 1);

                whisker.exit().transition().duration(duration).attr('y1', x1).attr('y2', x1).style('opacity', 1e-6).remove();
            }
            //Compute the tick format.
            var format = tickFormat || x1.tickFormat(8);

            //Update box ticks.
            var boxTick = g.selectAll('text.box').data(quartileData);

            if (flipped) {
                boxTick.enter().append('text').attr('class', 'box').attr('dx', '.3em').attr('dy', function (d, i) {
                    return i & 1 ? 6 : -6;
                }).attr('y', function (d, i) {
                    return i & 1 ? +width : 0;
                }).attr('x', x0).attr('text-anchor', function (d, i) {
                    return i & 1 ? 'start' : 'end';
                }).attr('style', function () {
                    if (!showLabels) {
                        return 'display: none;';
                    }
                }).text(format).transition().duration(duration).attr('x', x1);

                boxTick.transition().duration(duration).text(format).attr('x', x1);
            } else {
                boxTick.enter().append('text').attr('class', 'box').attr('dy', '.3em').attr('dx', function (d, i) {
                    return i & 1 ? 6 : -6;
                }).attr('x', function (d, i) {
                    return i & 1 ? +width : 0;
                }).attr('y', x0).attr('text-anchor', function (d, i) {
                    return i & 1 ? 'start' : 'end';
                }).attr('style', function () {
                    if (!showLabels) {
                        return 'display: none;';
                    }
                }).text(format).transition().duration(duration).attr('y', x1);

                boxTick.transition().duration(duration).text(format).attr('y', x1);
            }
            //Update whisker ticks. These are handled separately from the box
            //ticks because they may or may not exist, and we want don't want
            //to join box ticks pre-transition with whisker ticks post-.
            var whiskerTick = g.selectAll('text.whisker').data(whiskerData || []);

            if (flipped) {
                whiskerTick.enter().append('text').attr('class', 'whisker').attr('dx', '.3em').attr('dy', 6).attr('y', width).attr('x', x0).attr('style', function () {
                    if (!showLabels) {
                        return 'display:none;';
                    }
                }).text(format).style('opacity', 1e-6).transition().duration(duration).attr('x', x1).style('opacity', 1);

                whiskerTick.transition().duration(duration).text(format).attr('x', x1).style('opacity', 1);

                whiskerTick.exit().transition().duration(duration).attr('x', x1).style('opacity', 1e-6).remove();
            } else {
                whiskerTick.enter().append('text').attr('class', 'whisker').attr('dy', '.3em').attr('dx', 6).attr('x', width).attr('y', x0).attr('style', function () {
                    if (!showLabels) {
                        return 'display:none;';
                    }
                }).text(format).style('opacity', 1e-6).transition().duration(duration).attr('y', x1).style('opacity', 1);

                whiskerTick.transition().duration(duration).text(format).attr('y', x1).style('opacity', 1);

                whiskerTick.exit().transition().duration(duration).attr('y', x1).style('opacity', 1e-6).remove();
            }
        });
        //d3.timer.flush();
        d3.timerFlush();
    }

    box.width = function (x) {
        if (!arguments.length) return width;
        width = x;
        return box;
    };

    box.height = function (x) {
        if (!arguments.length) return height;
        height = x;
        return box;
    };

    box.tickFormat = function (x) {
        if (!arguments.length) return tickFormat;
        tickFormat = x;
        return box;
    };

    box.duration = function (x) {
        if (!arguments.length) return duration;
        duration = x;
        return box;
    };

    function constant(x) {
        return function () {
            return x;
        };
    }
    box.domain = function (x) {
        if (!arguments.length) return domain;
        //domain = x == null ? x : d3.functor(x);
        domain = x == null ? x : constant(x);

        return box;
    };

    box.value = function (x) {
        if (!arguments.length) return value;
        value = x;
        return box;
    };

    box.whiskers = function (x) {
        if (!arguments.length) return whiskers;
        whiskers = x;
        return box;
    };

    box.showLabels = function (x) {
        if (!arguments.length) return showLabels;
        showLabels = x;
        return box;
    };

    box.flipped = function (x) {
        if (!arguments.length) return flipped;
        flipped = x;
        return box;
    };

    box.chart = function (x) {
        if (!arguments.length) return chart;
        chart = x;
        return box;
    };

    box.quartiles = function (x) {
        if (!arguments.length) return quartiles;
        quartiles = x;
        return box;
    };

    return box;
};

function boxWhiskers(d) {
    return [0, d.length - 1];
}

function boxQuartiles(d) {
    return [d3.quantile(d, 0.25), d3.quantile(d, 0.5), d3.quantile(d, 0.75)];
}

module.exports = jvCharts;

},{"../jvCharts.js":4}],14:[function(require,module,exports){
'use strict';

var jvCharts = require('../jvCharts.js');

jvCharts.prototype.bubble = {
    paint: paint,
    setData: setData,
    getEventData: getEventData
};

jvCharts.prototype.generateBubble = generateBubble;

/************************************************ Bubble functions ******************************************************/

function paint(transitionTime) {
    var chart = this,
        bubbleMargins = {
        top: 15,
        right: 15,
        left: 15,
        bottom: 15
    };
    if (transitionTime || transitionTime === 0) {
        chart._vars.transitionTime = transitionTime;
    } else if (!chart._vars.transitionTime) {
        chart._vars.transitionTime = 800;
    }
    if (!chart.smallerFontRepaint) {
        chart._vars.fontSizeMax = 80;
        chart.currentData = chart.data;
    } else {
        chart.currentData = JSON.parse(JSON.stringify(chart.data));
    }

    chart._vars.color = chart.data.color;

    //Generate SVG-legend data is used to determine the size of the bottom margin (set to null for no legend)
    chart.generateSVG(null, bubbleMargins);
    chart.generateVerticalLegend('generateBubble');
    chart.generateBubble(chart.currentData);
}

/**setData
 *  gets Bubble data and adds it to the chart object
 *
 * @params data, dataTable, colors
 */
function setData() {
    var chart = this;
    //define color object for chartData
    chart.data.legendData = setBubbleLegendData(chart.data);
    chart.data.color = jvCharts.setChartColors(chart._vars.color, chart.data.legendData, chart.colors);
}

function getEventData() {
    return {};
}

/**setBubbleLegendData
 *  gets legend info from chart Data
 *
 * @params data, type
 * @returns [] of legend text
 */
function setBubbleLegendData(data) {
    var legendArray = [],
        item = data.dataTable.label;

    for (var value in data.chartData) {
        if (data.chartData.hasOwnProperty(value)) {
            var legendElement = data.chartData[value][item];
            if (legendArray.indexOf(legendElement) === -1) {
                legendArray.push(legendElement);
            }
        }
    }

    return legendArray;
}

/** generateBubble
 *
 * paints the bubble  on the chart
 * @params bubble Data
 */
function generateBubble(bubbleData) {
    var chart = this,
        svg = chart.svg,
        container = chart.config.container,
        width = container.width,
        height = container.height,
        pack = d3.pack().size([width, height]).padding(1.5),
        legendData = chart.data.legendData,
        valueKey = chart.data.dataTable.value,
        labelKey = chart.data.dataTable.label,
        colors = chart._vars.color,
        dataHeaders,
        bubbleDataNew,
        legendElementToggleArray,
        root,
        bubble;

    if (!chart._vars.legendHeaders) {
        chart._vars.legendHeaders = legendData;
    }
    dataHeaders = chart._vars.legendHeaders;
    if (!chart._vars.legendHeaders) {
        chart._vars.legendHeaders = legendData;
    }
    bubbleDataNew = jvCharts.getToggledData(bubbleData, dataHeaders);
    legendElementToggleArray = jvCharts.getLegendElementToggleArray(dataHeaders, legendData);

    if (legendElementToggleArray) {
        for (var j = 0; j < bubbleDataNew.length; j++) {
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = legendElementToggleArray[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var legendEle = _step.value;

                    if (legendEle.element === bubbleDataNew[j][labelKey] && legendEle.toggle === false) {
                        bubbleDataNew.splice(j, 1);
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
        }
    }
    svg.selectAll('.bubble').remove();
    //assigns the data to a hierarchy using parent-child relationships
    root = d3.hierarchy({ children: bubbleDataNew }).sum(function (d) {
        return d[valueKey];
    });

    bubble = svg.selectAll('.bubble').data(pack(root).leaves()).enter().append('g').attr('class', 'bubble').attr('transform', function (d) {
        return 'translate(' + d.x + ',' + d.y + ')';
    });

    bubble.append('circle').attr('fill', function (d) {
        return jvCharts.getColors(colors, legendData.indexOf(d.data[labelKey]), d.data[labelKey]);
    }).attr('class', function (d, i) {
        return 'editable editable-bubble bubble-' + i + ' highlight-class-' + i;
    }).attr('r', function (d) {
        return d.r;
    }).on('mouseover', function (d, i) {
        if (chart.showToolTip) {
            //Get tip data
            var tipData = chart.setTipData(d.data, i);
            //Draw tip line
            tipData.data.color = jvCharts.getColors(colors, tipData.index, d.data[labelKey]);
            chart.tip.generateSimpleTip(tipData, chart.data.dataTable);
            chart.tip.d = d.data;
            chart.tip.i = i;
        }
    }).on('mousemove', function (d, i) {
        if (chart.showToolTip) {
            if (chart.tip.d === d && chart.tip.i === i) {
                chart.tip.showTip(0);
            } else {
                //Get tip data
                var tipData = chart.setTipData(d.data, i);
                //Draw tip line
                chart.tip.generateSimpleTip(tipData, chart.data.dataTable);
            }
        }
    }).on('mouseout', function (d) {
        if (chart.showToolTip) {
            chart.tip.hideTip();
        }
    });

    bubble.append('text').attr('class', 'bubble-text').text(function (d) {
        return d.data[labelKey];
    }).attr('fill', 'white')
    //hide text if its too wide
    .attr('style', function (d) {
        if (this.clientWidth > d.r * 2) {
            return 'display: none';
        }
        return '';
    })
    //center the text on the bubble
    .attr('transform', function (d) {
        var diameter = d.r * 2,
            textWidth = this.clientWidth,
            emptySpace = diameter - textWidth;

        if (emptySpace < 0) {
            return '';
        }
        return 'translate(-' + (d.r - emptySpace / 2) + ', 0)';
    }).on('mouseover', function (d, i) {
        if (chart.showToolTip) {
            //Get tip data
            var tipData = chart.setTipData(d.data, i);

            //Draw tip line
            tipData.data.color = jvCharts.getColors(colors, tipData.index, d.data[labelKey]);
            chart.tip.generateSimpleTip(tipData, chart.data.dataTable);
            chart.tip.d = d.data;
            chart.tip.i = i;
        }
    }).on('mousemove', function (d, i) {
        if (chart.showToolTip) {
            if (chart.tip.d === d && chart.tip.i === i) {
                chart.tip.showTip(0);
            } else {
                //Get tip data
                var tipData = chart.setTipData(d.data, i);
                //Draw tip line
                chart.tip.generateSimpleTip(tipData, chart.data.dataTable);
            }
        }
    }).on('mouseout', function () {
        if (chart.showToolTip) {
            chart.tip.hideTip();
        }
    });

    bubble.append('text').text(function (d) {
        return d.data[valueKey];
    }).attr('fill', 'white')
    //hide text if its too wide
    .attr('style', function (d) {
        if (this.clientWidth > d.r * 2) {
            return 'display: none';
        }
        return '';
    })
    //center the text on the bubble
    .attr('transform', function (d) {
        var diameter = d.r * 2,
            textWidth = this.clientWidth,
            emptySpace = diameter - textWidth;

        if (emptySpace < 0) {
            return '';
        }
        return 'translate(-' + (d.r - emptySpace / 2) + ', 15)';
    }).on('mouseover', function (d, i) {
        if (chart.showToolTip) {
            //Get tip data
            var tipData = chart.setTipData(d.data, i);

            //Draw tip line
            tipData.data.color = jvCharts.getColors(colors, tipData.index, d.data[labelKey]);
            chart.tip.generateSimpleTip(tipData, chart.data.dataTable);
            chart.tip.d = d.data;
            chart.tip.i = i;
        }
    }).on('mousemove', function (d, i) {
        if (chart.showToolTip) {
            if (chart.tip.d === d && chart.tip.i === i) {
                chart.tip.showTip(0);
            } else {
                //Get tip data
                var tipData = chart.setTipData(d.data, i);
                //Draw tip line
                chart.tip.generateSimpleTip(tipData, chart.data.dataTable);
            }
        }
    }).on('mouseout', function () {
        if (chart.showToolTip) {
            chart.tip.hideTip();
        }
    });
}

module.exports = jvCharts;

},{"../jvCharts.js":4}],15:[function(require,module,exports){
'use strict';

var jvCharts = require('../jvCharts.js');

jvCharts.prototype.clustergram = {
    paint: paint,
    setData: setData,
    getEventData: null
};

jvCharts.prototype.generateClustergram = generateClustergram;

/************************************************ Clustergram functions ******************************************************/

/**setClustergramData
 *  gets heatmap data and adds it to the chart object
 *
 * @params data, dataTable, colors
 */
function setData() {
    var chart = this,
        leftTreeData = chart.data.chartData[0],
        rightTreeData = chart.data.chartData[1];

    chart.leftLabels = {};
    chart.leftLabels.values = [];
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = leftTreeData.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var leftEle = _step.value;

            if (leftEle.name) {
                chart.leftLabels.values.push(leftEle.name);
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    chart.rightLabels = {};
    chart.rightLabels.values = [];
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
        for (var _iterator2 = rightTreeData.children[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var rightEle = _step2.value;

            if (rightEle.name) {
                chart.rightLabels.values.push(rightEle.name);
            }
        }
    } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
            }
        } finally {
            if (_didIteratorError2) {
                throw _iteratorError2;
            }
        }
    }

    chart.leftLeaves = getLeafNodes([leftTreeData]);
    chart.rightLeaves = getLeafNodes([rightTreeData]);
}

function getLeafNodes(nodes) {
    var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

    var returnData = result;
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
        for (var _iterator3 = nodes[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var node = _step3.value;

            if (node.children.length === 0) {
                returnData.push(node.name);
            } else {
                returnData = getLeafNodes(node.children, returnData);
            }
        }
    } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
            }
        } finally {
            if (_didIteratorError3) {
                throw _iteratorError3;
            }
        }
    }

    return returnData;
}

function paint() {
    var chart = this,
        customMargin = {
        top: 20,
        right: 40,
        left: 0,
        bottom: 20
    };
    chart._vars.color = chart.data.color;
    chart.currentData = chart.data; //Might have to move into method bc of reference/value relationship

    //Generate SVG-legend data is used to determine the size of the bottom margin (set to null for no legend)
    chart.generateSVG(null, customMargin);
    //chart.generateLegend(chart.currentData.legendData, 'generateClustergram');
    chart.generateClustergram();
}

/**generateClustergram
 *
 * paints the Clustergram on the chart
 * @params ClustergramData
 */
function generateClustergram() {
    var chart = this,
        svg = chart.svg,
        container = chart.config.container,
        leftTreeData = chart.data.chartData[0],
        rightTreeData = chart.data.chartData[1],
        gridData = chart.data.chartData[2],
        sizeWidth = chart.rightLeaves.length * 20,
        sizeHeight = chart.leftLeaves.length * 20,
        vis,
        leftG,
        bottomG,
        heatG,
        newWidth,
        newHeight,
        leftChildCount,
        rightChildCount;

    chart.data.yAxisData = [];
    chart.data.xAxisData = [];

    if (sizeWidth < container.width) {
        sizeWidth = container.width;
    }

    if (sizeHeight < container.height) {
        sizeHeight = container.height;
    }

    //remove svg elements
    svg.selectAll('*').remove();

    vis = svg.append('g').attr('transform', 'translate(0, 0)').attr('class', 'heatmap');
    leftG = vis.append('g').attr('id', 'left-tree');
    bottomG = vis.append('g').attr('id', 'bottom-tree');
    heatG = vis.append('g').attr('class', 'clustergram-container').attr('id', 'heat');

    d3.select('body').append('div').attr('class', 'tooltip').style('opacity', 0);
    //calc new width and height
    newWidth = sizeWidth / 2;
    newHeight = sizeHeight / 2;

    leftChildCount = buildTree(leftTreeData, chart.data.yAxisData, leftG, newHeight, newWidth, 'left');
    rightChildCount = buildTree(rightTreeData, chart.data.xAxisData, bottomG, newHeight, newWidth, 'right');
    buildHeat(chart, gridData, heatG, newHeight, newWidth, leftChildCount, rightChildCount);

    chart.zoomed = function () {
        return svg.attr('transform', d3.event.transform);
    };
    chart.chartDiv.select('.editable-svg').call(d3.zoom().on('zoom', chart.zoomed));

    //align G tags
    chart._vars.leftTreeWidth = leftG.node().getBBox().width;
    chart._vars.topTreeHeight = bottomG.node().getBBox().height;
    leftG.attr('transform', 'translate(' + 0 + ',' + chart._vars.topTreeHeight + ')');
    bottomG.attr('transform', 'translate(' + chart._vars.leftTreeWidth + ',' + 0 + ')');
    heatG.attr('transform', 'translate(' + chart._vars.leftTreeWidth + ',' + chart._vars.topTreeHeight + ')');

    chart.config.container.height = heatG.node().getBBox().height;
    chart.config.container.width = heatG.node().getBBox().width;
}

function findPath(child) {
    var str = '';
    var childNode = child;
    while (childNode.parent) {
        str += childNode.data.name + '.';
        childNode = childNode.parent;
    }
    return str.slice(0, -1);
}

function buildTree(data, axisData, gEle, newHeight, newWidth, sideOfTree) {
    var makeTree,
        root,
        childCount = 0;

    makeTree = d3.cluster().size(sideOfTree === 'left' ? [newHeight, newWidth] : [newWidth, newHeight]);

    root = d3.hierarchy(data);
    makeTree(root);

    gEle.selectAll('.cluster-link').data(root.descendants().slice(1)).enter().append('path').attr('class', 'cluster-link').style('fill', 'none').style('stroke', 'black').attr('d', function (d) {
        if (sideOfTree === 'left') {
            return 'M' + d.y / 8 + ',' + d.x + 'V' + d.parent.x + 'H' + d.parent.y / 8;
        }
        return 'M' + d.x + ',' + d.y / 8 + 'V' + d.parent.y / 8 + 'H' + d.parent.x;
    });

    gEle.selectAll('.cluster-node').data(root.descendants()).enter().append('g').attr('class', function (d) {
        return 'cluster-node ' + (d.children ? 'cluster-node--internal' : 'cluster-node--leaf');
    }).attr('transform', function (d) {
        if (sideOfTree === 'left') {
            return 'translate(' + d.y / 8 + ', ' + d.x + ')';
        }
        return 'translate(' + d.x + ', ' + d.y / 8 + ')rotate(15)';
    });

    if (sideOfTree === 'left') {
        gEle.selectAll('.cluster-node').append('text').attr('dy', 3).attr('x', function (d) {
            return d.children ? -8 : 0;
        }).style('text-anchor', 'end').text(function (d) {
            if (!d.children) {
                childCount++;
                axisData.push(findPath(d));
            }
            //return d.data.name;
            if (d.data.name === 'root') {
                return '';
            }
            return d.children ? d.data.name.replace(/_/g, ' ') : '';
        });
        gEle.selectAll('.cluster-node').append('line').style('stroke', 'black').attr('x1', function (d) {
            return d.children ? 0 : 0;
        }).attr('x2', function (d) {
            return d.children ? 0 : 15;
        });
    } else if (sideOfTree === 'right') {
        gEle.selectAll('.cluster-node').append('text').attr('dy', 8).style('text-anchor', function (d) {
            return d.children ? 'end' : 'start';
        }).attr('y', function (d) {
            return d.children ? -8 : 8;
        }).text(function (d) {
            if (!d.children) {
                childCount++;
                axisData.push(findPath(d));
            }
            if (d.data.name === 'root') {
                return '';
            }
            return d.children ? d.data.name.replace(/_/g, ' ') : '';
        });
    }
    return childCount;
}

function buildHeat(chart, gridData, heatG, newHeight, newWidth, leftChildCount, rightChildCount) {
    var heatScores = [],
        gridHeight,
        gridWidth,
        color;

    for (var i = 0; i < gridData.length; i++) {
        var cell = gridData[i];
        heatScores.push(cell.value);
    }

    //heat variables
    color = d3.scaleThreshold().domain(heatScores).range(['#fbf2d2', '#fee7a0', '#ffc665', '#fea743', '#fd8c3c', '#fb4b29', '#ea241e', '#d60b20', '#b10026', '#620023']);

    gridHeight = newHeight / leftChildCount;
    gridWidth = newWidth / rightChildCount;

    chart._vars.clustergramGridWidth = gridWidth;
    chart._vars.clustergramGridHeight = gridHeight;

    //grid
    heatG.selectAll('.heat').data(gridData).enter().append('rect').attr('class', 'cluster-rect').attr('x', function (d) {
        return d.x_index * gridWidth;
    }).attr('y', function (d) {
        return d.y_index * gridHeight;
    }).attr('width', function () {
        return gridWidth;
    }).attr('height', function () {
        return gridHeight;
    }).attr('stroke', '#E6E6E6').attr('stroke-width', '1px').style('fill', function (d) {
        return color(d.value);
    }).on('mouseover', function (d, i) {
        if (chart.showToolTip) {
            if (chart.tip.d === d && chart.tip.i === i) {
                chart.tip.showTip(d3.event);
            } else {
                //Get tip data
                var tipData = chart.setTipData(d, i);
                tipData.color = color(d.value);
                //Draw tip line
                chart.tip.generateSimpleTip(tipData, chart.data.dataTable, d3.event);
            }
        }
    }).on('mouseout', function () {
        chart.tip.hideTip();
    });
}

module.exports = jvCharts;

},{"../jvCharts.js":4}],16:[function(require,module,exports){
'use strict';

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var jvCharts = require('../jvCharts.js');

jvCharts.prototype.gantt = {
    paint: paint,
    setData: setData,
    getEventData: getEventData
};

jvCharts.prototype.generateGanttBars = generateGanttBars;
jvCharts.prototype.setGanttLegendData = setGanttLegendData;
jvCharts.prototype.setGanttAxisData = setGanttAxisData;

/************************************************ Gantt functions ******************************************************/

/**
*
* @param data
* @param dataTable
* @param colors
*/
function setData() {
    var chart = this;
    chart.data.legendData = chart.setGanttLegendData(chart.data);
    chart.data.xAxisData = chart.setGanttAxisData(chart, 'x');
    chart.data.yAxisData = chart.setGanttAxisData(chart, 'y');
    //define color object for chartData
    chart.data.color = jvCharts.setChartColors(chart._vars.color, chart.data.legendData, chart.colors);
}

function getEventData(event) {
    var chart = this;
    var ele = event.target.classList.value.split('bar-col-')[1];
    if (ele) {
        return {
            data: _defineProperty({}, chart.currentData.dataTable.group, [ele.replace(/_/g, ' ').replace(/_dot_/g, '.')]),
            node: event.target
        };
    }
    return {};
}

function setGanttLegendData(data) {
    var legendArray = [];
    for (var i = 1; i <= Object.keys(data.dataTable).length; i++) {
        if (data.dataTable.hasOwnProperty(["start " + i])) {
            //check to make sure it has a matching end date
            if (data.dataTable.hasOwnProperty(["end " + i])) {
                legendArray.push(data.dataTable["start " + i]);
            }
        }
    }
    return legendArray;
}

function setGanttAxisData(chart, axis) {
    var axisData = [],
        data = chart.data,
        chartData = data.chartData,
        dataType;

    if (axis === 'x') {
        var label = data.dataTable.group;
        dataType = 'DATE';

        var numBars = data.legendData.length;
        //Loop through dataTable and assign labels based on how many groups there are
        var valueContainer = [];
        valueContainer.push(data.dataTable["start 1"]);
        valueContainer.push(data.dataTable["end 1"]);
        for (var i = 1; i < numBars; i++) {
            valueContainer.push(data.dataTable["start " + (i + 1)]);
            valueContainer.push(data.dataTable["end " + (i + 1)]);
        }

        //Get all the start and end dates and add them to axis data
        for (var i = 0; i < valueContainer.length; i++) {
            for (var ii = 0; ii < chartData.length; ii++) {
                if (chartData[ii][valueContainer[i]] != null) {
                    axisData.push(chartData[ii][valueContainer[i]]);
                }
            }
        }

        //Add any axis formatting to this object, need to use when painting
        chart._vars.xAxisFormatting = {};
    } else {
        dataType = "STRING";
        var label = data.dataTable.group;

        //Add any axis formatting to this object, need to use when painting
        chart._vars.yAxisFormatting = {};

        for (var i = 0; i < chartData.length; i++) {
            axisData.push(chartData[i][label]);
        }
    }

    return {
        'label': label,
        'values': axisData,
        'dataType': dataType
    };
}

function paint() {
    var chart = this;

    chart._vars.color = chart.data.color;

    chart.currentData = chart.data;

    chart.generateSVG(chart.currentData.legendData);
    chart.generateXAxis(chart.currentData.xAxisData);
    chart.generateYAxis(chart.currentData.yAxisData);
    chart.generateLegend(chart.currentData.legendData, 'generateGanttBars');
    chart.drawGridlines(chart.currentData.xAxisData);
    chart.generateGanttBars(chart.currentData);
    if (typeof chart.currentData.xAxisScale.ticks === "function") {
        chart.formatXAxisLabels(chart.currentData.xAxisScale.ticks().length);
    } else {
        chart.formatXAxisLabels(chart.currentData.xAxisScale.domain().length);
    }
}

function generateGanttBars(ganttData) {
    var chart = this,
        svg = chart.svg,
        colors = ganttData.color,
        container = chart.config.container,
        yAxisData = ganttData.yAxisData;

    //Remove existing bars from page
    svg.selectAll("g.gantt-container").remove();
    var bars = svg.append("g").attr("class", "gantt-container"),
        dataHeaders = chart._vars.legendHeaders ? chart._vars.legendHeaders : ganttData.legendData,
        ganttDataNew = jvCharts.getToggledData(ganttData, dataHeaders),
        x = jvCharts.getAxisScale('x', ganttData.xAxisData, container, chart._vars),
        y = jvCharts.getAxisScale('y', ganttData.yAxisData, container, chart._vars),
        sampleData = ganttDataNew;

    chart._vars.rotateAxis = true;

    var numBars = ganttData.legendData.length;
    var ganttBars = [];
    //create array of start dates and end dates to iterate through
    var startDates = [];
    var endDates = [];
    for (var i = 1; i <= numBars; i++) {
        startDates.push(chart.currentData.dataTable["start " + i]);
        endDates.push(chart.currentData.dataTable["end " + i]);
    }

    for (var ii = 0; ii < numBars; ii++) {
        var externalCounterForJ = -1;
        ganttBars[ii] = bars.selectAll(".gantt-bar" + ii).data(sampleData).enter().append("rect").attr('class', function (d, i, j) {
            externalCounterForJ++;
            var label = String(sampleData[externalCounterForJ][chart.currentData.dataTable.group]).replace(/\s/g, '_').replace(/\./g, '_dot_');

            return 'gantt-bar' + ii + ' editable editable-bar bar-col-' + label + '-index-' + ii + ' highlight-class-' + label + ' rect ';
        }).attr("width", 0).attr("height", y.bandwidth() / numBars).attr("x", function (d, i) {
            if (d[startDates[ii]]) {
                return x(new Date(d[startDates[ii]]));
            }
            return 0;
        }).attr("y", function (d, i) {
            return y(d[yAxisData.label]) + y.bandwidth() / numBars * ii;
        }).attr("rx", 3).attr("ry", 3).attr("fill", function (d, i, j) {
            var typeVal = chart.currentData.dataTable["Type" + (ii + 1)];
            if (chart._vars.legendHeaders) {
                var color = jvCharts.getColors(colors, 0, chart._vars.legendHeaders[ii]);
            } else {
                var color = jvCharts.getColors(colors, 0, chart.currentData.legendData[ii]);
            }
            return color;
        });

        ganttBars[ii].transition().duration(400).delay(100).attr("width", function (d, i) {
            var width = x(new Date(d[endDates[ii]])) - x(new Date(d[startDates[ii]])); //(x(d.StartDate) - x(d.EndDate));
            if (width >= 0) {
                return width;
            } else {
                return 0;
            }
        });
    }
    var externalCounterForJJ = -1;
    var dataToPlot = jvCharts.getPlotData(ganttDataNew, chart);
    var eventGroups = bars.selectAll(".event-rect").data(dataToPlot).enter().append('rect').attr("class", "event-rect").attr('class', function (d, i, j) {
        externalCounterForJJ++;
        var label = String(sampleData[externalCounterForJJ][chart.currentData.dataTable.group]).replace(/\s/g, '_').replace(/\./g, '_dot_');
        return 'event-rect bar-col-' + label;
    }).attr("x", 0).attr("y", function (d, i) {
        return container.height / ganttDataNew.length * i;
    }).attr("width", container.width).attr("height", function (d, i) {
        return container.height / ganttDataNew.length;
    }).attr("fill", "transparent").attr("transform", "translate(0,0)");
    eventGroups.on("mouseover", function (d, i, j) {
        // Transitions in D3 don't support the 'on' function They only exist on selections. So need to move that event listener above transition and after append
        if (chart.showToolTip) {
            //Get tip data
            var tipData = chart.setTipData(d, i);
            //Draw tip
            chart.tip.generateSimpleTip(tipData, chart.data.dataTable);
            chart.tip.d = d;
            chart.tip.i = i;
        }
    }).on("mousemove", function (d, i) {
        if (chart.showToolTip) {
            if (chart.tip.d === d && chart.tip.i === i) {
                chart.tip.showTip(d3.event);
            } else {
                //Get tip data
                var tipData = chart.setTipData(d, i);
                //Draw tip line
                chart.tip.generateSimpleTip(tipData, chart.data.dataTable);
            }
        }
    }).on("mouseout", function (d) {
        if (chart.showToolTip) {
            chart.tip.hideTip();
        }
    });

    var currentDate = new Date();
    var dateData = [currentDate];
    //Draws a line representing the current date
    svg.selectAll(".currentDateLine").data(dateData).enter().append("line").attr("x1", function (d, i) {
        return x(d);
    }).attr("x2", function (d, i) {
        return x(d);
    }).attr("y1", function (d, i) {
        return "0px";
    }).attr("y2", function (d, i) {
        return chart.config.container.height;
    }).attr("class", "currentDateLine").attr("stroke", chart._vars.axisColor).attr("stroke-width", chart._vars.STROKE_WIDTH).attr("stroke-dasharray", "3, 3");

    svg.selectAll(".currentDateLabel").data(dateData).enter().append("text").text(function () {
        var today = new Date();
        var dd = today.getDate();
        var mm = today.getMonth() + 1; //January is 0!

        var yyyy = today.getFullYear();
        if (dd < 10) {
            dd = '0' + dd;
        }
        if (mm < 10) {
            mm = '0' + mm;
        }
        var today = mm + '/' + dd + '/' + yyyy;
        return today;
    }).attr("x", function (d, i) {
        return x(d);
    }).attr("y", function (d, i) {
        return "-10px";
    }).attr("text-anchor", "middle").attr('fill', chart._vars.fontColor);
}

module.exports = jvCharts;

},{"../jvCharts.js":4}],17:[function(require,module,exports){
'use strict';

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var jvCharts = require('../jvCharts.js');

jvCharts.prototype.heatmap = {
    paint: paint,
    setData: setData,
    getEventData: getEventData
};

jvCharts.prototype.generateHeatMap = generateHeatMap;

/************************************************ HeatMap functions ******************************************************/

function quantized(chart, min, max) {
    var bucketCount = chart._vars.buckets,
        sectionValue = (max - min) / bucketCount,
        quantizedArray = [];
    for (var i = 0; i < bucketCount; i++) {
        quantizedArray[i] = min + i * sectionValue;
    }
    return quantizedArray;
}

/**setData
 *  gets heatmap data and adds it to the chart object
 *
 * @params data, dataTable, colors
 */
function setData() {
    var chart = this,
        axisNames = setHeatAxisNames(chart.data);
    chart.data.xAxisData = axisNames.xAxisData;
    chart.data.yAxisData = axisNames.yAxisData;
    chart.data.processedData = setProcessedData(chart, chart.data, chart.data.xAxisData.values, chart.data.yAxisData.values);
    //define color object for chartData
    chart._vars.color = jvCharts.setChartColors(chart._vars.color, chart.data.xAxisData.values, chart.colors);
    chart.data.heatData = setHeatmapLegendData(chart, chart.data);
}

function getEventData(event, mouse) {
    var chart = this,

    //determine if the click event happens inside the container
    brushContainer = chart.chartDiv.select('.' + chart.config.type + '-container').node(),
        containerBox = brushContainer.getBoundingClientRect(),
        x = mouse[0],
        y = mouse[1],
        insideContainer = false;

    if (x < containerBox.right && y < containerBox.bottom && x > containerBox.left && y > containerBox.top) {
        insideContainer = true;
    }
    if (insideContainer && event.target.__data__) {
        var _data;

        var data = event.target.__data__;
        return {
            data: (_data = {}, _defineProperty(_data, chart.currentData.dataTable.heat, [data.value]), _defineProperty(_data, chart.currentData.dataTable.x, [data.xAxisName]), _defineProperty(_data, chart.currentData.dataTable.y, [data.yAxisName]), _data),
            node: event.target
        };
    } else if (insideContainer) {
        return {
            data: {}
        };
    }
    return {
        data: false
    };
}

function setHeatmapLegendData(chart, data) {
    var heatData = void 0;

    chart._vars.colors = organizeColors(chart);
    data.heatScores.sort(function (a, b) {
        return a - b;
    });

    chart.data.colorScale = d3.scaleQuantile().domain(data.heatScores).range(chart._vars.colors);

    if (chart._vars.quantiles === true) {
        var temp = chart.data.colorScale.quantiles();
        if (temp[0] === 0) {
            heatData = chart.data.colorScale.quantiles();
        } else {
            heatData = [0].concat(chart.data.colorScale.quantiles());
        }
    } else {
        heatData = quantized(chart, data.heatScores[0], data.heatScores[data.heatScores.length - 1]);
    }

    return heatData;
}

function organizeColors(chart) {
    var colorSelectedBucket = [],
        sValue = chart._vars.buckets,
        newColors = [],
        bucketMapper = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
        bucketCount = bucketMapper[sValue - 1],
        colors = void 0;

    for (var c in chart._vars.colors) {
        if (chart._vars.colors.hasOwnProperty(c)) {
            colorSelectedBucket.push(chart._vars.colors[c]);
        }
    }

    for (var i = 0; i < bucketCount; i++) {
        if (i >= bucketCount / 2) {
            newColors[i] = colorSelectedBucket[Math.round((i + 1) / bucketCount * 20) - 1];
        } else {
            newColors[i] = colorSelectedBucket[Math.round(i / bucketCount * 20)];
        }
    }

    colors = newColors.slice(0);
    return colors;
}

function setHeatAxisNames(data) {
    var chartData = data.chartData,
        xAxisName = data.dataTable.x,
        yAxisName = data.dataTable.y,
        xAxisArray = [],
        yAxisArray = [],
        returnObj = {};

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = data.dataTableKeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var key = _step.value;

            if (key.model === 'x') {
                returnObj.xAxisData = {};
                returnObj.xAxisData.dataType = key.type;
                returnObj.xAxisData.label = data.dataTable.x;
            } else if (key.model === 'y') {
                returnObj.yAxisData = {};
                returnObj.yAxisData.dataType = key.type;
                returnObj.yAxisData.label = data.dataTable.y;
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
        for (var _iterator2 = chartData[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var ele = _step2.value;

            if (xAxisArray.indexOf(ele[xAxisName]) === -1) {
                xAxisArray.push(ele[xAxisName]);
                //TODO make into 1 function for min max... waste of space
                if (returnObj.xAxisData.dataType === 'NUMBER') {
                    //push min and max info
                    if (!returnObj.xAxisData.min) {
                        returnObj.xAxisData.min = ele[xAxisName];
                    } else if (ele[xAxisName] < returnObj.xAxisData.min) {
                        returnObj.xAxisData.min = ele[xAxisName];
                    }

                    if (!returnObj.xAxisData.max) {
                        returnObj.xAxisData.max = ele[xAxisName];
                    } else if (ele[xAxisName] < returnObj.xAxisData.max) {
                        returnObj.xAxisData.max = ele[xAxisName];
                    }
                }
            }
            if (yAxisArray.indexOf(ele[yAxisName]) === -1) {
                yAxisArray.push(ele[yAxisName]);
                if (returnObj.yAxisData.dataType === 'NUMBER') {
                    //push min and max info
                    if (!returnObj.yAxisData.min) {
                        returnObj.yAxisData.min = ele[yAxisName];
                    } else if (ele[yAxisName] < returnObj.yAxisData.min) {
                        returnObj.yAxisData.min = ele[yAxisName];
                    }

                    if (!returnObj.yAxisData.max) {
                        returnObj.yAxisData.max = ele[yAxisName];
                    } else if (ele[yAxisName] < returnObj.yAxisData.max) {
                        returnObj.yAxisData.max = ele[yAxisName];
                    }
                }
            }
        }
    } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
            }
        } finally {
            if (_didIteratorError2) {
                throw _iteratorError2;
            }
        }
    }

    returnObj.xAxisData.values = xAxisArray;
    returnObj.yAxisData.values = yAxisArray;

    return returnObj;
}

function setProcessedData(chart, data, xAxisArray, yAxisArray) {
    var chartData = data.chartData,
        xAxisName = data.dataTable.x,
        yAxisName = data.dataTable.y,
        heat = data.dataTable.heat,
        dataArray = [],
        keys;

    data.heatScores = [];
    /*Assign each name a number and place matrix coordinates inside of dataArray */
    for (var i = 0; i < chartData.length; i++) {
        dataArray.push({
            value: chartData[i][heat],
            xAxisName: chartData[i][xAxisName],
            yAxisName: chartData[i][yAxisName]
        });

        keys = Object.keys(data.dataTable);
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
            for (var _iterator3 = keys[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                var key = _step3.value;

                if (key.indexOf('tooltip') > -1) {
                    dataArray[i][key] = chartData[i][data.dataTable[key]];
                }
            }

            //This array stores the values as numbers
        } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion3 && _iterator3.return) {
                    _iterator3.return();
                }
            } finally {
                if (_didIteratorError3) {
                    throw _iteratorError3;
                }
            }
        }

        data.heatScores.push(chartData[i][heat]);
        for (var j = 0; j < xAxisArray.length; j++) {
            if (xAxisArray[j] === dataArray[i].xAxisName) {
                dataArray[i].xAxis = j;
                break;
            }
        }
        for (var _j = 0; _j < yAxisArray.length; _j++) {
            if (yAxisArray[_j] === dataArray[i].yAxisName) {
                dataArray[i].yAxis = _j;
                break;
            }
        }
    }

    return dataArray;
}

function paint() {
    var chart = this,
        customMargin = {
        top: 0,
        right: 40,
        left: 0,
        bottom: 20
    };

    chart._vars.color = chart.data.color;
    chart.currentData = chart.data; //Might have to move into method bc of reference/value relationship

    //Generate SVG-legend data is used to determine the size of the bottom margin (set to null for no legend)
    chart.generateSVG(null, customMargin);
    //chart.generateLegend(chart.currentData.legendData, 'generateHeatMap');
    chart.generateHeatMap();
}

/**generateHeatMap
 *
 * paints the HeatMap on the chart
 * @params HeatMapData
 */
function generateHeatMap() {
    var chart = this,
        svg = chart.svg,
        colors = chart._vars.colors,
        quantiles = chart._vars.quantiles,
        data = chart.data.processedData,
        toggleLegend = !chart._vars.toggleLegend,
        heatMapData = chart.currentData,
        gridSize = chart._vars.heatGridSize,
        legendSpacing = chart._vars.heatLegendSpacing,
        vis,
        yAxisTitle;

    d3.select('body').append('div').attr('class', 'tooltip').style('opacity', 0);
    vis = svg.append('g').attr('transform', 'translate(0,0)').attr('class', 'heatmap');

    yAxisTitle = vis.selectAll('.heatmap').data([heatMapData.dataTable.y]);

    yAxisTitle.enter().append('text').attr('class', 'axisLabels bold').attr('x', -21).attr('y', -5).attr('text-anchor', 'end').attr('transform', function () {
        return 'translate(-' + (chart._vars.heatmapYmargin + 10) + ',' + 0 + ')rotate(-90)';
    }).text(function (d) {
        return d;
    });

    yAxisTitle.exit().remove();
    var formatType = jvCharts.jvFormatValueType(chart.currentData.yAxisData.values, chart.currentData.yAxisData.dataType);

    var yAxisSection = vis.append('svg:g').attr('class', 'yAxisSection');

    var yAxis = yAxisSection.selectAll('.xAxis').data(heatMapData.yAxisData.values).enter().append('svg:g');

    yAxis.append('text').text(function (d) {
        var str = jvCharts.jvFormatValue(d, formatType);
        if (str.length > 15) {
            return str.substring(0, 14) + '...';
        }
        return str;
    }).attr('x', 0).attr('y', function (d, i) {
        return i * gridSize;
    }).style('text-anchor', 'end').style('font-size', chart._vars.fontSize).attr('transform', 'translate(-6,' + gridSize / 1.5 + ')').attr('class', 'rowLabel pointer').on('click', function (d) {
        //removing styling
        d3.selectAll('.rowLabel').classed('text-highlight', false);
        d3.selectAll('.colLabel').classed('text-highlight', false);
        d3.selectAll('.heat').classed('rect-highlight', false);
        d3.selectAll('.heat').classed('rect-border', false);

        var paintBool = true;
        if (d === chart._vars.selectedX) {
            chart._vars.selectedX = '';
            paintBool = false;
        } else {
            chart._vars.selectedX = d;
        }

        //fade all rects except in this row
        d3.selectAll('.heat').classed('rect-highlight', function (r) {
            for (var i = 0; i < chart.currentData.yAxisData.values.length; i++) {
                if (chart.currentData.yAxisData.values[i] === d && d) {
                    if (r.yAxis !== i && paintBool) {
                        return true;
                    }
                }
            }
            return false;
        });
    });

    yAxis.append('title').text(function (d) {
        return d;
    });

    var xAxisTitle = vis.selectAll('.xAxisTitle').data([heatMapData.dataTable.x]);

    xAxisTitle.enter().append('text').attr('class', 'axisLabels bold').attr('x', 6).attr('y', 9).attr('transform', 'translate(0, -' + (chart._vars.heatmapXmargin - 10) + ')').text(function (d) {
        return d;
    });

    xAxisTitle.exit().remove();

    var xAxisSection = vis.append('svg:g').attr('class', 'xAxisSection');

    var xAxis = xAxisSection.selectAll('.xAxis').data(heatMapData.xAxisData.values).enter().append('svg:g');

    formatType = jvCharts.jvFormatValueType(chart.currentData.xAxisData.values, chart.currentData.xAxisData.dataType);

    xAxis.append('text').text(function (d) {
        var str = jvCharts.jvFormatValue(d, formatType);
        if (str.length > 15) {
            return str.substring(0, 14) + '...';
        }
        return str;
    }).style('text-anchor', 'start').attr('x', 6).attr('y', 7).attr('class', 'colLabel pointer').attr('transform', function (d, i) {
        return 'translate(' + i * gridSize + ', -6)rotate(-45)';
    }).attr('title', function (d) {
        return d;
    }).style('font-size', chart._vars.fontSize).on('click', function (d) {
        //removing styling
        d3.selectAll('.rowLabel').classed('text-highlight', false);
        d3.selectAll('.colLabel').classed('text-highlight', false);
        d3.selectAll('.heat').classed('rect-highlight', false);
        d3.selectAll('.heat').classed('rect-border', false);

        var paintBool = true;
        if (d === chart._vars.selectedX) {
            chart._vars.selectedX = '';
            paintBool = false;
        } else {
            chart._vars.selectedX = d;
        }
        //fade all rects except in this column
        d3.selectAll('.heat').classed('rect-highlight', function (r) {
            for (var i = 0; i < chart.currentData.xAxisData.values.length; i++) {
                if (chart.currentData.xAxisData.values[i] === d) {
                    if (r.xAxis !== i && paintBool) {
                        return true;
                    }
                }
            }
            return false;
        });
    });

    xAxis.append('title').text(function (d) {
        return d;
    });

    var width = heatMapData.xAxisData.values.length * gridSize;
    var height = heatMapData.yAxisData.values.length * gridSize;
    var formatValueType = jvCharts.jvFormatValueType(chart.data.heatData);

    //vertical lines
    var vLine = vis.append('svg:g').attr('class', 'vLineSection');

    vLine.selectAll('.vLineSection').data(d3.range(heatMapData.xAxisData.values.length + 1)).enter().append('line').attr('x1', function (d) {
        return d * gridSize;
    }).attr('x2', function (d) {
        return d * gridSize;
    }).attr('y1', 0).attr('y2', height).style('stroke', chart._vars.axisColor);

    //horizontal lines
    var hLine = vis.append('svg:g').attr('class', 'heatmap-container');

    hLine.selectAll('.heatmap-container').data(d3.range(heatMapData.yAxisData.values.length + 1)).enter().append('line').attr('x1', 0).attr('x2', width).attr('y1', function (d) {
        return d * gridSize;
    }).attr('y2', function (d) {
        return d * gridSize;
    }).style('stroke', chart._vars.axisColor);

    var heatMap = vis.append('svg:g').attr('class', 'heatSection');

    heatMap.selectAll('.heatSection').data(data).enter().append('rect').attr('x', function (d) {
        return d.xAxis * gridSize;
    }).attr('y', function (d) {
        return d.yAxis * gridSize;
    }).attr('rx', 2).attr('ry', 2).attr('class', 'heat').attr('width', gridSize - 1).attr('height', gridSize - 1).style('fill', function (d) {
        if (quantiles === true) {
            if (chart._vars.domainArray.length === 0 || d.value >= chart._vars.domainArray[0] && d.value <= chart._vars.domainArray[1]) {
                return chart.data.colorScale(d.value);
            }
            return 'white';
        }
        if (chart._vars.domainArray.length === 0 || d.value >= chart._vars.domainArray[0] && d.value <= chart._vars.domainArray[1]) {
            return getQuantizedColor(chart.data.heatData, d.value);
        }
        return 'white';
    }).on('mouseover', function (d, i) {
        //Get tip data
        var tipData = chart.setTipData(d, i);
        tipData.color = chart.data.colorScale(d.value);

        //Draw tip
        chart.tip.generateSimpleTip(tipData, chart.data.dataTable);
        chart.tip.d = d;
        chart.tip.i = i;
    }).on('mousemove', function (d, i) {
        if (chart.showToolTip) {
            if (chart.tip.d === d && chart.tip.i === i) {
                chart.tip.showTip(d3.event);
            } else {
                //Get tip data
                var tipData = chart.setTipData(d, i);
                //Draw tip line
                chart.tip.generateSimpleTip(tipData, chart.data.dataTable);
            }
        }
    }).on('mouseout', function () {
        chart.tip.hideTip();
    }).on('dblclick', function (d) {
        chart.clicked = !chart.clicked;
        if (chart.clicked) {
            //border around selected rect
            d3.select(this).classed('rect-border', true);
            //Fade row labels
            d3.selectAll('.rowLabel').classed('text-highlight', function (r, ri) {
                return ri != d.yAxis;
            });
            //fade column labels
            d3.selectAll('.colLabel').classed('text-highlight', function (r, ri) {
                return ri != d.xAxis;
            });
            //fade all rects except selected
            d3.selectAll('.heat').classed('rect-highlight', function (r) {
                return r.yAxis != d.yAxis || r.xAxis != d.xAxis;
            });
        } else {
            //removing styling
            d3.selectAll('.rowLabel').classed('text-highlight', false);
            d3.selectAll('.colLabel').classed('text-highlight', false);
            d3.selectAll('.heat').classed('rect-highlight', false);
            d3.selectAll('.heat').classed('rect-border', false);
        }
    });

    chart.chartDiv.select('svg.heatLegend').remove();

    if (toggleLegend) {
        var legendContainer = chart.chartDiv.append('svg').style('top', chart.config.margin.top + 'px').style('background', chart._vars.backgroundColor).attr('class', 'heatLegend').attr('width', chart.config.heatWidth);

        var legend = legendContainer.selectAll('.legend').data(chart.data.heatData).enter().append('g').attr('transform', function (d, i) {
            return 'translate(0, ' + gridSize * i + ' )';
        });

        legend.append('rect').attr('class', 'legend').attr('width', gridSize).attr('height', gridSize).style('fill', function (d, i) {
            return colors[i];
        }).on('click', function () {
            return d3.selectAll('.heat').classed('rect-highlight', false);
        })
        //removing styling
        //fade all rects except selected
        .on('dblclick', function (d) {
            return d3.selectAll('.heat').classed('rect-highlight', function (r) {
                return r.value < d;
            });
        });

        legend.append('text').attr('class', 'legendText').attr('x', gridSize + legendSpacing).attr('y', gridSize - legendSpacing).text(function (d) {
            if (isNaN(d)) {
                return d;
            }
            return jvCharts.jvFormatValue(d, formatValueType);
        }).style('fill', chart._vars.black);
    }

    function getQuantizedColor(quantizedArray, value) {
        for (var i = 1; i < quantizedArray.length; i++) {
            if (value < quantizedArray[i]) {
                return colors[i - 1];
            }
        }
        return colors[quantizedArray.length - 1];
    }
}

module.exports = jvCharts;

},{"../jvCharts.js":4}],18:[function(require,module,exports){
'use strict';

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var jvCharts = require('../jvCharts.js');

jvCharts.prototype.line = {
    paint: paint,
    setData: setData,
    getEventData: getEventData
};

jvCharts.prototype.generateLine = generateLine;
jvCharts.prototype.setLineThresholdData = setLineThresholdData;

/************************************************ Line functions ******************************************************/

/**setLineData
 *  gets line data and adds it to the chart object
 *
 * @params data, dataTable, colors
 */
function setData() {
    var chart = this;
    //sort chart data if there is a sort type and label in the _vars
    if (chart._vars.sortType) {
        if (chart._vars.sortLabel && chart._vars.sortType !== 'default') {
            chart.organizeChartData(chart._vars.sortLabel, chart._vars.sortType);
        }
    }
    chart.data.legendData = setBarLineLegendData(chart.data);
    chart.data.xAxisData = chart.setAxisData('x', chart.data);
    chart.data.yAxisData = chart.setAxisData('y', chart.data);

    if (chart._vars.seriesFlipped) {
        chart.setFlippedSeries(chart.data.dataTableKeys);
        chart.flippedData.color = jvCharts.setChartColors(chart._vars.color, chart.flippedData.legendData, chart.colors);
    }

    if (chart.data.dataTable.hasOwnProperty('series')) {
        chart.data.chartData = setSeriesData(chart.data.chartData, chart.data.dataTable);
    }

    //define color object for chartData
    chart.data.color = jvCharts.setChartColors(chart._vars.color, chart.data.legendData, chart.colors);
}

function getEventData(event) {
    var chart = this;
    if (event.target.classList.value.split('bar-col-')[1]) {
        return {
            data: _defineProperty({}, chart.currentData.dataTable.label, [event.target.classList.value.split('bar-col-')[1].replace(/_/g, ' ').replace(/_dot_/g, '.')]),
            node: event.target
        };
    } else if (event.target.classList.value.indexOf('line-container') > -1) {
        return {
            data: {}
        };
    }
    return {
        data: false
    };
}

/**
 * @name setSeriesData
 * @desc Sets chartData to contain a series data if the series field exists in visual panel
 */
function setSeriesData(data, dataTable) {
    var labelList = [],
        add,
        newData = [];
    //Get unique label list
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var dataEle = _step.value;

            add = true;
            for (var _j = 0; _j < labelList.length; _j++) {
                if (dataEle[dataTable.label] === labelList[_j]) {
                    add = false;
                    break;
                }
            }
            if (add) {
                labelList.push(dataEle[dataTable.label]);
            }
        }
        //Iterate over label list
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    var newData = [];
    for (var i = 0; i < labelList.length; i++) {
        var dataObj = {};
        dataObj[dataTable.label] = labelList[i];
        for (var j = 0; j < data.length; j++) {
            if (data[j][dataTable.label] === labelList[i]) {
                var newEntry = data[j][dataTable.series] + ' ' + dataTable['value 1'];
                dataObj[newEntry] = data[j][dataTable['value 1']];
            }
        }
        newData.push(dataObj);
    }
    return newData;
}

/**setBarLineLegendData
 *  gets legend info from chart Data
 *
 * @params data, type
 * @returns [] of legend tex
 */
function setBarLineLegendData(data) {
    var legendArray = [];

    if (data.dataTable.hasOwnProperty('series')) {
        for (var i = 0; i < data.chartData.length; i++) {
            var addToLegend = true;
            for (var j = 0; j < legendArray.length; j++) {
                var entry = data.chartData[i][data.dataTable.series] + ' ' + data.dataTable['value 1'];
                if (entry === legendArray[j]) {
                    addToLegend = false;
                    break;
                }
            }
            if (addToLegend) {
                var newEntry = data.chartData[i][data.dataTable.series] + ' ' + data.dataTable['value 1'];
                legendArray.push(newEntry);
            }
        }
    } else {
        for (var item in data.dataTable) {
            if (data.dataTable.hasOwnProperty(item)) {
                if (item !== 'label' && item.indexOf('tooltip') === -1) {
                    legendArray.push(data.dataTable[item]);
                }
            }
        }
    }

    return legendArray;
}
/**paintLineChart
 *
 * The initial starting point for line chart, begins the drawing process. Must already have the data stored in the chart
 * object
 */
function paint() {
    var chart = this;
    //Uses the original data and then manipulates it based on any existing options
    var dataObj = chart.getBarDataFromOptions();

    //assign current data which is used by all bar chart operations
    chart.currentData = dataObj;

    //generate svg dynamically based on legend data
    chart.generateSVG(dataObj.legendData);
    chart.generateXAxis(dataObj.xAxisData);
    chart.generateYAxis(dataObj.yAxisData);
    chart.generateLegend(dataObj.legendData, 'generateLine');
    if (chart._vars.rotateAxis) {
        chart.formatXAxisLabels(dataObj.xAxisScale.ticks().length);
    } else {
        chart.formatXAxisLabels(dataObj.xAxisScale.domain().length);
    }

    chart.generateLine(dataObj);
}

/**generateLine
 *
 * Paints the lines
 * @params lineData
 */
function generateLine(lineData) {
    var chart = this,
        svg = chart.svg;

    svg.selectAll('g.' + chart.config.type + '-container').remove();
    var lines = svg.append('g').attr('class', chart.config.type + '-container').selectAll('g');

    var dataHeaders = lineData.legendData;

    if (chart._vars.seriesFlipped && chart._vars.flippedLegendHeaders) {
        dataHeaders = chart._vars.flippedLegendHeaders;
    } else if (chart._vars.legendHeaders) {
        dataHeaders = chart._vars.legendHeaders;
    }

    var lineDataNew = jvCharts.getToggledData(lineData, dataHeaders);

    //If it's an area chart, add the area
    if (chart.config.type === 'area') {
        chart.fillArea(lineDataNew);
    }

    generateLineGroups(lines, lineDataNew, chart);
    var eventGroups = jvCharts.generateEventGroups(lines, lineDataNew, chart);

    eventGroups.on('mouseover', function (d, i, j) {
        //Transitions in D3 don't support the 'on' function They only exist on selections. So need to move that event listener above transition and after append
        if (chart.showToolTip) {
            //Get tip data
            var tipData = chart.setTipData(d, i);

            //Draw tip
            chart.tip.generateSimpleTip(tipData, chart.data.dataTable);
            chart.tip.d = d;
            chart.tip.i = i;
        }
    }).on('mousemove', function (d, i) {
        if (chart.showToolTip) {
            if (chart.tip.d === d && chart.tip.i === i) {
                chart.tip.showTip(d3.event);
            } else {
                //Get tip data
                var tipData = chart.setTipData(d, i);
                //Draw tip line
                chart.tip.generateSimpleTip(tipData, chart.data.dataTable);
            }
        }
    }).on('mouseout', function (d) {
        chart.tip.hideTip();
        svg.selectAll('.tip-line').remove();
    });

    chart.displayValues();
    chart.generateClipPath();
    chart.generateLineThreshold();

    return lines;
}

/**generateLineGroups
 *
 * Paints the groups of the lines
 * @params chartContainer, barData, chart
 */
function generateLineGroups(lineContainer, lineData, chart) {
    var container = chart.config.container,
        xAxisData = chart.currentData.xAxisData,
        yAxisData = chart.currentData.yAxisData,
        legendData = chart.currentData.legendData,
        colors = chart._vars.color,
        lines,
        lineLength = lineData.length,
        legendLength = legendData.length;

    //Get Position Calculations
    var x = jvCharts.getAxisScale('x', xAxisData, container, chart._vars, 'no-padding');
    var y = jvCharts.getAxisScale('y', yAxisData, container, chart._vars, 'no-padding');

    var xTranslate, yTranslate;

    if (chart._vars.rotateAxis === true) {
        xTranslate = function xTranslate(d, i) {
            if (d === '') {
                return x('EMPTY_STRING');
            }
            return x(d);
        };
        yTranslate = function yTranslate(d, i) {
            return y(lineData[i][yAxisData.label]) + container.height / lineLength / 2; //+ container.height / (lineLength) / 2  - y.paddingInner());
        };
    } else {
        xTranslate = function xTranslate(d, i) {
            if (lineData[i][xAxisData.label] === '') {
                lineData[i][xAxisData.label] = 'EMPTY_STRING';
            }
            return x(lineData[i][xAxisData.label]) + container.width / lineLength / 2; //+ container.width / (lineLength) / 2 - x.paddingInner());
        };
        yTranslate = function yTranslate(d, i) {
            return y(d);
        };
    }

    //Append lines and circles

    var uniqueXAxisData = [];
    for (var i = 0; i < chart.data.xAxisData.values.length; i++) {
        var add = true;
        for (var j = 0; j < uniqueXAxisData.length; j++) {
            if (chart.data.xAxisData.values[i] === uniqueXAxisData[j]) {
                add = false;
                break;
            }
        }
        if (add) {
            uniqueXAxisData.push(chart.data.xAxisData.values[i]);
        }
    }

    var data = {};
    for (var _i = 0; _i < lineLength; _i++) {
        for (var _k = 0; _k < legendLength; _k++) {
            if (typeof chart._vars.legendOptions !== 'undefined') {
                //Accounting for legend toggles
                if (chart._vars.legendOptions[_k].toggle === false) {
                    //Don't write anything to data
                    continue;
                } else {
                    //Write something to data
                    if (!data[legendData[_k]]) {
                        data[legendData[_k]] = [];
                    }
                    data[legendData[_k]].push(parseFloat(lineData[_i][legendData[_k]]));
                }
            } else {
                //Initial creation of visualization w/o legend options
                if (!data[legendData[_k]]) {
                    data[legendData[_k]] = [];
                }
                if (data[legendData[_k]].length < lineLength) {
                    data[legendData[_k]].push(parseFloat(lineData[_i][legendData[_k]]));
                }
            }
        }
    }

    chart.svg.selectAll('.lines').remove();
    chart.svg.selectAll('.line').remove();
    chart.svg.selectAll('.circle').remove();
    chart.svg.selectAll('#line-gradient').remove();

    lines = chart.svg.selectAll('.' + chart.config.type + '-container');

    //curves object
    var curves = {
        'Linear': d3.curveLinear,
        'Step': d3.curveStep,
        'Step Before': d3.curveStepBefore,
        'Step After': d3.curveStepAfter,
        'Basis': d3.curveBasis,
        'Cardinal': d3.curveCardinal,
        'Monotone X': d3.curveMonotoneX,
        'Catmull Rom': d3.curveCatmullRom
    };

    var valueline = {};
    var circles = {};
    var index = 0;
    var lineColors = [];
    var thresholding = false;
    for (var k in data) {
        //Create path generator for each series
        if (data.hasOwnProperty(k)) {
            if (data[k] === '') {
                data[k] = 'EMPTY_STRING';
            }

            valueline[k] = d3.line() //line drawing function
            .curve(curves[chart._vars.lineCurveType]).defined(function (d) {
                return !isNaN(d);
            }).x(function (d, i) {
                if (isNaN(d)) {
                    return;
                }
                return xTranslate(d, i);
            }).y(function (d, i) {
                if (isNaN(d)) {
                    return;
                }
                return yTranslate(d, i);
            });

            //Add lines to the chart.config.type + '-container'
            lines.append('g').attr('class', 'line ' + k).append('path') //draws the line
            .attr('stroke', function (d, i, j) {
                var colorObj = jvCharts.getColors(colors, i, k);
                lineColors.push(colorObj);
                return colorObj;
            }) //fills the bar with color
            .attr('stroke-width', '2').attr('fill', 'none').attr('d', function (d, i) {
                return valueline[k](data[k]);
            });

            //Color Thresholding for each tier
            if (chart._vars.thresholds != 'none' && chart._vars.colorChart != false) {
                if (chart._vars.colorLine) {
                    var thresholdPercents = [];
                    var thresholdLength = Object.keys(chart._vars.thresholds).length;
                    if (chart._vars.rotateAxis) {
                        var zero = { percent: 0, color: lineColors[index] };
                        thresholdPercents.push(zero);

                        for (var z = 0; z < thresholdLength; z++) {
                            var pCent = chart._vars.thresholds[z].threshold * 100 / (xAxisData.max - xAxisData.min);
                            var temp = { percent: pCent, color: chart._vars.thresholds[z].thresholdColor };
                            thresholdPercents.push(temp);
                        }
                    } else {
                        var zero = { percent: 0, color: lineColors[index] };
                        thresholdPercents.push(zero);

                        for (var _z = 0; _z < thresholdLength; _z++) {
                            var pCent = chart._vars.thresholds[_z].threshold * 100 / (yAxisData.max - yAxisData.min);
                            var temp = { percent: pCent, color: chart._vars.thresholds[_z].thresholdColor };
                            thresholdPercents.push(temp);
                        }
                    }

                    var thresholdData = chart.setLineThresholdData(chart, thresholdPercents, lineColors[index]);

                    lines.selectAll('path').attr('class', 'line-threshold');

                    if (chart._vars.rotateAxis) {
                        chart.svg.append('linearGradient').attr('id', 'line-gradient').attr('gradientUnits', 'userSpaceOnUse').attr('x1', xTranslate(xAxisData.min)).attr('y1', 0).attr('x2', xTranslate(xAxisData.max)).attr('y2', 0).selectAll('stop').data(thresholdData).enter().append('stop').attr('offset', function (d) {
                            return d.offset;
                        }).attr('stop-color', function (d) {
                            return d.color;
                        });
                    } else {
                        chart.svg.append('linearGradient').attr('id', 'line-gradient').attr('gradientUnits', 'userSpaceOnUse').attr('x1', 0).attr('y1', yTranslate(yAxisData.min)).attr('x2', 0).attr('y2', yTranslate(yAxisData.max)).selectAll('stop').data(thresholdData).enter().append('stop').attr('offset', function (d) {
                            return d.offset;
                        }).attr('stop-color', function (d) {
                            return d.color;
                        });
                    }
                }
                thresholding = true;
            }

            //Add circles at joints in the lines
            circles[k] = lines.append('g').attr('class', 'circle ' + k).selectAll('circle').data(data[k]).enter().append('circle') //Circles for the joints in the line
            .attr('class', function (d, i) {
                return 'circle-' + chart.currentData.chartData[i][chart.currentData.dataTable.label] + ' highlight-class-' + i;
            }).attr('cx', function (d, i) {
                if (isNaN(d)) {
                    return null;
                }
                return xTranslate(d, i);
            }).attr('cy', function (d, i) {
                if (isNaN(d)) {
                    return null;
                }
                return yTranslate(d, i);
            }).attr('fill', function (d, i, j) {
                if (isNaN(d)) {
                    return null;
                } else if (thresholding == true) {
                    var length = Object.keys(chart._vars.thresholds).length - 1;
                    if (chart._vars.rotateAxis) {
                        for (var z = length; z > -1; z--) {
                            var threshold = chart._vars.thresholds[z];
                            if (d >= threshold.threshold) {
                                return threshold.thresholdColor;
                            }
                        }
                    } else {
                        for (var z = length; z > -1; z--) {
                            var threshold = chart._vars.thresholds[z];
                            if (d >= threshold.threshold) {
                                return threshold.thresholdColor;
                            }
                        }
                    }
                }

                return jvCharts.getColors(colors, i, k);
            }).attr('opacity', function (d, i, j) {
                if (isNaN(d)) {
                    return 0;
                }
                return 1;
            }).attr('r', 2.5);

            index++;
        }
    }

    //Return line groups
    return lines.selectAll('.circle');
}

function setLineThresholdData(chart, thresholds) {
    var data = [];
    var thresholdLength = thresholds.length;
    for (var k = 0; k < thresholdLength; k++) {
        var gradientOne = { offset: thresholds[k].percent + '%', color: thresholds[k].color };
        data.push(gradientOne);

        if (k + 1 < thresholdLength) {
            var gradientTwo = { offset: thresholds[k + 1].percent + '%', color: thresholds[k].color };
            data.push(gradientTwo);
        }

        if (k == thresholdLength - 1) {
            var last = { offset: '100%', color: thresholds[k].color };
            data.push(last);
        }
    }

    return data;
}

module.exports = jvCharts;

},{"../jvCharts.js":4}],19:[function(require,module,exports){
'use strict';

var jvCharts = require('../jvCharts.js');

jvCharts.prototype.circlepack = {
    paint: paint,
    setData: setData,
    getEventData: getEventData
};

jvCharts.prototype.generatePack = generatePack;

/************************************************ Pack functions ******************************************************/

/**setPackChartData
 *  gets pack data and adds it to the chart object
 *
 * @params data, dataTable, colors
 */
function setData() {
    var chart = this;
    chart.data.legendData = setPackLegendData(chart.data.dataTable);
    if (!chart.data.chartData.hasOwnProperty('children')) {
        chart.data.chartData = jvCharts.convertTableToTree(chart.data.chartData, chart.data.dataTable);
    }

    //define color object for chartData
    chart.data.color = chart.colors;
}

function getEventData() {
    return {};
}

/**setPackLegendData
 *  gets legend info from chart Data
 *
 * @params data, type
 * @returns [] of legend text
 */
function setPackLegendData(dataTable) {
    var legendArray = [],
        label = '';
    for (var key in dataTable) {
        if (dataTable.hasOwnProperty(key)) {
            if (key === 'value') {
                label = dataTable[key];
            } else if (key !== 'tooltip 1') {
                legendArray.push(dataTable[key]);
            }
        }
    }
    legendArray.unshift(label);
    return legendArray;
}

function paint() {
    var chart = this,
        packMargins = {
        top: 30,
        right: 20,
        bottom: 15,
        left: 20
    };
    chart._vars.color = chart.data.color;

    chart.currentData = chart.data; //Might have to move into method bc of reference/value relationship

    //Generate SVG-legend data is used to determine the size of the bottom margin (set to null for no legend)
    chart.generateSVG(null, packMargins);
    chart.generateVerticalLegend('generatePack');
    chart.generatePack(chart.currentData);
}

/**generatePack
 *
 * paints the pack on the chart
 * @params packData
 */
function generatePack() {
    var chart = this,
        svg = chart.svg,
        container = chart.config.container,
        w = container.width,
        h = container.height,
        r = Math.min(h / 2, w / 3),
        margin = 20,
        diameter = r * 2,
        color,
        root,
        pack,
        vis,
        circle,
        node,
        view;

    chart.children = chart.data.chartData;

    color = d3.scaleOrdinal().range(chart.data.color.map(function (c) {
        c = d3.rgb(c);
        c.opacity = 0.8;
        return c;
    }));

    //assigns the data to a hierarchy using parent-child relationships
    root = d3.hierarchy(chart.children, function (d) {
        return d.children;
    });

    pack = d3.pack().size([container.width, container.height]).padding(2);

    pack(root.sum(function (d) {
        return d.hasOwnProperty('children') ? 0 : d.name;
    }).sort(function (a, b) {
        return b.height - a.height || b.value - a.value;
    })).descendants();

    svg.selectAll('.pack').remove();

    vis = svg.append('g').attr('class', 'pack').attr('transform', 'translate(' + w / 2 + ',' + r + ')');

    circle = vis.selectAll('circle').data(root.descendants()).enter().append('circle').attr('class', function (d) {
        return d.parent ? d.children ? 'node' : 'node node--leaf' : 'node node--root';
    }).style('fill', function (d) {
        d.color = color(d.depth);
        return d.children ? color(d.depth) : null;
    }).on('click', function (d) {
        if (focus !== d) {
            zoom(d);
            d3.event.stopPropagation();
        }
    }).on('mouseover', function (d, i) {
        //Get tip data
        var tipData = chart.setTipData(d, i);
        //Draw tip line
        chart.tip.generateSimpleTip(tipData, chart.data.dataTable);
        chart.tip.d = d;
        chart.tip.i = i;
    }).on('mousemove', function (d, i) {
        if (chart.showToolTip) {
            if (chart.tip.d === d && chart.tip.i === i) {
                chart.tip.showTip(d3.event);
            } else {
                //Get tip data
                var tipData = chart.setTipData(d, i);
                //Draw tip line
                chart.tip.generateSimpleTip(tipData, chart.data.dataTable);
            }
        }
    }).on('mouseout', function () {
        chart.tip.hideTip();
    });

    node = svg.selectAll('circle,text');

    d3.select('body').on('click', function () {
        zoom(root);
    });

    zoomTo([root.x, root.y, root.r * 2 + margin]);

    function zoom(d) {
        var focus = d;
        d3.transition().duration(d3.event.altKey ? 7500 : 750).tween('zoom', function (d) {
            var i = d3.interpolateZoom(view, [focus.x, focus.y, focus.r * 2 + margin]);
            return function (t) {
                zoomTo(i(t));
            };
        });
    }
    function zoomTo(v) {
        var k = diameter / v[2];

        //set global zoom
        view = v;

        node.attr('transform', function (d) {
            if (d && d.x && d.y) {
                return 'translate(' + (d.x - v[0]) * k + ',' + (d.y - v[1]) * k + ')';
            }
            return '';
        });

        circle.attr('r', function (d) {
            return d.r * k;
        });
    }
}

module.exports = jvCharts;

},{"../jvCharts.js":4}],20:[function(require,module,exports){
'use strict';

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var jvCharts = require('../jvCharts.js');

jvCharts.prototype.pie = {
    paint: paint,
    setData: setData,
    getEventData: getEventData
};

jvCharts.prototype.generatePie = generatePie;

/************************************************ Pie Data functions ******************************************************/

/**setPieData
 *  gets pie data and adds it to the chart object
 *
 * @params data, dataTable, colors
 */
function setData() {
    var chart = this;

    //Set data if a 'bucket' is specified--paints # specified, groups rest into other category
    if (chart._vars.hasOwnProperty('buckets') && parseInt(chart._vars.buckets, 10) !== 0) {
        //bucket the data
        var data = chart.data,
            other = {},
            categorizedData = [],
            i = void 0;

        data.chartData.sort(function (a, b) {
            return b[data.dataTable.value] - a[data.dataTable.value];
        });
        other[data.dataTable.label] = 'Other';
        other[data.dataTable.value] = 0;
        for (i = 0; i < data.chartData.length; i++) {
            if (i < chart._vars.buckets) {
                categorizedData.push(data.chartData[i]);
            } else {
                other[data.dataTable.value] += data.chartData[i][data.dataTable.value];
            }
        }
        categorizedData.push(other);
        data.chartData = categorizedData;
    }
    //Set legend data after determining if the data is bucketed
    chart.data.legendData = setPieLegendData(chart.data);
    //define color object for chartData
    chart.data.color = jvCharts.setChartColors(chart._vars.color, chart.data.legendData, chart.colors);
}

function getEventData(event) {
    var chart = this,
        ele = event.target.classList.value.split('pie-data-')[1];
    if (ele) {
        return {
            data: _defineProperty({}, chart.currentData.dataTable.label, [ele.replace(/_/g, ' ').replace(/_dot_/g, '.')]),
            node: event.target
        };
    } else if (event.target.classList.value.indexOf('pie-container') > -1) {
        return {
            data: {}
        };
    }
    return {
        data: false
    };
}

/**setPieLegendData
 *  gets legend info from chart Data
 *
 * @params data, type
 * @returns [] of legend text
 */
function setPieLegendData(data) {
    var legendArray = [];
    for (var i = data.chartData.length - 1; i >= 0; i--) {
        legendArray.push(data.chartData[i][data.dataTable.label]);
    }
    return legendArray;
}

function paint() {
    var chart = this,
        customMargins = {
        top: 40,
        right: 20,
        bottom: 20,
        left: 20
    };

    chart.currentData = chart.data;
    chart._vars.color = chart.data.color;
    chart.legendData = chart.data.legendData;
    chart.generateSVG(chart.data.legendData, customMargins);

    //If the container size is small, don't generate a legend
    if (chart.config.container.width > 550) {
        chart.generateVerticalLegend('generatePie');
    }

    chart.generatePie(chart.currentData);
}

/**generatePie
 *
 * creates and draws a pie chart on the svg element
 * @params svg, pieData, _vars, container
 * @returns {{}}
 */
function generatePie(currentData) {
    var chart = this,
        svg = chart.svg,
        pieData = currentData.chartData,
        container = chart.config.container,
        legendData = chart.currentData.legendData,
        colors = chart._vars.color,
        w = container.width,
        h = container.height,
        r = Math.min(h / 2, w / 3),
        data = [],
        total = 0,
        pieDataNew,
        legendElementToggleArray,
        vis,
        pie,
        arc,
        arcs;

    //define variables to change attr's
    svg.select('g.pie-container').remove();

    for (var i = 0; i < pieData.length; i++) {
        var obj = {};
        for (var j in chart.data.dataTable) {
            if (chart.data.dataTable.hasOwnProperty(j)) {
                obj[j] = pieData[i][chart.data.dataTable[j]];
            }
        }
        data[i] = obj;
    }

    pieDataNew = data;

    if (!chart._vars.legendHeaders) {
        chart._vars.legendHeaders = legendData;
    }

    legendElementToggleArray = jvCharts.getLegendElementToggleArray(chart._vars.legendHeaders, legendData);

    if (legendElementToggleArray) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = pieDataNew[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var slice = _step.value;
                var _iteratorNormalCompletion2 = true;
                var _didIteratorError2 = false;
                var _iteratorError2 = undefined;

                try {
                    for (var _iterator2 = legendElementToggleArray[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                        var legendEle = _step2.value;

                        if (legendEle.element === slice.label && legendEle.toggle === false) {
                            slice.value = 0;
                        }
                    }
                } catch (err) {
                    _didIteratorError2 = true;
                    _iteratorError2 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion2 && _iterator2.return) {
                            _iterator2.return();
                        }
                    } finally {
                        if (_didIteratorError2) {
                            throw _iteratorError2;
                        }
                    }
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                    _iterator.return();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
    }

    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
        for (var _iterator3 = pieDataNew[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var _slice = _step3.value;

            total += parseFloat(_slice.value);
        }
    } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
            }
        } finally {
            if (_didIteratorError3) {
                throw _iteratorError3;
            }
        }
    }

    vis = svg.append('g').data([pieDataNew]).attr('class', 'pie-container').attr('height', 200).attr('transform', 'translate(' + w / 2 + ', ' + r + ')');

    pie = d3.pie().value(function (d) {
        return d.value;
    });

    //declare an arc generator function
    arc = d3.arc().innerRadius(0) //Normal pie chart when this = 0, can be changed to create donut chart
    .outerRadius(r);

    //select paths, use arc generator to draw
    arcs = vis.selectAll('g.slice').data(pie).enter().append('g').attr('class', 'slice');

    arcs.append('path').attr('fill', function (d, i) {
        return jvCharts.getColors(colors, i, d.data.label);
    }).attr('d', function (d) {
        return arc(d);
    }).attr('class', function (d, i) {
        return 'editable editable-pie pie-slice-' + i + ' highlight-class-' + i + ' pie-data-' + d.data.label.replace(/\s/g, '_').replace(/\./g, '_dot_');
    }).attr('stroke', chart._vars.pieBorder).attr('stroke-width', chart._vars.pieBorderWidth).on('mouseover', function (d, i) {
        if (chart.showToolTip) {
            //Get tip data
            var tipData = chart.setTipData(d.data, i);
            // Draw tip line
            chart.tip.generateSimpleTip(tipData, chart.data.dataTable);
            chart.tip.d = d;
            chart.tip.i = i;
        }
    }).on('mousemove', function (d, i) {
        if (chart.showToolTip) {
            if (chart.tip.d === d && chart.tip.i === i) {
                chart.tip.showTip(d3.event);
            } else {
                //Get tip data
                var tipData = chart.setTipData(d, i);
                //Draw tip line
                chart.tip.generateSimpleTip(tipData, chart.data.dataTable);
            }
        }
    }).on('mouseout', function () {
        chart.tip.hideTip();
    });

    arcs.append('svg:text').attr('class', 'sliceLabel').attr('transform', function (d) {
        var centroid = arc.centroid(d);
        centroid[0] = centroid[0] * 1.6;
        centroid[1] = centroid[1] * 1.6;
        return 'translate(' + centroid + ')';
    }).attr('dy', '.35em').attr('text-anchor', 'middle').text(function (d, i) {
        var percent = pieDataNew[i].value / total * 100;
        percent = d3.format('.1f')(percent);
        if (percent > 1) {
            return percent + '%';
        }
    }).attr('font-size', chart._vars.fontSize).attr('fill', chart._vars.pieTextColor).attr('pointer-events', 'none');
}

module.exports = jvCharts;

},{"../jvCharts.js":4}],21:[function(require,module,exports){
'use strict';

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var jvCharts = require('../jvCharts.js');

jvCharts.prototype.radial = {
    paint: paint,
    setData: setData,
    getEventData: getEventData
};

jvCharts.prototype.generateRadial = generateRadial;

/************************************************ Radial Data functions ******************************************************/
/**setRadialChartData
 *  gets bar data and adds it to the chart object
 *
 * @params data, dataTable, colors
 */
function setData() {
    var chart = this;
    chart.data.legendData = setRadialLegendData(chart.data);
    //define color object for chartData
    chart.data.color = jvCharts.setChartColors(chart._vars.color, chart.data.legendData, chart.colors);
}

function paint() {
    var chart = this,
        radialMargins = {
        top: 40,
        right: 20,
        bottom: 20,
        left: 20
    };
    chart._vars.color = chart.data.color;
    chart.currentData = chart.data; //Might have to move into method bc of reference/value relationship

    //Generate SVG-legend data is used to determine the size of the bottom margin (set to null for no legend)
    chart.generateSVG(null, radialMargins);
    chart.generateVerticalLegend('generateRadial');
    chart.generateRadial();
}

function getEventData(event) {
    var chart = this,
        ele = event.target.classList.value.split('radial-data-')[1];
    if (ele) {
        return {
            data: _defineProperty({}, chart.currentData.dataTable.label, [ele.replace(/_/g, ' ').replace(/_dot_/g, '.')]),
            node: event.target
        };
    } else if (event.target.classList.value.indexOf('radial-container') > -1) {
        return {
            data: {}
        };
    }
    return {
        data: false
    };
}

/**setRadialLegendData
 *  gets legend info from chart Data
 *
 * @params data, type
 * @returns [] of legend text
 */
function setRadialLegendData(data) {
    var legendArray = [];
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = data.chartData[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var chartEle = _step.value;

            if (legendArray.indexOf(chartEle[data.dataTable.label]) === -1) {
                legendArray.push(chartEle[data.dataTable.label]);
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    return legendArray;
}

/**generateRadial
 *
 * paints the radil bar chart on the chart
 * @params radialData
 */

function generateRadial() {
    var chart = this,
        svg = chart.svg,
        colors = chart._vars.color,
        container = chart.config.container,
        legendData = chart.data.legendData,
        radialData = chart.data.chartData,
        tickNumber = 3,
        barHeight = container.height / 2 - 40,
        width = container.width,
        height = container.height,
        r = Math.min(height / 2, width / 3),
        data = [],
        radialDataNew,
        dataHeaders,
        legendElementToggleArray = [],
        radialDataFiltered,
        obj,
        vis,
        extent,
        formatNumber,
        barScale,
        keys,
        numBars,
        x,
        xAxis,
        arc,
        segments,
        axisGroup;

    for (var i = 0, len = radialData.length; i < len; i++) {
        obj = {};
        for (var j in chart.data.dataTable) {
            obj[j] = radialData[i][chart.data.dataTable[j]];
        }
        data[i] = obj;
    }

    radialDataNew = JSON.parse(JSON.stringify(data)); //copy of pie data


    if (!chart._vars.legendHeaders) {
        chart._vars.legendHeaders = legendData;
    }

    dataHeaders = chart._vars.legendHeaders;
    legendElementToggleArray = jvCharts.getLegendElementToggleArray(dataHeaders, legendData);
    radialDataFiltered = [];

    if (legendElementToggleArray) {
        for (var _j = 0; _j < radialDataNew.length; _j++) {
            for (var _i = 0; _i < legendElementToggleArray.length; _i++) {
                if (legendElementToggleArray[_i].element === radialDataNew[_j].label && legendElementToggleArray[_i].toggle === false) {
                    radialDataNew[_j].value = -1;
                }
            }
        }
    }

    for (var _j2 = 0; _j2 < radialDataNew.length; _j2++) {
        if (radialDataNew[_j2].value !== -1) {
            radialDataFiltered.push(radialDataNew[_j2]);
        }
    }

    //Remove existing bars from page
    svg.selectAll('g.radial-container').remove();

    vis = svg.append('g').attr('class', 'radial-container').attr('height', height).attr('transform', 'translate( ' + width / 2 + ' , ' + r + ' )');

    extent = d3.extent(radialDataFiltered, function (d) {
        return d.value;
    });

    //commas and 0 decimals
    formatNumber = d3.format(',.0f');
    if (extent[1] >= 1000000) {
        //millions
        var p = d3.precisionPrefix(1e5, 1.3e6);
        formatNumber = d3.formatPrefix('.' + p, 1.3e6);
    } else if (extent[1] <= 100) {
        //2 decimals
        formatNumber = d3.format(',.2f');
    }

    if (extent[0] !== 0) {
        extent[0] = 0;
    }
    barScale = d3.scaleLinear().domain(extent).range([0, barHeight]);

    keys = radialDataFiltered.map(function (d) {
        return d.label;
    });
    numBars = keys.length;

    x = d3.scaleLinear().domain(extent).range([0, -barHeight]);

    //create xAxis drawing function
    xAxis = d3.axisLeft().scale(x).ticks(tickNumber).tickFormat(formatNumber);

    vis.selectAll('circle').data(x.ticks(3)).enter().append('circle').attr('r', function (d) {
        return barScale(d);
    }).style('fill', 'none').style('stroke', 'black').style('stroke-dasharray', '2,2').style('stroke-width', '.5px');

    arc = d3.arc().startAngle(function (d, i) {
        return i * 2 * Math.PI / numBars;
    }).endAngle(function (d, i) {
        return (i + 1) * 2 * Math.PI / numBars;
    }).innerRadius(0);

    segments = vis.selectAll('path').data(radialDataFiltered).enter().append('g').append('path').attr('class', function (d) {
        return 'radial-data-' + d.label.replace(/\s/g, '_').replace(/\./g, '_dot_');
    }).each(function (d) {
        d.outerRadius = 0;
    }).style('fill', function (d, i) {
        return jvCharts.getColors(colors, i, d.label);
    }).attr('d', arc).on('mouseover', function (d, i) {
        if (chart.showToolTip) {
            //Get tip data
            var tipData = chart.setTipData(d, i);
            //Draw tip line
            chart.tip.generateSimpleTip(tipData, chart.data.dataTable);
            chart.tip.d = d;
            chart.tip.i = i;
        }
    }).on('mousemove', function (d, i) {
        if (chart.showToolTip) {
            if (chart.tip.d === d && chart.tip.i === i) {
                chart.tip.showTip(d3.event);
            } else {
                //Get tip data
                var tipData = chart.setTipData(d, i);
                //Draw tip line
                chart.tip.generateSimpleTip(tipData, chart.data.dataTable);
            }
        }
    }).on('mouseout', function (d) {
        if (chart.showToolTip) {
            chart.tip.hideTip();
            svg.selectAll('line.tip-line').remove();
        }
    });

    segments.transition().duration(800).ease(d3.easeElastic).delay(function (d, i) {
        return 750 - 50 * i;
    }).attrTween('d', function (d, index) {
        var i = d3.interpolate(d.outerRadius, barScale(+d.value));
        return function (t) {
            d.outerRadius = i(t);
            return arc(d, index);
        };
    });

    vis.append('circle').attr('r', barHeight).classed('outer', true).style('fill', 'none').style('stroke', 'black').style('stroke-width', '1.5px');

    vis.selectAll('line').data(keys).enter().append('g').attr('class', 'label').append('line').attr('y2', -barHeight - 20).style('stroke', 'black').style('stroke-width', '.5px').attr('transform', function (d, i) {
        return 'rotate( ' + i * 360 / numBars + ' )';
    });

    axisGroup = vis.append('g').attr('class', 'xAxis').style('pointer-events', 'none').call(xAxis);

    axisGroup.selectAll('text').attr('fill', 'black') //Customize the color of axis labels
    .attr('class', 'yAxisLabels editable editable-yAxis editable-text editable-num').attr('transform', function (d) {
        if (d === xAxis.scale().ticks(tickNumber)[tickNumber]) {
            return 'translate(0, 10)';
        }
        return 'translate(0,0)';
    }).attr('font-size', chart._vars.fontSize).append('svg:title');
}

module.exports = jvCharts;

},{"../jvCharts.js":4}],22:[function(require,module,exports){
'use strict';

var jvCharts = require('../jvCharts.js');

jvCharts.prototype.sankey = {
    paint: paint,
    setData: setData,
    getEventData: getEventData
};

jvCharts.prototype.generateSankey = generateSankey;

/************************************************ Sankey functions ******************************************************/
/**
 *
 * @param data
 * @param dataTable
 * @param colors
 */
function setData() {
    var chart = this;
    var sankeyData = {},
        data = chart.data.chartData,
        dataTable = chart.data.dataTable;

    sankeyData.links = [];
    sankeyData.nodes = [];

    //Iterate through sources and targets to make a node list
    var nodeList = [];
    var nodeGroup = 1;
    for (var item in dataTable) {
        var nodeListForLabel = [];
        if (item === 'value') {
            continue;
        }
        for (var i = 0; i < data.length; i++) {
            var potentialNode = data[i][dataTable[item]] + '-' + nodeGroup;
            var addToList = true;
            for (var j = 0; j < nodeListForLabel.length; j++) {
                if (potentialNode === nodeListForLabel[j]) {
                    addToList = false;
                    break;
                }
            }
            if (addToList) {
                nodeListForLabel.push(potentialNode);
            }
        }
        nodeGroup++;
        nodeList = nodeList.concat(nodeListForLabel);
    }
    //Create nodes object
    for (var i = 0; i < nodeList.length; i++) {
        sankeyData.nodes.push({
            'name': nodeList[i]
        });
    }

    //See how many sets of links you need
    var linkGroups = 0;

    for (var _item in dataTable) {
        if (_item.indexOf('label') !== -1) {
            linkGroups++;
        }
    }

    var source = void 0,
        target = void 0,
        value = void 0;

    for (var k in dataTable) {
        if (k.indexOf('value') > -1) {
            value = dataTable[k];
        } else if (!source) {
            source = dataTable[k];
        } else {
            target = dataTable[k];
        }
    }

    var _loop = function _loop(_i) {
        linkGroup = [];

        linkGroup = data.map(function (x) {
            return {
                'source': x[source] + '-' + _i,
                'target': x[target] + '-' + (_i + 1),
                'value': x[value]
            };
        });

        sankeyData.links = sankeyData.links.concat(linkGroup);
    };

    for (var _i = 1; _i < linkGroups; _i++) {
        var linkGroup;

        _loop(_i);
    }

    var nodeMap = {};
    for (i = 0; i < sankeyData.nodes.length; i++) {
        sankeyData.nodes[i].node = i;
        nodeMap[sankeyData.nodes[i].name] = i;
    }
    sankeyData.links = sankeyData.links.map(function (x) {
        return {
            source: nodeMap[x.source],
            target: nodeMap[x.target],
            value: x.value
        };
    });

    //Group common sankey links together and add the values
    var aggregateSankeyLinks = [];
    for (var _i2 = 0; _i2 < sankeyData.links.length; _i2++) {
        var currentLink = {};
        currentLink.source = sankeyData.links[_i2].source;
        currentLink.target = sankeyData.links[_i2].target;
        currentLink.value = sankeyData.links[_i2].value;

        //Make sure that only unique links are pushed to the aggregated array
        var addToAggregate = true;
        for (var _k = 0; _k < aggregateSankeyLinks.length; _k++) {
            if (aggregateSankeyLinks[_k].source === currentLink.source && aggregateSankeyLinks[_k].target === currentLink.target) {
                addToAggregate = false;
                break;
            }
        }

        if (!addToAggregate) {
            continue;
        }

        //Sum the value of identical links
        for (var _j = 0; _j < sankeyData.links.length; _j++) {
            if (sankeyData.links[_i2].source === sankeyData.links[_j].source && sankeyData.links[_i2].target === sankeyData.links[_j].target) {
                currentLink.value = currentLink.value + sankeyData.links[_j].value;
            }
        }

        aggregateSankeyLinks.push(currentLink);
    }

    sankeyData.links = aggregateSankeyLinks;

    chart.data.chartData = sankeyData;
    chart.data.color = d3.scaleOrdinal(d3.schemeCategory20);
}

function paint() {
    var chart = this;
    var data = chart.data.chartData;

    //generate SVG
    chart.generateSVG(null);
    chart.generateSankey(data);
}

function getEventData() {
    return {};
}

/**
 * Generates a sankey chart with the given data
 * @param sankeyData
 */
function generateSankey(sankeyData) {
    var chart = this,
        svg = chart.svg,
        color = chart._vars.color;

    var width = chart.config.container.width;
    var height = chart.config.container.height;

    var formatNumber = d3.format(',.0f'),
        //zero decimal places
    format = function format(d) {
        return formatNumber(d) + ' ' + 'Widgets';
    },
        color = d3.scaleOrdinal(d3.schemeCategory20);

    var sankey = d3.sankey().nodeWidth(10).nodePadding(15).size([width, height]);

    var path = sankey.link();

    ////Adding zoom v4 behavior to sankey
    d3.selectAll('svg').call(d3.zoom().scaleExtent([0.1, 10]).on('zoom', zoom)); //zoom event listener

    sankey.nodes(sankeyData.nodes).links(sankeyData.links).layout(32);

    var link = svg.append('g').selectAll('.sankey-link').data(sankeyData.links).enter().append('path').filter(function (d) {
        return d.value > 0;
    }).attr('class', 'sankey-link').attr('d', path).style('stroke-width', function (d) {
        return Math.max(1, d.dy);
    }).sort(function (a, b) {
        return b.dy - a.dy;
    }).on('mouseover', function (d, i) {
        if (chart.showToolTip) {
            var tipData = chart.setTipData(d, i);
            chart.tip.generateSimpleTip(tipData, chart.data.dataTable);
            chart.tip.d = d;
            chart.tip.i = i;
        }
    }).on('mousemove', function (d, i) {
        if (chart.showToolTip) {
            if (chart.tip.d === d && chart.tip.i === i) {
                chart.tip.showTip(d3.event);
            } else {
                //Get tip data
                var tipData = chart.setTipData(d, i);
                //Draw tip line
                chart.tip.generateSimpleTip(tipData, chart.data.dataTable);
            }
        }
    }).on('mouseout', function (d, i) {
        if (chart.showToolTip) {
            chart.tip.hideTip();
        }
    });

    var node = svg.append('g').selectAll('.node').data(sankeyData.nodes).enter().append('g').filter(function (d) {
        return d.value > 0;
    }).attr('class', 'node').attr('transform', function (d) {
        return 'translate(' + d.x + ', ' + d.y + ')';
    }).call(d3.drag().subject(function (d) {
        return d;
    }).on('start', function (d) {
        d3.event.sourceEvent.stopPropagation();
        this.parentNode.appendChild(this);
    }).on('drag', dragmove));

    node.append('rect').attr('height', function (d) {
        //return d.dy;
        return Math.abs(d.dy);
        //return Math.max(d.dy, 2);
    }).attr('width', sankey.nodeWidth()).style('fill', function (d) {
        return d.color = color(d.name);
    }).style('stroke', function (d) {
        return d3.rgb(d.color).darker(2);
    });

    node.append('text').attr('x', -6).attr('y', function (d) {
        return d.dy / 2;
    }).attr('dy', '.35em').attr('text-anchor', 'end').attr('transform', null).attr('transform', null).text(function (d) {
        //Remove the the nodeGroup tag and hyphen from the end of the label
        return d.name.slice(0, -2);
    }).filter(function (d) {
        return d.x < width / 2;
    }).attr('x', 6 + sankey.nodeWidth()).attr('text-anchor', 'start');

    function dragmove(d) {
        d3.select(this).attr('transform', 'translate(' + (d.x = Math.max(0, Math.min(width - d.dx, d3.event.x))) + ',' + (d.y = Math.max(0, Math.min(height - d.dy, d3.event.y))) + ')');
        sankey.relayout();
        link.attr('d', path);
    }

    function zoom() {
        //Implementing the v4 zooming feature
        svg.attr('transform', d3.event.transform);
    }
}

module.exports = jvCharts;

},{"../jvCharts.js":4}],23:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var jvCharts = require('../jvCharts.js');

jvCharts.prototype.scatterplot = {
    paint: paint,
    setData: setData,
    getEventData: getEventData
};

jvCharts.prototype.generateScatter = generateScatter;
jvCharts.prototype.createLineGuide = createLineGuide;

/************************************************ Scatter functions ******************************************************/

/**setScatterData
 *  gets scatter data and adds it to the chart object
 *
 * @params data, dataTable, colors
 */
function setData() {
    var chart = this;
    chart.data.legendData = setScatterLegendData(chart.data);
    chart.data.xAxisData = setScatterAxisData(chart.data, 'x', chart._vars);
    chart.data.yAxisData = setScatterAxisData(chart.data, 'y', chart._vars);
    chart.data.zAxisData = chart.data.dataTable.hasOwnProperty('z') ? setScatterAxisData(chart.data, 'z', chart._vars) : {};
    //define color object for chartData
    chart.data.color = jvCharts.setChartColors(chart._vars.color, chart.data.legendData, chart.colors);
}

function getEventData(event, mouse) {
    var chart = this,
        ele = event.target.__data__;

    //determine if the click event happens inside the container
    var brushContainer = chart.chartDiv.select('.' + chart.config.type + '-container').node(),
        containerBox = brushContainer.getBoundingClientRect(),
        x = mouse[0],
        y = mouse[1],
        insideContainer = false;

    if (x < containerBox.right && y < containerBox.bottom && x > containerBox.left && y > containerBox.top) {
        insideContainer = true;
    }

    if (insideContainer && ele) {
        return {
            data: _defineProperty({}, chart.currentData.dataTable.label, [ele[chart.currentData.dataTable.label].replace(/_/g, ' ').replace(/_dot_/g, '.')]),
            node: event.target
        };
    } else if (insideContainer) {
        return {
            data: {}
        };
    }
    return {
        data: false
    };
}

/**setScatterLegendData
 *  gets legend info from chart Data
 *
 * @params data, type
 * @returns [] of legend text
 */
function setScatterLegendData(data) {
    var legendArray = [];
    if (data.dataTable.hasOwnProperty('series')) {
        var series = data.dataTable.series;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = data.chartData[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var chartEle = _step.value;

                if (legendArray.indexOf(chartEle[series]) === -1) {
                    legendArray.push(chartEle[series]);
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                    _iterator.return();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
    }

    if (legendArray.length === 0 || typeof legendArray[0] === 'undefined') {
        legendArray.push(data.dataTable.label);
        data.dataTable.series = data.dataTable.label;
    }

    //order legend data in alphabetical order
    legendArray.sort();
    return legendArray;
}

/**setScatterAxisData
 *  gets z axis data based on the chartData
 *
 * @params data, dataTable
 * @returns object with label and values
 */
function setScatterAxisData(data, axis, _vars) {
    //declare vars
    var axisData = [],
        chartData = data.chartData,
        scatterLabel = data.dataTable[axis],
        min = scatterLabel ? chartData[0][scatterLabel] : 0,
        max = scatterLabel ? chartData[0][scatterLabel] : 0;

    //loop over data to find max and min
    //also determines the y axis total if the data is stacked
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
        for (var _iterator2 = chartData[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var chartEle = _step2.value;

            if (chartEle.hasOwnProperty(scatterLabel)) {
                var num = chartEle[scatterLabel];
                if (!isNaN(num)) {
                    num = parseFloat(num);
                    if (num > max) {
                        max = num;
                    } else if (num < min) {
                        min = num;
                    }
                }
            }
        }
    } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
            }
        } finally {
            if (_didIteratorError2) {
                throw _iteratorError2;
            }
        }
    }

    if (axis !== 'z') {
        min *= 0.9;
        max *= 1.1;
    }

    if (_vars.yMin && !isNaN(_vars.yMin) && axis === 'y') {
        min = _vars.yMin;
    }
    if (_vars.yMax && !isNaN(_vars.yMax) && axis === 'y') {
        max = _vars.yMax;
    }
    if (_vars.xMin && !isNaN(_vars.xMin) && axis === 'x') {
        min = _vars.xMin;
    }
    if (_vars.xMax && !isNaN(_vars.xMax) && axis === 'x') {
        max = _vars.xMax;
    }

    axisData.push(min);
    axisData.push(max);
    return {
        'label': scatterLabel,
        'values': axisData,
        'dataType': 'NUMBER',
        'min': min,
        'max': max
    };
}

function paint() {
    var chart = this,
        dataObj = {};

    dataObj.chartData = chart.data.chartData;
    dataObj.legendData = chart.data.legendData;
    dataObj.dataTable = chart.data.dataTable;
    chart._vars.color = chart.data.color;
    dataObj.xAxisData = chart.data.xAxisData;
    dataObj.yAxisData = chart.data.yAxisData;
    dataObj.zAxisData = chart.data.zAxisData;
    chart.currentData = dataObj;

    //generate svg dynamically based on legend data
    chart.generateSVG(dataObj.legendData);

    //TODO remove these from draw object
    chart.generateXAxis(chart.currentData.xAxisData);
    chart.generateYAxis(chart.currentData.yAxisData);
    chart.generateLegend(chart.currentData.legendData, 'generateScatter');

    chart.generateScatter();

    if (chart._vars.lineGuide) {
        chart.createLineGuide();
    }

    if (typeof dataObj.xAxisScale.ticks === 'function') {
        chart.formatXAxisLabels(dataObj.xAxisScale.ticks().length);
    } else {
        chart.formatXAxisLabels(dataObj.xAxisScale.domain().length);
    }
}

function calculateMean(data, type) {
    return d3.mean(data, function (value) {
        return +value[type];
    });
}

function createLineGuide() {
    var chart = this,
        svg = chart.svg,
        container = chart.config.container,
        chartData = chart.currentData.chartData,
        dataTable = chart.currentData.dataTable,
        xAxisData = chart.currentData.xAxisData,
        yAxisData = chart.currentData.yAxisData,
        xMean = calculateMean(chartData, dataTable.x),
        yMean = calculateMean(chartData, dataTable.y),
        xScale = jvCharts.getAxisScale('x', xAxisData, container, chart._vars),
        yScale = jvCharts.getAxisScale('y', yAxisData, container, chart._vars),
        lineGroup;

    svg.selectAll('g.lineguide.x').remove();
    svg.selectAll('g.lineguide.y').remove();

    lineGroup = svg.append('g').attr('class', 'line-group scatterplot-container');

    //create crosshair based on median x (up/down)
    lineGroup.append('g').attr('class', 'lineguide x').append('line').style('stroke', 'gray').style('stroke-dasharray', '3, 3').style('fill', 'black').attr('x1', xScale(xMean)).attr('y1', 0).attr('x2', xScale(xMean)).attr('y2', container.height);

    //create crosshair based on median y (left/right)
    lineGroup.append('g').attr('class', 'lineguide y').append('line').style('stroke', 'gray').style('stroke-dasharray', '3, 3').style('fill', 'black').attr('x1', 0).attr('y1', yScale(yMean)).attr('x2', container.width).attr('y2', yScale(yMean));
}

/**generateScatter
 *
 * creates and draws a scatter plot on the svg element
 * @params svg, scatterData, _vars, xAxisData, yAxisData, zAxisData, container, dataTable legendData
 * @returns {{}}
 */
function generateScatter() {
    var chart = this,
        svg = chart.svg,
        container = chart.config.container,
        scatterData = chart.currentData.chartData,
        dataTable = chart.currentData.dataTable,
        xAxisData = chart.currentData.xAxisData,
        yAxisData = chart.currentData.yAxisData,
        zAxisData = chart.currentData.zAxisData,
        legendData = chart.currentData.legendData,
        colors = chart._vars.color,
        legendElementToggleArray,
        scatterDataFiltered = [],
        x,
        y,
        z;

    if (!chart._vars.NODE_MIN_SIZE) {
        chart._vars.NODE_MIN_SIZE = 4.5;
    }
    if (!chart._vars.NODE_MAX_SIZE) {
        chart._vars.NODE_MAX_SIZE = 25;
    }

    //set clip path rectangle
    svg.append('clipPath').attr('id', 'scatter-area').append('rect').attr('x', 1).attr('width', container.width - 1).attr('height', container.height).attr('fill', chart._vars.backgroundColor);

    svg.selectAll('g.scatterplot-container').remove();
    svg.selectAll('g.scatterplot-container.editable-scatter').remove();

    if (!chart._vars.legendHeaders) {
        chart._vars.legendHeaders = legendData;
    }

    legendElementToggleArray = jvCharts.getLegendElementToggleArray(chart._vars.legendHeaders, legendData);

    if (legendElementToggleArray) {
        for (var j = 0; j < scatterData.length; j++) {
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
                for (var _iterator3 = legendElementToggleArray[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                    var legendEle = _step3.value;

                    if (typeof scatterData[j][dataTable.label] === 'undefined' || scatterData[j][dataTable.label] === '') {
                        if (legendEle.toggle !== false) {
                            scatterDataFiltered.push(scatterData[j]);
                        }
                    } else if (legendEle.element !== scatterData[j][dataTable.series] || legendEle.toggle !== false) {
                        scatterDataFiltered.push(scatterData[j]);
                    }
                }
            } catch (err) {
                _didIteratorError3 = true;
                _iteratorError3 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion3 && _iterator3.return) {
                        _iterator3.return();
                    }
                } finally {
                    if (_didIteratorError3) {
                        throw _iteratorError3;
                    }
                }
            }
        }
    }

    x = jvCharts.getAxisScale('x', xAxisData, container, chart._vars);
    y = jvCharts.getAxisScale('y', yAxisData, container, chart._vars);
    z;

    if (zAxisData && (typeof zAxisData === 'undefined' ? 'undefined' : _typeof(zAxisData)) === 'object' && Object.keys(zAxisData).length > 0) {
        z = jvCharts.getZScale(zAxisData, container, chart._vars);
    }

    svg.append('g').attr('class', 'scatterplot-circles').selectAll('g').data(scatterDataFiltered).enter().append('circle').attr('clip-path', 'url(#scatter-area)').attr('class', function (d, i) {
        return 'editable editable-scatter scatter-circle-' + i + ' highlight-class';
    }).attr('cx', function (d, i) {
        return x(scatterDataFiltered[i][xAxisData.label]);
    }).attr('cy', function (d, i) {
        return y(scatterDataFiltered[i][yAxisData.label]);
    }).attr('opacity', 0.8).attr('r', function (d, i) {
        if (dataTable.hasOwnProperty('z')) {
            if (chart._vars.toggleZ && zAxisData && (typeof zAxisData === 'undefined' ? 'undefined' : _typeof(zAxisData)) === 'object' && Object.keys(zAxisData).length > 0 && scatterDataFiltered[i][dataTable.z]) {
                return z(scatterDataFiltered[i][dataTable.z]);
            }
        }
        return chart._vars.NODE_MIN_SIZE;
    }).on('mouseover', function (d, i, j) {
        if (chart.showToolTip) {
            this.setAttribute('clip-path', '');
            var tipData = chart.setTipData(d, i);

            //Draw tip line
            chart.tip.generateSimpleTip(tipData, chart.data.dataTable);
            chart.tip.d = d;
            chart.tip.i = i;
        }
    }).on('mousemove', function (d, i) {
        if (chart.showToolTip) {
            if (chart.tip.d === d && chart.tip.i === i) {
                chart.tip.showTip(d3.event);
            } else {
                //Get tip data
                var tipData = chart.setTipData(d, i);
                //Draw tip line
                chart.tip.generateSimpleTip(tipData, chart.data.dataTable);
            }
        }
    }).on('mouseout', function () {
        if (chart.showToolTip) {
            this.setAttribute('clip-path', 'url(#scatter-area)');
            chart.tip.hideTip();
        }
    }).attr('fill', function (d, i) {
        return jvCharts.getColors(colors, i, scatterDataFiltered[i][dataTable.series]);
    });
}

module.exports = jvCharts;

},{"../jvCharts.js":4}],24:[function(require,module,exports){
'use strict';

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var jvCharts = require('../jvCharts.js');

jvCharts.prototype.singleaxis = {
    paint: paint,
    setData: setData,
    getEventData: getEventData
};

jvCharts.prototype.getSingleAxisData = getSingleAxisData;
jvCharts.prototype.getSingleAxisZ = getSingleAxisZ;
jvCharts.prototype.generatePoints = generatePoints;

function isEmpty(value) {
    return typeof value === 'undefined' || value === null;
}

/************************************************ Single Axis Cluster functions ******************************************************/

function setData() {
    var chart = this;
    chart.currentData = { chartData: chart.data.chartData, dataTable: chart.data.dataTable };

    //Set the legend Data to the label from dataTable Keys
    chart.currentData.legendData = [chart.currentData.dataTable.x];
    chart.currentData.xAxisData = chart.getSingleAxisData(chart.currentData.chartData, chart.currentData.dataTable);

    if (chart.currentData.dataTable.hasOwnProperty('size')) {
        chart.currentData.zAxisData = chart.getSingleAxisZ(chart.currentData.chartData);
    }

    chart.currentData.color = 'red'; //chart.setChartColors (chart._vars.color, chart.data.legendData, colors);
}

function getEventData(event) {
    var chart = this;
    if (event.target.classList.value.split('cell-')[1]) {
        return {
            data: _defineProperty({}, chart.currentData.dataTable.label, [event.target.classList.value.split('cell-')[1].replace(/_/g, ' ').replace(/_dot_/g, '.')]),
            node: event.target
        };
    } else if (event.target.classList.value.indexOf('editable-svg') > -1) {
        return {
            data: {}
        };
    }
    return {
        data: false
    };
}

function paint() {
    var chart = this,
        splitData = {},
        //If there is a split, the data that has been split
    numVizzes,
        //If there is a split, the number of single axis clusters that are created
    customSize = {},
        //If there is a split, the svg needs to be a custom predefined height
    margin = {
        top: 50,
        left: 100,
        right: 100,
        bottom: 50
    };

    //If there is a split on the viz, run through this logic
    if (chart.data.dataTable.facet) {
        var splitDataKeys = [],
            splitOptionName = chart.data.dataTable.facet.replace(/_/g, ' ');

        //Check to see how many vizzes need to be created because of the split
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = chart.currentData.chartData[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var ele = _step.value;

                var addToKeys = true;
                var _iteratorNormalCompletion4 = true;
                var _didIteratorError4 = false;
                var _iteratorError4 = undefined;

                try {
                    for (var _iterator4 = splitDataKeys[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                        var key = _step4.value;

                        if (ele[splitOptionName] === key) {
                            addToKeys = false;
                            break;
                        }
                    }
                } catch (err) {
                    _didIteratorError4 = true;
                    _iteratorError4 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion4 && _iterator4.return) {
                            _iterator4.return();
                        }
                    } finally {
                        if (_didIteratorError4) {
                            throw _iteratorError4;
                        }
                    }
                }

                if (addToKeys) {
                    splitDataKeys.push(ele[splitOptionName]);
                }
            }

            //Create Object with keys and assign each element of the data array to corresponding object
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                    _iterator.return();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }

        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
            for (var _iterator2 = splitDataKeys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var _key = _step2.value;

                splitData[_key] = []; //Assign empty array to each location
            }

            //Assign Data elements to appropriate place in splitData object
        } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                    _iterator2.return();
                }
            } finally {
                if (_didIteratorError2) {
                    throw _iteratorError2;
                }
            }
        }

        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
            for (var _iterator3 = chart.currentData.chartData[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                var _ele = _step3.value;

                splitData[_ele[splitOptionName]].push(_ele);
            }
        } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion3 && _iterator3.return) {
                    _iterator3.return();
                }
            } finally {
                if (_didIteratorError3) {
                    throw _iteratorError3;
                }
            }
        }

        numVizzes = splitDataKeys.length;
        customSize.height = numVizzes * 300;

        chart.generateSVG(chart.currentData.legendData, margin, customSize);
        chart.generateXAxis(chart.currentData.xAxisData);
        chart.drawGridlines(chart.currentData.xAxisData);

        for (var i = 0; i < numVizzes; i++) {
            chart.generatePoints(splitData[splitDataKeys[i]], i);
        }
    } else {
        //When there isn't a split, the base case
        chart.generateSVG(chart.currentData.legendData, margin, customSize);
        chart.generateXAxis(chart.currentData.xAxisData);
        chart.drawGridlines(chart.currentData.xAxisData);
        chart.generatePoints(chart.currentData.chartData);
    }

    if (typeof chart.currentData.xAxisScale.ticks === 'function') {
        chart.formatXAxisLabels(chart.currentData.xAxisScale.ticks().length);
    } else {
        chart.formatXAxisLabels(chart.currentData.xAxisScale.domain().length);
    }
}

function getSingleAxisZ(data) {
    var chart = this,
        size = chart.currentData.dataTable.size,
        min = data[0][size],
        max = data[0][size];
    //Find min and max of the data
    for (var i = 0; i < data.length; i++) {
        var num = data[i][size];
        if (num > max) {
            max = num;
        } else if (num < min) {
            min = num;
        }
    }

    return {
        'min': min,
        'max': max,
        'label': size
    };
}

function generatePoints(data, yLevel) {
    var chart = this,
        svg = chart.svg,
        width = chart.config.container.width,
        height = chart.config.container.height,
        dataTable = chart.currentData.dataTable,
        xAxisData = chart.currentData.xAxisData,
        zAxisData = chart.currentData.zAxisData,
        container = chart.config.container,
        pointColor = '#609cdb',
        coloredPoint = '#e88a17',
        x = jvCharts.getAxisScale('x', xAxisData, chart.config.container, chart._vars),
        currentAxisHeight,
        simulation,
        cell;

    var SPLIT_CLUSTER_HEIGHT = 300,
        TRANSLATE_SPLIT_CLUSTER = 150;

    //If there's a split, account for the multiple axes
    if (!isEmpty(yLevel)) {
        currentAxisHeight = yLevel * SPLIT_CLUSTER_HEIGHT + TRANSLATE_SPLIT_CLUSTER; //Each height is 100px
    } else {
        currentAxisHeight = height / 2;
    }

    if (!chart._vars.NODE_MIN_SIZE) {
        chart._vars.NODE_MIN_SIZE = 4.5;
    }
    if (!chart._vars.NODE_MAX_SIZE) {
        chart._vars.NODE_MAX_SIZE = 25;
    }

    chart.chartDiv.select('.container').attr('class', 'singleaxis-container');

    //Add a path line through the height of the axis
    if (!isEmpty(yLevel)) {
        svg.append('line').attr('x1', 0).attr('x2', container.width).attr('y1', currentAxisHeight).attr('y2', currentAxisHeight).attr('stroke', 'white').attr('stroke-width', '20px').attr('transform', 'translate(0, ' + TRANSLATE_SPLIT_CLUSTER + ')');

        svg.append('text').datum(data).attr('x', 0).attr('y', currentAxisHeight).text(function (d) {
            if (chart.data.dataTable.facet) {
                d[0][chart.data.dataTable.facet.replace(/_/g, ' ')];
            }
        }).attr('transform', 'translate(-85, 0)');
    }

    simulation = d3.forceSimulation(data).alphaDecay(0.05).force('x', d3.forceX(function (d) {
        return x(d[dataTable.x]);
    }).strength(1)).force('y', d3.forceY(currentAxisHeight)).force('collide', d3.forceCollide(function (d) {
        var norm = void 0,
            val = chart._vars.NODE_MIN_SIZE;
        //Set collision radius equal to the radius of the circle
        if (dataTable.hasOwnProperty('size')) {
            norm = (d[dataTable.size] - zAxisData.min) / (zAxisData.max - zAxisData.min);
            val = (chart._vars.NODE_MAX_SIZE - chart._vars.NODE_MIN_SIZE) * norm + chart._vars.NODE_MIN_SIZE;
        }
        return val;
    }).strength(1)).force('charge', d3.forceManyBody().strength(-6)).stop();

    for (var i = 0; i < 120; ++i) {
        simulation.tick();
    }cell = svg.append('g').attr('class', 'cells').selectAll('g').data(d3.voronoi().extent([[0, 0], [width, height]]).x(function (d) {
        return d.x;
    }).y(function (d) {
        return d.y;
    }).polygons(data)).enter().append('g');

    cell.append('circle').attr('class', function (d) {
        'cell-' + d.data[chart.currentData.dataTable.label].replace(/\s/g, '_').replace(/\./g, '_dot_');
    }).attr('r', function (d) {
        var val = chart._vars.NODE_MIN_SIZE; //Default node size of 15
        if (dataTable.hasOwnProperty('size') && !isEmpty(d) && d.hasOwnProperty('data')) {
            var norm = (d.data[dataTable.size] - zAxisData.min) / (zAxisData.max - zAxisData.min);
            if (!isNaN(norm)) {
                val = (chart._vars.NODE_MAX_SIZE - chart._vars.NODE_MIN_SIZE) * norm + chart._vars.NODE_MIN_SIZE;
            } else {
                //If there is only 1 node on the chart
                val = chart._vars.NODE_MIN_SIZE;
            }
        } else if (isEmpty(d)) {
            val = 0; //Don't display undefined nodes
        }
        return val;
    }).attr('cx', function (d) {
        return isEmpty(d) ? 0 : d.data.x;
    }).attr('cy', function (d) {
        return isEmpty(d) ? 0 : d.data.y;
    }).attr('fill', function (d) {
        if (!isEmpty(d) && d.data[chart._vars.colorDataCategory] === chart._vars.colorDataInstance) {
            return coloredPoint;
        }
        return pointColor;
    }).attr('opacity', 0.8).attr('stroke', 'black').attr('stroke-width', 1).on('mouseover', function (d, i) {
        if (chart.showToolTip) {
            var tipData = chart.setTipData(d, i);
            chart.tip.generateSimpleTip(tipData, dataTable);
            d3.select(this).attr('fill', chart._vars.singleAxisFillHoverColor);
            chart.tip.d = d;
            chart.tip.i = i;
        }
    }).on('mousemove', function (d, i) {
        if (chart.showToolTip) {
            if (chart.tip.d === d && chart.tip.i === i) {
                chart.tip.showTip(d3.event);
            } else {
                //Get tip data
                var tipData = chart.setTipData(d, i);
                //Draw tip line
                chart.tip.generateSimpleTip(tipData, chart.data.dataTable);
            }
        }
    }).on('mouseout', function () {
        if (chart.showToolTip) {
            chart.tip.hideTip();
        }
        d3.select(this).attr('fill', function (d) {
            if (!isEmpty(d) && d.data[chart._vars.colorDataCategory] === chart._vars.colorDataInstance) {
                return coloredPoint;
            }
            return pointColor;
        });
    });
}

function getSingleAxisData(data, dataTable) {
    var chart = this,
        label,
        dataType,
        min,
        max,
        values = [];

    if (dataTable) {
        if (dataTable.hasOwnProperty('x')) {
            label = dataTable.x;
        }
    }

    dataType = 'NUMBER';

    var _iteratorNormalCompletion5 = true;
    var _didIteratorError5 = false;
    var _iteratorError5 = undefined;

    try {
        for (var _iterator5 = data[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
            var ele = _step5.value;

            values.push(ele[dataTable.x]);
        }
    } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion5 && _iterator5.return) {
                _iterator5.return();
            }
        } finally {
            if (_didIteratorError5) {
                throw _iteratorError5;
            }
        }
    }

    min = Math.min.apply(null, values);
    max = Math.max.apply(null, values);

    //Add a 10% buffer to both sides
    min = Math.floor(min - (max - min) * 0.10);
    max = Math.ceil(max + (max - min) * 0.10);

    //For axis min/max widget
    if (chart._vars.hasOwnProperty('xMin') && chart._vars.xMin !== 'none') {
        min = chart.options.xMin;
    }
    if (chart._vars.hasOwnProperty('xMax') && chart._vars.xMax !== 'none') {
        max = chart._vars.xMax;
    }

    return {
        'label': label,
        'values': values,
        'dataType': dataType,
        'min': min,
        'max': max
    };
}

module.exports = jvCharts;

},{"../jvCharts.js":4}],25:[function(require,module,exports){
'use strict';

var jvCharts = require('../jvCharts.js');

jvCharts.prototype.sunburst = {
    paint: paint,
    setData: setData,
    getEventData: getEventData
};

jvCharts.prototype.generateSunburst = generateSunburst;

/************************************************ Sunburst functions ******************************************************/

/**setSunburstChartData
 *  gets sunburst data and adds it to the chart object
 *
 * @params data, dataTable, colors
 */
function setData() {
    var chart = this;
    if (!chart.data.chartData.hasOwnProperty('children')) {
        chart.data.chartData = jvCharts.convertTableToTree(chart.data.chartData, chart.data.dataTable, true);
    }

    chart.data.color = chart.colors;
}

function getEventData() {
    return {};
}

function paint() {
    var chart = this,
        sunburstMargins = {
        top: 15,
        right: 15,
        bottom: 15,
        left: 15
    };

    chart._vars.color = chart.data.color;
    chart.currentData = chart.data;

    //Generate SVG-legend data is used to determine the size of the bottom margin (set to null for no legend)
    chart.generateSVG(null, sunburstMargins);
    //chart.generateLegend(chart.currentData.legendData, 'generateSunburst');
    chart.generateSunburst();
}

/**generateSunburst
 *
 * paints the sunburst on the chart
 * @params sunburstData
 */
function generateSunburst() {
    var chart = this,
        svg = chart.svg,
        vis,
        text,
        container = chart.config.container,
        width = container.width,
        height = container.height,
        radius = Math.min(width, height) / 2 - 10,
        x = d3.scaleLinear().range([0, 2 * Math.PI]),
        y = d3.scaleSqrt().range([0, radius]),
        color = d3.scaleOrdinal().range(chart.data.color.map(function (c) {
        c = d3.rgb(c);
        c.opacity = 1;
        return c;
    })),
        partition = d3.partition(),
        arc = d3.arc().startAngle(function (d) {
        return Math.max(0, Math.min(2 * Math.PI, x(d.x0)));
    }).endAngle(function (d) {
        return Math.max(0, Math.min(2 * Math.PI, x(d.x1)));
    }).innerRadius(function (d) {
        return Math.max(0, y(d.y0));
    }).outerRadius(function (d) {
        return Math.max(0, y(d.y1));
    }),


    //assigns the data to a hierarchy using parent-child relationships
    root = d3.hierarchy(chart.currentData.chartData, function (d) {
        return d.children;
    });

    root.sum(function (d) {
        return d.value;
    });

    vis = svg.append('g').attr('class', 'sunburst').attr('width', width).attr('height', height).attr('transform', 'translate(' + width / 2 + ',' + height / 2 + ')');

    vis.selectAll('path').data(partition(root).descendants()).enter().append('g').attr('class', 'node');

    vis.selectAll('.node').append('path').attr('d', arc).style('fill', function (d) {
        if (d.data.name === 'root') {
            d.color = chart._vars.backgroundColor;
            return chart._vars.backgroundColor;
        }
        d.color = color(d.data.name);
        return color(d.data.name);
    }).on('mouseover', function (d, i) {
        if (chart.showToolTip) {
            var tipData = chart.setTipData(d, i);

            //Draw tip line
            chart.tip.generateSimpleTip(tipData, chart.data.dataTable);
            chart.tip.d = d;
            chart.tip.i = i;
        }
    }).on('mousemove', function (d, i) {
        if (chart.showToolTip) {
            if (chart.tip.d === d && chart.tip.i === i) {
                chart.tip.showTip(d3.event);
            } else {
                //Get tip data
                var tipData = chart.setTipData(d, i);
                //Draw tip line
                chart.tip.generateSimpleTip(tipData, chart.data.dataTable);
            }
        }
    }).on('click', click).on('mouseout', function () {
        chart.tip.hideTip();
    });

    if (chart._vars.displayValues) {
        text = vis.selectAll('.node').append('text').attr('transform', function (d) {
            return 'rotate(' + computeTextRotation(d) + ')';
        }).attr('x', function (d) {
            return y(d.y0);
        }).attr('dx', '6') //margin
        .attr('dy', '.35em') //vertical-align
        .text(function (d) {
            if (Number(d.data.value) > 0) {
                return d.data.name === 'root' ? '' : d.data.name;
            }
            return '';
        });
    }

    function click(d) {
        //fade out all text elements
        if (chart._vars.displayValues) {
            text.transition().attr('opacity', 0);
        }

        vis.transition().duration(750).tween('scale', function () {
            var xd = d3.interpolate(x.domain(), [d.x0, d.x1]),
                yd = d3.interpolate(y.domain(), [d.y0, 1]),
                yr = d3.interpolate(y.range(), [d.y0 ? 20 : 0, radius]);

            return function (t) {
                x.domain(xd(t));y.domain(yd(t)).range(yr(t));
            };
        }).selectAll('path').attrTween('d', function (ele) {
            return function () {
                return arc(ele);
            };
        }).on('end', function (e, i) {
            if (chart._vars.displayValues) {
                //check if the animated element's data e lies within the visible angle span given in d
                if (e.x0 > d.x0 && e.x0 < d.x1) {
                    //get a selection of the associated text element
                    var arcText = d3.select(this.parentNode).select('text');
                    //fade in the text element and recalculate positions
                    arcText.transition().duration(750).attr('opacity', 1).attr('class', 'visible').attr('transform', function () {
                        return 'rotate(' + computeTextRotation(e) + ')';
                    }).attr('x', function (ele) {
                        return y(ele.y0);
                    }).text(function (ele) {
                        return ele.data.name === 'root' ? '' : ele.data.name;
                    });
                }
            }
        });
    }

    function computeTextRotation(d) {
        return (x((d.x0 + d.x1) / 2) - Math.PI / 2) / Math.PI * 180;
    }
}

module.exports = jvCharts;

},{"../jvCharts.js":4}],26:[function(require,module,exports){
'use strict';

var jvCharts = require('../jvCharts.js');

jvCharts.prototype.treemap = {
    paint: paint,
    setData: setData,
    getEventData: getEventData
};

jvCharts.prototype.generateTreeMap = generateTreeMap;
/************************************************ TreeMap functions ******************************************************/

/**setTreeMapData
 *  gets treemap data and adds it to the chart object
 *
 * @params data, dataTable, colors
 */
function setData() {
    var chart = this;
    if (!chart.data.chartData.hasOwnProperty('children')) {
        chart.data.chartData = jvCharts.convertTableToTreemap(chart.data.chartData, chart.data.dataTable);
    }
    chart.data.legendData = setTreeMapLegendData(chart.data);
    //define color object for chartData
    chart.data.color = jvCharts.setChartColors(chart._vars.color, chart.data.legendData, chart.colors);
}

function getEventData() {
    return {};
}

/**setTreeMapLegendData
 *  gets legend info from chart Data
 *
 * @params data, type
 * @returns [] of legend text
 */
function setTreeMapLegendData(data) {
    var legendArray = [],
        series = data.dataTable.series;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = data.chartData.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var childEle = _step.value;

            if (legendArray.indexOf(childEle[series]) === -1) {
                legendArray.push(childEle[series]);
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    return legendArray;
}

function paint() {
    var chart = this,
        treeMapMargins = {
        top: 45,
        right: 50,
        left: 50,
        bottom: 130
    };
    chart._vars.color = chart.data.color;
    chart.currentData = chart.data;

    //Generate SVG-legend data is used to determine the size of the bottom margin (set to null for no legend)
    chart.generateSVG(null, treeMapMargins);
    chart.generateLegend(chart.currentData.legendData, 'generateTreeMap');
    chart.generateTreeMap(chart.currentData);
}

/**generateTreeMap
 *
 * paints the treemap on the chart
 * @params treeMapData
 */
function generateTreeMap(treeMapData) {
    var chart = this,
        svg = chart.svg,
        colors = treeMapData.color,
        container = chart.config.container,
        relationMap = chart.data.dataTable,
        data = chart.currentData.chartData,
        dataHeaders,
        legendElementToggleArray,
        treeMapDataFiltered,
        root,
        treemapFunc,
        node,
        textNode;

    if (!chart._vars.legendHeaders) {
        chart._vars.legendHeaders = chart.currentData.legendData;
    }

    dataHeaders = chart._vars.legendHeaders;
    legendElementToggleArray = jvCharts.getLegendElementToggleArray(dataHeaders, chart.data.legendData);

    if (legendElementToggleArray) {
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
            for (var _iterator2 = data.children[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var childEle = _step2.value;
                var _iteratorNormalCompletion3 = true;
                var _didIteratorError3 = false;
                var _iteratorError3 = undefined;

                try {
                    for (var _iterator3 = legendElementToggleArray[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                        var legendEle = _step3.value;

                        if (legendEle.element === childEle[relationMap.series] && legendEle.toggle === false) {
                            childEle.show = false;
                        }
                    }
                } catch (err) {
                    _didIteratorError3 = true;
                    _iteratorError3 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion3 && _iterator3.return) {
                            _iterator3.return();
                        }
                    } finally {
                        if (_didIteratorError3) {
                            throw _iteratorError3;
                        }
                    }
                }
            }
        } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                    _iterator2.return();
                }
            } finally {
                if (_didIteratorError2) {
                    throw _iteratorError2;
                }
            }
        }
    }

    treeMapDataFiltered = {
        Parent: 'Top Level',
        children: []
    };

    var _iteratorNormalCompletion4 = true;
    var _didIteratorError4 = false;
    var _iteratorError4 = undefined;

    try {
        for (var _iterator4 = data.children[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var _childEle = _step4.value;

            if (_childEle.show !== false) {
                treeMapDataFiltered.children.push(_childEle);
            }
        }

        //assigns the data to a hierarchy using parent-child relationships
    } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion4 && _iterator4.return) {
                _iterator4.return();
            }
        } finally {
            if (_didIteratorError4) {
                throw _iteratorError4;
            }
        }
    }

    root = d3.hierarchy(treeMapDataFiltered, function (d) {
        return d.children;
    });

    treemapFunc = d3.treemap().size([container.width, container.height]).padding(2);

    treemapFunc(root.sum(function (d) {
        return d[relationMap.size];
    }).sort(function (a, b) {
        return b.height - a.height || b.value - a.value;
    })).descendants();

    //Remove existing bars from page
    svg.selectAll('g.treemap').remove();
    svg.append('g').attr('class', 'treemap');

    node = svg.select('.treemap').selectAll('g').data(root.leaves()).enter().append('g').attr('transform', 'translate(0,0)');

    node.append('rect').attr('x', function (d) {
        return d.x0 + 'px';
    }).attr('y', function (d) {
        return d.y0 + 'px';
    }).attr('width', function (d) {
        return d.x1 - d.x0 + 'px';
    }).attr('height', function (d) {
        return d.y1 - d.y0 + 'px';
    }).attr('fill', function (d, i) {
        return jvCharts.getColors(colors, i, d.data[relationMap.series]);
    }).attr('fill-opacity', 0.8).attr('stroke', chart._vars.white).attr('stroke-width', chart._vars.strokeWidth).on('mouseover', function (d, i) {
        //Get tip data
        var tipData = chart.setTipData(d.data, i);
        //Draw tip line
        chart.tip.generateSimpleTip(tipData, chart.data.dataTable);
        chart.tip.d = d;
        chart.tip.i = i;
    }).on('mousemove', function (d, i) {
        if (chart.showToolTip) {
            if (chart.tip.d === d && chart.tip.i === i) {
                chart.tip.showTip(d3.event);
            } else {
                //Get tip data
                var tipData = chart.setTipData(d, i);
                //Draw tip line
                chart.tip.generateSimpleTip(tipData, chart.data.dataTable);
            }
        }
    }).on('mouseout', function () {
        chart.tip.hideTip();
    });

    node.append('text').attr('x', function (d) {
        return d.x0 + 'px';
    }).attr('y', function (d) {
        return d.y0 + 'px';
    }).attr('width', function (d) {
        return d.x1 - d.x0 + 'px';
    }).attr('height', function (d) {
        return d.y1 - d.y0 + 'px';
    }).attr('transform', 'translate(3, 18)').text(function (d) {
        if (d.dy !== 0 && !d.children) {
            return d.data[relationMap.label];
        }
        return null;
    });

    /*Don't display text if text is wider than rect */
    textNode = node.selectAll('text');
    textNode.attr('style', function (d) {
        var bbox = this.getBBox();
        if (bbox.width >= d.x1 - d.x0 - 5 || bbox.height >= d.y1 - d.y0 - 5) {
            return 'display:none';
        }
        return '';
    });
}
module.exports = jvCharts;

},{"../jvCharts.js":4}],27:[function(require,module,exports){
'use strict';

var jvCharts = require('../jvCharts.js');

jvCharts.prototype.cloud = {
    paint: paint,
    setData: setData,
    getEventData: getEventData
};

jvCharts.prototype.generateCloud = generateCloud;

/************************************************ Cloud functions ******************************************************/

/**setCloudData
 *  gets cloud data and adds it to the chart object
 *
 * @params data, dataTable, colors
 */
function setData() {
    var chart = this;
    //define color object for chartData
    chart.data.color = chart.colors;
}

function getEventData() {
    return {};
}

/**setCloudLegendData
 *  gets legend info from chart Data
 *
 * @params data, type
 * @returns [] of legend text
 */
function setCloudLegendData(data) {
    var legendArray = [];
    for (var i = 0; i < data.chartData.children.length; i++) {
        if (legendArray.indexOf(data.chartData.children[i][data.dataTable.series]) == -1) {
            legendArray.push(data.chartData.children[i][data.dataTable.series]);
        }
    }
    return legendArray;
}

function paint() {
    var chart = this;
    if (!chart.smallerFontRepaint) {
        chart._vars.fontSizeMax = 80;
        chart.currentData = chart.data;
    } else {
        chart.currentData = JSON.parse(JSON.stringify(chart.data));
    }

    chart._vars.color = chart.data.color;

    var cloudMargins = {
        top: 15,
        right: 15,
        left: 15,
        bottom: 15
    };

    //Generate SVG-legend data is used to determine the size of the bottom margin (set to null for no legend)
    chart.generateSVG(null, cloudMargins);
    // chart.generateLegend(chart.currentData.legendData, 'generateCloud');
    chart.generateCloud(chart.currentData);
};

/** generateCloud
 *
 * paints the cloud  on the chart
 * @params cloud Data
 */
function generateCloud(cloudData) {
    var chart = this,
        svg = chart.svg,
        container = chart.config.container,
        allFilterList = [],
        relationMap = chart.data.dataTable,
        width = container.width,
        height = container.height,
        margin = chart.config.margin,
        min,
        max;

    var categories = d3.keys(d3.nest().key(function (d) {
        if (!min && !max) {
            min = d[relationMap.value];
            max = d[relationMap.value];
        } else {
            if (d[relationMap.value] > max) {
                max = d[relationMap.value];
            }
            if (d[relationMap.value] < min) {
                min = d[relationMap.value];
            }
        }

        return d[relationMap.value];
    }).map(cloudData.chartData));

    if (!chart._vars.fontSizeMax) {
        chart._vars.fontSizeMax = 80;
    }

    var color = d3.scaleOrdinal().range(chart.data.color.map(function (c) {
        c = d3.rgb(c);c.opacity = 0.8;return c;
    }));

    var fontSize = d3.scalePow().exponent(5).domain([0, 1]).range([10, chart._vars.fontSizeMax]);
    chart.smallerFontRepaint = false;
    var layout = d3.layout.cloud().timeInterval(10).size([width, height]).words(cloudData.chartData).rotate(function (d) {
        return 0;
    }).font('Roboto').fontSize(function (d, i) {
        return fontSize(max - min !== 0 ? (d[relationMap.value] - min) / (max - min) : 0);
    }).repaintWithSmallerFont(function () {
        if (chart._vars.fontSizeMax > 10) {
            chart._vars.fontSizeMax -= 5;
            chart.smallerFontRepaint = true;
            paint(chart);
        }
    }).text(function (d) {
        return d[relationMap.label];
    }).spiral("archimedean").on("end", draw).start();

    var wordcloud = svg.append("g").attr('class', 'wordcloud').attr("width", width + margin.left + margin.right).attr("height", height + margin.top + margin.bottom).attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");

    function draw(words) {
        if (chart.smallerFontRepaint) {
            return;
        }
        wordcloud.selectAll("text").data(cloudData.chartData).enter().append("text").attr('class', 'word').style("font-size", function (d) {
            return d.size + "px";
        }).style("font-family", function (d) {
            return d.font;
        }).style("fill", function (d) {
            return color(d[relationMap.value]);
        }).attr("text-anchor", "middle").text(function (d) {
            return d.text;
        }).on("mouseover", function (d, i) {
            //Get tip data
            var tipData = chart.setTipData(d, i);
            tipData.color = color(d[relationMap.value]);

            //Draw tip
            chart.tip.generateSimpleTip(tipData, chart.data.dataTable);
            chart.tip.d = d;
            chart.tip.i = i;
        }).on('mousemove', function (d, i) {
            if (chart.showToolTip) {
                if (chart.tip.d === d && chart.tip.i === i) {
                    chart.tip.showTip(d3.event);
                } else {
                    //Get tip data
                    var tipData = chart.setTipData(d, i);
                    //Draw tip line
                    chart.tip.generateSimpleTip(tipData, chart.data.dataTable);
                }
            }
        }).on("mouseout", function (d) {
            chart.tip.hideTip();
        }).transition().duration("1000").attr("transform", function (d) {
            return "translate(" + [d.x, d.y] + ")rotate(" + d.rotate + ")";
        });
    }
};

module.exports = jvCharts;

},{"../jvCharts.js":4}]},{},[2])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmNcXGVkaXRPcHRpb25zVGVtcGxhdGUuanMiLCJzcmNcXGp2LmpzIiwic3JjXFxqdkJydXNoLmpzIiwic3JjXFxqdkNoYXJ0cy5qcyIsInNyY1xcanZDb21tZW50LmpzIiwic3JjXFxqdkVkaXQuanMiLCJzcmNcXGp2RXZlbnRzLmpzIiwic3JjXFxqdlNlbGVjdC5qcyIsInNyY1xcanZUaXAuanMiLCJzcmNcXGp2VmFycy5qcyIsInNyY1xcdmlzdWFsc1xcanZBcmVhLmpzIiwic3JjXFx2aXN1YWxzXFxqdkJhci5qcyIsInNyY1xcdmlzdWFsc1xcanZCb3hXaGlza2VyLmpzIiwic3JjXFx2aXN1YWxzXFxqdkJ1YmJsZS5qcyIsInNyY1xcdmlzdWFsc1xcanZDbHVzdGVyZ3JhbS5qcyIsInNyY1xcdmlzdWFsc1xcanZHYW50dC5qcyIsInNyY1xcdmlzdWFsc1xcanZIZWF0bWFwLmpzIiwic3JjXFx2aXN1YWxzXFxqdkxpbmUuanMiLCJzcmNcXHZpc3VhbHNcXGp2UGFjay5qcyIsInNyY1xcdmlzdWFsc1xcanZQaWUuanMiLCJzcmNcXHZpc3VhbHNcXGp2UmFkaWFsLmpzIiwic3JjXFx2aXN1YWxzXFxqdlNhbmtleS5qcyIsInNyY1xcdmlzdWFsc1xcanZTY2F0dGVyLmpzIiwic3JjXFx2aXN1YWxzXFxqdlNpbmdsZUF4aXMuanMiLCJzcmNcXHZpc3VhbHNcXGp2U3VuYnVyc3QuanMiLCJzcmNcXHZpc3VhbHNcXGp2VHJlZW1hcC5qcyIsInNyY1xcdmlzdWFsc1xcanZXb3JkQ2xvdWQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7OztBQ0FBLElBQUksbXVJQUFKOztBQTRHQSxPQUFPLE9BQVAsR0FBaUIsSUFBakI7OztBQzVHQTtBQUNBOztBQUNBLFFBQVEsYUFBUjtBQUNBLFFBQVEsZUFBUjtBQUNBLFFBQVEsWUFBUjtBQUNBLFFBQVEsY0FBUjtBQUNBLFFBQVEsZ0JB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aUIsUUFBakIiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwidmFyIGh0bWwgPSBgPCEtLVRvcCB0aXRsZSBiYXIgb2YgZWRpdCBwb3B1cC0tPlxyXG48ZGl2IGNsYXNzPSd0aXRsZSc+XHJcbiAgICA8ZGl2IGNsYXNzPVwianYtaW5saW5lXCI+XHJcbiAgICAgICAgPGI+RWRpdCBPcHRpb25zPGRpdiBpZD1cImVkaXQtb3B0aW9uLWVsZW1lbnRcIiBjbGFzcz1cImp2LWlubGluZVwiIHN0eWxlPVwidmlzaWJpbGl0eTogaGlkZGVuO1wiPjwvZGl2Pjo8L2I+XHJcbiAgICA8L2Rpdj5cclxuXHJcbiAgICA8ZGl2IGlkPSdleGl0RWRpdE1vZGUnIGNsYXNzPSdqdi1wdWxsLXJpZ2h0IGp2LXBvaW50ZXInPlxyXG4gICAgICAgIDxpIGNsYXNzPSdmYSBmYS10aW1lcyc+PC9pPlxyXG4gICAgPC9kaXY+XHJcbjwvZGl2PlxyXG5cclxuPCEtLUxpbmUgZGl2aWRpbmcgdG9wIGJhciB3aXRoIGZvcm0gb3B0aW9ucyBiZWxvdy0tPlxyXG48aHIgc3R5bGU9J21hcmdpbjozcHggMCAzcHggMDsnLz5cclxuXHJcbjwhLS1Gb3JtIE9wdGlvbnMtLT5cclxuPGRpdiBpZD1cImZvcm0nK2NoYXJ0LmNvbmZpZy5uYW1lKydcIj5cclxuXHJcbiAgICA8IS0tTnVtYmVyIGZvcm1hdHRpbmcgb3B0aW9ucy0tPlxyXG4gICAgPGRpdiBjbGFzcz1cImp2LWZ1bGwtd2lkdGggZWRpdGFibGUtbnVtLWZvcm1hdFwiIHN0eWxlPVwiZGlzcGxheTogbm9uZTtcIj5cclxuICAgICAgICA8ZGl2IGNsYXNzPVwianYtZWRpdC1tb2RlLWlucHV0XCI+TnVtYmVyIEZvcm1hdDpcclxuICAgICAgICAgICAgPHNlbGVjdCBpZD1cImVkaXRhYmxlLW51bS1mb3JtYXRcIj5cclxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJcIj4tLVNlbGVjdCBPcHRpb24tLTwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cImN1cnJlbmN5XCI+Q3VycmVuY3k8L29wdGlvbj5cclxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJmaXhlZEN1cnJlbmN5XCI+Rml4ZWQgUG9pbnQgQ3VycmVuY3k8L29wdGlvbj5cclxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJwZXJjZW50XCI+UGVyY2VudDwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIm1pbGxpb25zXCI+TWlsbGlvbnM8L29wdGlvbj5cclxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJjb21tYXNcIj5Db21tYXM8L29wdGlvbj5cclxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJub25lXCI+Tm9uZTwvb3B0aW9uPlxyXG4gICAgICAgICAgICA8L3NlbGVjdD5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8YnIvPlxyXG4gICAgPC9kaXY+XHJcblxyXG4gICAgPCEtLVRleHQgZm9ybWF0dGluZyBvcHRpb25zLS0+XHJcbiAgICA8ZGl2IGNsYXNzPVwiZWRpdGFibGUtdGV4dC1zaXplLWJ1dHRvbnMganYtY2VudGVyIHRvcEJhck9wdGlvbiBpbmNyZWFzZWZvbnQganYtcG9pbnRlclwiIHN0eWxlPVwiZGlzcGxheTogbm9uZTtcIj5cclxuICAgICAgICA8YnV0dG9uIGlkPSdkZWNyZWFzZUZvbnRTaXplJyB0aXRsZT0nRGVjcmVhc2UgdGhlIGZvbnQgc2l6ZScgY2xhc3M9J3RvcGJhci1idXR0b24gZm9udCBqdi1idXR0b24ganYtcG9pbnRlcic+PGkgY2xhc3M9J2ZhIGZhLWZvbnQnPjwvaT48aSBjbGFzcz0nZmEgZmEtbG9uZy1hcnJvdy1kb3duJz48L2k+PC9idXR0b24+XHJcbiAgICAgICAgPGJ1dHRvbiBpZD0naW5jcmVhc2VGb250U2l6ZScgdGl0bGU9J0luY3JlYXNlIHRoZSBmb250IHNpemUnIGNsYXNzPSd0b3BiYXItYnV0dG9uIGZvbnQganYtYnV0dG9uIGp2LXBvaW50ZXInPjxpIGNsYXNzPSdmYSBmYS1mb250Jz48L2k+PGkgY2xhc3M9J2ZhIGZhLWxvbmctYXJyb3ctdXAnPjwvaT48L2J1dHRvbj5cclxuICAgIDwvZGl2PlxyXG5cclxuXHJcbiAgICA8ZGl2IGNsYXNzPVwianYtZnVsbC13aWR0aCBlZGl0YWJsZS10ZXh0LWNvbG9yXCIgc3R5bGU9XCJkaXNwbGF5OiBub25lO1wiPlxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJqdi1lZGl0LW1vZGUtaW5wdXRcIj5UZXh0IENvbG9yOlxyXG4gICAgICAgICAgICA8aW5wdXQgdHlwZT1cImNvbG9yXCIgaWQ9XCJlZGl0YWJsZS10ZXh0LWNvbG9yXCIgdmFsdWU9XCIjMDAwMDAwXCI+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPGJyLz5cclxuICAgIDwvZGl2PlxyXG5cclxuICAgIDxkaXYgY2xhc3M9XCJqdi1mdWxsLXdpZHRoIGVkaXRhYmxlLXRleHQtc2l6ZVwiIHN0eWxlPVwiZGlzcGxheTogbm9uZTtcIj5cclxuICAgICAgICA8ZGl2IGNsYXNzPVwianYtZWRpdC1tb2RlLWlucHV0XCI+VGV4dCBTaXplOlxyXG4gICAgICAgICAgICA8aW5wdXQgdHlwZT1cIm51bWJlclwiIGlkPVwiZWRpdGFibGUtdGV4dC1zaXplXCIgbWluPVwiMFwiIG1heD1cIjMwXCIgdmFsdWU9XCIxMlwiPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDxici8+XHJcbiAgICA8L2Rpdj5cclxuXHJcbiAgICA8ZGl2IGNsYXNzPVwianYtZnVsbC13aWR0aCBlZGl0YWJsZS1jb250ZW50XCIgc3R5bGU9XCJkaXNwbGF5OiBub25lO1wiPlxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJqdi1lZGl0LW1vZGUtaW5wdXRcIj5UZXh0OlxyXG4gICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBpZD1cImVkaXRhYmxlLWNvbnRlbnRcIiBwbGFjZWhvbGRlcj1cIkVudGVyIHRleHQgaGVyZVwiPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDxici8+XHJcbiAgICA8L2Rpdj5cclxuXHJcbiAgICA8IS0tYmFyIGNoYXJ0IGZvcm1hdHRpbmctLT5cclxuICAgIDxkaXYgY2xhc3M9XCJqdi1mdWxsLXdpZHRoIGVkaXRhYmxlLWJhclwiIHN0eWxlPVwiZGlzcGxheTogbm9uZTtcIj5cclxuICAgICAgICA8ZGl2IGNsYXNzPVwianYtZWRpdC1tb2RlLWlucHV0XCI+QmFyIENvbG9yOlxyXG4gICAgICAgICAgICA8aW5wdXQgdHlwZT1cImNvbG9yXCIgaWQ9XCJlZGl0YWJsZS1iYXJcIiB2YWx1ZT1cIiNhYWFhYWFcIj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8YnIvPlxyXG4gICAgPC9kaXY+XHJcblxyXG4gICAgPCEtLXBpZSBjaGFydCBmb3JtYXR0aW5nLS0+XHJcbiAgICA8ZGl2IGNsYXNzPVwianYtZnVsbC13aWR0aCBlZGl0YWJsZS1waWVcIiBzdHlsZT1cImRpc3BsYXk6IG5vbmU7XCI+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cImp2LWVkaXQtbW9kZS1pbnB1dFwiPlBpZSBTbGljZSBDb2xvcjpcclxuICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJjb2xvclwiIGlkPVwiZWRpdGFibGUtcGllXCIgdmFsdWU9XCIjYWFhYWFhXCI+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPGJyLz5cclxuICAgIDwvZGl2PlxyXG5cclxuICAgIDwhLS1zY2F0dGVyIHBsb3QgZm9ybWF0dGluZy0tPlxyXG4gICAgPGRpdiBjbGFzcz1cImp2LWZ1bGwtd2lkdGggZWRpdGFibGUtc2NhdHRlclwiIHN0eWxlPVwiZGlzcGxheTogbm9uZTtcIj5cclxuICAgICAgICA8ZGl2IGNsYXNzPVwianYtZWRpdC1tb2RlLWlucHV0XCI+U2NhdHRlciBDaXJjbGUgQ29sb3I6XHJcbiAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwiY29sb3JcIiBpZD1cImVkaXRhYmxlLXNjYXR0ZXJcIiB2YWx1ZT1cIiNhYWFhYWFcIj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8YnIvPlxyXG4gICAgPC9kaXY+XHJcblxyXG4gICAgPCEtLWJ1YmJsZSBjaGFydCBmb3JtYXR0aW5nLS0+XHJcbiAgICA8ZGl2IGNsYXNzPVwianYtZnVsbC13aWR0aCBlZGl0YWJsZS1idWJibGVcIiBzdHlsZT1cImRpc3BsYXk6IG5vbmU7XCI+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cImp2LWVkaXQtbW9kZS1pbnB1dFwiPkJ1YmJsZSBDb2xvcjpcclxuICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJjb2xvclwiIGlkPVwiZWRpdGFibGUtYnViYmxlXCIgdmFsdWU9XCIjYWFhYWFhXCI+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPGJyLz5cclxuICAgIDwvZGl2PlxyXG5cclxuICAgIDwhLS1ib3ggYW5kIHdoaXNrZXIgcGxvdCBmb3JtYXR0aW5nLS0+XHJcbiAgICA8ZGl2IGNsYXNzPVwianYtZnVsbC13aWR0aCBlZGl0YWJsZS1ib3hcIiBzdHlsZT1cImRpc3BsYXk6IG5vbmU7XCI+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cImp2LWVkaXQtbW9kZS1pbnB1dFwiPkJveCBDb2xvcjpcclxuICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJjb2xvclwiIGlkPVwiZWRpdGFibGUtYm94XCIgdmFsdWU9XCIjYWFhYWFhXCI+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPGJyLz5cclxuICAgIDwvZGl2PlxyXG5cclxuICAgIDwhLS1TdWJtaXQgYnV0dG9uLS0+XHJcbiAgICA8ZGl2IGNsYXNzPVwiZWRpdGFibGUtZGVmYXVsdC1hbmQtYXBwbHlcIj5cclxuICAgICAgICA8YnV0dG9uIGlkPVwic3VibWl0RWRpdE1vZGVEZWZhdWx0XCIgY2xhc3M9XCJqdi1idXR0b24ganYtcHVsbC1sZWZ0XCI+RGVmYXVsdDwvYnV0dG9uPlxyXG4gICAgICAgIDxidXR0b24gaWQ9XCJzdWJtaXRFZGl0TW9kZVwiIGNsYXNzPVwianYtYnV0dG9uIGp2LWJ1dHRvbi1ncmVlbiBqdi1wdWxsLXJpZ2h0XCI+QXBwbHk8L2J1dHRvbj5cclxuICAgIDwvZGl2PlxyXG48L2Rpdj5gO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBodG1sOyIsIid1c2Ugc3RyaWN0JztcclxuLy9hZGQgYWxsIHJlcXVpcmVkIGZpbGVzXHJcbnJlcXVpcmUoJy4vanZWYXJzLmpzJyk7XHJcbnJlcXVpcmUoJy4vanZFdmVudHMuanMnKTtcclxucmVxdWlyZSgnLi9qdlRpcC5qcycpO1xyXG5yZXF1aXJlKCcuL2p2QnJ1c2guanMnKTtcclxucmVxdWlyZSgnLi9qdkNvbW1lbnQuanMnKTtcclxucmVxdWlyZSgnLi9qdkVkaXQuanMnKTtcclxucmVxdWlyZSgnLi92aXN1YWxzL2p2QmFyLmpzJyk7XHJcbnJlcXVpcmUoJy4vdmlzdWFscy9qdlBpZS5qcycpO1xyXG5yZXF1aXJlKCcuL3Zpc3VhbHMvanZMaW5lLmpzJyk7XHJcbnJlcXVpcmUoJy4vdmlzdWFscy9qdlNjYXR0ZXIuanMnKTtcclxucmVxdWlyZSgnLi92aXN1YWxzL2p2QXJlYS5qcycpO1xyXG5yZXF1aXJlKCcuL3Zpc3VhbHMvanZHYW50dC5qcycpO1xyXG5yZXF1aXJlKCcuL3Zpc3VhbHMvanZIZWF0bWFwLmpzJyk7XHJcbnJlcXVpcmUoJy4vdmlzdWFscy9qdlBhY2suanMnKTtcclxucmVxdWlyZSgnLi92aXN1YWxzL2p2UmFkaWFsLmpzJyk7XHJcbnJlcXVpcmUoJy4vdmlzdWFscy9qdlNhbmtleS5qcycpO1xyXG5yZXF1aXJlKCcuL3Zpc3VhbHMvanZTaW5nbGVBeGlzLmpzJyk7XHJcbnJlcXVpcmUoJy4vdmlzdWFscy9qdlN1bmJ1cnN0LmpzJyk7XHJcbnJlcXVpcmUoJy4vdmlzdWFscy9qdlRyZWVtYXAuanMnKTtcclxucmVxdWlyZSgnLi92aXN1YWxzL2p2V29yZENsb3VkLmpzJyk7XHJcbnJlcXVpcmUoJy4vdmlzdWFscy9qdkJveFdoaXNrZXIuanMnKTtcclxucmVxdWlyZSgnLi92aXN1YWxzL2p2QnViYmxlLmpzJyk7XHJcbnJlcXVpcmUoJy4vdmlzdWFscy9qdkNsdXN0ZXJncmFtLmpzJyk7XHJcblxyXG4vL2F0dGFjaCBqdiBjaGFydHMgb2JqZWN0cyB0byB0aGUgd2luZG93XHJcbnZhciBqdkNoYXJ0cyA9IHJlcXVpcmUoJy4vanZDaGFydHMuanMnKTtcclxudmFyIGp2QnJ1c2ggPSByZXF1aXJlKCcuL2p2QnJ1c2guanMnKTtcclxudmFyIGp2Q29tbWVudCA9IHJlcXVpcmUoJy4vanZDb21tZW50LmpzJyk7XHJcbnZhciBqdkVkaXQgPSByZXF1aXJlKCcuL2p2RWRpdC5qcycpO1xyXG52YXIganZTZWxlY3QgPSByZXF1aXJlKCcuL2p2U2VsZWN0Jyk7XHJcbi8vIHZhciBqdkRvb2RsZSA9IHJlcXVpcmUoJy4vanZEb29kbGUuanMnKTtcclxuXHJcbi8vQ29tbWVudCBvdXQgdG8gcmVtb3ZlIGZyb20gd2luZG93IG9iamVjdCAtIGlmIHlvdSBhcmUgbm90IHVzaW5nIGp2Q2hhcnRzIGFzIGEgbWluaWZpZWQgZmlsZVxyXG53aW5kb3cuanZDaGFydHMgPSBqdkNoYXJ0cztcclxud2luZG93Lmp2QnJ1c2ggPSBqdkJydXNoO1xyXG53aW5kb3cuanZDb21tZW50ID0ganZDb21tZW50O1xyXG53aW5kb3cuanZFZGl0ID0ganZFZGl0O1xyXG53aW5kb3cuanZTZWxlY3QgPSBqdlNlbGVjdDtcclxuXHJcblxyXG4vL2FkZCBwb2x5ZmlsbCBmb3IgT2JqZWN0LmFzc2lnbigpIGlmIHVuc3VwcG9ydGVkXHJcbmlmICh0eXBlb2YgT2JqZWN0LmFzc2lnbiAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgT2JqZWN0LmFzc2lnbiA9IGZ1bmN0aW9uICh0YXJnZXQpIHsgLy8ubGVuZ3RoIG9mIGZ1bmN0aW9uIGlzIDJcclxuICAgICAgICAndXNlIHN0cmljdCc7XHJcbiAgICAgICAgaWYgKHRhcmdldCA9PSBudWxsKSB7IC8vVHlwZUVycm9yIGlmIHVuZGVmaW5lZCBvciBudWxsXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdG8gPSBPYmplY3QodGFyZ2V0KTtcclxuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDE7IGluZGV4IDwgYXJndW1lbnRzLmxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgICAgICB2YXIgbmV4dFNvdXJjZSA9IGFyZ3VtZW50c1tpbmRleF07XHJcblxyXG4gICAgICAgICAgICBpZiAobmV4dFNvdXJjZSAhPSBudWxsKSB7IC8vU2tpcCBvdmVyIGlmIHVuZGVmaW5lZCBvciBudWxsXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBuZXh0S2V5IGluIG5leHRTb3VyY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL0F2b2lkIGJ1Z3Mgd2hlbiBoYXNPd25Qcm9wZXJ0eSBpcyBzaGFkb3dlZFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobmV4dFNvdXJjZSwgbmV4dEtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9bbmV4dEtleV0gPSBuZXh0U291cmNlW25leHRLZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdG87XHJcbiAgICB9O1xyXG59XHJcbiIsIi8qKiogIGp2QnJ1c2ggKioqL1xyXG4ndXNlLXN0cmljdCc7XHJcblxyXG4vKipqdiBCcnVzaCBGbG93XHJcbipcclxuKiAgMS4gY3JlYXRlIG5ldyBqdkJydXNoIG9iamVjdCB3aXRoIGEgY29uZmlnIG9iamVjdCBjb250YWluaW5nIHRoZSBzcGVjaWZpYyBqdkNoYXJ0IGFuZCBhbiBvbkJydXNoQ2FsbGJhY2tcclxuKiAgMi4ganZCcnVzaCBleHBvc2VzIHN0YXJ0QnJ1c2ggYW5kIHJlbW92ZUJydXNoIGZ1bmN0aW9uc1xyXG4qICAzLiBpZiBzdGFydEJydXNoIGlzIGNhbGxlZCB3aXRoIGEgZDMuZXZlbnQsIGJydXNoIHdpbGwgYXNzdW1lIHRoYXQgYSBmb3JjZSBjbGljayBldmVudCBzaG91bGQgYmUgZmlyZWQgYXQgdGhlIGxvY2F0aW9uIG9mIHRoZSBkMy5ldmVudFxyXG4qICA0LiBpZiBhIGQzLmV2ZW50IGlzIG5vdCBnaXZlbiB0byBzdGFydEJydXNoKCksIGEgYnJ1c2ggbGlzZW5lciB3aWxsIGJlIGFkZGVkIHRvIHRoZSB2aXN1YWwgdG8gbGlzdGVuIGZvciB0aGUgdXNlciB0byBicnVzaFxyXG4qICA1LiBBZnRlciB0aGUgdXNlciBmaW5pc2hzIGJydXNoaW5nIGFuIGFyZWEgb2YgdGhlIGNoYXJ0LCBicnVzaEVuZCgpIGlzIGNhbGxlLlxyXG4qICA2LiBicnVzaEVuZCgpIHdpbGwgY3JlYXRlIGEgZGF0YSBvYmplY3QgZm9yIHRoZSBicnVzaGVkIGFyZWEgaW4gdGhlIGZvcm1hdDpcclxuKiAgICAgIHsnbGFiZWwxJzogWyd2YWx1ZTEnLCd2YWx1ZTInXX1cclxuKiAgICAgIEV4YW1wbGVcclxuKiAgICAgIHsnTW92aWVfR2VucmUnOiBbJ0RyYW1hJywnRG9jdW1lbnRhcnknLCdBY3Rpb24nXX1cclxuKiAgNy4gYnJ1c2hFbmQgd2lsbCB0aGVuIGNhbGwgdGhlIG9uQnJ1c2hDYWxsYmFjayBmdW5jdGlvbiB3aXRoIHRoZSBhYm92ZSBkYXRhIG9iamVjdFxyXG4qICA4LiBicnVzaEVuZCB3aWxsIGZpbmFsbHkgY2FsbCB0aGUgcmVtb3ZlQnJ1c2goKSBmdW5jdGlvblxyXG4qL1xyXG5cclxuLyoqXHJcbiogQG5hbWUganZCcnVzaFxyXG4qIEBkZXNjIENvbnN0cnVjdG9yIGZvciBKViBCcnVzaCAtIGNyZWF0ZXMgYnJ1c2ggbW9kZSBmb3IgYSBqdiB2aXN1YWxpemF0aW9uIGFuZCBleGVjdXRlcyBhIGNhbGxiYWNrIGZvciB0aGUgdmlzdWFsIHRvIGJlIGZpbHRlcmVkXHJcbiogQHBhcmFtIHtvYmplY3R9IGNvbmZpZ09iaiAtIGNvbnN0cnVjdG9yIG9iamVjdCBjb250YWluaW5nIHRoZSBqdkNoYXJ0IGFuZCBvdGhlciBvcHRpb25zXHJcbiogQHJldHVybiB7dW5kZWZpbmVkfSAtIG5vIHJldHVyblxyXG4qL1xyXG5jbGFzcyBqdkJydXNoIHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ09iaikge1xyXG4gICAgICAgIHZhciBicnVzaE9iaiA9IHRoaXM7XHJcbiAgICAgICAgYnJ1c2hPYmouY2hhcnREaXYgPSBjb25maWdPYmouanZDaGFydC5jaGFydERpdjtcclxuICAgICAgICBicnVzaE9iai5qdkNoYXJ0ID0gY29uZmlnT2JqLmp2Q2hhcnQ7XHJcbiAgICAgICAgYnJ1c2hPYmoub25CcnVzaENhbGxiYWNrID0gY29uZmlnT2JqLm9uQnJ1c2hDYWxsYmFjaztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogQG5hbWUgcmVtb3ZlQnJ1c2hcclxuICAgICogQGRlc2MgcmVtb3ZlcyB0aGUgYnJ1c2ggYXJlYSBmcm9tIHRoZSB2aXN1YWxcclxuICAgICogQHJldHVybiB7dW5kZWZpbmVkfSAtIG5vIHJldHVyblxyXG4gICAgKi9cclxuICAgIHJlbW92ZUJydXNoKCkge1xyXG4gICAgICAgIGxldCBicnVzaE9iaiA9IHRoaXM7XHJcbiAgICAgICAgYnJ1c2hPYmouanZDaGFydC5jaGFydERpdi5zZWxlY3RBbGwoJy5icnVzaGFyZWEnKS5yZW1vdmUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogQG5hbWUgc3RhcnRCcnVzaFxyXG4gICAgKiBAZGVzYyByZW1vdmVzIHRoZSBicnVzaCBhcmVhIGZyb20gdGhlIHZpc3VhbFxyXG4gICAgKiBAcGFyYW0ge29iamVjdH0gZXZlbnQgLSBvcHRpb25hbCBldmVudCB0byBzdGFydCBicnVzaCBpbW1lZGlhdGVseSB3aXRoIGEgbmV3IG1vdXNlZG93blxyXG4gICAgKiBAcmV0dXJuIHt1bmRlZmluZWR9IC0gbm8gcmV0dXJuXHJcbiAgICAqL1xyXG4gICAgc3RhcnRCcnVzaChldmVudCA9IGZhbHNlKSB7XHJcbiAgICAgICAgbGV0IGJydXNoT2JqID0gdGhpcyxcclxuICAgICAgICAgICAgaGVpZ2h0ID0gYnJ1c2hPYmouanZDaGFydC5jb25maWcuY29udGFpbmVyLmhlaWdodCxcclxuICAgICAgICAgICAgd2lkdGggPSBicnVzaE9iai5qdkNoYXJ0LmNvbmZpZy5jb250YWluZXIud2lkdGgsXHJcbiAgICAgICAgICAgIHN2ZyA9IGJydXNoT2JqLmp2Q2hhcnQuc3ZnO1xyXG5cclxuICAgICAgICBpZiAoYnJ1c2hPYmouanZDaGFydC5jb25maWcudHlwZSA9PT0gJ3NpbmdsZWF4aXMnKSB7XHJcbiAgICAgICAgICAgIGJydXNoT2JqLmJydXNoVHlwZSA9ICd4JztcclxuICAgICAgICAgICAgc3ZnLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnYnJ1c2hhcmVhJylcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgnaGVpZ2h0JywgaGVpZ2h0ICsgJ3B4JylcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgnd2lkdGgnLCB3aWR0aCArICdweCcpXHJcbiAgICAgICAgICAgICAgICAuY2FsbChkMy5icnVzaFgoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5leHRlbnQoW1swLCAwXSwgW3dpZHRoLCBoZWlnaHRdXSlcclxuICAgICAgICAgICAgICAgICAgICAub24oJ2VuZCcsIGJydXNoRW5kLmJpbmQoYnJ1c2hPYmopKSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChicnVzaE9iai5qdkNoYXJ0LmNvbmZpZy50eXBlID09PSAnY2x1c3RlcmdyYW0nKSB7XHJcbiAgICAgICAgICAgIGJydXNoT2JqLmJydXNoVHlwZSA9ICd4eSc7XHJcbiAgICAgICAgICAgIHN2Zy5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2JydXNoYXJlYScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke2JydXNoT2JqLmp2Q2hhcnQuX3ZhcnMubGVmdFRyZWVXaWR0aH0sICR7YnJ1c2hPYmouanZDaGFydC5fdmFycy50b3BUcmVlSGVpZ2h0fSlgKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdoZWlnaHQnLCBoZWlnaHQgKyAncHgnKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCd3aWR0aCcsIHdpZHRoICsgJ3B4JylcclxuICAgICAgICAgICAgICAgIC5jYWxsKGQzLmJydXNoKClcclxuICAgICAgICAgICAgICAgICAgICAuZXh0ZW50KFtbMCwgMF0sIFt3aWR0aCwgaGVpZ2h0XV0pXHJcbiAgICAgICAgICAgICAgICAgICAgLm9uKCdlbmQnLCBicnVzaEVuZC5iaW5kKGJydXNoT2JqKSkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGJydXNoT2JqLmJydXNoVHlwZSA9ICd4eSc7XHJcbiAgICAgICAgICAgIHN2Zy5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2JydXNoYXJlYScpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2hlaWdodCcsIGhlaWdodCArICdweCcpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3dpZHRoJywgd2lkdGggKyAncHgnKVxyXG4gICAgICAgICAgICAgICAgLmNhbGwoZDMuYnJ1c2goKVxyXG4gICAgICAgICAgICAgICAgICAgIC5leHRlbnQoW1swLCAwXSwgW3dpZHRoLCBoZWlnaHRdXSlcclxuICAgICAgICAgICAgICAgICAgICAub24oJ2VuZCcsIGJydXNoRW5kLmJpbmQoYnJ1c2hPYmopKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgLy9kaXNwYXRjaCBtb3VzZWRvd24gdG8gc3RhcnQgYSBicnVzaCBhdCB0aGUgZXZlbnQgY29vcmRpbmF0ZXNcclxuICAgICAgICAgICAgbGV0IGJydXNoRWxlbWVudCA9IHN2Zy5zZWxlY3QoJy5icnVzaGFyZWEnKS5ub2RlKCksXHJcbiAgICAgICAgICAgICAgICBuZXdFdmVudCA9IG5ldyBFdmVudCgnbW91c2Vkb3duJyk7XHJcbiAgICAgICAgICAgIG5ld0V2ZW50LnBhZ2VYID0gZXZlbnQucGFnZVg7XHJcbiAgICAgICAgICAgIG5ld0V2ZW50LmNsaWVudFggPSBldmVudC5jbGllbnRYO1xyXG4gICAgICAgICAgICBuZXdFdmVudC5wYWdlWSA9IGV2ZW50LnBhZ2VZO1xyXG4gICAgICAgICAgICBuZXdFdmVudC5jbGllbnRZID0gZXZlbnQuY2xpZW50WTtcclxuICAgICAgICAgICAgbmV3RXZlbnQudmlldyA9IGV2ZW50LnZpZXc7XHJcbiAgICAgICAgICAgIGJydXNoRWxlbWVudC5fX2RhdGFfXyA9IHsgdHlwZTogJ292ZXJsYXknIH07XHJcbiAgICAgICAgICAgIGJydXNoRWxlbWVudC5kaXNwYXRjaEV2ZW50KG5ld0V2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4qIEBuYW1lIGJydXNoRW5kXHJcbiogQGRlc2MgY2FsbGVkIGF0IHRoZSBlbmQgb2YgdGhlIHVzZXIgYnJ1c2hpbmcgd2hpY2ggY2FsbHMgdGhlIG9uQnJ1c2ggY2FsbGJhY2tcclxuKiBAcmV0dXJuIHt1bmRlZmluZWR9IC0gbm8gcmV0dXJuXHJcbiovXHJcbmZ1bmN0aW9uIGJydXNoRW5kKCkge1xyXG4gICAgdmFyIGJydXNoT2JqID0gdGhpcyxcclxuICAgICAgICB4U2NhbGUgPSBicnVzaE9iai5qdkNoYXJ0LmN1cnJlbnREYXRhLnhBeGlzU2NhbGUsXHJcbiAgICAgICAgeVNjYWxlID0gYnJ1c2hPYmouanZDaGFydC5jdXJyZW50RGF0YS55QXhpc1NjYWxlLFxyXG4gICAgICAgIGZpbHRlcmVkWEF4aXNMYWJlbHMgPSBbXSxcclxuICAgICAgICBmaWx0ZXJlZFlBeGlzTGFiZWxzID0gW10sXHJcbiAgICAgICAgc2hvdWxkUmVzZXQgPSBmYWxzZSxcclxuICAgICAgICBlID0gZDMuZXZlbnQuc2VsZWN0aW9uLFxyXG4gICAgICAgIHJldHVybk9iaixcclxuICAgICAgICBmaWx0ZXJlZExhYmVscyA9IFtdLFxyXG4gICAgICAgIGZpbHRlcmVkQ29uY2VwdHMgPSB7fSxcclxuICAgICAgICBpbmRleCxcclxuICAgICAgICBmaWx0ZXJDb2wsXHJcbiAgICAgICAgZmlsdGVyZWRMYWJlbHNYLFxyXG4gICAgICAgIGZpbHRlcmVkTGFiZWxzWSxcclxuICAgICAgICBjbGVhbkRhdGFGbGFnID0gdHJ1ZTtcclxuXHJcbiAgICBpZiAoZSkge1xyXG4gICAgICAgIGlmIChicnVzaE9iai5icnVzaFR5cGUgPT09ICd4eScpIHtcclxuICAgICAgICAgICAgaWYgKHhTY2FsZSAmJiB0eXBlb2YgeFNjYWxlLmludmVydCAhPT0gJ2Z1bmN0aW9uJykgeyAvL21lYW5zIHRoYXQgdGhlIHNjYWxlIGlzIG9yZGluYWwgYW5kIG5vdCBsaW5lYXJcclxuICAgICAgICAgICAgICAgIHJldHVybk9iaiA9IGNhbGN1bGF0ZUJydXNoQXJlYU9yZGluYWwoZVswXVswXSwgZVsxXVswXSwgeFNjYWxlKTtcclxuICAgICAgICAgICAgICAgIGZpbHRlcmVkWEF4aXNMYWJlbHMgPSByZXR1cm5PYmouZmlsdGVyZWRBeGlzTGFiZWxzO1xyXG4gICAgICAgICAgICAgICAgc2hvdWxkUmVzZXQgPSByZXR1cm5PYmouc2hvdWxkUmVzZXQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoeFNjYWxlKSB7XHJcbiAgICAgICAgICAgICAgICAvL2NhbGN1bGF0ZSBsYWJlbHMgZm9yIGxpbmVhciBzY2FsZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuT2JqID0gY2FsY3VsYXRlQnJ1c2hBcmVhTGluZWFyKGVbMF1bMF0sIGVbMV1bMF0sIHhTY2FsZSwgYnJ1c2hPYmouanZDaGFydC5jdXJyZW50RGF0YSwgYnJ1c2hPYmouanZDaGFydC5jb25maWcudHlwZSwgJ3gnKTtcclxuICAgICAgICAgICAgICAgIGZpbHRlcmVkWEF4aXNMYWJlbHMgPSByZXR1cm5PYmouZmlsdGVyZWRBeGlzTGFiZWxzO1xyXG4gICAgICAgICAgICAgICAgc2hvdWxkUmVzZXQgPSByZXR1cm5PYmouc2hvdWxkUmVzZXQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh5U2NhbGUgJiYgdHlwZW9mIHlTY2FsZS5pbnZlcnQgIT09ICdmdW5jdGlvbicpIHsgLy9tZWFucyB0aGF0IHRoZSBzY2FsZSBpcyBvcmlkbmFsIGFuZCBub3QgbGluZWFyXHJcbiAgICAgICAgICAgICAgICByZXR1cm5PYmogPSBjYWxjdWxhdGVCcnVzaEFyZWFPcmRpbmFsKGVbMF1bMV0sIGVbMV1bMV0sIHlTY2FsZSk7XHJcbiAgICAgICAgICAgICAgICBmaWx0ZXJlZFlBeGlzTGFiZWxzID0gcmV0dXJuT2JqLmZpbHRlcmVkQXhpc0xhYmVscztcclxuICAgICAgICAgICAgICAgIGlmIChyZXR1cm5PYmouc2hvdWxkUmVzZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICBzaG91bGRSZXNldCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoeVNjYWxlKSB7XHJcbiAgICAgICAgICAgICAgICAvL2NhbGN1bGF0ZSBsYWJlbHMgZm9yIGxpbmVhciBzY2FsZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuT2JqID0gY2FsY3VsYXRlQnJ1c2hBcmVhTGluZWFyKGVbMF1bMV0sIGVbMV1bMV0sIHlTY2FsZSwgYnJ1c2hPYmouanZDaGFydC5jdXJyZW50RGF0YSwgYnJ1c2hPYmouanZDaGFydC5jb25maWcudHlwZSwgJ3knKTtcclxuICAgICAgICAgICAgICAgIGZpbHRlcmVkWUF4aXNMYWJlbHMgPSByZXR1cm5PYmouZmlsdGVyZWRBeGlzTGFiZWxzO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJldHVybk9iai5zaG91bGRSZXNldCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNob3VsZFJlc2V0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChicnVzaE9iai5qdkNoYXJ0LmNvbmZpZy50eXBlID09PSAnaGVhdG1hcCcpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybk9iaiA9IGNhbGN1bGF0ZUhlYXRtYXBCcnVzaChlLCBicnVzaE9iai5qdkNoYXJ0LmN1cnJlbnREYXRhLCBicnVzaE9iai5qdkNoYXJ0KTtcclxuICAgICAgICAgICAgICAgIGZpbHRlcmVkTGFiZWxzWCA9IHJldHVybk9iai5maWx0ZXJlZFhBeGlzTGFiZWxzO1xyXG4gICAgICAgICAgICAgICAgZmlsdGVyZWRMYWJlbHNZID0gcmV0dXJuT2JqLmZpbHRlcmVkWUF4aXNMYWJlbHM7XHJcbiAgICAgICAgICAgICAgICBpZiAocmV0dXJuT2JqLnNob3VsZFJlc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkUmVzZXQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGJydXNoT2JqLmp2Q2hhcnQuY29uZmlnLnR5cGUgPT09ICdjbHVzdGVyZ3JhbScpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybk9iaiA9IGNhbGN1bGF0ZUNsdXN0ZXJncmFtQnJ1c2goZSwgYnJ1c2hPYmouanZDaGFydC5jdXJyZW50RGF0YSwgYnJ1c2hPYmouanZDaGFydCk7XHJcbiAgICAgICAgICAgICAgICBmaWx0ZXJlZExhYmVsc1ggPSByZXR1cm5PYmouZmlsdGVyZWRYQXhpc0xhYmVscztcclxuICAgICAgICAgICAgICAgIGZpbHRlcmVkTGFiZWxzWSA9IHJldHVybk9iai5maWx0ZXJlZFlBeGlzTGFiZWxzO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJldHVybk9iai5zaG91bGRSZXNldCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNob3VsZFJlc2V0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoYnJ1c2hPYmouYnJ1c2hUeXBlID09PSAneCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuT2JqID0gY2FsY3VsYXRlQnJ1c2hBcmVhTGluZWFyKGVbMF0sIGVbMV0sIHhTY2FsZSwgYnJ1c2hPYmouanZDaGFydC5jdXJyZW50RGF0YSwgYnJ1c2hPYmouanZDaGFydC5jb25maWcudHlwZSwgJ3gnKTtcclxuICAgICAgICAgICAgZmlsdGVyZWRYQXhpc0xhYmVscyA9IHJldHVybk9iai5maWx0ZXJlZEF4aXNMYWJlbHM7XHJcbiAgICAgICAgICAgIGlmIChyZXR1cm5PYmouc2hvdWxkUmVzZXQpIHtcclxuICAgICAgICAgICAgICAgIHNob3VsZFJlc2V0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc2hvdWxkUmVzZXQgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChmaWx0ZXJlZFhBeGlzTGFiZWxzLmxlbmd0aCA+IDAgJiYgZmlsdGVyZWRZQXhpc0xhYmVscy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgLy9tZXJnZSBheGlzTGFiZWxzXHJcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBmaWx0ZXJlZFhBeGlzTGFiZWxzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgIGluZGV4ID0gZmlsdGVyZWRZQXhpc0xhYmVscy5pbmRleE9mKGZpbHRlcmVkWEF4aXNMYWJlbHNbal0pO1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgZmlsdGVyZWRMYWJlbHMucHVzaChmaWx0ZXJlZFhBeGlzTGFiZWxzW2pdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoZmlsdGVyZWRYQXhpc0xhYmVscy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgZmlsdGVyZWRMYWJlbHMgPSBmaWx0ZXJlZFhBeGlzTGFiZWxzO1xyXG4gICAgfSBlbHNlIGlmIChmaWx0ZXJlZFlBeGlzTGFiZWxzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBmaWx0ZXJlZExhYmVscyA9IGZpbHRlcmVkWUF4aXNMYWJlbHM7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGJydXNoT2JqLmp2Q2hhcnQuY29uZmlnLnR5cGUgPT09ICdoZWF0bWFwJykge1xyXG4gICAgICAgIGlmICghc2hvdWxkUmVzZXQpIHtcclxuICAgICAgICAgICAgbGV0IGZpbHRlckNvbFggPSBicnVzaE9iai5qdkNoYXJ0LmN1cnJlbnREYXRhLmRhdGFUYWJsZS54LFxyXG4gICAgICAgICAgICAgICAgZmlsdGVyQ29sWSA9IGJydXNoT2JqLmp2Q2hhcnQuY3VycmVudERhdGEuZGF0YVRhYmxlLnk7XHJcbiAgICAgICAgICAgIGlmIChmaWx0ZXJlZExhYmVsc1gubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgZmlsdGVyZWRDb25jZXB0c1tmaWx0ZXJDb2xYXSA9IGZpbHRlcmVkTGFiZWxzWDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZmlsdGVyZWRMYWJlbHNZLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGZpbHRlcmVkQ29uY2VwdHNbZmlsdGVyQ29sWV0gPSBmaWx0ZXJlZExhYmVsc1k7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKGJydXNoT2JqLmp2Q2hhcnQuY29uZmlnLnR5cGUgPT09ICdjbHVzdGVyZ3JhbScpIHtcclxuICAgICAgICBpZiAoIXNob3VsZFJlc2V0KSB7XHJcbiAgICAgICAgICAgIGxldCB4TGVuZ3RoID0gT2JqZWN0LmtleXMoZmlsdGVyZWRMYWJlbHNYKS5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICB5TGVuZ3RoID0gT2JqZWN0LmtleXMoZmlsdGVyZWRMYWJlbHNZKS5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHhMZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGZpbHRlckNvbFggPSBicnVzaE9iai5qdkNoYXJ0LmN1cnJlbnREYXRhLmRhdGFUYWJsZVsneF9jYXRlZ29yeSAnICsgKHhMZW5ndGggLSBpKV07XHJcbiAgICAgICAgICAgICAgICBmaWx0ZXJlZENvbmNlcHRzW2ZpbHRlckNvbFhdID0gZmlsdGVyZWRMYWJlbHNYW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgeUxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgZmlsdGVyQ29sWSA9IGJydXNoT2JqLmp2Q2hhcnQuY3VycmVudERhdGEuZGF0YVRhYmxlWyd5X2NhdGVnb3J5ICcgKyAoeUxlbmd0aCAtIGkpXTtcclxuICAgICAgICAgICAgICAgIGZpbHRlcmVkQ29uY2VwdHNbZmlsdGVyQ29sWV0gPSBmaWx0ZXJlZExhYmVsc1lbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2xlYW5EYXRhRmxhZyA9IGZhbHNlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoYnJ1c2hPYmouanZDaGFydC5jb25maWcudHlwZSA9PT0gJ2dhbnR0Jykge1xyXG4gICAgICAgICAgICBmaWx0ZXJDb2wgPSBicnVzaE9iai5qdkNoYXJ0LmN1cnJlbnREYXRhLmRhdGFUYWJsZS5ncm91cDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBmaWx0ZXJDb2wgPSBicnVzaE9iai5qdkNoYXJ0LmN1cnJlbnREYXRhLmRhdGFUYWJsZS5sYWJlbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmlsdGVyZWRDb25jZXB0c1tmaWx0ZXJDb2xdID0gZmlsdGVyZWRMYWJlbHM7XHJcbiAgICB9XHJcblxyXG4gICAgLy9jYWxscyBiYWNrIHRvIHVwZGF0ZSBkYXRhIHdpdGggYnJ1c2hlZCBkYXRhXHJcbiAgICBicnVzaE9iai5vbkJydXNoQ2FsbGJhY2soe1xyXG4gICAgICAgIGRhdGE6IGZpbHRlcmVkQ29uY2VwdHMsXHJcbiAgICAgICAgcmVzZXQ6IHNob3VsZFJlc2V0LFxyXG4gICAgICAgIGNsZWFuOiBjbGVhbkRhdGFGbGFnXHJcbiAgICB9KTtcclxuICAgIGJydXNoT2JqLnJlbW92ZUJydXNoKCk7XHJcbn1cclxuXHJcbi8qKlxyXG4qIEBuYW1lIGNhbGN1bGF0ZUJydXNoQXJlYU9yZGluYWxcclxuKiBAZGVzYyBjYWxjdWxhdGVzIHRoZSBvcmRpbmFsIHZhbHVlcyB0aGF0IGFyZSBpbiB0aGUgYnJ1c2hlZCBhcmVhXHJcbiogQHBhcmFtIHtudW1iZXJ9IG1vdXNlUG9zTWluIC0gbG93ZXIgYm91bmQgbW91c2UgcG9zaXRpb25cclxuKiBAcGFyYW0ge251bWJlcn0gbW91c2VQb3NNYXggLSB1cHBlciBib3VuZCBtb3VzZSBwb3NpdGlvblxyXG4qIEBwYXJhbSB7b2JqZWN0fSBzY2FsZSAtIGQzIGF4aXMgc2NhbGVcclxuKiBAcmV0dXJuIHtPYmplY3R9IC0gb2JqZWN0IG9mIGZpbHRlcmVkIHZhbHVlc1xyXG4qL1xyXG5mdW5jdGlvbiBjYWxjdWxhdGVCcnVzaEFyZWFPcmRpbmFsKG1vdXNlUG9zTWluLCBtb3VzZVBvc01heCwgc2NhbGUpIHtcclxuICAgIGxldCBkb21haW4gPSBzY2FsZS5kb21haW4oKSxcclxuICAgICAgICBwYWRkaW5nID0gc2NhbGUucGFkZGluZygpLFxyXG4gICAgICAgIHN0ZXAgPSBzY2FsZS5zdGVwKCksXHJcbiAgICAgICAgbWluSW5kZXgsIG1heEluZGV4LFxyXG4gICAgICAgIHBhZGRpbmdEaXN0YW5jZSA9IHBhZGRpbmcgKiBzdGVwIC8gMixcclxuICAgICAgICBmaWx0ZXJlZEF4aXNMYWJlbHM7XHJcblxyXG4gICAgLy9kZXRlcm1pbmUgbWluIGluZGV4XHJcbiAgICBpZiAobW91c2VQb3NNaW4gJSBzdGVwID4gc3RlcCAtIHBhZGRpbmdEaXN0YW5jZSkge1xyXG4gICAgICAgIC8vZG9uJ3QgaW5jbHVkZSBvbiBtaW4gc2lkZVxyXG4gICAgICAgIG1pbkluZGV4ID0gKE1hdGguZmxvb3IobW91c2VQb3NNaW4gLyBzdGVwKSArIDEpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAvL2luY2x1ZGUgb24gbWluIHNpZGVcclxuICAgICAgICBtaW5JbmRleCA9IChNYXRoLmZsb29yKG1vdXNlUG9zTWluIC8gc3RlcCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vZGV0ZXJtaW5lIG1heCBpbmRleFxyXG4gICAgaWYgKG1vdXNlUG9zTWF4ICUgc3RlcCA8IHBhZGRpbmdEaXN0YW5jZSkge1xyXG4gICAgICAgIC8vZG9uJ3QgaW5jbHVkZSBvbiBtYXggc2lkZVxyXG4gICAgICAgIG1heEluZGV4ID0gKE1hdGguZmxvb3IobW91c2VQb3NNYXggLyBzdGVwKSAtIDEpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAvL2luY2x1ZGUgb24gbWF4IHNpZGVcclxuICAgICAgICBtYXhJbmRleCA9IChNYXRoLmZsb29yKG1vdXNlUG9zTWF4IC8gc3RlcCkpO1xyXG4gICAgICAgIGlmIChtYXhJbmRleCA9PT0gZG9tYWluLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBtYXhJbmRleCAtPSAxO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZpbHRlcmVkQXhpc0xhYmVscyA9IGRvbWFpbi5zbGljZShtaW5JbmRleCwgbWF4SW5kZXggKyAxKTtcclxuICAgIHJldHVybiB7IGZpbHRlcmVkQXhpc0xhYmVsczogZmlsdGVyZWRBeGlzTGFiZWxzLCBzaG91bGRSZXNldDogZmlsdGVyZWRBeGlzTGFiZWxzLmxlbmd0aCA9PT0gMCB9O1xyXG59XHJcblxyXG5cclxuLyoqXHJcbiogQG5hbWUgY2FsY3VsYXRlQnJ1c2hBcmVhTGluZWFyXHJcbiogQGRlc2MgY2FsY3VsYXRlcyB0aGUgbGluZWFyIHZhbHVlcyB0aGF0IGFyZSBpbiB0aGUgYnJ1c2hlZCBhcmVhXHJcbiogQHBhcmFtIHtudW1iZXJ9IG1vdXNlUG9zTWluIC0gbG93ZXIgYm91bmQgbW91c2UgcG9zaXRpb25cclxuKiBAcGFyYW0ge251bWJlcn0gbW91c2VQb3NNYXggLSB1cHBlciBib3VuZCBtb3VzZSBwb3NpdGlvblxyXG4qIEBwYXJhbSB7b2JqZWN0fSBzY2FsZSAtIGQzIGF4aXMgc2NhbGVcclxuKiBAcGFyYW0ge29iamVjdH0gZGF0YSAtIGNoYXJ0RGF0YVxyXG4qIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gdmlzdWFsIHR5cGVcclxuKiBAcGFyYW0ge3N0cmluZ30gYXhpcyAtIHggLyB5IC8gelxyXG4qIEByZXR1cm4ge09iamVjdH0gLSBvYmplY3Qgb2YgZmlsdGVyZWQgdmFsdWVzXHJcbiovXHJcbmZ1bmN0aW9uIGNhbGN1bGF0ZUJydXNoQXJlYUxpbmVhcihtb3VzZVBvc01pbiwgbW91c2VQb3NNYXgsIHNjYWxlLCBkYXRhLCB0eXBlLCBheGlzKSB7XHJcbiAgICBsZXQgZmlsdGVyZWRBeGlzTGFiZWxzID0gW10sXHJcbiAgICAgICAgbWluLFxyXG4gICAgICAgIG1heCxcclxuICAgICAgICBheGlzTGFiZWw7XHJcblxyXG4gICAgLy9zd2l0Y2ggbWluIGFuZCBtYXggaWYgc2NhbGUgaXMgeSBkdWUgdG8gc3ZnIGRyYXdpbmcgKHkgYXhpcyBpbmNyZWFzZXMgdXAgdGhlIHNjcmVlbiB3aGlsZSBtb3VzZVBvcyBkZWNyZWFzZXMpXHJcbiAgICBpZiAoYXhpcyA9PT0gJ3knKSB7XHJcbiAgICAgICAgbWF4ID0gc2NhbGUuaW52ZXJ0KG1vdXNlUG9zTWluKTtcclxuICAgICAgICBtaW4gPSBzY2FsZS5pbnZlcnQobW91c2VQb3NNYXgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBtaW4gPSBzY2FsZS5pbnZlcnQobW91c2VQb3NNaW4pO1xyXG4gICAgICAgIG1heCA9IHNjYWxlLmludmVydChtb3VzZVBvc01heCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHR5cGUgPT09ICdiYXInKSB7XHJcbiAgICAgICAgZm9yIChheGlzTGFiZWwgb2YgZGF0YS5sZWdlbmREYXRhKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGRhdGFFbGVtZW50IG9mIGRhdGEuY2hhcnREYXRhKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0YUVsZW1lbnRbYXhpc0xhYmVsXSA+PSBtaW4pIHtcclxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJlZEF4aXNMYWJlbHMucHVzaChkYXRhRWxlbWVudFtkYXRhLmRhdGFUYWJsZS5sYWJlbF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnZ2FudHQnKSB7XHJcbiAgICAgICAgbWF4ID0gbmV3IERhdGUobWF4KTtcclxuICAgICAgICBtaW4gPSBuZXcgRGF0ZShtaW4pO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZWdlbmREYXRhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBjb3VudCA9IGkgKyAxLFxyXG4gICAgICAgICAgICAgICAgc3RhcnREYXRlLFxyXG4gICAgICAgICAgICAgICAgZW5kRGF0ZTtcclxuICAgICAgICAgICAgZm9yIChsZXQgZGF0YUVsZW1lbnQgb2YgZGF0YS5jaGFydERhdGEpIHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZSA9IG5ldyBEYXRlKGRhdGFFbGVtZW50W2RhdGEuZGF0YVRhYmxlWydzdGFydCAnICsgY291bnRdXSk7XHJcbiAgICAgICAgICAgICAgICBlbmREYXRlID0gbmV3IERhdGUoZGF0YUVsZW1lbnRbZGF0YS5kYXRhVGFibGVbJ2VuZCAnICsgY291bnRdXSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHN0YXJ0RGF0ZSA8PSBtYXggJiYgc3RhcnREYXRlID49IG1pbikgfHwgKGVuZERhdGUgPD0gbWF4ICYmIGVuZERhdGUgPj0gbWluKSB8fCAoc3RhcnREYXRlIDw9IG1pbiAmJiBlbmREYXRlID49IG1heCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJlZEF4aXNMYWJlbHMucHVzaChkYXRhRWxlbWVudFtkYXRhLmRhdGFUYWJsZS5ncm91cF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnbGluZScgfHwgdHlwZSA9PT0gJ2FyZWEnIHx8IHR5cGUgPT09ICdzaW5nbGVheGlzJykge1xyXG4gICAgICAgIGZvciAoYXhpc0xhYmVsIG9mIGRhdGEubGVnZW5kRGF0YSkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBkYXRhRWxlbWVudCBvZiBkYXRhLmNoYXJ0RGF0YSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRhdGFFbGVtZW50W2F4aXNMYWJlbF0gPD0gbWF4ICYmIGRhdGFFbGVtZW50W2F4aXNMYWJlbF0gPj0gbWluKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyZWRBeGlzTGFiZWxzLnB1c2goZGF0YUVsZW1lbnRbZGF0YS5kYXRhVGFibGUubGFiZWxdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3NjYXR0ZXJwbG90Jykge1xyXG4gICAgICAgIGF4aXNMYWJlbCA9IGRhdGEuZGF0YVRhYmxlW2F4aXNdO1xyXG4gICAgICAgIGZvciAobGV0IGRhdGFFbGVtZW50IG9mIGRhdGEuY2hhcnREYXRhKSB7XHJcbiAgICAgICAgICAgIGlmIChkYXRhRWxlbWVudFtheGlzTGFiZWxdIDw9IG1heCAmJiBkYXRhRWxlbWVudFtheGlzTGFiZWxdID49IG1pbikge1xyXG4gICAgICAgICAgICAgICAgZmlsdGVyZWRBeGlzTGFiZWxzLnB1c2goZGF0YUVsZW1lbnRbZGF0YS5kYXRhVGFibGUubGFiZWxdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2JveHdoaXNrZXInKSB7XHJcbiAgICAgICAgaWYgKGF4aXMgPT09ICd5Jykge1xyXG4gICAgICAgICAgICBheGlzTGFiZWwgPSBkYXRhLmRhdGFUYWJsZS52YWx1ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBheGlzTGFiZWwgPSBkYXRhLmRhdGFUYWJsZS5sYWJlbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAobGV0IGRhdGFFbGVtZW50IG9mIGRhdGEuY2hhcnREYXRhKSB7XHJcbiAgICAgICAgICAgIGlmIChkYXRhRWxlbWVudFtheGlzTGFiZWxdIDw9IG1heCAmJiBkYXRhRWxlbWVudFtheGlzTGFiZWxdID49IG1pbikge1xyXG4gICAgICAgICAgICAgICAgZmlsdGVyZWRBeGlzTGFiZWxzLnB1c2goZGF0YUVsZW1lbnRbZGF0YS5kYXRhVGFibGUubGFiZWxdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2hlYXRtYXAnKSB7XHJcbiAgICAgICAgYXhpc0xhYmVsID0gZGF0YS5kYXRhVGFibGVbYXhpc107XHJcbiAgICAgICAgZm9yIChsZXQgZGF0YUVsZW1lbnQgb2YgZGF0YS5jaGFydERhdGEpIHtcclxuICAgICAgICAgICAgaWYgKGRhdGFFbGVtZW50W2F4aXNMYWJlbF0gPD0gbWF4ICYmIGRhdGFFbGVtZW50W2F4aXNMYWJlbF0gPj0gbWluKSB7XHJcbiAgICAgICAgICAgICAgICBmaWx0ZXJlZEF4aXNMYWJlbHMucHVzaChkYXRhRWxlbWVudFtkYXRhLmRhdGFUYWJsZS5sYWJlbF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHsgZmlsdGVyZWRBeGlzTGFiZWxzOiBmaWx0ZXJlZEF4aXNMYWJlbHMsIHNob3VsZFJlc2V0OiBmaWx0ZXJlZEF4aXNMYWJlbHMubGVuZ3RoID09PSAwIH07XHJcbn1cclxuXHJcbi8qKlxyXG4qIEBuYW1lIGNhbGN1bGF0ZUhlYXRtYXBCcnVzaFxyXG4qIEBkZXNjIGNhbGN1bGF0ZXMgdmFsdWVzIGluc2lkZSBvZiBicnVzaGVkIGFyZWEgb2YgYSBoZWF0bWFwXHJcbiogQHBhcmFtIHthcnJheX0gZSAtIG1vdXNlIGV4dGVudCBmb3IgbG9jYXRpb24gb2YgYnJ1c2hlZCBhcmVhXHJcbiogQHBhcmFtIHthcnJheX0gZGF0YSAtIGNoYXJ0IGRhdGFcclxuKiBAcGFyYW0ge2FycmF5fSBjaGFydCAtIGp2Q2hhcnRcclxuKiBAcmV0dXJuIHtvYmplY3R9IC0gZmlsdGVyZWQgZGF0YVxyXG4qL1xyXG5mdW5jdGlvbiBjYWxjdWxhdGVIZWF0bWFwQnJ1c2goZSwgZGF0YSwgY2hhcnQpIHtcclxuICAgIGxldCBtb3VzZVhtaW4gPSBlWzBdWzBdLFxyXG4gICAgICAgIG1vdXNlWW1pbiA9IGVbMF1bMV0sXHJcbiAgICAgICAgbW91c2VYbWF4ID0gZVsxXVswXSxcclxuICAgICAgICBtb3VzZVltYXggPSBlWzFdWzFdLFxyXG4gICAgICAgIGZpbHRlcmVkWEF4aXNMYWJlbHMgPSBbXSxcclxuICAgICAgICBmaWx0ZXJlZFlBeGlzTGFiZWxzID0gW10sXHJcbiAgICAgICAgcmVzZXQgPSB0cnVlLFxyXG4gICAgICAgIHhCdWNrZXRNYXggPSBNYXRoLmZsb29yKG1vdXNlWG1heCAvIGNoYXJ0Ll92YXJzLmhlYXRHcmlkU2l6ZSkgKyAxLFxyXG4gICAgICAgIHlCdWNrZXRNYXggPSBNYXRoLmZsb29yKG1vdXNlWW1heCAvIGNoYXJ0Ll92YXJzLmhlYXRHcmlkU2l6ZSkgKyAxLFxyXG4gICAgICAgIHhCdWNrZXRNaW4gPSBNYXRoLmZsb29yKG1vdXNlWG1pbiAvIGNoYXJ0Ll92YXJzLmhlYXRHcmlkU2l6ZSksXHJcbiAgICAgICAgeUJ1Y2tldE1pbiA9IE1hdGguZmxvb3IobW91c2VZbWluIC8gY2hhcnQuX3ZhcnMuaGVhdEdyaWRTaXplKTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHhCdWNrZXRNYXg7IGkrKykge1xyXG4gICAgICAgIGlmIChpID49IHhCdWNrZXRNaW4pIHtcclxuICAgICAgICAgICAgZmlsdGVyZWRYQXhpc0xhYmVscy5wdXNoKGRhdGEueEF4aXNEYXRhLnZhbHVlc1tpXSk7XHJcbiAgICAgICAgICAgIHJlc2V0ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB5QnVja2V0TWF4OyBpKyspIHtcclxuICAgICAgICBpZiAoaSA+PSB5QnVja2V0TWluKSB7XHJcbiAgICAgICAgICAgIGZpbHRlcmVkWUF4aXNMYWJlbHMucHVzaChkYXRhLnlBeGlzRGF0YS52YWx1ZXNbaV0pO1xyXG4gICAgICAgICAgICByZXNldCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4geyBmaWx0ZXJlZFhBeGlzTGFiZWxzOiBmaWx0ZXJlZFhBeGlzTGFiZWxzLCBmaWx0ZXJlZFlBeGlzTGFiZWxzOiBmaWx0ZXJlZFlBeGlzTGFiZWxzLCBzaG91bGRSZXNldDogcmVzZXQgfTtcclxufVxyXG5cclxuLyoqXHJcbiogQG5hbWUgY2FsY3VsYXRlQ2x1c3RlcmdyYW1CcnVzaFxyXG4qIEBkZXNjIGNhbGN1bGF0ZXMgdmFsdWVzIGluc2lkZSBvZiBicnVzaGVkIGFyZWEgb2YgYSBjbHVzdGVyZ3JhbVxyXG4qIEBwYXJhbSB7YXJyYXl9IGUgLSBtb3VzZSBleHRlbnQgZm9yIGxvY2F0aW9uIG9mIGJydXNoZWQgYXJlYVxyXG4qIEBwYXJhbSB7YXJyYXl9IGRhdGEgLSBjaGFydCBkYXRhXHJcbiogQHBhcmFtIHthcnJheX0gY2hhcnQgLSBqdkNoYXJ0XHJcbiogQHJldHVybiB7b2JqZWN0fSAtIGZpbHRlcmVkIGRhdGFcclxuKi9cclxuZnVuY3Rpb24gY2FsY3VsYXRlQ2x1c3RlcmdyYW1CcnVzaChlLCBkYXRhLCBjaGFydCkge1xyXG4gICAgbGV0IG1vdXNlWG1pbiA9IGVbMF1bMF0sXHJcbiAgICAgICAgbW91c2VZbWluID0gZVswXVsxXSxcclxuICAgICAgICBtb3VzZVhtYXggPSBlWzFdWzBdLFxyXG4gICAgICAgIG1vdXNlWW1heCA9IGVbMV1bMV0sXHJcbiAgICAgICAgZmlsdGVyZWRYQXhpc0xhYmVscyA9IFtdLFxyXG4gICAgICAgIGZpbHRlcmVkWUF4aXNMYWJlbHMgPSBbXSxcclxuICAgICAgICByZXNldCA9IHRydWUsXHJcbiAgICAgICAgeEJ1Y2tldE1heCA9IE1hdGguZmxvb3IobW91c2VYbWF4IC8gY2hhcnQuX3ZhcnMuY2x1c3RlcmdyYW1HcmlkV2lkdGgpICsgMSxcclxuICAgICAgICB5QnVja2V0TWF4ID0gTWF0aC5mbG9vcihtb3VzZVltYXggLyBjaGFydC5fdmFycy5jbHVzdGVyZ3JhbUdyaWRIZWlnaHQpICsgMSxcclxuICAgICAgICB4QnVja2V0TWluID0gTWF0aC5mbG9vcihtb3VzZVhtaW4gLyBjaGFydC5fdmFycy5jbHVzdGVyZ3JhbUdyaWRXaWR0aCksXHJcbiAgICAgICAgeUJ1Y2tldE1pbiA9IE1hdGguZmxvb3IobW91c2VZbWluIC8gY2hhcnQuX3ZhcnMuY2x1c3RlcmdyYW1HcmlkSGVpZ2h0KSxcclxuICAgICAgICB4TGV2ZWxzID0ge30sXHJcbiAgICAgICAgeUxldmVscyA9IHt9O1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgeEJ1Y2tldE1heDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGkgPj0geEJ1Y2tldE1pbikge1xyXG4gICAgICAgICAgICBmaWx0ZXJlZFhBeGlzTGFiZWxzLnB1c2goZGF0YS54QXhpc0RhdGFbaV0pO1xyXG4gICAgICAgICAgICByZXNldCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgeUJ1Y2tldE1heDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGkgPj0geUJ1Y2tldE1pbikge1xyXG4gICAgICAgICAgICBmaWx0ZXJlZFlBeGlzTGFiZWxzLnB1c2goZGF0YS55QXhpc0RhdGFbaV0pO1xyXG4gICAgICAgICAgICByZXNldCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvL1ggQXhpc1xyXG4gICAgLy9EeW5hbWljYWxseSBjcmVhdGUgYXJyYXlzIGZvciBlYWNoIGxldmVsIG9mIHRoZSBoaWVyYXJjaHlcclxuICAgIGlmIChmaWx0ZXJlZFhBeGlzTGFiZWxzWzBdKSB7XHJcbiAgICAgICAgbGV0IHBhcmVudENvdW50WCA9IChmaWx0ZXJlZFhBeGlzTGFiZWxzWzBdLm1hdGNoKC9cXC4vZykgfHwgW10pLmxlbmd0aDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmVudENvdW50WCArIDE7IGkrKykge1xyXG4gICAgICAgICAgICB4TGV2ZWxzW2ldID0gW107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL1BvcHVsYXRlIHRoZSBoaWVyYXJjaHkgYXJyYXlzIHdpdGggdGhlIGxhYmVscyBvZiB0aGF0IHJlc3BlY3RpdmUgaGllcmFyY2h5XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWx0ZXJlZFhBeGlzTGFiZWxzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChmaWx0ZXJlZFhBeGlzTGFiZWxzW2ldKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgeEZpZWxkcyA9IGZpbHRlcmVkWEF4aXNMYWJlbHNbaV0uc3BsaXQoJy4nKTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgeEZpZWxkcy5sZW5ndGg7IGsrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh4TGV2ZWxzW2tdLmluZGV4T2YoeEZpZWxkc1trXSkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhMZXZlbHNba10ucHVzaCh4RmllbGRzW2tdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy9ZIEF4aXNcclxuICAgIC8vRHluYW1pY2FsbHkgY3JlYXRlIGFycmF5cyBmb3IgZWFjaCBsZXZlbCBvZiB0aGUgaGllcmFyY2h5XHJcbiAgICBpZiAoZmlsdGVyZWRZQXhpc0xhYmVsc1swXSkge1xyXG4gICAgICAgIGxldCBwYXJlbnRDb3VudFkgPSAoZmlsdGVyZWRZQXhpc0xhYmVsc1swXS5tYXRjaCgvXFwuL2cpIHx8IFtdKS5sZW5ndGg7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJlbnRDb3VudFkgKyAxOyBpKyspIHtcclxuICAgICAgICAgICAgeUxldmVsc1tpXSA9IFtdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9Qb3B1bGF0ZSB0aGUgaGllcmFyY2h5IGFycmF5cyB3aXRoIHRoZSBsYWJlbHMgb2YgdGhhdCByZXNwZWN0aXZlIGhpZXJhcmNoeVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlsdGVyZWRZQXhpc0xhYmVscy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZmlsdGVyZWRZQXhpc0xhYmVsc1tpXSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHlGaWVsZHMgPSBmaWx0ZXJlZFlBeGlzTGFiZWxzW2ldLnNwbGl0KCcuJyk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHlGaWVsZHMubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoeUxldmVsc1trXS5pbmRleE9mKHlGaWVsZHNba10pID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB5TGV2ZWxzW2tdLnB1c2goeUZpZWxkc1trXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7IGZpbHRlcmVkWEF4aXNMYWJlbHM6IHhMZXZlbHMsIGZpbHRlcmVkWUF4aXNMYWJlbHM6IHlMZXZlbHMsIHNob3VsZFJlc2V0OiByZXNldCB9O1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGp2QnJ1c2g7XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuLyoqKiAganZDaGFydHMgKioqL1xyXG5sZXQganZUaXAgPSByZXF1aXJlKCcuL2p2VGlwLmpzJyk7XHJcblxyXG4vKipDcmVhdGUgYSBqdkNoYXJ0cyBvYmplY3RcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdPYmogLSBDb25maWd1cmF0aW9uIG9iamVjdCBwYXNzZWQgaW50byBqdkNoYXJ0cyBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge3N0cmluZ30gY29uZmlnT2JqLnR5cGUgLSBUaGUgdHlwZSBvZiBjaGFydFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gY29uZmlnT2JqLm5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgY2hhcnRcclxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ09iai5jb250YWluZXIgLSBUaGUgY29udGFpbmVyIG9mIHRoZSBjaGFydFxyXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnT2JqLnVzZXJPcHRpb25zIC0gVUkgb3B0aW9ucyBmb3IgdGhlIGNoYXJ0XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdPYmoudGlwQ29uZmlnIC0gQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGp2VG9vbHRpcFxyXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnT2JqLmNoYXJ0RGl2IC0gQSBkaXYgd3JhcHBlciBmb3IgdGhlIGNoYXJ0IGFuZCBvdGhlciBqdiBmZWF0dXJlc1xyXG4gKi9cclxuY2xhc3MganZDaGFydHMge1xyXG4gICAgY29uc3RydWN0b3IoY29uZmlnT2JqKSB7XHJcbiAgICAgICAgbGV0IGNoYXJ0ID0gdGhpcztcclxuICAgICAgICBjb25maWdPYmoudHlwZSA9IGNvbmZpZ09iai50eXBlLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgY2hhcnQuY2hhcnREaXYgPSBjb25maWdPYmouY2hhcnREaXY7XHJcbiAgICAgICAgY29uZmlnT2JqLm9wdGlvbnMgPSBjbGVhblRvb2xEYXRhKGNvbmZpZ09iai5vcHRpb25zLCBjb25maWdPYmouZWRpdE9wdGlvbnMpO1xyXG4gICAgICAgIGNoYXJ0Ll92YXJzID0gY2hhcnQuZ2V0RGVmYXVsdE9wdGlvbnMoY29uZmlnT2JqLm9wdGlvbnMpO1xyXG4gICAgICAgIGNoYXJ0Lm1vZGUgPSBjb25maWdPYmoubW9kZSB8fCAnZGVmYXVsdC1tb2RlJztcclxuXHJcbiAgICAgICAgLy9yZW1vdmUgcGllY2VzIGZyb20gY29uZmlnIHRoYXQgaGF2ZSBiZWVuIGNvcGllZCBzb21ld2hlcmUgZWxzZVxyXG4gICAgICAgIGRlbGV0ZSBjb25maWdPYmouY2hhcnREaXY7XHJcbiAgICAgICAgZGVsZXRlIGNvbmZpZ09iai5vcHRpb25zO1xyXG4gICAgICAgIGRlbGV0ZSBjb25maWdPYmoubW9kZTtcclxuXHJcbiAgICAgICAgY2hhcnQuY29uZmlnID0gY29uZmlnT2JqO1xyXG5cclxuICAgICAgICAvL1N0YXJ0IHBhaW50aW5nIHRoZSBqdiBDaGFydFxyXG4gICAgICAgIGNoYXJ0LmNyZWF0ZVRvb2x0aXAoKTtcclxuICAgICAgICBjaGFydC5zZXREYXRhKCk7XHJcbiAgICAgICAgY2hhcnQucGFpbnQoKTtcclxuICAgIH1cclxuXHJcbiAgICBjcmVhdGVUb29sdGlwKCkge1xyXG4gICAgICAgIGxldCBjaGFydCA9IHRoaXM7XHJcbiAgICAgICAgY2hhcnQudGlwID0gbmV3IGp2VGlwKHtcclxuICAgICAgICAgICAgY29uZmlnOiBjaGFydC5jb25maWcudGlwQ29uZmlnLFxyXG4gICAgICAgICAgICBjaGFydERpdjogY2hhcnQuY2hhcnREaXZcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBzZXREYXRhKCkge1xyXG4gICAgICAgIGxldCBjaGFydCA9IHRoaXM7XHJcbiAgICAgICAgaWYgKGNoYXJ0LmNvbmZpZy5zZXREYXRhKSB7XHJcbiAgICAgICAgICAgIGNoYXJ0LmRhdGEgPSBjaGFydC5jb25maWcuc2V0RGF0YTtcclxuICAgICAgICAgICAgLy9yZWZlciB0byBtYWluIGRhdGEgYXMgY2hhcnREYXRhIHRvIGtlZXAgbmFtaW5nIHNlcGFyYXRlIGFuZCB1bmRlcnN0YW5kYWJsZVxyXG4gICAgICAgICAgICBjaGFydC5kYXRhLmNoYXJ0RGF0YSA9IGNoYXJ0LmNvbmZpZy5zZXREYXRhLmRhdGE7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBjaGFydC5kYXRhLmRhdGE7XHJcbiAgICAgICAgICAgIGlmIChjaGFydC5kYXRhLmRhdGFUYWJsZUtleXMpIHtcclxuICAgICAgICAgICAgICAgIGNoYXJ0LmNsZWFuRGF0YVRhYmxlS2V5cygpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoY2hhcnQuZGF0YS5oZWFkZXJzKSB7XHJcbiAgICAgICAgICAgICAgICBjaGFydC5zZXRBbGlnbkFuZEtleXMoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY2hhcnQuY29sb3JzID0gY2hhcnQuY29uZmlnLnNldERhdGEuY29sb3JzO1xyXG4gICAgICAgICAgICBjaGFydFtjaGFydC5jb25maWcudHlwZV0uc2V0RGF0YS5jYWxsKGNoYXJ0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBuYW1lIHVwZGF0ZURhdGFUYWJsZUFsaWduXHJcbiAgICAqIEBwYXJhbSB7YXJyYXl9IGN1cnJlbnRLZXlzIC0gYXJyYXkgb2Ygb2JqZWN0cyB0byBkZXNjcmliZSBob3cgdG8gYnVpbGQgdGhlIHZpc3VhbFxyXG4gICAgKiBAcmV0dXJuIHtvYmplY3R9IGRhdGFUYWJsZUFsaWduIC0ga2V5OnZhbHVlIG1hcHBpbmcgb2YgY3VycmVudCBhbGlnbm1lbnRcclxuICAgICovXHJcbiAgICBzZXRBbGlnbkFuZEtleXMoKSB7XHJcbiAgICAgICAgdmFyIGNoYXJ0ID0gdGhpcyxcclxuICAgICAgICAgICAgZGF0YVRhYmxlQWxpZ24gPSB7fSxcclxuICAgICAgICAgICAgaSxcclxuICAgICAgICAgICAgbGVuLFxyXG4gICAgICAgICAgICBrZXlNYXBwaW5nID0ge30sXHJcbiAgICAgICAgICAgIGtleXMgPSBjaGFydC5kYXRhLmhlYWRlcnM7XHJcblxyXG4gICAgICAgIC8vaXRlcmF0ZSBvdmVyIGN1cnJlbnQga2V5cyB0byBjcmVhdGUgbmV3IG9iamVjdCB3aXRoIGtleTp2YWx1ZSBtYXBwaW5nIGluc3RlYWQgb2Yga2V5OmFycmF5IG1hcHBpbmdcclxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICgha2V5TWFwcGluZy5oYXNPd25Qcm9wZXJ0eShrZXlzW2ldLm1vZGVsKSkge1xyXG4gICAgICAgICAgICAgICAga2V5TWFwcGluZ1trZXlzW2ldLm1vZGVsXSA9IDA7XHJcbiAgICAgICAgICAgICAgICBkYXRhVGFibGVBbGlnbltrZXlzW2ldLm1vZGVsXSA9IGtleXNbaV0ubmFtZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRhdGFUYWJsZUFsaWduW2tleXNbaV0ubW9kZWwgKyAnICcgKyBpXSA9IGtleXNbaV0ubmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjaGFydC5kYXRhLmRhdGFUYWJsZUtleXMgPSBjaGFydC5kYXRhLmhlYWRlcnM7XHJcbiAgICAgICAgY2hhcnQuZGF0YS5kYXRhVGFibGUgPSBkYXRhVGFibGVBbGlnbjtcclxuICAgIH1cclxuXHJcbiAgICBjbGVhbkRhdGFUYWJsZUtleXMoKSB7XHJcbiAgICAgICAgbGV0IGNoYXJ0ID0gdGhpcyxcclxuICAgICAgICAgICAgbmV3S2V5cyA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGtleSBvZiBjaGFydC5kYXRhLmRhdGFUYWJsZUtleXMpIHtcclxuICAgICAgICAgICAgbmV3S2V5cy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIG5hbWU6IGtleS52YXJLZXkgfHwga2V5LmFsaWFzIHx8IGtleS5uYW1lLFxyXG4gICAgICAgICAgICAgICAgbW9kZWw6IGtleS52aXpUeXBlIHx8IGtleS5tb2RlbCxcclxuICAgICAgICAgICAgICAgIHR5cGU6IGtleS50eXBlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjaGFydC5kYXRhLmRhdGFUYWJsZUtleXMgPSBuZXdLZXlzO1xyXG4gICAgfVxyXG5cclxuICAgIGNoZWNrRGltZW5zaW9ucygpIHtcclxuICAgICAgICBsZXQgY2hhcnQgPSB0aGlzLFxyXG4gICAgICAgICAgICBkaW1lbnNpb25zID0gY2hhcnQuY2hhcnREaXYubm9kZSgpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgIGlmIChkaW1lbnNpb25zLmhlaWdodCA+IDUwICYmIGRpbWVuc2lvbnMud2lkdGggPiAxMjApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnNvbGUubG9nKCdDaGFydCBjb250YWluZXIgaXMgdG9vIHNtYWxsIHRvIHBhaW50Jyk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHBhaW50KGFubmltYXRpb24pIHtcclxuICAgICAgICBsZXQgY2hhcnQgPSB0aGlzO1xyXG4gICAgICAgIGlmIChjaGFydC5jaGVja0RpbWVuc2lvbnMoKSkge1xyXG4gICAgICAgICAgICBpZiAoY2hhcnQuZGF0YSAmJiB0eXBlb2YgY2hhcnRbY2hhcnQuY29uZmlnLnR5cGVdID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgY2hhcnRbY2hhcnQuY29uZmlnLnR5cGVdLnBhaW50ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICBjaGFydFtjaGFydC5jb25maWcudHlwZV0ucGFpbnQuY2FsbChjaGFydCwgYW5uaW1hdGlvbik7XHJcbiAgICAgICAgICAgICAgICBjaGFydC5pbml0aWFsaXplTW9kZXMoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoY2hhcnQuX3ZhcnMuaGlnaGxpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhcnRbY2hhcnQuY29uZmlnLnR5cGVdLmhpZ2hsaWdodEZyb21FdmVudERhdGEuY2FsbChjaGFydCwgY2hhcnQuX3ZhcnMuaGlnaGxpZ2h0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdubyBwYWludCBmdW5jdGlvbiBmb3I6ICcgKyBjaGFydC5jb25maWcudHlwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc2V0QXhpc0RhdGEoYXhpcywgZGF0YSwga2V5cykge1xyXG4gICAgICAgIGxldCBjaGFydCA9IHRoaXMsXHJcbiAgICAgICAgICAgIGF4aXNEYXRhID0gW10sXHJcbiAgICAgICAgICAgIGNoYXJ0RGF0YSA9IGRhdGEuY2hhcnREYXRhLFxyXG4gICAgICAgICAgICBsYWJlbCA9ICcnLFxyXG4gICAgICAgICAgICBtYXhTdGFjayA9IDAsXHJcbiAgICAgICAgICAgIGRhdGFUYWJsZUtleXMgPSBkYXRhLmRhdGFUYWJsZUtleXMsXHJcbiAgICAgICAgICAgIGRhdGFUeXBlO1xyXG5cclxuICAgICAgICBpZiAoIWRhdGFUYWJsZUtleXMpIHtcclxuICAgICAgICAgICAgZGF0YVRhYmxlS2V5cyA9IGtleXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL1N0ZXAgMTogZmluZCBvdXQgd2hhdCB0aGUgbGFiZWwgaXMgZm9yIHRoZSBheGlzXHJcbiAgICAgICAgaWYgKGF4aXMgPT09ICd4Jykge1xyXG4gICAgICAgICAgICBpZiAoZGF0YS5kYXRhVGFibGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChkYXRhLmRhdGFUYWJsZS5oYXNPd25Qcm9wZXJ0eSgnbGFiZWwnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsID0gZGF0YS5kYXRhVGFibGUubGFiZWw7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJMYWJlbCBkb2Vzbid0IGV4aXN0IGluIGRhdGFUYWJsZVwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdEYXRhVGFibGUgZG9lcyBub3QgZXhpc3QnKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZGF0YVR5cGUgPSAnU1RSSU5HJztcclxuXHJcbiAgICAgICAgICAgIC8vUmVwbGFjZSB1bmRlcnNjb3JlcyB3aXRoIHNwYWNlc1xyXG4gICAgICAgICAgICBsYWJlbCA9IGxhYmVsLnJlcGxhY2UoL18vZywgJyAnKTtcclxuXHJcbiAgICAgICAgICAgIC8vbG9vcCB0aHJvdWdoIGRhdGEgdG8gcG9wdWxhdGUgYXhpc0RhdGFcclxuICAgICAgICAgICAgZm9yIChsZXQgY2hhcnRFbGUgb2YgY2hhcnREYXRhKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hhcnRFbGVbbGFiZWxdID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXhpc0RhdGEucHVzaCgnTlVMTF9WQUxVRScpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGFydEVsZVtsYWJlbF0gPT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXhpc0RhdGEucHVzaCgnRU1QVFlfU1RSSU5HJyk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoYXJ0RWxlW2xhYmVsXSB8fCBjaGFydEVsZVtsYWJlbF0gPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBheGlzRGF0YS5wdXNoKGNoYXJ0RWxlW2xhYmVsXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoZGF0YVRhYmxlS2V5cyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdkYXRhVGFibGVLZXlzIGRvIG5vdCBleGlzdCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vRmluZCB0aGUgbWF4IHZhbHVlIGZvciBZIERhdGFcclxuICAgICAgICAgICAgbGV0IGNvdW50ID0gMDtcclxuXHJcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBvZiBkYXRhVGFibGVLZXlzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoa2V5Lm1vZGVsICE9PSAnbGFiZWwnICYmIGtleS5tb2RlbCAhPT0gJ3Rvb2x0aXAnICYmIGtleS5tb2RlbCAhPT0gJ3NlcmllcycpIHtcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbCA9IGtleS5uYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvdW50Kys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGF0YVR5cGUgPSBnZXREYXRhVHlwZUZyb21LZXlzKGxhYmVsLCBkYXRhVGFibGVLZXlzLCAnTlVNQkVSJyk7XHJcblxyXG4gICAgICAgICAgICAvL0FkZCBhbGwgdmFsdWVzIHRoYXQgYXJlIG9uIHlheGlzIHRvIGF4aXMgZGF0YVxyXG4gICAgICAgICAgICBmb3IgKGxldCBjaGFydEVsZSBvZiBjaGFydERhdGEpIHtcclxuICAgICAgICAgICAgICAgIGxldCBzdGFjayA9IDA7IC8vS2VlcHMgdHJhY2sgb2YgdGhlIG1heGltdW0gc2l6ZSBvZiBzdGFja2VkIGRhdGEgc28gdGhhdCBheGlzIGNhbiBiZSBzY2FsZWQgdG8gZml0IG1heCBzaXplXHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrIGluIGRhdGEuZGF0YVRhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJ0RWxlLmhhc093blByb3BlcnR5KGRhdGEuZGF0YVRhYmxlW2tdKSAmJiBrICE9PSAnbGFiZWwnICYmIGsuaW5kZXhPZigndG9vbHRpcCcpID09PSAtMSAmJiBrICE9PSAnc2VyaWVzJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjayArPSBjaGFydEVsZVtkYXRhLmRhdGFUYWJsZVtrXV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4aXNEYXRhLnB1c2goY2hhcnRFbGVbZGF0YS5kYXRhVGFibGVba11dKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhY2sgPiBtYXhTdGFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgIG1heFN0YWNrID0gc3RhY2s7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vSWYgdGhlcmUgYXJlIG11bHRpcGxlIHZhbHVlcyBvbiB0aGUgeUF4aXMsIGRvbid0IHNwZWNpZnkgYSBsYWJlbFxyXG4gICAgICAgICAgICBpZiAoY291bnQgPiAxKSB7XHJcbiAgICAgICAgICAgICAgICBsYWJlbCA9ICcnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxhYmVsID0gbGFiZWwucmVwbGFjZSgvXy9nLCAnICcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9GaW5kIHRoZSBtaW4gYW5kIG1heCBvZiBudW1lcmljIGRhdGEgZm9yIGJ1aWxkaW5nIGF4ZXMgYW5kIGFkZCBpdCB0byB0aGUgcmV0dXJuZWQgb2JqZWN0XHJcbiAgICAgICAgaWYgKGRhdGFUeXBlID09PSAnTlVNQkVSJykge1xyXG4gICAgICAgICAgICBsZXQgbWF4LFxyXG4gICAgICAgICAgICAgICAgbWluLFxyXG4gICAgICAgICAgICAgICAgdGVtcCxcclxuICAgICAgICAgICAgICAgIHRlbXBNaW4sXHJcbiAgICAgICAgICAgICAgICB0ZW1wTWF4O1xyXG4gICAgICAgICAgICBpZiAoY2hhcnQuX3ZhcnMuc3RhY2tUb2dnbGUpIHtcclxuICAgICAgICAgICAgICAgIG1heCA9IG1heFN0YWNrO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbWF4ID0gTWF0aC5tYXguYXBwbHkobnVsbCwgYXhpc0RhdGEpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBtaW4gPSBNYXRoLm1pbi5hcHBseShudWxsLCBheGlzRGF0YSk7XHJcbiAgICAgICAgICAgIG1pbiA9IE1hdGgubWluKDAsIG1pbik7XHJcblxyXG4gICAgICAgICAgICAvL0NoZWNrIGlmIHRoZXJlJ3MgYW4gYXhpcyBtaW4vbWF4IHNldFxyXG4gICAgICAgICAgICBpZiAoYXhpcyA9PT0gJ3gnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hhcnQuX3ZhcnMueE1pbiAhPSBudWxsICYmIGNoYXJ0Ll92YXJzLnhNaW4gIT09ICdub25lJykge1xyXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IGNoYXJ0Ll92YXJzLnhNaW47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hhcnQuX3ZhcnMueE1heCAhPSBudWxsICYmIGNoYXJ0Ll92YXJzLnhNYXggIT09ICdub25lJykge1xyXG4gICAgICAgICAgICAgICAgICAgIG1heCA9IGNoYXJ0Ll92YXJzLnhNYXg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXhpcyA9PT0gJ3knKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hhcnQuX3ZhcnMueU1pbiAhPSBudWxsICYmIGNoYXJ0Ll92YXJzLnlNaW4gIT09ICdub25lJykge1xyXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IGNoYXJ0Ll92YXJzLnlNaW47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hhcnQuX3ZhcnMueU1heCAhPSBudWxsICYmIGNoYXJ0Ll92YXJzLnlNYXggIT09ICdub25lJykge1xyXG4gICAgICAgICAgICAgICAgICAgIG1heCA9IGNoYXJ0Ll92YXJzLnlNYXg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChkYXRhVHlwZSA9PT0gJ05VTUJFUicgJiYgYXhpc0RhdGEubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXhpc0RhdGFbMF0gPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGF4aXNEYXRhLnVuc2hpZnQoMCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGF4aXNEYXRhLnB1c2goMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRlbXBNaW4gPSBwYXJzZUludChtaW4sIDEwKTtcclxuICAgICAgICAgICAgdGVtcE1heCA9IHBhcnNlSW50KG1heCwgMTApO1xyXG4gICAgICAgICAgICAvL01ha2Ugc3VyZSB0aGF0IGF4aXMgbWluIGFuZCBtYXggZG9uJ3QgZ2V0IGZsaXBwZWRcclxuICAgICAgICAgICAgaWYgKHRlbXBNaW4gPiB0ZW1wTWF4KSB7XHJcbiAgICAgICAgICAgICAgICB0ZW1wID0gbWluO1xyXG4gICAgICAgICAgICAgICAgbWluID0gbWF4O1xyXG4gICAgICAgICAgICAgICAgbWF4ID0gdGVtcDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICdsYWJlbCc6IGxhYmVsLFxyXG4gICAgICAgICAgICAgICAgJ3ZhbHVlcyc6IGF4aXNEYXRhLFxyXG4gICAgICAgICAgICAgICAgJ2RhdGFUeXBlJzogZGF0YVR5cGUsXHJcbiAgICAgICAgICAgICAgICAnbWluJzogbWluLFxyXG4gICAgICAgICAgICAgICAgJ21heCc6IG1heFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgJ2xhYmVsJzogbGFiZWwsXHJcbiAgICAgICAgICAgICd2YWx1ZXMnOiBheGlzRGF0YSxcclxuICAgICAgICAgICAgJ2RhdGFUeXBlJzogZGF0YVR5cGVcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipzZXRGbGlwcGVkU2VyaWVzXHJcbiAgICAgKiAgZmxpcHMgc2VyaWVzIGFuZCByZXR1cm5zIGZsaXBwZWQgZGF0YVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbXMgY2hhcnREYXRhLCBkYXRhVGFibGUsIGRhdGFMYWJlbFxyXG4gICAgICogQHJldHVybnMgT2JqZWN0IG9mIGRhdGEgYW5kIHRhYmxlIGZvciBmbGlwcGVkIHNlcmllc1xyXG4gICAgICovXHJcbiAgICBzZXRGbGlwcGVkU2VyaWVzKGRhdGFUYWJsZUtleXMpIHtcclxuICAgICAgICBsZXQgY2hhcnQgPSB0aGlzLFxyXG4gICAgICAgICAgICBjaGFydERhdGEgPSBjaGFydC5kYXRhLmNoYXJ0RGF0YSxcclxuICAgICAgICAgICAgZGF0YVRhYmxlID0gY2hhcnQuZGF0YS5kYXRhVGFibGUsXHJcbiAgICAgICAgICAgIGRhdGFMYWJlbCA9IGNoYXJ0LmRhdGEueEF4aXNEYXRhLmxhYmVsLFxyXG4gICAgICAgICAgICBmbGlwcGVkRGF0YSA9IFtdLFxyXG4gICAgICAgICAgICBmbGlwcGVkRGF0YVRhYmxlID0ge30sXHJcbiAgICAgICAgICAgIHZhbHVlQ291bnQgPSAxLFxyXG4gICAgICAgICAgICBmaWx0ZXJlZERhdGFUYWJsZUFycmF5ID0gW107XHJcblxyXG4gICAgICAgIGZvciAobGV0IGsgaW4gZGF0YVRhYmxlKSB7XHJcbiAgICAgICAgICAgIGlmIChkYXRhVGFibGUuaGFzT3duUHJvcGVydHkoaykpIHtcclxuICAgICAgICAgICAgICAgIGxldCBmbGlwcGVkT2JqZWN0ID0ge307XHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0YVRhYmxlW2tdICE9PSBkYXRhTGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBmbGlwcGVkT2JqZWN0W2RhdGFMYWJlbF0gPSBkYXRhVGFibGVba107XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgY2hhcnRFbGUgb2YgY2hhcnREYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsaXBwZWRPYmplY3RbY2hhcnRFbGVbZGF0YUxhYmVsXV0gPSBjaGFydEVsZVtkYXRhVGFibGVba11dO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyZWREYXRhVGFibGVBcnJheS5pbmRleE9mKGNoYXJ0RWxlW2RhdGFMYWJlbF0pID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxpcHBlZERhdGFUYWJsZVsndmFsdWUgJyArIHZhbHVlQ291bnRdID0gY2hhcnRFbGVbZGF0YUxhYmVsXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlQ291bnQrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlcmVkRGF0YVRhYmxlQXJyYXkucHVzaChjaGFydEVsZVtkYXRhTGFiZWxdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmbGlwcGVkRGF0YS5wdXNoKGZsaXBwZWRPYmplY3QpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZsaXBwZWREYXRhVGFibGUubGFiZWwgPSBkYXRhTGFiZWw7XHJcbiAgICAgICAgY2hhcnQuZmxpcHBlZERhdGEgPSB7IGNoYXJ0RGF0YTogZmxpcHBlZERhdGEsIGRhdGFUYWJsZTogZmxpcHBlZERhdGFUYWJsZSB9O1xyXG5cclxuICAgICAgICBpZiAoY2hhcnQuY29uZmlnLnR5cGUgPT09ICdiYXInIHx8IGNoYXJ0LmNvbmZpZy50eXBlID09PSAnbGluZScgfHwgY2hhcnQuY29uZmlnLnR5cGUgPT09ICdhcmVhJykge1xyXG4gICAgICAgICAgICBjaGFydC5mbGlwcGVkRGF0YS54QXhpc0RhdGEgPSBjaGFydC5zZXRBeGlzRGF0YSgneCcsIGNoYXJ0LmZsaXBwZWREYXRhLCBkYXRhVGFibGVLZXlzKTtcclxuICAgICAgICAgICAgY2hhcnQuZmxpcHBlZERhdGEueUF4aXNEYXRhID0gY2hhcnQuc2V0QXhpc0RhdGEoJ3knLCBjaGFydC5mbGlwcGVkRGF0YSwgZGF0YVRhYmxlS2V5cyk7XHJcbiAgICAgICAgICAgIGNoYXJ0LmZsaXBwZWREYXRhLmxlZ2VuZERhdGEgPSBzZXRCYXJMaW5lTGVnZW5kRGF0YShjaGFydC5mbGlwcGVkRGF0YSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ0FkZCBhZGRpdGlvbmFsIGNoYXJ0IHR5cGUgdG8gc2V0IGZsaXBwZWQgc2VyaWVzJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKm9yZ2FuaXplQ2hhcnREYXRhXHJcbiAgICAgKiAgcmVvcmRlcnMgYWxsIGRhdGEgYmFzZWQgb24gdGhlIHNvcnRMYWJlbCBhbmQgc29ydFR5cGVcclxuICAgICAqICAtT25seSBmb3IgY2hhcnREYXRhLCBkb2VzIG5vdCB3b3JrIHdpdGggZmxpcHBlZCBkYXRhXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtcyBzb3J0TGFiZWwgLCBzb3J0VHlwZVxyXG4gICAgICogQHJldHVybnMgW10gc29ydGVkIGRhdGFcclxuICAgICAqL1xyXG4gICAgb3JnYW5pemVDaGFydERhdGEoc29ydFBhcmFtLCBzb3J0VHlwZSkge1xyXG4gICAgICAgIGxldCBjaGFydCA9IHRoaXMsXHJcbiAgICAgICAgICAgIG9yZ2FuaXplZERhdGEsXHJcbiAgICAgICAgICAgIGRhdGFUeXBlLFxyXG4gICAgICAgICAgICBkYXRhVGFibGVLZXlzID0gY2hhcnQuZGF0YS5kYXRhVGFibGVLZXlzLFxyXG4gICAgICAgICAgICBzb3J0TGFiZWwgPSBzb3J0UGFyYW07XHJcblxyXG4gICAgICAgIC8vSWYgc29ydExhYmVsIGRvZXNuJ3QgZXhpc3QsIHNvcnQgb24gdGhlIHggYXhpcyBsYWJlbCBieSBkZWZhdWx0XHJcbiAgICAgICAgaWYgKHNvcnRMYWJlbCA9PT0gJ25vbmUnKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBvZiBkYXRhVGFibGVLZXlzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoa2V5Lm1vZGVsID09PSAnbGFiZWwnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc29ydExhYmVsID0ga2V5Lm5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vUmVtb3ZlIHVuZGVyc2NvcmVzIGZyb20gc29ydExhYmVsXHJcbiAgICAgICAgaWYgKHNvcnRMYWJlbCkge1xyXG4gICAgICAgICAgICBzb3J0TGFiZWwgPSBzb3J0TGFiZWwucmVwbGFjZSgvXy9nLCAnICcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFjaGFydC5kYXRhLmNoYXJ0RGF0YVswXVtzb3J0TGFiZWxdKSB7XHJcbiAgICAgICAgICAgIC8vQ2hlY2sgaWYgdGhlIHNvcnQgbGFiZWwgaXMgYSBjYWxjdWxhdGVkQnkgZmllbGRcclxuICAgICAgICAgICAgbGV0IGlzVmFsaWRTb3J0TGFiZWwgPSBmYWxzZTtcclxuICAgICAgICAgICAgZm9yIChsZXQga2V5IG9mIGRhdGFUYWJsZUtleXMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChrZXkub3BlcmF0aW9uLmhhc093blByb3BlcnR5KCdjYWxjdWxhdGVkQnknKSAmJiBrZXkub3BlcmF0aW9uLmNhbGN1bGF0ZWRCeVswXSA9PT0gc29ydExhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc29ydExhYmVsID0ga2V5Lm5hbWUucmVwbGFjZSgvXy9nLCAnICcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlzVmFsaWRTb3J0TGFiZWwgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vSWYgaXQncyBub3QgYSB2YWxpZCBzb3J0IGxhYmVsLCByZXR1cm4gYW5kIGRvbid0IHNvcnQgdGhlIGRhdGFcclxuICAgICAgICAgICAgaWYgKCFpc1ZhbGlkU29ydExhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdOb3QgYSB2YWxpZCBzb3J0Jyk7XHJcbiAgICAgICAgICAgICAgICAvL3Rocm93IG5ldyBFcnJvcignTm90IGEgdmFsaWQgc29ydCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL0NoZWNrIHRoZSBkYXRhIHR5cGUgdG8gZGV0ZXJtaW5lIHdoaWNoIGxvZ2ljIHRvIGZsb3cgdGhyb3VnaFxyXG4gICAgICAgIGZvciAobGV0IGtleSBvZiBkYXRhVGFibGVLZXlzKSB7XHJcbiAgICAgICAgICAgIC8vTG9vcCB0aHJvdWdoIGRhdGFUYWJsZUtleXMgdG8gZmluZCBzb3J0TGFiZWxcclxuICAgICAgICAgICAgaWYgKGtleS5uYW1lLnJlcGxhY2UoL18vZywgJyAnKSA9PT0gc29ydExhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICBkYXRhVHlwZSA9IGtleS50eXBlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vRGF0ZSBzb3J0aW5nXHJcbiAgICAgICAgaWYgKGRhdGFUeXBlICE9IG51bGwgJiYgZGF0YVR5cGUgPT09ICdEQVRFJykge1xyXG4gICAgICAgICAgICBvcmdhbml6ZWREYXRhID0gY2hhcnQuZGF0YS5jaGFydERhdGEuc29ydCgoYSwgYikgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGFbc29ydExhYmVsXSkgLSBuZXcgRGF0ZShiW3NvcnRMYWJlbF0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2UgaWYgKGRhdGFUeXBlICE9IG51bGwgJiYgZGF0YVR5cGUgPT09ICdOVU1CRVInKSB7XHJcbiAgICAgICAgICAgIG9yZ2FuaXplZERhdGEgPSBjaGFydC5kYXRhLmNoYXJ0RGF0YS5zb3J0KChhLCBiKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKGFbc29ydExhYmVsXSkgJiYgIWlzTmFOKGJbc29ydExhYmVsXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYVtzb3J0TGFiZWxdIC0gYltzb3J0TGFiZWxdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBvcmdhbml6ZWREYXRhID0gY2hhcnQuZGF0YS5jaGFydERhdGEuc29ydCgoYSwgYikgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc05hTihhW3NvcnRMYWJlbF0pICYmICFpc05hTihiW3NvcnRMYWJlbF0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlRmxvYXQoYVtzb3J0TGFiZWxdKSA8IHBhcnNlRmxvYXQoYltzb3J0TGFiZWxdKSkgeyAvL3NvcnQgc3RyaW5nIGFzY2VuZGluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZUZsb2F0KGFbc29ydExhYmVsXSkgPiBwYXJzZUZsb2F0KGJbc29ydExhYmVsXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGFbc29ydExhYmVsXS50b0xvd2VyQ2FzZSgpIDwgYltzb3J0TGFiZWxdLnRvTG93ZXJDYXNlKCkpIHsgLy9zb3J0IHN0cmluZyBhc2NlbmRpbmdcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoYVtzb3J0TGFiZWxdLnRvTG93ZXJDYXNlKCkgPiBiW3NvcnRMYWJlbF0udG9Mb3dlckNhc2UoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3dpdGNoIChzb3J0VHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlICdzb3J0QXNjZW5kaW5nJzpcclxuICAgICAgICAgICAgY2FzZSAnYXNjZW5kaW5nJzpcclxuICAgICAgICAgICAgICAgIGNoYXJ0LmRhdGEuY2hhcnREYXRhID0gb3JnYW5pemVkRGF0YTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdzb3J0RGVzY2VuZGluZyc6XHJcbiAgICAgICAgICAgIGNhc2UgJ2Rlc2NlbmRpbmcnOlxyXG4gICAgICAgICAgICAgICAgY2hhcnQuZGF0YS5jaGFydERhdGEgPSBvcmdhbml6ZWREYXRhLnJldmVyc2UoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgY2hhcnQuZGF0YS5jaGFydERhdGEgPSBvcmdhbml6ZWREYXRhO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipzZXRUaXBEYXRhXHJcbiAgICAgKlxyXG4gICAgICogY3JlYXRlcyBkYXRhIG9iamVjdCB0byBkaXNwbGF5IGluIHRvb2x0aXBcclxuICAgICAqIEBwYXJhbXNcclxuICAgICAqIEByZXR1cm5zIHt7fX1cclxuICAgICAqL1xyXG4gICAgc2V0VGlwRGF0YShkLCBpKSB7XHJcbiAgICAgICAgbGV0IGNoYXJ0ID0gdGhpcyxcclxuICAgICAgICAgICAgZGF0YSA9IGNoYXJ0LmN1cnJlbnREYXRhLmNoYXJ0RGF0YSxcclxuICAgICAgICAgICAgLy9HZXQgQ29sb3IgZnJvbSBjaGFydERhdGEgYW5kIGFkZCB0byBvYmplY3RcclxuICAgICAgICAgICAgY29sb3IgPSBjaGFydC5fdmFycy5jb2xvcixcclxuICAgICAgICAgICAgdGl0bGUgPSBkW2NoYXJ0LmRhdGEuZGF0YVRhYmxlLmxhYmVsXSxcclxuICAgICAgICAgICAgZGF0YVRhYmxlID0ge307XHJcblxyXG4gICAgICAgIGlmIChjaGFydC5jb25maWcudHlwZSA9PT0gJ3RyZWVtYXAnKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGl0ZW0gaW4gZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0gIT09IGNoYXJ0LmRhdGEuZGF0YVRhYmxlLmxhYmVsICYmIGl0ZW0gIT09ICdQYXJlbnQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YVRhYmxlW2l0ZW1dID0gZFtpdGVtXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoY2hhcnQuY29uZmlnLnR5cGUgPT09ICdiYXInIHx8IGNoYXJ0LmNvbmZpZy50eXBlID09PSAnbGluZScgfHwgY2hhcnQuY29uZmlnLnR5cGUgPT09ICdhcmVhJykge1xyXG4gICAgICAgICAgICB0aXRsZSA9IGRhdGFbaV1bY2hhcnQuZGF0YS5kYXRhVGFibGUubGFiZWxdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpdGVtIGluIGRhdGFbaV0pIHtcclxuICAgICAgICAgICAgICAgIGlmIChpdGVtICE9PSBjaGFydC5kYXRhLmRhdGFUYWJsZS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFUYWJsZVtpdGVtXSA9IGRhdGFbaV1baXRlbV07XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChjaGFydC5jb25maWcudHlwZSA9PT0gJ2dhbnR0Jykge1xyXG4gICAgICAgICAgICAvL0NhbGN1bGF0ZSBsZW5ndGggb2YgZGF0ZXNcclxuICAgICAgICAgICAgZm9yIChsZXQgaXRlbSBpbiBkYXRhW2ldKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0YVtpXS5oYXNPd25Qcm9wZXJ0eShpdGVtKSAmJiBpdGVtICE9PSBjaGFydC5kYXRhLmRhdGFUYWJsZS5ncm91cCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFUYWJsZVtpdGVtXSA9IGRhdGFbaV1baXRlbV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGxldCBzdGFydCxcclxuICAgICAgICAgICAgICAgIGVuZCxcclxuICAgICAgICAgICAgICAgIGRpZmZlcmVuY2UsXHJcbiAgICAgICAgICAgICAgICAvL0NhbGN1bHRpbmcgZHVyYXRpb24gb2YgZGF0ZSByYW5nZXMgdG8gYWRkIHRvIHRvb2x0aXBcclxuICAgICAgICAgICAgICAgIG51bVBhaXJzID0gTWF0aC5mbG9vcihPYmplY3Qua2V5cyhjaGFydC5kYXRhLmRhdGFUYWJsZSkubGVuZ3RoIC8gMik7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMTsgaiA8PSBudW1QYWlyczsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydCA9IG5ldyBEYXRlKGRhdGFbaV1bY2hhcnQuZGF0YS5kYXRhVGFibGVbJ3N0YXJ0ICcgKyBqXV0pO1xyXG4gICAgICAgICAgICAgICAgZW5kID0gbmV3IERhdGUoZGF0YVtpXVtjaGFydC5kYXRhLmRhdGFUYWJsZVsnZW5kICcgKyBqXV0pO1xyXG4gICAgICAgICAgICAgICAgZGlmZmVyZW5jZSA9IGVuZC5nZXRUaW1lKCkgLSBzdGFydC5nZXRUaW1lKCk7XHJcbiAgICAgICAgICAgICAgICBkYXRhVGFibGVbJ0R1cmF0aW9uICcgKyBqXSA9IE1hdGguY2VpbChkaWZmZXJlbmNlIC8gKDEwMDAgKiA2MCAqIDYwICogMjQpKSArICcgZGF5cyc7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRpdGxlID0gZGF0YVtpXVtjaGFydC5kYXRhLmRhdGFUYWJsZS5ncm91cF07XHJcbiAgICAgICAgfSBlbHNlIGlmIChjaGFydC5jb25maWcudHlwZSA9PT0gJ3BpZScgfHwgY2hhcnQuY29uZmlnLnR5cGUgPT09ICdyYWRpYWwnKSB7XHJcbiAgICAgICAgICAgIHRpdGxlID0gZC5sYWJlbDtcclxuICAgICAgICAgICAgZm9yIChsZXQgaXRlbSBpbiBkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXRlbSAhPT0gJ2xhYmVsJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFUYWJsZVtpdGVtXSA9IGRbaXRlbV07XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRlbGV0ZSBkYXRhVGFibGUub3V0ZXJSYWRpdXM7XHJcbiAgICAgICAgfSBlbHNlIGlmIChjaGFydC5jb25maWcudHlwZSA9PT0gJ2NpcmNsZXBhY2snIHx8IGNoYXJ0LmNvbmZpZy50eXBlID09PSAnc3VuYnVyc3QnKSB7XHJcbiAgICAgICAgICAgIHRpdGxlID0gZC5kYXRhLm5hbWU7XHJcbiAgICAgICAgICAgIGRhdGFUYWJsZVtjaGFydC5kYXRhLmRhdGFUYWJsZS52YWx1ZV0gPSBkLnZhbHVlO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoY2hhcnQuY29uZmlnLnR5cGUgPT09ICdjbG91ZCcpIHtcclxuICAgICAgICAgICAgdGl0bGUgPSBkW2NoYXJ0LmRhdGEuZGF0YVRhYmxlLmxhYmVsXTtcclxuICAgICAgICAgICAgZGF0YVRhYmxlW2NoYXJ0LmRhdGEuZGF0YVRhYmxlLnZhbHVlXSA9IGRbY2hhcnQuZGF0YS5kYXRhVGFibGUudmFsdWVdO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGRbY2hhcnQuZGF0YS5kYXRhVGFibGVbJ3Rvb2x0aXAgMSddXSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgIGRhdGFUYWJsZVtjaGFydC5kYXRhLmRhdGFUYWJsZVsndG9vbHRpcCAxJ11dID0gZFtjaGFydC5kYXRhLmRhdGFUYWJsZVsndG9vbHRpcCAxJ11dO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChjaGFydC5jb25maWcudHlwZSA9PT0gJ2hlYXRtYXAnKSB7XHJcbiAgICAgICAgICAgIHRpdGxlID0gZC55QXhpc05hbWUgKyAnIHRvICcgKyBkLnhBeGlzTmFtZTtcclxuICAgICAgICAgICAgaWYgKGQuaGFzT3duUHJvcGVydHkoJ3ZhbHVlJykpIHtcclxuICAgICAgICAgICAgICAgIGRhdGFUYWJsZS52YWx1ZSA9IGQudmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChsZXQgdG9vbHRpcCBpbiBkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodG9vbHRpcC5pbmRleE9mKCd0b29sdGlwJykgPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFUYWJsZVtjaGFydC5kYXRhLmRhdGFUYWJsZVt0b29sdGlwXV0gPSBkW3Rvb2x0aXBdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChjaGFydC5jb25maWcudHlwZSA9PT0gJ2NsdXN0ZXJncmFtJykge1xyXG4gICAgICAgICAgICAvL3RpdGxlID0gZC55X3BhdGgucmVwbGFjZSgvXFwuL2csICfihpInKSArICc8L2JyPicgKyBkLnhfcGF0aC5yZXBsYWNlKC9cXC4vZywgJ+KGkicpO1xyXG4gICAgICAgICAgICAvL0J1aWxkIHN0cmluZ3MgZm9yIHRvb2x0aXBcclxuICAgICAgICAgICAgbGV0IHlUZW1wID0gZC55X3BhdGguc3BsaXQoJy4nKSxcclxuICAgICAgICAgICAgICAgIHlUZW1wU3RyaW5nID0gJycsXHJcbiAgICAgICAgICAgICAgICB4VGVtcCA9IGQueF9wYXRoLnNwbGl0KCcuJyksXHJcbiAgICAgICAgICAgICAgICB4VGVtcFN0cmluZyA9ICcnO1xyXG5cclxuICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCB5VGVtcC5sZW5ndGg7IGsrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoYXJ0LmRhdGEuZGF0YVRhYmxlWyd5X2NhdGVnb3J5ICcgKyAoayArIDEpXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHlUZW1wU3RyaW5nICs9IHlUZW1wW2tdICs9ICcgKCcgKyBjaGFydC5kYXRhLmRhdGFUYWJsZVsneV9jYXRlZ29yeSAnICsgKGsgKyAxKV0gKyAnKSc7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHlUZW1wU3RyaW5nICs9IHlUZW1wW2tdICs9ICcgKCcgKyBjaGFydC5kYXRhLmRhdGFUYWJsZS55X2NhdGVnb3J5ICsgJyknO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChrICE9PSB5VGVtcC5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeVRlbXBTdHJpbmcgKz0gJyDihpIgJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHhUZW1wLmxlbmd0aDsgaysrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hhcnQuZGF0YS5kYXRhVGFibGVbJ3hfY2F0ZWdvcnkgJyArIChrICsgMSldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeFRlbXBTdHJpbmcgKz0geFRlbXBba10gKz0gJyAoJyArIGNoYXJ0LmRhdGEuZGF0YVRhYmxlWyd4X2NhdGVnb3J5ICcgKyAoayArIDEpXSArICcpJztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeFRlbXBTdHJpbmcgKz0geFRlbXBba10gKz0gJyAoJyArIGNoYXJ0LmRhdGEuZGF0YVRhYmxlLnhfY2F0ZWdvcnkgKyAnKSc7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGsgIT09IHhUZW1wLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICB4VGVtcFN0cmluZyArPSAnIOKGkiAnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aXRsZSA9ICdZID4gJyArIHlUZW1wU3RyaW5nICsgJzxicj4nICsgJ1ggPiAnICsgeFRlbXBTdHJpbmc7XHJcbiAgICAgICAgICAgIGlmIChkLmhhc093blByb3BlcnR5KCd2YWx1ZScpKSB7XHJcbiAgICAgICAgICAgICAgICBkYXRhVGFibGUudmFsdWUgPSBkLnZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAobGV0IHRvb2x0aXAgaW4gZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRvb2x0aXAuaW5kZXhPZigndG9vbHRpcCcpID4gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhVGFibGVbY2hhcnQuZGF0YS5kYXRhVGFibGVbdG9vbHRpcF1dID0gZFt0b29sdGlwXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoY2hhcnQuY29uZmlnLnR5cGUgPT09ICdzYW5rZXknKSB7XHJcbiAgICAgICAgICAgIHRpdGxlID0gZC5zb3VyY2UubmFtZS5zbGljZSgwLCAtMikgKyAnIHRvICcgKyBkLnRhcmdldC5uYW1lLnNsaWNlKDAsIC0yKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChkLmhhc093blByb3BlcnR5KCd2YWx1ZScpKSB7XHJcbiAgICAgICAgICAgICAgICBkYXRhVGFibGUudmFsdWUgPSBkLnZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChjaGFydC5jb25maWcudHlwZSA9PT0gJ3NpbmdsZWF4aXMnKSB7XHJcbiAgICAgICAgICAgIHRpdGxlID0gZC5kYXRhW2NoYXJ0LmRhdGEuZGF0YVRhYmxlLmxhYmVsXTtcclxuXHJcbiAgICAgICAgICAgIGZvciAobGV0IGl0ZW0gaW4gY2hhcnQuZGF0YS5kYXRhVGFibGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpdGVtICE9PSAnbGFiZWwnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YVRhYmxlW2NoYXJ0LmRhdGEuZGF0YVRhYmxlW2l0ZW1dXSA9IGQuZGF0YVtjaGFydC5kYXRhLmRhdGFUYWJsZVtpdGVtXV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpdGVtIGluIGQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpdGVtICE9PSBjaGFydC5kYXRhLmRhdGFUYWJsZS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFUYWJsZVtpdGVtXSA9IGRbaXRlbV07XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgcmV0dXJuIHsgJ2RhdGEnOiBkLCAndGlwRGF0YSc6IGRhdGFUYWJsZSwgJ2luZGV4JzogaSwgJ3RpdGxlJzogdGl0bGUsICdjb2xvcic6IGNvbG9yLCAndml6JzogY2hhcnQuY29uZmlnLnR5cGUgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIERyYXcgZnVuY3Rpb25zICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcbiAgICAvKipnZW5lcmF0ZVNWR1xyXG4gICAgICpjcmVhdGVzIGFuIFNWRyBlbGVtZW50IG9uIHRoZSBwYW5lbFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbXMgY29udGFpbmVyLCBtYXJnaW4sIG5hbWVcclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIGdlbmVyYXRlU1ZHKGxlZ2VuZERhdGEsIGN1c3RvbU1hcmdpblBhcmFtLCBjdXN0b21TaXplUGFyYW0pIHtcclxuICAgICAgICBsZXQgY2hhcnQgPSB0aGlzLFxyXG4gICAgICAgICAgICBtYXJnaW4gPSB7fSxcclxuICAgICAgICAgICAgY29udGFpbmVyID0ge30sXHJcbiAgICAgICAgICAgIGRpbWVuc2lvbnMgPSBjaGFydC5jaGFydERpdi5ub2RlKCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXHJcbiAgICAgICAgICAgIGN1c3RvbU1hcmdpbnMgPSBjdXN0b21NYXJnaW5QYXJhbSxcclxuICAgICAgICAgICAgY3VzdG9tU2l6ZSA9IGN1c3RvbVNpemVQYXJhbSxcclxuICAgICAgICAgICAgdGV4dFdpZHRoO1xyXG5cclxuICAgICAgICBpZiAoY2hhcnQuX3ZhcnMuY3VzdG9tTWFyZ2lucykge1xyXG4gICAgICAgICAgICBjdXN0b21NYXJnaW5zID0gY2hhcnQuX3ZhcnMuY3VzdG9tTWFyZ2lucztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vc2V0IG1hcmdpbnNcclxuICAgICAgICBpZiAoIWN1c3RvbU1hcmdpbnMpIHtcclxuICAgICAgICAgICAgLy9kZWNsYXJlIG1hcmdpbnMgaWYgdGhleSBhcmVudCBwYXNzZWQgaW5cclxuICAgICAgICAgICAgbWFyZ2luID0ge1xyXG4gICAgICAgICAgICAgICAgdG9wOiA1NSxcclxuICAgICAgICAgICAgICAgIHJpZ2h0OiA1MCxcclxuICAgICAgICAgICAgICAgIGxlZnQ6IDEwMCxcclxuICAgICAgICAgICAgICAgIGJvdHRvbTogNzBcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKGxlZ2VuZERhdGEgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGxlZ2VuZERhdGEubGVuZ3RoIDw9IDMpIHtcclxuICAgICAgICAgICAgICAgICAgICBtYXJnaW4uYm90dG9tID0gNzA7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxlZ2VuZERhdGEubGVuZ3RoIDw9IDYpIHtcclxuICAgICAgICAgICAgICAgICAgICBtYXJnaW4uYm90dG9tID0gODU7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbi5ib3R0b20gPSAxMzA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBtYXJnaW4gPSBjdXN0b21NYXJnaW5zO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9yZWR1Y2UgbWFyZ2lucyBpZiBsZWdlbmQgaXMgdG9nZ2xlZCBvZmZcclxuICAgICAgICAvL1RPRE8gbWFrZSB0aGlzIGJldHRlclxyXG4gICAgICAgIGlmIChjaGFydC5fdmFycy50b2dnbGVMZWdlbmQgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGlmIChjaGFydC5jb25maWcudHlwZSA9PT0gJ3BpZScgfHwgY2hhcnQuY29uZmlnLnR5cGUgPT09ICdyYWRpYWwnIHx8IGNoYXJ0LmNvbmZpZy50eXBlID09PSAnY2lyY2xlcGFjaycgfHwgY2hhcnQuY29uZmlnLnR5cGUgPT09ICdoZWF0bWFwJykge1xyXG4gICAgICAgICAgICAgICAgbWFyZ2luLmxlZnQgPSA0MDtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChjaGFydC5jb25maWcudHlwZSA9PT0gJ3RyZWVtYXAnIHx8IGNoYXJ0LmNvbmZpZy50eXBlID09PSAnYmFyJyB8fCBjaGFydC5jb25maWcudHlwZSA9PT0gJ2dhbnR0JyB8fCBjaGFydC5jb25maWcudHlwZSA9PT0gJ3NjYXR0ZXInIHx8IGNoYXJ0LmNvbmZpZy50eXBlID09PSAnbGluZScpIHtcclxuICAgICAgICAgICAgICAgIG1hcmdpbi5ib3R0b20gPSA0MDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGNoYXJ0LmNvbmZpZy50eXBlID09PSAnY2x1c3RlcmdyYW0nKSB7XHJcbiAgICAgICAgICAgIHRleHRXaWR0aCA9IGdldE1heFdpZHRoRm9yQXhpc0RhdGEoJ3knLCBjaGFydC5sZWZ0TGFiZWxzLCBjaGFydC5fdmFycywgZGltZW5zaW9ucywgbWFyZ2luLCBjaGFydC5jaGFydERpdiwgY2hhcnQuY29uZmlnLnR5cGUpO1xyXG4gICAgICAgICAgICBtYXJnaW4ubGVmdCA9IE1hdGguY2VpbCh0ZXh0V2lkdGgpO1xyXG4gICAgICAgICAgICBpZiAobWFyZ2luLmxlZnQgPCAzMCkge1xyXG4gICAgICAgICAgICAgICAgbWFyZ2luLmxlZnQgPSAzMDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGV4dFdpZHRoID0gZ2V0TWF4V2lkdGhGb3JBeGlzRGF0YSgneScsIGNoYXJ0LnJpZ2h0TGFiZWxzLCBjaGFydC5fdmFycywgZGltZW5zaW9ucywgbWFyZ2luLCBjaGFydC5jaGFydERpdiwgY2hhcnQuY29uZmlnLnR5cGUpO1xyXG4gICAgICAgICAgICBtYXJnaW4udG9wID0gTWF0aC5jZWlsKHRleHRXaWR0aCk7XHJcbiAgICAgICAgICAgIGlmIChtYXJnaW4udG9wIDwgMzApIHtcclxuICAgICAgICAgICAgICAgIG1hcmdpbi50b3AgPSAzMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9zZXQgeUF4aXMgbWFyZ2luc1xyXG4gICAgICAgIGlmIChjaGFydC5jdXJyZW50RGF0YSAmJiBjaGFydC5jdXJyZW50RGF0YS55QXhpc0RhdGEpIHtcclxuICAgICAgICAgICAgdGV4dFdpZHRoID0gZ2V0TWF4V2lkdGhGb3JBeGlzRGF0YSgneScsIGNoYXJ0LmN1cnJlbnREYXRhLnlBeGlzRGF0YSwgY2hhcnQuX3ZhcnMsIGRpbWVuc2lvbnMsIG1hcmdpbiwgY2hhcnQuY2hhcnREaXYsIGNoYXJ0LmNvbmZpZy50eXBlKTtcclxuICAgICAgICAgICAgaWYgKHRleHRXaWR0aCA+IDEwMCAmJiBjaGFydC5jb25maWcudHlwZSA9PT0gJ2hlYXRtYXAnKSB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0V2lkdGggPSAxMDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2hhcnQuX3ZhcnMuaGVhdG1hcFltYXJnaW4gPSB0ZXh0V2lkdGg7XHJcbiAgICAgICAgICAgIG1hcmdpbi5sZWZ0ID0gTWF0aC5jZWlsKHRleHRXaWR0aCkgKyAzMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vc2V0IHhBeGlzIHRvcCBtYXJnaW5zXHJcbiAgICAgICAgaWYgKGNoYXJ0LmNvbmZpZy50eXBlID09PSAnaGVhdG1hcCcgJiYgY2hhcnQuY3VycmVudERhdGEgJiYgY2hhcnQuY3VycmVudERhdGEueEF4aXNEYXRhKSB7XHJcbiAgICAgICAgICAgIHRleHRXaWR0aCA9IGdldE1heFdpZHRoRm9yQXhpc0RhdGEoJ3gnLCBjaGFydC5jdXJyZW50RGF0YS54QXhpc0RhdGEsIGNoYXJ0Ll92YXJzLCBkaW1lbnNpb25zLCBtYXJnaW4sIGNoYXJ0LmNoYXJ0RGl2LCBjaGFydC5jb25maWcudHlwZSk7XHJcbiAgICAgICAgICAgIC8vc3VidHJhY3Qgc3BhY2UgZm9yIHRpbHRcclxuICAgICAgICAgICAgdGV4dFdpZHRoID0gTWF0aC5jZWlsKHRleHRXaWR0aCk7XHJcbiAgICAgICAgICAgIGlmICh0ZXh0V2lkdGggPiAxMDApIHtcclxuICAgICAgICAgICAgICAgIHRleHRXaWR0aCA9IDEwMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL3NwZWNpZmljIHRvIGhlYXRtYXBcclxuICAgICAgICAgICAgLy9pZiAoY2hhcnQuY29uZmlnLnR5cGUgPT09ICdoZWF0bWFwJykge1xyXG4gICAgICAgICAgICBpZiAodGV4dFdpZHRoID4gMTAwKSB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0V2lkdGggPSAxMDA7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGV4dFdpZHRoIDwgODApIHtcclxuICAgICAgICAgICAgICAgIHRleHRXaWR0aCA9IDgwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vfVxyXG4gICAgICAgICAgICBjaGFydC5fdmFycy5oZWF0bWFwWG1hcmdpbiA9IHRleHRXaWR0aDtcclxuICAgICAgICAgICAgbWFyZ2luLnRvcCA9IHRleHRXaWR0aDtcclxuICAgICAgICAgICAgY3VzdG9tU2l6ZSA9IHt9O1xyXG4gICAgICAgICAgICAvL3NldCBjb250YWluZXJcclxuICAgICAgICAgICAgY3VzdG9tU2l6ZS53aWR0aCA9IGNoYXJ0LmN1cnJlbnREYXRhLnhBeGlzRGF0YS52YWx1ZXMubGVuZ3RoICogMjA7XHJcbiAgICAgICAgICAgIGN1c3RvbVNpemUuaGVpZ2h0ID0gY2hhcnQuY3VycmVudERhdGEueUF4aXNEYXRhLnZhbHVlcy5sZW5ndGggKiAyMDtcclxuXHJcbiAgICAgICAgICAgIGlmICghY2hhcnQuX3ZhcnMudG9nZ2xlTGVnZW5kKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgZHVtbXlPYmogPSB7fTtcclxuICAgICAgICAgICAgICAgIGR1bW15T2JqLnZhbHVlcyA9IGNoYXJ0LmRhdGEuaGVhdERhdGE7XHJcbiAgICAgICAgICAgICAgICBkdW1teU9iai52YWx1ZXMuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xyXG4gICAgICAgICAgICAgICAgZHVtbXlPYmoubGFiZWwgPSAnJztcclxuICAgICAgICAgICAgICAgIGR1bW15T2JqLm1pbiA9IGR1bW15T2JqLnZhbHVlc1swXTtcclxuICAgICAgICAgICAgICAgIGR1bW15T2JqLm1heCA9IGR1bW15T2JqLnZhbHVlc1tkdW1teU9iai52YWx1ZXMubGVuZ3RoIC0gMV07XHJcblxyXG4gICAgICAgICAgICAgICAgdGV4dFdpZHRoID0gZ2V0TWF4V2lkdGhGb3JBeGlzRGF0YSgneScsIGR1bW15T2JqLCBjaGFydC5fdmFycywgZGltZW5zaW9ucywgbWFyZ2luLCBjaGFydC5jaGFydERpdiwgY2hhcnQuY29uZmlnLnR5cGUpO1xyXG4gICAgICAgICAgICAgICAgY2hhcnQuY29uZmlnLmhlYXRXaWR0aCA9IE1hdGguY2VpbCh0ZXh0V2lkdGgpICsgMzA7XHJcbiAgICAgICAgICAgICAgICBtYXJnaW4ubGVmdCA9IG1hcmdpbi5sZWZ0ICsgY2hhcnQuY29uZmlnLmhlYXRXaWR0aDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGN1c3RvbVNpemUud2lkdGggKyBtYXJnaW4ubGVmdCArIG1hcmdpbi5yaWdodCA8IGRpbWVuc2lvbnMud2lkdGgpIHtcclxuICAgICAgICAgICAgICAgIG1hcmdpbi5yaWdodCA9IHBhcnNlSW50KGRpbWVuc2lvbnMud2lkdGgsIDEwKSAtIG1hcmdpbi5sZWZ0IC0gY3VzdG9tU2l6ZS53aWR0aCAtIDIwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjdXN0b21TaXplLmhlaWdodCArIG1hcmdpbi50b3AgKyBtYXJnaW4uYm90dG9tIDwgZGltZW5zaW9ucy5oZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgIG1hcmdpbi5ib3R0b20gPSBwYXJzZUludChkaW1lbnNpb25zLmhlaWdodCwgMTApIC0gbWFyZ2luLnRvcCAtIGN1c3RvbVNpemUuaGVpZ2h0IC0gMTA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3VzdG9tU2l6ZS53aWR0aCArPSBtYXJnaW4ucmlnaHQgKyBtYXJnaW4ubGVmdDtcclxuICAgICAgICAgICAgY3VzdG9tU2l6ZS5oZWlnaHQgKz0gbWFyZ2luLnRvcCArIG1hcmdpbi5ib3R0b207XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL3NldCBjb250YWluZXIgYXR0cmlidXRlc1xyXG4gICAgICAgIC8vU2V0IHN2ZyBzaXplIGJhc2VkIG9uIGNhbGN1bGF0aW9uIG1hcmdpbnMgb3IgY3VzdG9tIHNpemUgaWYgc3BlY2lmaWVkXHJcbiAgICAgICAgaWYgKGN1c3RvbVNpemUgJiYgY3VzdG9tU2l6ZS5oYXNPd25Qcm9wZXJ0eSgnaGVpZ2h0JykpIHtcclxuICAgICAgICAgICAgY29udGFpbmVyLmhlaWdodCA9IGN1c3RvbVNpemUuaGVpZ2h0IC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b207XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29udGFpbmVyLmhlaWdodCA9IHBhcnNlSW50KGRpbWVuc2lvbnMuaGVpZ2h0LCAxMCkgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbTtcclxuICAgICAgICAgICAgaWYgKGNvbnRhaW5lci5oZWlnaHQgPD0gNTApIHtcclxuICAgICAgICAgICAgICAgIG1hcmdpbi50b3AgPSAxMDtcclxuICAgICAgICAgICAgICAgIG1hcmdpbi5ib3R0b20gPSAxMDtcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5oZWlnaHQgPSBwYXJzZUludChkaW1lbnNpb25zLmhlaWdodCwgMTApIC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b207XHJcbiAgICAgICAgICAgICAgICBjaGFydC5fdmFycy54TGFiZWxGb250U2l6ZSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChjdXN0b21TaXplICYmIGN1c3RvbVNpemUuaGFzT3duUHJvcGVydHkoJ3dpZHRoJykpIHtcclxuICAgICAgICAgICAgY29udGFpbmVyLndpZHRoID0gY3VzdG9tU2l6ZS53aWR0aCAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lci53aWR0aCA9IHBhcnNlSW50KGRpbWVuc2lvbnMud2lkdGgsIDEwKSAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9hZGQgbWFyZ2luIGFuZCBjb250YWluZXIgdG8gY2hhcnQgY29uZmlnIG9iamVjdFxyXG4gICAgICAgIGNoYXJ0LmNvbmZpZy5tYXJnaW4gPSBtYXJnaW47XHJcbiAgICAgICAgY2hhcnQuY29uZmlnLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcclxuXHJcbiAgICAgICAgLy9yZW1vdmUgb2xkIHN2ZyBpZiBpdCBleGlzdHNcclxuICAgICAgICBjaGFydC5zdmcgPSBjaGFydC5jaGFydERpdi5zZWxlY3QoJ3N2ZycpLnJlbW92ZSgpO1xyXG5cclxuICAgICAgICAvL3N2ZyBsYXllclxyXG4gICAgICAgIGlmIChjaGFydC5jb25maWcudHlwZSA9PT0gJ2hlYXRtYXAnIHx8IGNoYXJ0LmNvbmZpZy50eXBlID09PSAnc2luZ2xlYXhpcycpIHtcclxuICAgICAgICAgICAgY2hhcnQuc3ZnID0gY2hhcnQuY2hhcnREaXYuYXBwZW5kKCdzdmcnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2VkaXRhYmxlLXN2ZycpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCBjb250YWluZXIud2lkdGggKyBtYXJnaW4ubGVmdCArIG1hcmdpbi5yaWdodClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBjb250YWluZXIuaGVpZ2h0ICsgbWFyZ2luLnRvcCArIG1hcmdpbi5ib3R0b20pXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdjb250YWluZXInKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIG1hcmdpbi5sZWZ0ICsgJywnICsgKG1hcmdpbi50b3ApICsgJyknKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGNoYXJ0LmNvbmZpZy50eXBlID09PSAnY2x1c3RlcmdyYW0nKSB7XHJcbiAgICAgICAgICAgIHZhciBzaXplV2lkdGggPSBjaGFydC5yaWdodExlYXZlcy5sZW5ndGggKiAyMDtcclxuICAgICAgICAgICAgaWYgKHNpemVXaWR0aCA8IGNvbnRhaW5lci53aWR0aCkge1xyXG4gICAgICAgICAgICAgICAgc2l6ZVdpZHRoID0gY29udGFpbmVyLndpZHRoO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgc2l6ZUhlaWdodCA9IGNoYXJ0LmxlZnRMZWF2ZXMubGVuZ3RoICogMjA7XHJcbiAgICAgICAgICAgIGlmIChzaXplSGVpZ2h0IDwgY29udGFpbmVyLmhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgc2l6ZUhlaWdodCA9IGNvbnRhaW5lci5oZWlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNoYXJ0LnN2ZyA9IGNoYXJ0LmNoYXJ0RGl2LmFwcGVuZCgnc3ZnJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlZGl0YWJsZS1zdmcnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgc2l6ZVdpZHRoICsgbWFyZ2luLmxlZnQgKyBtYXJnaW4ucmlnaHQpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0Jywgc2l6ZUhlaWdodCArIG1hcmdpbi50b3AgKyBtYXJnaW4uYm90dG9tKVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgbWFyZ2luLmxlZnQgKyAnLCcgKyAobWFyZ2luLnRvcCkgKyAnKScpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNoYXJ0LnN2ZyA9IGNoYXJ0LmNoYXJ0RGl2LmFwcGVuZCgnc3ZnJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlZGl0YWJsZS1zdmcnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgY29udGFpbmVyLndpZHRoICsgbWFyZ2luLmxlZnQgKyBtYXJnaW4ucmlnaHQpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgY29udGFpbmVyLmhlaWdodCArIG1hcmdpbi50b3AgKyBtYXJnaW4uYm90dG9tKVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgbWFyZ2luLmxlZnQgKyAnLCcgKyAobWFyZ2luLnRvcCkgKyAnKScpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9UT0RPIG1vdmUgdG8gZWRpdCBtb2RlXHJcbiAgICAgICAgaWYgKGNoYXJ0Ll92YXJzLmJhY2tncm91bmRDb2xvciAhPT0gJ25vbmUnKSB7XHJcbiAgICAgICAgICAgIGNoYXJ0LmNvbG9yQmFja2dyb3VuZChjaGFydC5fdmFycy5iYWNrZ3JvdW5kQ29sb3IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipnZW5lcmF0ZVhBeGlzXHJcbiAgICAgKiBjcmVhdGVzIHggYXhpcyBvbiB0aGUgc3ZnXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtcyB4QXhpc0RhdGFcclxuICAgICAqL1xyXG4gICAgZ2VuZXJhdGVYQXhpcyh4QXhpc0RhdGEsIHRpY2tzKSB7XHJcbiAgICAgICAgLy9kZWNsYXJlIHZhcmlhYmxlc1xyXG4gICAgICAgIGxldCBjaGFydCA9IHRoaXMsXHJcbiAgICAgICAgICAgIHhBeGlzLFxyXG4gICAgICAgICAgICAvL05lZWQgdG8gZ2V0WEF4aXNTY2FsZSBlYWNoIHRpbWUgc28gdGhhdCBheGlzIHVwZGF0ZXMgb24gcmVzaXplXHJcbiAgICAgICAgICAgIHhBeGlzU2NhbGUgPSBqdkNoYXJ0cy5nZXRBeGlzU2NhbGUoJ3gnLCB4QXhpc0RhdGEsIGNoYXJ0LmNvbmZpZy5jb250YWluZXIsIGNoYXJ0Ll92YXJzKSxcclxuICAgICAgICAgICAgY29udGFpbmVySGVpZ2h0ID0gY2hhcnQuY29uZmlnLmNvbnRhaW5lci5oZWlnaHQsXHJcbiAgICAgICAgICAgIGNvbnRhaW5lcldpZHRoID0gY2hhcnQuY29uZmlnLmNvbnRhaW5lci53aWR0aCxcclxuICAgICAgICAgICAgeEF4aXNDbGFzcyA9ICd4QXhpc0xhYmVscyBlZGl0YWJsZSBlZGl0YWJsZS14QXhpcyBlZGl0YWJsZS10ZXh0JyxcclxuICAgICAgICAgICAgdGlja1NpemUgPSAwLFxyXG4gICAgICAgICAgICBheGlzSGVpZ2h0ID0gY29udGFpbmVySGVpZ2h0LFxyXG4gICAgICAgICAgICB4Q29udGVudCxcclxuICAgICAgICAgICAgeEF4aXNHcm91cCxcclxuICAgICAgICAgICAgZm9ybWF0VmFsdWVUeXBlO1xyXG5cclxuICAgICAgICAvL2Fzc2lnbiBjc3MgY2xhc3MgZm9yIGVkaXQgbW9kZVxyXG4gICAgICAgIC8vaWYgdGhlIGF4aXMgaXMgbnVtYmVycyBhZGQgZWRpdGFibGUtbnVtXHJcbiAgICAgICAgaWYgKHhBeGlzRGF0YS5kYXRhVHlwZSA9PT0gJ05VTUJFUicpIHtcclxuICAgICAgICAgICAgeEF4aXNDbGFzcyArPSAnIGVkaXRhYmxlLW51bSc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL3JlbW92ZSBwcmV2aW91cyB4QXhpcyBjb250YWluZXIgaWYgaXRzIHRoZXJlXHJcbiAgICAgICAgY2hhcnQuc3ZnLnNlbGVjdEFsbCgnLnhBeGlzQ29udGFpbmVyJykucmVtb3ZlKCk7XHJcblxyXG4gICAgICAgIC8vU2F2ZSB0aGUgYXhpcyBzY2FsZSB0byBjaGFydCBvYmplY3RcclxuICAgICAgICBjaGFydC5jdXJyZW50RGF0YS54QXhpc1NjYWxlID0geEF4aXNTY2FsZTtcclxuXHJcbiAgICAgICAgaWYgKGNoYXJ0LmN1cnJlbnREYXRhLnhBeGlzRGF0YS5kYXRhVHlwZSA9PT0gJ05VTUJFUicpIHtcclxuICAgICAgICAgICAgdGlja1NpemUgPSA1O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9jcmVhdGUgeEF4aXMgZHJhd2luZyBmdW5jdGlvblxyXG4gICAgICAgIGlmIChjaGFydC5jb25maWcudHlwZSA9PT0gJ3NpbmdsZWF4aXMnKSB7XHJcbiAgICAgICAgICAgIHhBeGlzID0gZDMuYXhpc1RvcCh4QXhpc1NjYWxlKVxyXG4gICAgICAgICAgICAgICAgLnRpY2tTaXplKHRpY2tTaXplKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB4QXhpcyA9IGQzLmF4aXNCb3R0b20oeEF4aXNTY2FsZSlcclxuICAgICAgICAgICAgICAgIC50aWNrU2l6ZSh0aWNrU2l6ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGlja3MpIHtcclxuICAgICAgICAgICAgeEF4aXMudGlja3ModGlja3MpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGNoYXJ0LmNvbmZpZy50eXBlID09PSAnc2luZ2xlYXhpcycpIHsvL0ZvciBhbnkgYXhlcyB0aGF0IGFyZSBvbiB0b3Agb2YgdGhlIGRhdGFcclxuICAgICAgICAgICAgYXhpc0hlaWdodCA9IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB4Q29udGVudCA9IGNoYXJ0LnN2Zy5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAneEF4aXNDb250YWluZXInKVxyXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLCcgKyAoYXhpc0hlaWdodCkgKyAnKScpO1xyXG5cclxuICAgICAgICB4QXhpc0dyb3VwID0geENvbnRlbnQuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3hBeGlzJylcclxuICAgICAgICAgICAgLmNhbGwoeEF4aXMpO1xyXG5cclxuICAgICAgICBmb3JtYXRWYWx1ZVR5cGUgPSBqdkZvcm1hdFZhbHVlVHlwZSh4QXhpc0RhdGEudmFsdWVzKTtcclxuXHJcbiAgICAgICAgLy9TdHlsaW5nIHRoZSBheGlzXHJcbiAgICAgICAgeEF4aXNHcm91cC5zZWxlY3QoJ3BhdGgnKVxyXG4gICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgY2hhcnQuX3ZhcnMuYXhpc0NvbG9yKVxyXG4gICAgICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgY2hhcnQuX3ZhcnMuc3Ryb2tlV2lkdGgpO1xyXG5cclxuICAgICAgICAvL1N0eWxpbmcgZm9yIHRpY2tzXHJcbiAgICAgICAgeEF4aXNHcm91cC5zZWxlY3RBbGwoJ2xpbmUnKVxyXG4gICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgY2hhcnQuX3ZhcnMuYXhpc0NvbG9yKVxyXG4gICAgICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgY2hhcnQuX3ZhcnMuc3Ryb2tlKTtcclxuXHJcbiAgICAgICAgLy9TdHlsaW5nIHRoZSBsYWJlbHMgZm9yIGVhY2ggcGllY2Ugb2YgZGF0YVxyXG4gICAgICAgIHhBeGlzR3JvdXAuc2VsZWN0QWxsKCd0ZXh0JylcclxuICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCBjaGFydC5fdmFycy5mb250Q29sb3IpLy9DdXN0b21pemUgdGhlIGNvbG9yIG9mIGF4aXMgbGFiZWxzXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIHhBeGlzQ2xhc3MpXHJcbiAgICAgICAgICAgIC5zdHlsZSgndGV4dC1hbmNob3InLCAnbWlkZGxlJylcclxuICAgICAgICAgICAgLmF0dHIoJ2ZvbnQtc2l6ZScsIGNoYXJ0Ll92YXJzLmZvbnRTaXplKVxyXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLCAzKScpXHJcbiAgICAgICAgICAgIC50ZXh0KChkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoeEF4aXNEYXRhLmRhdGFUeXBlID09PSAnTlVNQkVSJyB8fCBjaGFydC5fdmFycy5yb3RhdGVBeGlzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGp2Rm9ybWF0VmFsdWUoZCwgZm9ybWF0VmFsdWVUeXBlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBkO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy9TdHlsaW5nIHRoZSBsYWJlbCBmb3IgdGhlIGVudGlyZSBheGlzXHJcbiAgICAgICAgeENvbnRlbnQuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3hMYWJlbCcpXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAneExhYmVsIGVkaXRhYmxlIGVkaXRhYmxlLXRleHQgZWRpdGFibGUtY29udGVudCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKVxyXG4gICAgICAgICAgICAuYXR0cignZm9udC1zaXplJywgY2hhcnQuX3ZhcnMuZm9udFNpemUpXHJcbiAgICAgICAgICAgIC50ZXh0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh4QXhpc0RhdGEuZGF0YVR5cGUgPT09ICdEQVRFJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB4QXhpc0RhdGEubGFiZWw7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBjb250YWluZXJXaWR0aCAvIDIgKyAnLCAzMyknKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipGb3JtYXRYQXhpc0xhYmVsc1xyXG4gICAgICpcclxuICAgICAqIElmIHgtYXhpcyBsYWJlbHMgYXJlIHRvbyBsb25nL292ZXJsYXBwaW5nLCB0aGV5IHdpbGwgYmUgaGlkZGVuL3Nob3J0ZW5lZFxyXG4gICAgICovXHJcbiAgICBmb3JtYXRYQXhpc0xhYmVscyhkYXRhTGVuZ3RoLCByZWN1cnNpb24pIHtcclxuICAgICAgICBsZXQgY2hhcnQgPSB0aGlzLFxyXG4gICAgICAgICAgICBzaG93QXhpc0xhYmVscyA9IHRydWUsXHJcbiAgICAgICAgICAgIHhBeGlzTGVuZ3RoID0gY2hhcnQuY29uZmlnLmNvbnRhaW5lci53aWR0aCxcclxuICAgICAgICAgICAgdGV4dFdpZHRoID0gW10sXHJcbiAgICAgICAgICAgIGZvcm1hdFZhbHVlVHlwZSA9IG51bGwsXHJcbiAgICAgICAgICAgIGRhdGFUeXBlID0gY2hhcnQuY3VycmVudERhdGEueEF4aXNEYXRhLmRhdGFUeXBlLFxyXG4gICAgICAgICAgICBheGlzVmFsdWVzID0gY2hhcnQuY3VycmVudERhdGEueEF4aXNEYXRhLnZhbHVlcztcclxuXHJcbiAgICAgICAgaWYgKGRhdGFUeXBlID09PSAnTlVNQkVSJykge1xyXG4gICAgICAgICAgICBmb3JtYXRWYWx1ZVR5cGUgPSBqdkZvcm1hdFZhbHVlVHlwZShheGlzVmFsdWVzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vY3JlYXRlIGR1bW15IHRleHQgdG8gZGV0ZXJtaW5lIGNvbXB1dGVkIHRleHQgbGVuZ3RoIGZvciB0aGUgYXhpcyBsYWJlbHNcclxuICAgICAgICAvL25lY2Vzc2FyeSB0byBkbyB0aGlzIGJlY2F1c2UgYXhpcyBsYWJlbHMgZ2V0QkJveCgpIGlzIHJldHVybmluZyAwIHNpbmNlIHRoZXkgZG8gbm90IHNlZW0gdG8gYmUgZHJhd24geWV0XHJcbiAgICAgICAgY2hhcnQuc3ZnLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoJy5kdW1teVRleHQnKVxyXG4gICAgICAgICAgICAuZGF0YShheGlzVmFsdWVzKVxyXG4gICAgICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgLmF0dHIoJ2ZvbnQtZmFtaWx5JywgJ3NhbnMtc2VyaWYnKVxyXG4gICAgICAgICAgICAuYXR0cignZm9udC1zaXplJywgY2hhcnQuX3ZhcnMuZm9udFNpemUpXHJcbiAgICAgICAgICAgIC50ZXh0KChkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmV0dXJuVmFsID0gZDtcclxuICAgICAgICAgICAgICAgIGlmIChkYXRhVHlwZSA9PT0gJ05VTUJFUicpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWwgPSBqdkZvcm1hdFZhbHVlKGQsIGZvcm1hdFZhbHVlVHlwZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAvL2FkZGluZyAxMHB4IGJ1ZmZlclxyXG4gICAgICAgICAgICAgICAgbGV0IHRoaXNXaWR0aCA9IHRoaXMuZ2V0Q29tcHV0ZWRUZXh0TGVuZ3RoKCkgKyAxMDtcclxuICAgICAgICAgICAgICAgIHRleHRXaWR0aC5wdXNoKHRoaXNXaWR0aCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZSgpOyAvL3JlbW92ZSB0aGVtIGp1c3QgYWZ0ZXIgZGlzcGxheWluZyB0aGVtXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICBmb3IgKGxldCB0ZXh0RWxlIG9mIHRleHRXaWR0aCkge1xyXG4gICAgICAgICAgICBpZiAodGV4dEVsZSA+IHhBeGlzTGVuZ3RoIC8gZGF0YUxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgc2hvd0F4aXNMYWJlbHMgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHNob3dBeGlzTGFiZWxzKSB7XHJcbiAgICAgICAgICAgIGlmIChyZWN1cnNpb24pIHtcclxuICAgICAgICAgICAgICAgIGNoYXJ0LmdlbmVyYXRlWEF4aXMoY2hhcnQuY3VycmVudERhdGEueEF4aXNEYXRhLCBkYXRhTGVuZ3RoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjaGFydC5zdmcuc2VsZWN0QWxsKCcueEF4aXNMYWJlbHMnKS5zdHlsZSgnZGlzcGxheScsICdibG9jaycpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YUxlbmd0aCA+IDEgJiYgY2hhcnQuY3VycmVudERhdGEueEF4aXNEYXRhLmRhdGFUeXBlID09PSAnTlVNQkVSJykge1xyXG4gICAgICAgICAgICAvL3JlY3Vyc2l2ZWx5IGtlZXAgZGVjcmVhc2luZyB0byBmaWd1cmUgb3V0IHRpY2tzIGxlbmd0aCB0byByZXBhaW50IHRoZSB4QXhpcyBpZiBpdHMgbnVtZXJpY1xyXG4gICAgICAgICAgICBjaGFydC5mb3JtYXRYQXhpc0xhYmVscygoZGF0YUxlbmd0aCAtIDEpLCB0cnVlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjaGFydC5zdmcuc2VsZWN0QWxsKCcueEF4aXMnKS5zZWxlY3RBbGwoJ3RleHQnKS5zdHlsZSgnZGlzcGxheScsICdub25lJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKmdlbmVyYXRlWUF4aXNcclxuICAgICAqIGNyZWF0ZXMgeSBheGlzIG9uIHRoZSBzdmdcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW1zIGdlbmVyYXRlWUF4aXNcclxuICAgICAqL1xyXG4gICAgZ2VuZXJhdGVZQXhpcyh5QXhpc0RhdGEpIHtcclxuICAgICAgICBsZXQgY2hhcnQgPSB0aGlzLFxyXG4gICAgICAgICAgICB5QXhpc1NjYWxlID0ganZDaGFydHMuZ2V0QXhpc1NjYWxlKCd5JywgeUF4aXNEYXRhLCBjaGFydC5jb25maWcuY29udGFpbmVyLCBjaGFydC5fdmFycyksXHJcbiAgICAgICAgICAgIHlBeGlzQ2xhc3MgPSAneUF4aXNMYWJlbHMgZWRpdGFibGUgZWRpdGFibGUteUF4aXMgZWRpdGFibGUtdGV4dCcsXHJcbiAgICAgICAgICAgIG1heFlBeGlzTGFiZWxXaWR0aCxcclxuICAgICAgICAgICAgbnVtYmVyT2ZUaWNrcyA9IE1hdGguZmxvb3IoY2hhcnQuY29uZmlnLmNvbnRhaW5lci5oZWlnaHQgLyAxNCksXHJcbiAgICAgICAgICAgIHlBeGlzLFxyXG4gICAgICAgICAgICB5Q29udGVudCxcclxuICAgICAgICAgICAgeUF4aXNHcm91cCxcclxuICAgICAgICAgICAgZm9yY2VGb3JtYXRUeXBlVG8gPSBudWxsLFxyXG4gICAgICAgICAgICB5bGFiZWwgPSAnJztcclxuXHJcbiAgICAgICAgLy9hc3NpZ24gY3NzIGNsYXNzIGZvciBlZGl0IG1vZGVcclxuICAgICAgICAvL2lmIHRoZSBheGlzIGlzIG51bWJlcnMgYWRkIGVkaXRhYmxlLW51bVxyXG4gICAgICAgIGlmICh5QXhpc0RhdGEuZGF0YVR5cGUgPT09ICdOVU1CRVInKSB7XHJcbiAgICAgICAgICAgIHlBeGlzQ2xhc3MgKz0gJyBlZGl0YWJsZS1udW0nO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9TYXZlIHkgYXhpcyBzY2FsZSB0byBjaGFydCBvYmplY3RcclxuICAgICAgICBjaGFydC5jdXJyZW50RGF0YS55QXhpc1NjYWxlID0geUF4aXNTY2FsZTtcclxuXHJcbiAgICAgICAgLy9yZW1vdmUgcHJldmlvdXMgc3ZnIGVsZW1lbnRzXHJcbiAgICAgICAgY2hhcnQuc3ZnLnNlbGVjdEFsbCgnLnlBeGlzQ29udGFpbmVyJykucmVtb3ZlKCk7XHJcbiAgICAgICAgY2hhcnQuc3ZnLnNlbGVjdEFsbCgndGV4dC55TGFiZWwnKS5yZW1vdmUoKTtcclxuXHJcbiAgICAgICAgaWYgKG51bWJlck9mVGlja3MgPiAxMCkge1xyXG4gICAgICAgICAgICBpZiAobnVtYmVyT2ZUaWNrcyA8IDIwKSB7XHJcbiAgICAgICAgICAgICAgICBudW1iZXJPZlRpY2tzID0gMTA7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtYmVyT2ZUaWNrcyA8IDMwKSB7XHJcbiAgICAgICAgICAgICAgICBudW1iZXJPZlRpY2tzIC89IDI7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBudW1iZXJPZlRpY2tzID0gMTU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vSWYgYWxsIHktYXhpcyB2YWx1ZXMgYXJlIHRoZSBzYW1lLCBvbmx5IHNob3cgYSB0aWNrIGZvciB0aGF0IHZhbHVlLiBJZiB2YWx1ZSBpcyAxLCBkb24ndCBzaG93IGFueSBkZWNpbWFsIHBsYWNlc1xyXG4gICAgICAgIGlmICh5QXhpc0RhdGEudmFsdWVzLmxlbmd0aCA+IDAgJiYgISF5QXhpc0RhdGEudmFsdWVzLnJlZHVjZSgoYSwgYikgPT4gYSA9PT0gYiA/IGEgOiBOYU4pKSB7XHJcbiAgICAgICAgICAgIG51bWJlck9mVGlja3MgPSAxO1xyXG4gICAgICAgICAgICBpZiAoeUF4aXNEYXRhLnZhbHVlc1swXSA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgZm9yY2VGb3JtYXRUeXBlVG8gPSAnbm9kZWNpbWFscyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgeUF4aXMgPSBkMy5heGlzTGVmdCgpXHJcbiAgICAgICAgICAgIC50aWNrcyhudW1iZXJPZlRpY2tzKS8vTGluayB0byBEMy5zdmcuYXhpcyBvcHRpb25zOiBodHRwczovL2dpdGh1Yi5jb20vbWJvc3RvY2svZDMvd2lraS9TVkctQXhlc1xyXG4gICAgICAgICAgICAuc2NhbGUoeUF4aXNTY2FsZSkvL1NldHMgdGhlIHNjYWxlIHRvIHVzZSBpbiB0aGUgYXhpc1xyXG4gICAgICAgICAgICAudGlja1NpemUoNSkvL1NldHMgdGhlIHRoaWNrbmVzcyBvZiB0aGUgYXhpcyBsaW5lXHJcbiAgICAgICAgICAgIC50aWNrUGFkZGluZyg1KTtcclxuXHJcbiAgICAgICAgLy9IaWRlIEF4aXMgdmFsdWVzIGlmIG5lY2Vzc2FyeVxyXG4gICAgICAgIGlmICh5QXhpc0RhdGEuaGlkZVZhbHVlcykge1xyXG4gICAgICAgICAgICB5QXhpcy50aWNrRm9ybWF0KCcnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNoYXJ0Ll92YXJzLmRpc3BsYXlZQXhpc0xhYmVsKSB7XHJcbiAgICAgICAgICAgIHlsYWJlbCA9IHlBeGlzRGF0YS5sYWJlbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHlDb250ZW50ID0gY2hhcnQuc3ZnLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICd5QXhpc0NvbnRhaW5lcicpO1xyXG5cclxuICAgICAgICB5Q29udGVudC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAneUxhYmVsJylcclxuICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICd5TGFiZWwgZWRpdGFibGUgZWRpdGFibGUtdGV4dCBlZGl0YWJsZS1jb250ZW50JylcclxuICAgICAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ3N0YXJ0JylcclxuICAgICAgICAgICAgLmF0dHIoJ2ZvbnQtc2l6ZScsIGNoYXJ0Ll92YXJzLmZvbnRTaXplKVxyXG4gICAgICAgICAgICAuYXR0cigneCcsIDApXHJcbiAgICAgICAgICAgIC5hdHRyKCd5JywgMClcclxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArICgtY2hhcnQuY29uZmlnLm1hcmdpbi5sZWZ0ICsgMTApICsgJywgLTEwKScpXHJcbiAgICAgICAgICAgIC50ZXh0KHlsYWJlbClcclxuICAgICAgICAgICAgLmF0dHIoJ2ZpbGwtb3BhY2l0eScsIDEpO1xyXG5cclxuICAgICAgICB5QXhpc0dyb3VwID0geUNvbnRlbnQuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3lBeGlzJyk7XHJcblxyXG5cclxuICAgICAgICB5QXhpc0dyb3VwXHJcbiAgICAgICAgICAgIC5jYWxsKHlBeGlzKTtcclxuXHJcbiAgICAgICAgLy9TdHlsaW5nIGZvciBBeGlzXHJcbiAgICAgICAgeUF4aXNHcm91cC5zZWxlY3QoJ3BhdGgnKVxyXG4gICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgY2hhcnQuX3ZhcnMuYXhpc0NvbG9yKVxyXG4gICAgICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgY2hhcnQuX3ZhcnMuc3Ryb2tlV2lkdGgpO1xyXG5cclxuICAgICAgICBtYXhZQXhpc0xhYmVsV2lkdGggPSAwO1xyXG5cclxuICAgICAgICBpZiAoeUF4aXNEYXRhLmhpZGVWYWx1ZXMpIHtcclxuICAgICAgICAgICAgLy9TdHlsaW5nIGZvciB0aWNrc1xyXG4gICAgICAgICAgICB5QXhpc0dyb3VwLnNlbGVjdEFsbCgnbGluZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgMCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbGV0IGZvcm1hdFZhbHVlVHlwZSA9IGp2Rm9ybWF0VmFsdWVUeXBlKHlBeGlzRGF0YS52YWx1ZXMpO1xyXG4gICAgICAgICAgICAvL1N0eWxpbmcgZm9yIHRpY2tzXHJcbiAgICAgICAgICAgIHlBeGlzR3JvdXAuc2VsZWN0QWxsKCdsaW5lJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCBjaGFydC5fdmFycy5heGlzQ29sb3IpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgY2hhcnQuX3ZhcnMuc3Ryb2tlKTtcclxuICAgICAgICAgICAgLy9TdHlsaW5nIGZvciBkYXRhIGxhYmVscyBvbiBheGlzXHJcbiAgICAgICAgICAgIHlBeGlzR3JvdXAuc2VsZWN0QWxsKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgY2hhcnQuX3ZhcnMuZm9udENvbG9yKS8vQ3VzdG9taXplIHRoZSBjb2xvciBvZiBheGlzIGxhYmVsc1xyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgeUF4aXNDbGFzcylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAncm90YXRlKDApJykvL0FkZCBsb2dpYyB0byByb3RhdGUgYXhpcyBiYXNlZCBvbiBzaXplIG9mIHRpdGxlXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZm9udC1zaXplJywgY2hhcnQuX3ZhcnMuZm9udFNpemUpXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdzdmc6dGl0bGUnKTtcclxuXHJcbiAgICAgICAgICAgIHlBeGlzR3JvdXAuc2VsZWN0QWxsKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgIC50ZXh0KChkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJ0Ll92YXJzLnJvdGF0ZUF4aXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBtYXhMZW5ndGggPSAxMyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkLmxlbmd0aCA+IG1heExlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gZC5zdWJzdHJpbmcoMCwgbWF4TGVuZ3RoKSArICcuLi4nO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBkO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvcmNlRm9ybWF0VHlwZVRvICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdFZhbHVlVHlwZSA9IGZvcmNlRm9ybWF0VHlwZVRvO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ganZGb3JtYXRWYWx1ZShjdXJyZW50LCBmb3JtYXRWYWx1ZVR5cGUpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5lYWNoKChkLCBpLCBqKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGpbMF0uZ2V0QkJveCgpLndpZHRoID4gbWF4WUF4aXNMYWJlbFdpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heFlBeGlzTGFiZWxXaWR0aCA9IGpbMF0uZ2V0QkJveCgpLndpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAobWF4WUF4aXNMYWJlbFdpZHRoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgY2hhcnQuX3ZhcnMueUxhYmVsV2lkdGggPSBNYXRoLmNlaWwobWF4WUF4aXNMYWJlbFdpZHRoKSArIDIwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBMZWdlbmQgZnVuY3Rpb25zICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcbiAgICBnZW5lcmF0ZUxlZ2VuZChsZWdlbmREYXRhLCBkcmF3RnVuYykge1xyXG4gICAgICAgIGxldCBjaGFydCA9IHRoaXMsXHJcbiAgICAgICAgICAgIHN2ZyA9IGNoYXJ0LnN2ZyxcclxuICAgICAgICAgICAgbGVnZW5kRWxlbWVudHM7XHJcblxyXG4gICAgICAgIGlmICghY2hhcnQuX3ZhcnMudG9nZ2xlTGVnZW5kKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3ZnLnNlbGVjdEFsbCgnLmxlZ2VuZCcpLnJlbW92ZSgpO1xyXG5cclxuICAgICAgICBsZWdlbmRFbGVtZW50cyA9IGdlbmVyYXRlTGVnZW5kRWxlbWVudHMoY2hhcnQsIGxlZ2VuZERhdGEsIGRyYXdGdW5jKTtcclxuXHJcbiAgICAgICAgLy9SZXR1cm5zIHRoZSBsZWdlbmQgcmVjdGFuZ2xlcyB0aGF0IGFyZSB0b2dnbGVkIG9uL29mZlxyXG4gICAgICAgIGlmIChkcmF3RnVuYykge1xyXG4gICAgICAgICAgICBhdHRhY2hDbGlja0V2ZW50c1RvTGVnZW5kKGNoYXJ0LCBsZWdlbmRFbGVtZW50cywgZHJhd0Z1bmMsIGxlZ2VuZERhdGEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGNoYXJ0Ll92YXJzLnRocmVzaG9sZHMgIT09ICdub25lJyAmJiBjaGFydC5fdmFycy50aGVzaG9sZExlZ2VuZCA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICBpZiAoY2hhcnQuY29uZmlnLnR5cGUgPT09ICdiYXInIHx8IGNoYXJ0LmNvbmZpZy50eXBlID09PSAnYXJlYScgfHwgY2hhcnQuY29uZmlnLnR5cGUgPT09ICdsaW5lJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoYXJ0LmNvbmZpZy5jb250YWluZXIuaGVpZ2h0ID4gMzAwICYmIGNoYXJ0LmNvbmZpZy5jb250YWluZXIud2lkdGggPiAzMDApIHtcclxuICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZVRocmVzaG9sZExlZ2VuZChjaGFydCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqZ2VuZXJhdGVWZXJ0aWNhbExlZ2VuZFxyXG4gICAgICpcclxuICAgICAqIGNyZWF0ZXMgYW5kIGRyYXdzIGEgdmVydGljYWwgbGVnZW5kIG9uIHRoZSBzdmcgZWxlbWVudFxyXG4gICAgICogQHBhcmFtcyBzdmcsIGxlZ2VuZERhdGEsIG9wdGlvbnMsIGNvbnRhaW5lciwgY2hhcnREYXRhLCB4QXhpc0RhdGEsIHlBeGlzRGF0YSwgY2hhcnRUeXBlXHJcbiAgICAgKiBAcmV0dXJucyB7e319XHJcbiAgICAgKi9cclxuICAgIGdlbmVyYXRlVmVydGljYWxMZWdlbmQocGFpbnRGdW5jKSB7XHJcbiAgICAgICAgbGV0IGNoYXJ0ID0gdGhpcyxcclxuICAgICAgICAgICAgc3ZnID0gY2hhcnQuc3ZnLFxyXG4gICAgICAgICAgICBsZWdlbmREYXRhID0gY2hhcnQuY3VycmVudERhdGEubGVnZW5kRGF0YSxcclxuICAgICAgICAgICAgbGVnZW5kRWxlbWVudHM7XHJcblxyXG4gICAgICAgIGlmICghY2hhcnQuX3ZhcnMudG9nZ2xlTGVnZW5kKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN2Zy5zZWxlY3RBbGwoJy5sZWdlbmQnKS5yZW1vdmUoKTtcclxuICAgICAgICBsZWdlbmRFbGVtZW50cyA9IGdlbmVyYXRlVmVydGljYWxMZWdlbmRFbGVtZW50cyhjaGFydCwgbGVnZW5kRGF0YSwgcGFpbnRGdW5jKTtcclxuXHJcbiAgICAgICAgLy9SZXR1cm5zIHRoZSBsZWdlbmQgcmVjdGFuZ2xlcyB0aGF0IGFyZSB0b2dnbGVkIG9uL29mZlxyXG4gICAgICAgIGlmIChwYWludEZ1bmMgIT09ICdnZW5lcmF0ZVBhY2snKSB7XHJcbiAgICAgICAgICAgIGF0dGFjaENsaWNrRXZlbnRzVG9MZWdlbmQoY2hhcnQsIGxlZ2VuZEVsZW1lbnRzLCBwYWludEZ1bmMsIGxlZ2VuZERhdGEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBHZW5lcmF0ZXMgYSBjbGlwIHBhdGggdGhhdCBjb250YWlucyB0aGUgY29udGVudHMgb2YgdGhlIGNoYXJ0IGFyZWEgdG8gdGhlIHZpZXcgb2YgdGhlIGNoYXJ0IGFyZWEgY29udGFpbmVyXHJcbiAgICAgKiBpLmUgLSBkb24ndCB3YW50IGJhcnMgZ29pbmcgYmVsb3cgdGhlIHggYXhpc1xyXG4gICAgICovXHJcbiAgICBnZW5lcmF0ZUNsaXBQYXRoKCkge1xyXG4gICAgICAgIGxldCBjaGFydCA9IHRoaXMsXHJcbiAgICAgICAgICAgIHN2ZyA9IGNoYXJ0LnN2ZyxcclxuICAgICAgICAgICAgdHlwZSA9IGNoYXJ0LmNvbmZpZy50eXBlLFxyXG4gICAgICAgICAgICBjb250YWluZXJOYW1lID0gJy4nICsgdHlwZSArICctY29udGFpbmVyJztcclxuXHJcbiAgICAgICAgc3ZnXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ2NsaXBQYXRoJylcclxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2NsaXAnKVxyXG4gICAgICAgICAgICAuYXBwZW5kKCdyZWN0JylcclxuICAgICAgICAgICAgLmF0dHIoJ3gnLCAwKVxyXG4gICAgICAgICAgICAuYXR0cigneScsIDApXHJcbiAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIGNoYXJ0LmNvbmZpZy5jb250YWluZXIud2lkdGgpXHJcbiAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBjaGFydC5jb25maWcuY29udGFpbmVyLmhlaWdodCk7XHJcblxyXG4gICAgICAgIC8vQnJlYWsgdGhpcyBvdXQgaW50byBsb2dpYyBmb3IgYWxsIG90aGVyIHZpenplcyB0aGF0IGhhdmUgb3ZlcmZsb3cgaXNzdWVzXHJcbiAgICAgICAgc3ZnXHJcbiAgICAgICAgICAgIC5zZWxlY3QoY29udGFpbmVyTmFtZSlcclxuICAgICAgICAgICAgLmF0dHIoJ2NsaXAtcGF0aCcsICd1cmwoI2NsaXApJyk7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0VGhyZXNob2xkKGRhdGEpIHtcclxuICAgICAgICBsZXQgY2hhcnQgPSB0aGlzLFxyXG4gICAgICAgICAgICB0aHJlc2hvbGRzID0gY2hhcnQuX3ZhcnMudGhyZXNob2xkcyxcclxuICAgICAgICAgICAgbGVuZ3RoID0gdGhyZXNob2xkcyA/IE9iamVjdC5rZXlzKHRocmVzaG9sZHMpLmxlbmd0aCA6IDA7XHJcblxyXG4gICAgICAgIGlmICh0aHJlc2hvbGRzICE9PSAnbm9uZScpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgdGhyZXNob2xkID0gdGhyZXNob2xkc1tpXTtcclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2codHlwZW9mIGRhdGEgPT0gXCJkYXRlXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEgPj0gTnVtYmVyKHRocmVzaG9sZC50aHJlc2hvbGQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdyZWN0LScgKyBpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAnJztcclxuICAgIH1cclxuXHJcbiAgICBnZW5lcmF0ZUxpbmVUaHJlc2hvbGQoKSB7XHJcbiAgICAgICAgbGV0IGNoYXJ0ID0gdGhpcyxcclxuICAgICAgICAgICAgc3ZnID0gY2hhcnQuc3ZnLFxyXG4gICAgICAgICAgICB3aWR0aCA9IGNoYXJ0LmNvbmZpZy5jb250YWluZXIud2lkdGgsXHJcbiAgICAgICAgICAgIGhlaWdodCA9IGNoYXJ0LmNvbmZpZy5jb250YWluZXIuaGVpZ2h0LFxyXG4gICAgICAgICAgICB0aHJlc2hvbGRzID0gY2hhcnQuX3ZhcnMudGhyZXNob2xkcyxcclxuICAgICAgICAgICAgbGVuZ3RoID0gT2JqZWN0LmtleXMoY2hhcnQuX3ZhcnMudGhyZXNob2xkcykubGVuZ3RoLFxyXG4gICAgICAgICAgICB4ID0gY2hhcnQuY3VycmVudERhdGEueEF4aXNTY2FsZSxcclxuICAgICAgICAgICAgeSA9IGNoYXJ0LmN1cnJlbnREYXRhLnlBeGlzU2NhbGU7XHJcblxyXG4gICAgICAgIGlmICh0aHJlc2hvbGRzICE9PSAnbm9uZScpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbGV0IHRocmVzaG9sZCA9IHRocmVzaG9sZHNbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hhcnQuX3ZhcnMucm90YXRlQXhpcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHN2Zy5hcHBlbmQoJ2xpbmUnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsIHRocmVzaG9sZC50aHJlc2hvbGRDb2xvcilcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gxJywgeCh0aHJlc2hvbGQudGhyZXNob2xkKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgeCh0aHJlc2hvbGQudGhyZXNob2xkKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kyJywgaGVpZ2h0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlLWRhc2hhcnJheScsICgnMywgMycpKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ZnLmFwcGVuZCgnbGluZScpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgdGhyZXNob2xkLnRocmVzaG9sZENvbG9yKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneDEnLCAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneTEnLCB5KHRocmVzaG9sZC50aHJlc2hvbGQpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneDInLCB3aWR0aClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kyJywgeSh0aHJlc2hvbGQudGhyZXNob2xkKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZS1kYXNoYXJyYXknLCAoJzMsIDMnKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29sb3JCYWNrZ3JvdW5kKGNvbG9yKSB7XHJcbiAgICAgICAgbGV0IGNoYXJ0ID0gdGhpcztcclxuICAgICAgICBjaGFydC5fdmFycy5iYWNrZ3JvdW5kQ29sb3IgPSBjb2xvcjtcclxuICAgICAgICBjaGFydC5jaGFydERpdi5zdHlsZSgnYmFja2dyb3VuZC1jb2xvcicsICcnICsgY29sb3IpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipkaXNwbGF5VmFsdWVzXHJcbiAgICAgKlxyXG4gICAgICogdG9nZ2xlcyBkYXRhIHZhbHVlcyB0aGF0IGFyZSBkaXNwbGF5ZWQgb24gdGhlIHNwZWNpZmljIHR5cGUgb2YgY2hhcnQgb24gdGhlIHN2Z1xyXG4gICAgICogQHBhcmFtcyBzdmcsIGJhckRhdGEsIG9wdGlvbnMsIHhBeGlzRGF0YSwgeUF4aXNEYXRhLCBjb250YWluZXJcclxuICAgICAqIEByZXR1cm5zIHt7fX1cclxuICAgICAqL1xyXG4gICAgZGlzcGxheVZhbHVlcygpIHtcclxuICAgICAgICB2YXIgY2hhcnQgPSB0aGlzLFxyXG4gICAgICAgICAgICBzdmcgPSBjaGFydC5zdmcsXHJcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IGNoYXJ0LmNvbmZpZy5jb250YWluZXIsXHJcbiAgICAgICAgICAgIGNoYXJ0RGF0YSA9IGNoYXJ0LmRhdGEuY2hhcnREYXRhLFxyXG4gICAgICAgICAgICB4QXhpc0RhdGEgPSBjaGFydC5jdXJyZW50RGF0YS54QXhpc0RhdGEsXHJcbiAgICAgICAgICAgIHlBeGlzRGF0YSA9IGNoYXJ0LmN1cnJlbnREYXRhLnlBeGlzRGF0YSxcclxuICAgICAgICAgICAgbGVnZW5kT3B0aW9ucyA9IGNoYXJ0Ll92YXJzLmxlZ2VuZE9wdGlvbnMsXHJcbiAgICAgICAgICAgIGNsZWFuZWRDaGFydERhdGEgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGNoYXJ0RGF0YSkpLFxyXG4gICAgICAgICAgICBkYXRhID0gW10sIC8vT25seSBzdG9yZXMgdmFsdWVzXHJcbiAgICAgICAgICAgIHBvc0NhbGMsXHJcbiAgICAgICAgICAgIHgsXHJcbiAgICAgICAgICAgIHksXHJcbiAgICAgICAgICAgIGRpc3BsYXlWYWx1ZXNHcm91cDtcclxuXHJcbiAgICAgICAgLy9JZiBzZXJpZXMgaXMgZmxpcHBlZCwgdXNlIGZsaXBwZWQgZGF0YTsgaW5pdGlhbGl6ZSB3aXRoIHRoZSBmdWxsIGRhdGEgc2V0XHJcbiAgICAgICAgaWYgKGNoYXJ0Ll92YXJzLnNlcmllc0ZsaXBwZWQpIHtcclxuICAgICAgICAgICAgY2hhcnREYXRhID0gY2hhcnQuZmxpcHBlZERhdGEuY2hhcnREYXRhO1xyXG4gICAgICAgICAgICBsZWdlbmRPcHRpb25zID0gY2hhcnQuX3ZhcnMuZmxpcHBlZExlZ2VuZE9wdGlvbnM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoY2hhcnQuX3ZhcnMuZGlzcGxheVZhbHVlcyA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICBzdmcuc2VsZWN0QWxsKCcuZGlzcGxheVZhbHVlQ29udGFpbmVyJykucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIGlmIChsZWdlbmRPcHRpb25zKSB7Ly9DaGVja2luZyB3aGljaCBsZWdlbmQgZWxlbWVudHMgYXJlIHRvZ2dsZWQgb24gcmVzaXplXHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjaGFydEVsZSBvZiBjbGVhbmVkQ2hhcnREYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgbGVnZW5kRWxlIG9mIGxlZ2VuZE9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxlZ2VuZEVsZS50b2dnbGUgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgY2hhcnRFbGVbbGVnZW5kRWxlLmVsZW1lbnRdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmb3IgKGxldCBjaGFydEVsZSBvZiBjbGVhbmVkQ2hhcnREYXRhKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgdmFsID0gZ2V0RGlzcGxheVZhbHVlc0VsZW1lbnQoY2hhcnRFbGUsIGNoYXJ0LmN1cnJlbnREYXRhLmRhdGFUYWJsZSwgY2hhcnQuY29uZmlnLnR5cGUpO1xyXG4gICAgICAgICAgICAgICAgZGF0YS5wdXNoKHZhbCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHBvc0NhbGMgPSBnZXRQb3NDYWxjdWxhdGlvbnMoY2xlYW5lZENoYXJ0RGF0YSwgY2hhcnQuX3ZhcnMsIHhBeGlzRGF0YSwgeUF4aXNEYXRhLCBjb250YWluZXIsIGNoYXJ0KTtcclxuICAgICAgICAgICAgeCA9IGp2Q2hhcnRzLmdldEF4aXNTY2FsZSgneCcsIHhBeGlzRGF0YSwgY29udGFpbmVyLCBjaGFydC5fdmFycyk7XHJcbiAgICAgICAgICAgIHkgPSBqdkNoYXJ0cy5nZXRBeGlzU2NhbGUoJ3knLCB5QXhpc0RhdGEsIGNvbnRhaW5lciwgY2hhcnQuX3ZhcnMpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGNoYXJ0Ll92YXJzLnJvdGF0ZUF4aXMpIHtcclxuICAgICAgICAgICAgICAgIC8vQWRkIGEgY29udGFpbmVyIGZvciBkaXNwbGF5IHZhbHVlcyBvdmVyIGVhY2ggYmFyIGdyb3VwXHJcbiAgICAgICAgICAgICAgICBkaXNwbGF5VmFsdWVzR3JvdXAgPVxyXG4gICAgICAgICAgICAgICAgICAgIHN2Z1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2Rpc3BsYXlWYWx1ZXNHcm91cCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoJ2cnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuZGF0YShkYXRhKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2Rpc3BsYXlWYWx1ZXNHcm91cCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAoZCwgaSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRyYW5zbGF0ZSA9ICh5LnBhZGRpbmdPdXRlcigpICogeS5zdGVwKCkpICsgKHkuc3RlcCgpICogaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgwLCcgKyB0cmFuc2xhdGUgKyAnKSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGRpc3BsYXlWYWx1ZXNHcm91cC5zZWxlY3RBbGwoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5kYXRhKGQgPT4gZClcclxuICAgICAgICAgICAgICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdkaXNwbGF5VmFsdWUnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgKGQsIGksIGopID0+IHsgLy9zZXRzIHRoZSB4IHBvc2l0aW9uIG9mIHRoZSBiYXIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwb3NDYWxjLndpZHRoKGQsIGksIGopICsgcG9zQ2FsYy54KGQsIGksIGopO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAoZCwgaSwgaikgPT4geyAvL3NldHMgdGhlIHkgcG9zaXRpb24gb2YgdGhlIGJhclxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9zQ2FsYy55KGQsIGksIGopICsgKHBvc0NhbGMuaGVpZ2h0KGQsIGksIGopIC8gMik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignZHknLCAnLjM1ZW0nKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdzdGFydCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCBjaGFydC5fdmFycy5mb250Q29sb3IpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRleHQoKGQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJldHVyblRleHQgPSBNYXRoLnJvdW5kKGQgKiAxMDApIC8gMTAwOy8vcm91bmQgdG8gMiBkZWNpbWFsc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ganZGb3JtYXRWYWx1ZShyZXR1cm5UZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdmb250LXNpemUnLCBjaGFydC5fdmFycy5mb250U2l6ZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvL0FkZCBhIGRpc3BsYXkgdmFsdWVzIGNvbnRhaW5lciBvdmVyIGVhY2ggYmFyIGdyb3VwXHJcbiAgICAgICAgICAgICAgICBkaXNwbGF5VmFsdWVzR3JvdXAgPSBzdmcuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZGlzcGxheVZhbHVlc0dyb3VwJylcclxuICAgICAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKCdnJylcclxuICAgICAgICAgICAgICAgICAgICAuZGF0YShkYXRhKVxyXG4gICAgICAgICAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2Rpc3BsYXlWYWx1ZXNHcm91cCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIChkLCBpKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0cmFuc2xhdGUgPSAoeC5wYWRkaW5nT3V0ZXIoKSAqIHguc3RlcCgpKSArICh4LnN0ZXAoKSAqIGkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgdHJhbnNsYXRlICsgJywwKSc7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBkaXNwbGF5VmFsdWVzR3JvdXAuc2VsZWN0QWxsKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgICAgICAuZGF0YShkID0+IGQpXHJcbiAgICAgICAgICAgICAgICAgICAgLmVudGVyKClcclxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZGlzcGxheVZhbHVlJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIChkLCBpLCBqKSA9PiB7IC8vc2V0cyB0aGUgeCBwb3NpdGlvbiBvZiB0aGUgYmFyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCgocG9zQ2FsYy54KGQsIGksIGopICsgKHBvc0NhbGMud2lkdGgoZCwgaSwgaikgLyAyKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAoZCwgaSwgaikgPT4geyAvL3NldHMgdGhlIHkgcG9zaXRpb24gb2YgdGhlIGJhclxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChwb3NDYWxjLnkoZCwgaSwgaikpIC0gMzsvLysgcG9zQ2FsYy5oZWlnaHQoZCwgaSwgaikgLSA1KTtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgY2hhcnQuX3ZhcnMuZm9udENvbG9yKVxyXG4gICAgICAgICAgICAgICAgICAgIC50ZXh0KChkLCBpLCBqKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGFydC5fdmFycy5zdGFja1RvZ2dsZSAmJiBjaGFydC5fdmFycy5kaXNwbGF5VmFsdWVzU3RhY2tBc1BlcmNlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0b3RhbCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgai5sZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3RhbCArPSBqW2luZGV4XS5fX2RhdGFfXztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBqdkZvcm1hdFZhbHVlKGQgLyB0b3RhbCwgJ3BlcmNlbnQnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGp2Rm9ybWF0VmFsdWUoZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignZm9udC1zaXplJywgY2hhcnQuX3ZhcnMuZm9udFNpemUpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChjaGFydC5fdmFycy5zdGFja1RvZ2dsZSAmJiBjaGFydC5fdmFycy5kaXNwbGF5VmFsdWVzU3RhY2tUb3RhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBzdGFja0NvdW50ZXIgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHN2Zy5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZGlzcGxheVN0YWNrVG90YWwnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKCdnJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmRhdGEoZGF0YSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmVudGVyKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAoZCwgaSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRyYW5zbGF0ZSA9ICh4LnBhZGRpbmdPdXRlcigpICogeC5zdGVwKCkpICsgKHguc3RlcCgpICogaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgdHJhbnNsYXRlICsgJywwKSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuZGF0YShkID0+IGQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIChkLCBpLCBqKSA9PiB7IC8vc2V0cyB0aGUgeCBwb3NpdGlvbiBvZiB0aGUgYmFyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoKHBvc0NhbGMueChkLCBpLCBqKSArIChwb3NDYWxjLndpZHRoKGQsIGksIGopIC8gMikpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAoZCwgaSwgaikgPT4geyAvL3NldHMgdGhlIHkgcG9zaXRpb24gb2YgdGhlIGJhclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQocG9zQ2FsYy55KGQsIGksIGopKSAtIDE4Oy8vKyBwb3NDYWxjLmhlaWdodChkLCBpLCBqKSAtIDUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigndGV4dC1hbmNob3InLCAnbWlkZGxlJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCBjaGFydC5fdmFycy5mb250Q29sb3IpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC50ZXh0KChkLCBpLCBqKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgeUxlbmd0aCA9IGNoYXJ0LmN1cnJlbnREYXRhLnlBeGlzRGF0YS52YWx1ZXMubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhMZW5ndGggPSBjaGFydC5jdXJyZW50RGF0YS54QXhpc0RhdGEudmFsdWVzLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleE1heCA9IHlMZW5ndGggLyB4TGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoaSArIDEpID09PSBpbmRleE1heCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBqIDwgaW5kZXhNYXg7IGsrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjayArPSBjaGFydC5jdXJyZW50RGF0YS55QXhpc0RhdGEudmFsdWVzW2luZGV4TWF4ICogc3RhY2tDb3VudGVyICsga107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrQ291bnRlcisrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBqdkZvcm1hdFZhbHVlKHN0YWNrKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2ZvbnQtc2l6ZScsIGNoYXJ0Ll92YXJzLmZvbnRTaXplKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHN2Zy5zZWxlY3RBbGwoJy5kaXNwbGF5VmFsdWVDb250YWluZXInKS5yZW1vdmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZHJhd0dyaWRsaW5lcyhheGlzRGF0YSkge1xyXG4gICAgICAgIGxldCBjaGFydCA9IHRoaXMsXHJcbiAgICAgICAgICAgIHNjYWxlRGF0YTtcclxuXHJcbiAgICAgICAgY2hhcnQuc3ZnLnNlbGVjdEFsbCgnZy5ncmlkTGluZXMnKS5yZW1vdmUoKTtcclxuICAgICAgICBjaGFydC5zdmcuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2dyaWRMaW5lcycpO1xyXG5cclxuICAgICAgICAvL0RldGVybWluZSBpZiBncmlkbGluZXMgYXJlIGhvcml6b250YWwgb3IgdmVydGljYWwgYmFzZWQgb24gcm90YXRlQXhpc1xyXG4gICAgICAgIGlmIChjaGFydC5fdmFycy5yb3RhdGVBeGlzID09PSB0cnVlIHx8IGNoYXJ0LmNvbmZpZy50eXBlID09PSAnZ2FudHQnIHx8IGNoYXJ0LmNvbmZpZy50eXBlID09PSAnc2luZ2xlYXhpcycpIHtcclxuICAgICAgICAgICAgbGV0IGdyaWRMaW5lSGVpZ2h0ID0gY2hhcnQuY29uZmlnLmNvbnRhaW5lci5oZWlnaHQsXHJcbiAgICAgICAgICAgICAgICB4QXhpc1NjYWxlID0ganZDaGFydHMuZ2V0QXhpc1NjYWxlKCd4JywgYXhpc0RhdGEsIGNoYXJ0LmNvbmZpZy5jb250YWluZXIsIGNoYXJ0Ll92YXJzKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChheGlzRGF0YS5kYXRhVHlwZSA9PT0gJ1NUUklORycpIHtcclxuICAgICAgICAgICAgICAgIHNjYWxlRGF0YSA9IGF4aXNEYXRhLnZhbHVlcztcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChheGlzRGF0YS5kYXRhVHlwZSA9PT0gJ05VTUJFUicgfHwgYXhpc0RhdGEuZGF0YVR5cGUgPT09ICdEQVRFJykge1xyXG4gICAgICAgICAgICAgICAgc2NhbGVEYXRhID0geEF4aXNTY2FsZS50aWNrcygxMCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNoYXJ0LnN2Zy5zZWxlY3QoJy5ncmlkTGluZXMnKS5zZWxlY3RBbGwoJy5ob3Jpem9udGFsR3JpZCcpXHJcbiAgICAgICAgICAgICAgICAuZGF0YShzY2FsZURhdGEpXHJcbiAgICAgICAgICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgnbGluZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnaG9yaXpvbnRhbEdyaWQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gxJywgKGQsIGkpID0+IGkgPiAwID8geEF4aXNTY2FsZShkKSA6IDApXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneDInLCAoZCwgaSkgPT4gaSA+IDAgPyB4QXhpc1NjYWxlKGQpIDogMClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIDApXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneTInLCAoZCwgaSkgPT4gaSA+IDAgPyBncmlkTGluZUhlaWdodCA6IDApXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZmlsbCcsICdub25lJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdzaGFwZS1yZW5kZXJpbmcnLCAnY3Jpc3BFZGdlcycpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgY2hhcnQuX3ZhcnMuYXhpc0NvbG9yKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIGNoYXJ0Ll92YXJzLmdyaWRMaW5lU3Ryb2tlV2lkdGgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGxldCBncmlkTGluZVdpZHRoID0gY2hhcnQuY29uZmlnLmNvbnRhaW5lci53aWR0aCxcclxuICAgICAgICAgICAgICAgIHlBeGlzU2NhbGUgPSBqdkNoYXJ0cy5nZXRBeGlzU2NhbGUoJ3knLCBheGlzRGF0YSwgY2hhcnQuY29uZmlnLmNvbnRhaW5lciwgY2hhcnQuX3ZhcnMpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGF4aXNEYXRhLmRhdGFUeXBlID09PSAnU1RSSU5HJykge1xyXG4gICAgICAgICAgICAgICAgc2NhbGVEYXRhID0gYXhpc0RhdGEudmFsdWVzO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGF4aXNEYXRhLmRhdGFUeXBlID09PSAnTlVNQkVSJyB8fCBheGlzRGF0YS5kYXRhVHlwZSA9PT0gJ0RBVEUnKSB7XHJcbiAgICAgICAgICAgICAgICBzY2FsZURhdGEgPSB5QXhpc1NjYWxlLnRpY2tzKDEwKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY2hhcnQuc3ZnLnNlbGVjdCgnLmdyaWRMaW5lcycpLnNlbGVjdEFsbCgnLmhvcml6b250YWxHcmlkJykuZGF0YShzY2FsZURhdGEpLmVudGVyKClcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2xpbmUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2hvcml6b250YWxHcmlkJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsIDApXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneDInLCAoZCwgaSkgPT4gaSA+IDAgPyBncmlkTGluZVdpZHRoIDogMClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIChkLCBpKSA9PiBpID4gMCA/IHlBeGlzU2NhbGUoZCkgOiAwKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3kyJywgKGQsIGkpID0+IGkgPiAwID8geUF4aXNTY2FsZShkKSA6IDApXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZmlsbCcsICdub25lJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdzaGFwZS1yZW5kZXJpbmcnLCAnY3Jpc3BFZGdlcycpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgY2hhcnQuX3ZhcnMuYXhpc0NvbG9yKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIGNoYXJ0Ll92YXJzLmdyaWRMaW5lU3Ryb2tlV2lkdGgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipnZXRCYXJEYXRhRnJvbU9wdGlvbnNcclxuICAgICogXl4gbm90IGp1c3QgYSBiYXIgZnVuY3Rpb24sIGxpbmUgYW5kIGFyZWEgYWxzbyB1c2UgaXRcclxuICAgICpcclxuICAgICogQXNzaWducyB0aGUgY29ycmVjdCBjaGFydCBkYXRhIHRvIGN1cnJlbnQgZGF0YSB1c2luZyB0aGUgY2hhcnQub3B0aW9uc1xyXG4gICAgKi9cclxuICAgIGdldEJhckRhdGFGcm9tT3B0aW9ucygpIHtcclxuICAgICAgICBsZXQgY2hhcnQgPSB0aGlzLFxyXG4gICAgICAgICAgICBkYXRhT2JqID0ge30sXHJcbiAgICAgICAgICAgIGRhdGEgPSBjaGFydC5kYXRhO1xyXG5cclxuICAgICAgICAvL3NldCBmbGlwcGVkIGRhdGEgaWYgbmVjZXNzYXJ5XHJcbiAgICAgICAgaWYgKGNoYXJ0Ll92YXJzLnNlcmllc0ZsaXBwZWQpIHtcclxuICAgICAgICAgICAgZGF0YSA9IGNoYXJ0LmZsaXBwZWREYXRhO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZGF0YU9iai5jaGFydERhdGEgPSBkYXRhLmNoYXJ0RGF0YTtcclxuICAgICAgICBkYXRhT2JqLmxlZ2VuZERhdGEgPSBkYXRhLmxlZ2VuZERhdGE7XHJcbiAgICAgICAgZGF0YU9iai5kYXRhVGFibGUgPSBkYXRhLmRhdGFUYWJsZTtcclxuICAgICAgICBjaGFydC5fdmFycy5jb2xvciA9IGRhdGEuY29sb3I7XHJcbiAgICAgICAgaWYgKGNoYXJ0Ll92YXJzLnJvdGF0ZUF4aXMgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgZGF0YU9iai54QXhpc0RhdGEgPSBkYXRhLnlBeGlzRGF0YTtcclxuICAgICAgICAgICAgZGF0YU9iai55QXhpc0RhdGEgPSBkYXRhLnhBeGlzRGF0YTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBkYXRhT2JqLnhBeGlzRGF0YSA9IGRhdGEueEF4aXNEYXRhO1xyXG4gICAgICAgICAgICBkYXRhT2JqLnlBeGlzRGF0YSA9IGRhdGEueUF4aXNEYXRhO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGRhdGFPYmo7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBVdGlsaXR5IGZ1bmN0aW9ucyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG4gICAgLyoqaGlnaGxpZ2h0SXRlbXNcclxuICAgICAqXHJcbiAgICAgKiBoaWdobGlnaHRzIGl0ZW1zIG9uIHRoZSBzdmcgZWxlbWVudFxyXG4gICAgICogQHBhcmFtcyBpdGVtcywgc3ZnXHJcbiAgICAgKiBAcmV0dXJucyB7e319XHJcbiAgICAgKi9cclxuICAgIGhpZ2hsaWdodEl0ZW0oaXRlbXMsIHRhZywgaGlnaGxpZ2h0SW5kZXgsIGhpZ2hsaWdodFVyaSkge1xyXG4gICAgICAgIGxldCBjaGFydCA9IHRoaXMsXHJcbiAgICAgICAgICAgIHN2ZyA9IGNoYXJ0LnN2ZztcclxuXHJcbiAgICAgICAgLy9UT0RPIHJlbW92ZSBpZiBzdGF0ZW1lbnRzXHJcbiAgICAgICAgaWYgKGhpZ2hsaWdodEluZGV4ID49IDApIHtcclxuICAgICAgICAgICAgaWYgKGNoYXJ0LmNvbmZpZy50eXBlID09PSAncGllJykge1xyXG4gICAgICAgICAgICAgICAgLy9zZXQgYWxsIGNpcmNsZXMgc3Ryb2tlIHdpZHRoIHRvIDBcclxuICAgICAgICAgICAgICAgIHN2Zy5zZWxlY3QoJy5waWUtY29udGFpbmVyJykuc2VsZWN0QWxsKHRhZylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgY2hhcnQuX3ZhcnMucGllQm9yZGVyKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCAxKTtcclxuICAgICAgICAgICAgICAgIC8vaGlnaGxpZ2h0IG5lY2Vzc2FyeSBwaWUgc2xpY2VzXHJcbiAgICAgICAgICAgICAgICBzdmcuc2VsZWN0KCcucGllLWNvbnRhaW5lcicpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNlbGVjdEFsbCh0YWcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcignLmhpZ2hsaWdodC1jbGFzcy0nICsgaGlnaGxpZ2h0SW5kZXgpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsIGNoYXJ0Ll92YXJzLmhpZ2hsaWdodEJvcmRlckNvbG9yKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCBjaGFydC5fdmFycy5oaWdobGlnaHRCb3JkZXJXaWR0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNoYXJ0LmNvbmZpZy50eXBlID09PSAnc2NhdHRlcnBsb3QnKSB7XHJcbiAgICAgICAgICAgICAgICAvL3NldCBhbGwgY2lyY2xlcyBzdHJva2Ugd2lkdGggdG8gMFxyXG4gICAgICAgICAgICAgICAgc3ZnLnNlbGVjdCgnLnNjYXR0ZXItY29udGFpbmVyJykuc2VsZWN0QWxsKHRhZylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgMCk7XHJcbiAgICAgICAgICAgICAgICAvL2hpZ2hsaWdodCBuZWNlc3Nhcnkgc2NhdHRlciBkb3RzXHJcbiAgICAgICAgICAgICAgICBzdmcuc2VsZWN0KCcuc2NhdHRlci1jb250YWluZXInKS5zZWxlY3RBbGwodGFnKS5maWx0ZXIoJy5zY2F0dGVyLWNpcmNsZS0nICsgaGlnaGxpZ2h0SW5kZXgpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsIGNoYXJ0Ll92YXJzLmhpZ2hsaWdodEJvcmRlckNvbG9yKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCBjaGFydC5fdmFycy5oaWdobGlnaHRCb3JkZXJXaWR0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKGhpZ2hsaWdodFVyaSkge1xyXG4gICAgICAgICAgICBpZiAoY2hhcnQuY29uZmlnLnR5cGUgPT09ICdiYXInKSB7XHJcbiAgICAgICAgICAgICAgICAvL3NldCBhbGwgYmFycyBzdHJva2Ugd2lkdGggdG8gMFxyXG4gICAgICAgICAgICAgICAgc3ZnLnNlbGVjdCgnLmJhci1jb250YWluZXInKS5zZWxlY3RBbGwodGFnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCAwKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCAwKTtcclxuICAgICAgICAgICAgICAgIC8vaGlnaGxpZ2h0IG5lY2Vzc2FyeSBiYXJzXHJcbiAgICAgICAgICAgICAgICBzdmcuc2VsZWN0KCcuYmFyLWNvbnRhaW5lcicpLnNlbGVjdEFsbCgnLmhpZ2hsaWdodC1jbGFzcy0nICsgaGlnaGxpZ2h0VXJpKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCBjaGFydC5fdmFycy5oaWdobGlnaHRCb3JkZXJDb2xvcilcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgY2hhcnQuX3ZhcnMuaGlnaGxpZ2h0Qm9yZGVyV2lkdGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjaGFydC5jb25maWcudHlwZSA9PT0gJ2xpbmUnIHx8IGNoYXJ0LmNvbmZpZy50eXBlID09PSAnYXJlYScpIHtcclxuICAgICAgICAgICAgICAgIC8vc2V0IGFsbCBjaXJjbGVzIHN0cm9rZSB3aWR0aCB0byAwXHJcbiAgICAgICAgICAgICAgICBzdmcuc2VsZWN0KCcubGluZS1jb250YWluZXInKS5zZWxlY3RBbGwodGFnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCAwKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCAwKTtcclxuICAgICAgICAgICAgICAgIC8vaGlnaGxpZ2h0IG5lY2Vzc2FyeSBjaXJsY2VzXHJcbiAgICAgICAgICAgICAgICBzdmcuc2VsZWN0KCcubGluZS1jb250YWluZXInKS5zZWxlY3RBbGwodGFnKS5maWx0ZXIoJy5oaWdobGlnaHQtY2xhc3MtJyArIGhpZ2hsaWdodFVyaSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgY2hhcnQuX3ZhcnMuaGlnaGxpZ2h0Qm9yZGVyQ29sb3IpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIGNoYXJ0Ll92YXJzLmhpZ2hsaWdodEJvcmRlcldpZHRoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCduZWVkIHRvIHBhc3MgaGlnaGxpZ2h0IGluZGV4IHRvIGhpZ2hsaWdodCBpdGVtJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKkBkZXNjIFJlbW92ZXMgaGlnaGxpZ2h0cyB0aGF0IHdlcmUgYXBwbGllZCB3aXRoIHJlbGF0ZWQgaW5zaWdodHNcclxuICAgICpcclxuICAgICovXHJcbiAgICByZW1vdmVIaWdobGlnaHQoKSB7XHJcbiAgICAgICAgbGV0IGNoYXJ0ID0gdGhpcyxcclxuICAgICAgICAgICAgc3ZnID0gY2hhcnQuc3ZnO1xyXG4gICAgICAgIGlmIChjaGFydC5jb25maWcudHlwZSA9PT0gJ3BpZScpIHtcclxuICAgICAgICAgICAgLy9zZXQgYWxsIGNpcmNsZXMgc3Ryb2tlIHdpZHRoIHRvIDBcclxuICAgICAgICAgICAgc3ZnLnNlbGVjdCgnLnBpZS1jb250YWluZXInKS5zZWxlY3RBbGwoJ3BhdGgnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsIGNoYXJ0Ll92YXJzLnBpZUJvcmRlcilcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNoYXJ0LmNvbmZpZy50eXBlID09PSAnc2NhdHRlcnBsb3QnKSB7XHJcbiAgICAgICAgICAgIHN2Zy5zZWxlY3QoJy5zY2F0dGVyLWNvbnRhaW5lcicpLnNlbGVjdEFsbCgnY2lyY2xlJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNoYXJ0LmNvbmZpZy50eXBlID09PSAnYmFyJykge1xyXG4gICAgICAgICAgICBzdmcuc2VsZWN0KCcuYmFyLWNvbnRhaW5lcicpLnNlbGVjdEFsbCgncmVjdCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgMClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNoYXJ0LmNvbmZpZy50eXBlID09PSAnbGluZScgfHwgY2hhcnQuY29uZmlnLnR5cGUgPT09ICdhcmVhJykge1xyXG4gICAgICAgICAgICBzdmcuc2VsZWN0KCcubGluZS1jb250YWluZXInKS5zZWxlY3RBbGwoJ2NpcmNsZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgMClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCAwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBqdkZvcm1hdFZhbHVlKHZhbCwgZm9ybWF0VHlwZSkge1xyXG4gICAgaWYgKCFpc05hTih2YWwpKSB7XHJcbiAgICAgICAgbGV0IGZvcm1hdE51bWJlciA9IGQzLmZvcm1hdCgnLjBmJyk7XHJcblxyXG4gICAgICAgIGlmIChmb3JtYXRUeXBlID09PSAnYmlsbGlvbnMnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXROdW1iZXIodmFsIC8gMWU5KSArICdCJztcclxuICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdFR5cGUgPT09ICdtaWxsaW9ucycpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE51bWJlcih2YWwgLyAxZTYpICsgJ00nO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0VHlwZSA9PT0gJ3Rob3VzYW5kcycpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE51bWJlcih2YWwgLyAxZTMpICsgJ0snO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0VHlwZSA9PT0gJ2RlY2ltYWxzJykge1xyXG4gICAgICAgICAgICBmb3JtYXROdW1iZXIgPSBkMy5mb3JtYXQoJy4yZicpO1xyXG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0TnVtYmVyKHZhbCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChmb3JtYXRUeXBlID09PSAnbm9kZWNpbWFscycpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE51bWJlcih2YWwpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0VHlwZSA9PT0gJ3BlcmNlbnQnKSB7XHJcbiAgICAgICAgICAgIGxldCBwID0gTWF0aC5tYXgoMCwgZDMucHJlY2lzaW9uRml4ZWQoMC4wNSkgLSAyKSxcclxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gPSBkMy5mb3JtYXQoJy4nICsgcCArICclJyk7XHJcbiAgICAgICAgICAgIHJldHVybiBleHByZXNzaW9uKHZhbCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChmb3JtYXRUeXBlID09PSAnJykge1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHZhbCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChNYXRoLmFicyh2YWwpID49IDEwMDAwMDAwMDApIHtcclxuICAgICAgICAgICAgLy9CaWxsaW9uc1xyXG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0TnVtYmVyKHZhbCAvIDFlOSkgKyAnQic7XHJcbiAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyh2YWwpID49IDEwMDAwMDApIHtcclxuICAgICAgICAgICAgLy9NaWxsaW9uc1xyXG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0TnVtYmVyKHZhbCAvIDFlNikgKyAnTSc7XHJcbiAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyh2YWwpID49IDEwMDApIHtcclxuICAgICAgICAgICAgLy9UaG91c2FuZHNcclxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE51bWJlcih2YWwgLyAxZTMpICsgJ0snO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoTWF0aC5hYnModmFsKSA8PSAxMCkge1xyXG4gICAgICAgICAgICAvLzIgZGVjaW1hbHNcclxuICAgICAgICAgICAgZm9ybWF0TnVtYmVyID0gZDMuZm9ybWF0KCcuMmYnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZvcm1hdE51bWJlcih2YWwpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB0aGUgc2V0IG9mIHZhbHVlcyB0aGF0IHlvdSB3YW50IHRvIGZvcm1hdCB1bmlmb3JtbHlcclxuICogQHJldHVybiAnJyB0aGUgbGV2ZWwgb2YgZm9ybWF0dGluZyBmb3IgdGhlIGdyb3VwIG9mIGRhdGFcclxuICogUHJvYmxlbSB3aXRoIGp2Rm9ybWF0VmFsdWUgZnVuY3Rpb24gaXMgdGhhdCBpZiB5b3UgcGFzcyBpbiB2YWx1ZXMgMTAsIDIwLi4uIDkwLCAxMDAsIDExMjAsIDEyMFxyXG4gKiB5b3Ugd2lsbCBnZXQgdGhlIGZvcm1hdHMgMTAuMDAsIDIwLjAwIC4uLi4gMTAwLCAxMTAsIDEyMCB3aGVuIHlvdSB3YW50IDEwLCAyMCwgLi4uIDEwMCwgMTEwXHJcbiAqIC0tRm9ybWF0IHRoZSB2YWx1ZSBiYXNlZCBvZmYgb2YgdGhlIGhpZ2hlc3QgbnVtYmVyIGluIHRoZSBncm91cFxyXG4gKi9cclxuZnVuY3Rpb24ganZGb3JtYXRWYWx1ZVR5cGUodmFsdWVBcnJheSwgZGF0YVR5cGUpIHtcclxuICAgIGlmICh2YWx1ZUFycmF5ICE9IG51bGwgJiYgZGF0YVR5cGUgIT09ICdTVFJJTkcnKSB7XHJcbiAgICAgICAgbGV0IG1heCA9IE1hdGgubWF4LmFwcGx5KG51bGwsIHZhbHVlQXJyYXkpLFxyXG4gICAgICAgICAgICAvL0FmdGVyIGdldHRpbmcgdGhlIG1heCwgY2hlY2sgdGhlIG1pblxyXG4gICAgICAgICAgICBtaW4gPSBNYXRoLm1pbi5hcHBseShudWxsLCB2YWx1ZUFycmF5KSxcclxuICAgICAgICAgICAgcmFuZ2UgPSBtYXggLSBtaW4sXHJcbiAgICAgICAgICAgIGluY3JlbWVtbnQgPSBNYXRoLmFicyhNYXRoLnJvdW5kKHJhbmdlIC8gMTApKTsvLzEwIGJlaW5nIHRoZSBudW1iZXIgb2YgYXhpcyBsYWJlbHMgdG8gc2hvd1xyXG5cclxuICAgICAgICBpZiAoTWF0aC5hYnMoaW5jcmVtZW1udCkgPj0gMTAwMDAwMDAwMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ2JpbGxpb25zJztcclxuICAgICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKGluY3JlbWVtbnQpID49IDEwMDAwMDApIHtcclxuICAgICAgICAgICAgcmV0dXJuICdtaWxsaW9ucyc7XHJcbiAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhpbmNyZW1lbW50KSA+PSAxMDAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAndGhvdXNhbmRzJztcclxuICAgICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKGluY3JlbWVtbnQpIDw9IDEwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnZGVjaW1hbHMnO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoTWF0aC5hYnMoaW5jcmVtZW1udCkgPj0gMTApIHtcclxuICAgICAgICAgICAgcmV0dXJuICdub2RlY2ltYWxzJztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gJyc7XHJcbn1cclxuXHJcbi8qKmdldEZvcm1hdEV4cHJlc3Npb25cclxuICpcclxuICogQGRlc2MgcmV0dXJucyB0aGUgZDMgZm9ybWF0IGV4cHJlc3Npb24gZm9yIGEgZ2l2ZW4gb3B0aW9uXHJcbiAqIEBwYXJhbXMgb3B0aW9uXHJcbiAqIEByZXR1cm5zIHN0cmluZyBleHByZXNzaW9uXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRGb3JtYXRFeHByZXNzaW9uKG9wdGlvbikge1xyXG4gICAgbGV0IGV4cHJlc3Npb24gPSAnJyxcclxuICAgICAgICBwO1xyXG4gICAgaWYgKG9wdGlvbiA9PT0gJ2N1cnJlbmN5Jykge1xyXG4gICAgICAgIGV4cHJlc3Npb24gPSBkMy5mb3JtYXQoJyQsJyk7XHJcbiAgICB9XHJcbiAgICBpZiAob3B0aW9uID09PSAnZml4ZWRDdXJyZW5jeScpIHtcclxuICAgICAgICBleHByZXNzaW9uID0gZDMuZm9ybWF0KCcoJC4yZicpO1xyXG4gICAgfVxyXG4gICAgaWYgKG9wdGlvbiA9PT0gJ3BlcmNlbnQnKSB7XHJcbiAgICAgICAgcCA9IE1hdGgubWF4KDAsIGQzLnByZWNpc2lvbkZpeGVkKDAuMDUpIC0gMik7XHJcbiAgICAgICAgZXhwcmVzc2lvbiA9IGQzLmZvcm1hdCgnLicgKyBwICsgJyUnKTtcclxuICAgIH1cclxuICAgIGlmIChvcHRpb24gPT09ICdtaWxsaW9ucycpIHtcclxuICAgICAgICBwID0gZDMucHJlY2lzaW9uUHJlZml4KDFlNSwgMS4zZTYpO1xyXG4gICAgICAgIGV4cHJlc3Npb24gPSBkMy5mb3JtYXRQcmVmaXgoJy4nICsgcCwgMS4zZTYpO1xyXG4gICAgfVxyXG4gICAgaWYgKG9wdGlvbiA9PT0gJ2NvbW1hcycpIHtcclxuICAgICAgICBleHByZXNzaW9uID0gZDMuZm9ybWF0KCcsLjBmJyk7XHJcbiAgICB9XHJcbiAgICBpZiAob3B0aW9uID09PSAnbm9uZScgfHwgb3B0aW9uID09PSAnJykge1xyXG4gICAgICAgIGV4cHJlc3Npb24gPSBkMy5mb3JtYXQoJycpO1xyXG4gICAgfVxyXG4gICAgaWYgKG9wdGlvbiA9PT0gJ2Rpc3BsYXlWYWx1ZXMnKSB7XHJcbiAgICAgICAgZXhwcmVzc2lvbiA9IGQzLmZvcm1hdCgnLC4yZicpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBleHByZXNzaW9uO1xyXG59XHJcblxyXG4vKipnZXRUb2dnbGVkRGF0YVxyXG4gKlxyXG4gKiBHZXRzIHRoZSBoZWFkZXJzIG9mIHRoZSBkYXRhIHRvIGJlIGRyYXduIGFuZCBmaWx0ZXJzIHRoZSBkYXRhIGJhc2VkIG9uIHRoYXRcclxuICogQHBhcmFtcyBjaGFydERhdGEsIGRhdGFIZWFkZXJzXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRUb2dnbGVkRGF0YShkYXRhLCBkYXRhSGVhZGVycykge1xyXG4gICAgbGV0IGxlZ2VuZFRvZ2dsZUFycmF5ID0gZ2V0TGVnZW5kRWxlbWVudFRvZ2dsZUFycmF5KGRhdGFIZWFkZXJzLCBkYXRhLmxlZ2VuZERhdGEpLFxyXG4gICAgICAgIG5ld0RhdGEgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGRhdGEuY2hhcnREYXRhKSk7XHJcbiAgICBpZiAobGVnZW5kVG9nZ2xlQXJyYXkpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEuY2hhcnREYXRhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHRvZ2dsZUtleSBvZiBsZWdlbmRUb2dnbGVBcnJheSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRvZ2dsZUtleS50b2dnbGUgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG5ld0RhdGFbaV1bdG9nZ2xlS2V5LmVsZW1lbnRdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ld0RhdGE7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAbmFtZSBnZXRMZWdlbmRFbGVtZW50VG9nZ2xlQXJyYXlcclxuICogQGRlc2MgR2V0cyBhbiBhcnJheSBvZiBsZWdlbmQgZWxlbWVudHMgd2l0aCB0cnVlL2ZhbHNlIHRhZ3MgZm9yIGlmIHRvZ2dsZWRcclxuICogQHBhcmFtIHthbnl9IHNlbGVjdGVkSGVhZGVycyAtIGhlYWRlcnMgc2VsZWN0ZWQgYnkgdXNlclxyXG4gKiBAcGFyYW0ge2FueX0gYWxsSGVhZGVycyAtIGFsbCBhdmFpbGFibGUgaGVhZGVycyBpbiB0aGUgdmlzdWFsXHJcbiAqIEByZXR1cm5zIHthcnJheX0gLSBhcnJheSBvZiBsZWdlbmQgZWxlbWVudHNcclxuICovXHJcbmZ1bmN0aW9uIGdldExlZ2VuZEVsZW1lbnRUb2dnbGVBcnJheShzZWxlY3RlZEhlYWRlcnMsIGFsbEhlYWRlcnMpIHtcclxuICAgIGxldCBsZWdlbmRUb2dnbGVBcnJheSA9IFtdO1xyXG4gICAgZm9yIChsZXQgaGVhZGVyIG9mIGFsbEhlYWRlcnMpIHtcclxuICAgICAgICBsZWdlbmRUb2dnbGVBcnJheS5wdXNoKHsgZWxlbWVudDogaGVhZGVyIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAobGV0IHRvZ2dsZUtleSBvZiBsZWdlbmRUb2dnbGVBcnJheSkge1xyXG4gICAgICAgIGZvciAobGV0IGhlYWRlciBvZiBzZWxlY3RlZEhlYWRlcnMpIHtcclxuICAgICAgICAgICAgaWYgKHRvZ2dsZUtleS5lbGVtZW50ID09PSBoZWFkZXIpIHtcclxuICAgICAgICAgICAgICAgIHRvZ2dsZUtleS50b2dnbGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRvZ2dsZUtleS50b2dnbGUgIT09IHRydWUpIHtcclxuICAgICAgICAgICAgdG9nZ2xlS2V5LnRvZ2dsZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBsZWdlbmRUb2dnbGVBcnJheTtcclxufVxyXG5cclxuLyoqXHJcbiAqIGdlbmVyYXRlTGVnZW5kRWxlbWVudHNcclxuICpcclxuICogQHBhcmFtIHthbnl9IGNoYXJ0IC0gY2hhcnQgb2JqZWN0XHJcbiAqIEBwYXJhbSB7YW55fSBsZWdlbmREYXRhIC1sZWdlbmQgZGF0YSBmb3IgdmlzdWFsXHJcbiAqIEBwYXJhbSB7YW55fSBkcmF3RnVuYyAtIHJlZHJhdyBmdW5jdGlvbiBmb3IgdmlzdWFsXHJcbiAqIEByZXR1cm5zIHtvYmplY3R9IC0gbGVnZW5kIHJlY3RhbmdsZXNcclxuICovXHJcbmZ1bmN0aW9uIGdlbmVyYXRlTGVnZW5kRWxlbWVudHMoY2hhcnQsIGxlZ2VuZERhdGEsIGRyYXdGdW5jKSB7XHJcbiAgICBsZXQgc3ZnID0gY2hhcnQuc3ZnLFxyXG4gICAgICAgIGNvbnRhaW5lciA9IGNoYXJ0LmNvbmZpZy5jb250YWluZXIsXHJcbiAgICAgICAgbGVnZW5kLFxyXG4gICAgICAgIGxlZ2VuZFJvdyA9IDAsXHJcbiAgICAgICAgbGVnZW5kQ29sdW1uID0gMCxcclxuICAgICAgICBsZWdlbmREYXRhTGVuZ3RoID0gbGVnZW5kRGF0YS5sZW5ndGgsXHJcbiAgICAgICAgbGVnZW5kRWxlbWVudFRvZ2dsZUFycmF5LFxyXG4gICAgICAgIGxlZ2VuZFJlY3RhbmdsZXMsXHJcbiAgICAgICAgbGVnZW5kVGV4dDtcclxuXHJcbiAgICBpZiAoIWNoYXJ0Ll92YXJzLmxlZ2VuZEluZGV4KSB7XHJcbiAgICAgICAgY2hhcnQuX3ZhcnMubGVnZW5kSW5kZXggPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghY2hhcnQuX3ZhcnMubGVnZW5kSW5kZXhNYXgpIHtcclxuICAgICAgICBjaGFydC5fdmFycy5sZWdlbmRJbmRleE1heCA9IE1hdGguZmxvb3IobGVnZW5kRGF0YUxlbmd0aCAvIGNoYXJ0Ll92YXJzLmxlZ2VuZE1heCAtIDAuMDEpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vaWYgbGVnZW5kIGhlYWRlcnMgZG9uJ3QgZXhpc3QsIHNldCB0aGVtIGVxdWFsIHRvIGxlZ2VuZCBkYXRhXHJcbiAgICBpZiAoIWNoYXJ0Ll92YXJzLmxlZ2VuZEhlYWRlcnMgJiYgIWNoYXJ0Ll92YXJzLnNlcmllc0ZsaXBwZWQpIHtcclxuICAgICAgICBjaGFydC5fdmFycy5sZWdlbmRIZWFkZXJzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShsZWdlbmREYXRhKSk7XHJcbiAgICB9IGVsc2UgaWYgKCFjaGFydC5fdmFycy5mbGlwcGVkTGVnZW5kSGVhZGVycyAmJiBjaGFydC5fdmFycy5zZXJpZXNGbGlwcGVkKSB7XHJcbiAgICAgICAgY2hhcnQuX3ZhcnMuZmxpcHBlZExlZ2VuZEhlYWRlcnMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGxlZ2VuZERhdGEpKTtcclxuICAgIH1cclxuICAgIC8vU2V0IGxlZ2VuZCBlbGVtZW50IHRvZ2dsZSBhcnJheSBiYXNlZCBvbiBpZiBzZXJpZXMgaXMgZmxpcHBlZFxyXG4gICAgaWYgKCFjaGFydC5fdmFycy5zZXJpZXNGbGlwcGVkKSB7XHJcbiAgICAgICAgbGVnZW5kRWxlbWVudFRvZ2dsZUFycmF5ID0gZ2V0TGVnZW5kRWxlbWVudFRvZ2dsZUFycmF5KGNoYXJ0Ll92YXJzLmxlZ2VuZEhlYWRlcnMsIGxlZ2VuZERhdGEpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBsZWdlbmRFbGVtZW50VG9nZ2xlQXJyYXkgPSBnZXRMZWdlbmRFbGVtZW50VG9nZ2xlQXJyYXkoY2hhcnQuX3ZhcnMuZmxpcHBlZExlZ2VuZEhlYWRlcnMsIGxlZ2VuZERhdGEpO1xyXG4gICAgfVxyXG5cclxuICAgIGxlZ2VuZCA9IHN2Zy5hcHBlbmQoJ2cnKVxyXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICdsZWdlbmQnKTtcclxuXHJcbiAgICAvL0FkZGluZyBjb2xvcmVkIHJlY3RhbmdsZXMgdG8gdGhlIGxlZ2VuZFxyXG4gICAgbGVnZW5kUmVjdGFuZ2xlcyA9IGxlZ2VuZC5zZWxlY3RBbGwoJ3JlY3QnKVxyXG4gICAgICAgIC5kYXRhKGxlZ2VuZERhdGEpXHJcbiAgICAgICAgLmVudGVyKClcclxuICAgICAgICAuYXBwZW5kKCdyZWN0JylcclxuICAgICAgICAuYXR0cignY2xhc3MnLCAnbGVnZW5kUmVjdCcpXHJcbiAgICAgICAgLmF0dHIoJ3gnLCAoZCwgaSkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgbGVnZW5kUG9zO1xyXG4gICAgICAgICAgICBpZiAoaSAlIChjaGFydC5fdmFycy5sZWdlbmRNYXggLyAzKSA9PT0gMCAmJiBpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgbGVnZW5kQ29sdW1uID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZWdlbmRQb3MgPSAyMDAgKiBsZWdlbmRDb2x1bW47XHJcbiAgICAgICAgICAgIGxlZ2VuZENvbHVtbisrO1xyXG4gICAgICAgICAgICByZXR1cm4gbGVnZW5kUG9zO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmF0dHIoJ3knLCAoZCwgaSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoaSAlIChjaGFydC5fdmFycy5sZWdlbmRNYXggLyAzKSA9PT0gMCAmJiBpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgbGVnZW5kUm93Kys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGkgJSBjaGFydC5fdmFycy5sZWdlbmRNYXggPT09IDAgJiYgaSA+IDApIHtcclxuICAgICAgICAgICAgICAgIGxlZ2VuZFJvdyA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIChjb250YWluZXIuaGVpZ2h0ICsgMTApICsgKDE1ICogKGxlZ2VuZFJvdyArIDEpKSAtIDU7IC8vSW5jcmVtZW50IHJvdyB3aGVuIGNvbHVtbiBsaW1pdCBpcyByZWFjaGVkXHJcbiAgICAgICAgfSlcclxuICAgICAgICAuYXR0cignd2lkdGgnLCBjaGFydC5fdmFycy5ncmlkU2l6ZSlcclxuICAgICAgICAuYXR0cignaGVpZ2h0JywgY2hhcnQuX3ZhcnMuZ3JpZFNpemUpXHJcbiAgICAgICAgLmF0dHIoJ2ZpbGwnLCAoZCwgaSkgPT4gZ2V0Q29sb3JzKGNoYXJ0Ll92YXJzLmNvbG9yLCBpLCBsZWdlbmREYXRhW2ldKSlcclxuICAgICAgICAuYXR0cignZGlzcGxheScsIChkLCBpKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChpID49IChjaGFydC5fdmFycy5sZWdlbmRJbmRleCAqIGNoYXJ0Ll92YXJzLmxlZ2VuZE1heCkgJiYgaSA8PSAoKGNoYXJ0Ll92YXJzLmxlZ2VuZEluZGV4ICogY2hhcnQuX3ZhcnMubGVnZW5kTWF4KSArIChjaGFydC5fdmFycy5sZWdlbmRNYXggLSAxKSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnYWxsJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gJ25vbmUnO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmF0dHIoJ29wYWNpdHknLCAoZCwgaSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIWxlZ2VuZEVsZW1lbnRUb2dnbGVBcnJheSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICcxJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobGVnZW5kRWxlbWVudFRvZ2dsZUFycmF5W2ldLnRvZ2dsZSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICcxJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gJzAuMic7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgbGVnZW5kUm93ID0gMDtcclxuICAgIGxlZ2VuZENvbHVtbiA9IDA7XHJcblxyXG4gICAgLy9BZGRpbmcgdGV4dCBsYWJlbHMgZm9yIGVhY2ggcmVjdGFuZ2xlIGluIGxlZ2VuZFxyXG4gICAgbGVnZW5kVGV4dCA9IGxlZ2VuZC5zZWxlY3RBbGwoJ3RleHQnKVxyXG4gICAgICAgIC5kYXRhKGxlZ2VuZERhdGEpXHJcbiAgICAgICAgLmVudGVyKClcclxuICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAuYXR0cignY2xhc3MnLCAoZCwgaSkgPT4gJ2xlZ2VuZFRleHQgZWRpdGFibGUgZWRpdGFibGUtdGV4dCBlZGl0YWJsZS1jb250ZW50IGVkaXRhYmxlLWxlZ2VuZC0nICsgaSlcclxuICAgICAgICAuYXR0cigneCcsIChkLCBpKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChpICUgKGNoYXJ0Ll92YXJzLmxlZ2VuZE1heCAvIDMpID09PSAwICYmIGkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBsZWdlbmRDb2x1bW4gPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBsZWdlbmRQb3MgPSAyMDAgKiBsZWdlbmRDb2x1bW47XHJcbiAgICAgICAgICAgIGxlZ2VuZENvbHVtbisrO1xyXG4gICAgICAgICAgICByZXR1cm4gbGVnZW5kUG9zICsgMTc7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuYXR0cigneScsIChkLCBpKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChpICUgKGNoYXJ0Ll92YXJzLmxlZ2VuZE1heCAvIDMpID09PSAwICYmIGkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBsZWdlbmRSb3crKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaSAlIGNoYXJ0Ll92YXJzLmxlZ2VuZE1heCA9PT0gMCAmJiBpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgbGVnZW5kUm93ID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gKGNvbnRhaW5lci5oZWlnaHQgKyAxMCkgKyAoMTUgKiAobGVnZW5kUm93ICsgMSkpOyAvL0luY3JlbWVudCByb3cgd2hlbiBjb2x1bW4gbGltaXQgaXMgcmVhY2hlZFxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ3N0YXJ0JylcclxuICAgICAgICAuYXR0cignZHknLCAnMC4zNWVtJykgLy9WZXJ0aWNhbGx5IGFsaWduIHdpdGggbm9kZVxyXG4gICAgICAgIC5hdHRyKCdmaWxsJywgY2hhcnQuX3ZhcnMuZm9udENvbG9yKVxyXG4gICAgICAgIC5hdHRyKCdmb250LXNpemUnLCBjaGFydC5fdmFycy5mb250U2l6ZSlcclxuICAgICAgICAuYXR0cignZGlzcGxheScsIChkLCBpKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChpID49IChjaGFydC5fdmFycy5sZWdlbmRJbmRleCAqIGNoYXJ0Ll92YXJzLmxlZ2VuZE1heCkgJiYgaSA8PSAoKGNoYXJ0Ll92YXJzLmxlZ2VuZEluZGV4ICogY2hhcnQuX3ZhcnMubGVnZW5kTWF4KSArIChjaGFydC5fdmFycy5sZWdlbmRNYXggLSAxKSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnYWxsJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gJ25vbmUnO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLnRleHQoKGQsIGkpID0+IHtcclxuICAgICAgICAgICAgbGV0IGVsZW1lbnROYW1lID0gbGVnZW5kRGF0YVtpXTtcclxuICAgICAgICAgICAgaWYgKGNoYXJ0LmNvbmZpZy50eXBlID09PSAnZ2FudHQnKSB7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50TmFtZSA9IGxlZ2VuZERhdGFbaV0uc2xpY2UoMCwgLTUpOy8vUmVtb3ZpbmcgbGFzdCA1IGNoYXJhY3RlcnMgb2YgbGVnZW5kIGxhYmVsLS0taS5lIHBsYW5uZWRTVEFSVCAtPiBwbGFubmVkXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGVsZW1lbnROYW1lLmxlbmd0aCA+IDIwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudE5hbWUuc3Vic3RyaW5nKDAsIDE5KSArICcuLi4nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50TmFtZTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAvL0FkZGluZyBpbmZvIGJveCB0byBsZWdlbmQgZWxlbWVudHMgd2hlbiBob3ZlcmluZyBvdmVyXHJcbiAgICBsZWdlbmRUZXh0XHJcbiAgICAgICAgLmRhdGEobGVnZW5kRGF0YSlcclxuICAgICAgICAuYXBwZW5kKCdzdmc6dGl0bGUnKVxyXG4gICAgICAgIC50ZXh0KGQgPT4gZCk7XHJcblxyXG5cclxuICAgIC8vT25seSBjcmVhdGUgY2Fyb3VzZWwgaWYgdGhlIG51bWJlciBvZiBlbGVtZW50cyBleGNlZWRzIG9uZSBsZWdlbmQgXCJwYWdlXCJcclxuICAgIGlmIChjaGFydC5fdmFycy5sZWdlbmRJbmRleE1heCA+IDApIHtcclxuICAgICAgICBjcmVhdGVDYXJvdXNlbChjaGFydCwgbGVnZW5kRGF0YSwgZHJhd0Z1bmMpO1xyXG4gICAgfVxyXG4gICAgLy9DZW50ZXJzIHRoZSBsZWdlbmQgaW4gdGhlIHBhbmVsXHJcbiAgICBpZiAobGVnZW5kKSB7XHJcbiAgICAgICAgbGV0IGxlZ2VuZFdpZHRoID0gbGVnZW5kLm5vZGUoKS5nZXRCQm94KCkud2lkdGg7XHJcbiAgICAgICAgbGVnZW5kLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArICgoY29udGFpbmVyLndpZHRoIC0gbGVnZW5kV2lkdGgpIC8gMikgKyAnLCAzMCknKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbGVnZW5kUmVjdGFuZ2xlcztcclxufVxyXG5cclxuLyoqdXBkYXRlRGF0YUZyb21MZWdlbmRcclxuICpcclxuICogUmV0dXJucyBhIGxpc3Qgb2YgZGF0YSBoZWFkZXJzIHRoYXQgc2hvdWxkIGJlIGRpc3BsYXllZCBpbiB2aXpcclxuICogYmFzZWQgb2ZmIHdoYXQgaXMgdG9nZ2xlZCBvbi9vZmYgaW4gbGVnZW5kXHJcbiAqIEBwYXJhbXMgbGVnZW5kRGF0YVxyXG4gKi9cclxuZnVuY3Rpb24gdXBkYXRlRGF0YUZyb21MZWdlbmQobGVnZW5kRGF0YSkge1xyXG4gICAgbGV0IGRhdGEgPSBbXSxcclxuICAgICAgICBsZWdlbmRFbGVtZW50ID0gbGVnZW5kRGF0YVswXTtcclxuICAgIGZvciAobGV0IGVsZSBvZiBsZWdlbmRFbGVtZW50KSB7XHJcbiAgICAgICAgaWYgKGVsZS5hdHRyaWJ1dGVzLm9wYWNpdHkudmFsdWUgIT09ICcwLjInKSB7XHJcbiAgICAgICAgICAgIC8vSWYgbm90IHdoaXRlLCBhZGQgaXQgdG8gdGhlIHVwZGF0ZWQgZGF0YSBhcnJheVxyXG4gICAgICAgICAgICBkYXRhLnB1c2goZWxlLl9fZGF0YV9fKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGF0YTtcclxufVxyXG5cclxuLyoqY3JlYXRlQ2Fyb3VzZWxcclxuICpcclxuICogRHJhd3MgdGhlIGhvcml6b250YWwgbGVnZW5kIGNhcm91c2VsXHJcbiAqIEBwYXJhbXMgY2hhcnQsIGxlZ2VuZERhdGEsIGRyYXdGdW5jXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVDYXJvdXNlbChjaGFydCwgbGVnZW5kRGF0YSwgZHJhd0Z1bmMpIHtcclxuICAgIGxldCBzdmcgPSBjaGFydC5zdmcsXHJcbiAgICAgICAgY29udGFpbmVyID0gY2hhcnQuY29uZmlnLmNvbnRhaW5lcixcclxuICAgICAgICBsZWdlbmRQb2x5Z29uO1xyXG5cclxuICAgIC8vQWRkaW5nIGNhcm91c2VsIHRvIGxlZ2VuZFxyXG4gICAgc3ZnLnNlbGVjdEFsbCgnLmxlZ2VuZC1jYXJvdXNlbCcpLnJlbW92ZSgpO1xyXG4gICAgc3ZnLnNlbGVjdEFsbCgnI2xlZ2VuZC10ZXh0LWluZGV4JykucmVtb3ZlKCk7XHJcblxyXG4gICAgbGVnZW5kUG9seWdvbiA9IHN2Zy5hcHBlbmQoJ2cnKVxyXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICdsZWdlbmQtY2Fyb3VzZWwnKTtcclxuXHJcbiAgICAvL0NyZWF0ZXMgbGVmdCBuYXZpZ2F0aW9uIGFycm93IGZvciBjYXJvdXNlbFxyXG4gICAgbGVnZW5kUG9seWdvbi5hcHBlbmQoJ3BvbHlnb24nKVxyXG4gICAgICAgIC5hdHRyKCdpZCcsICdsZWZ0Q2hldnJvbicpXHJcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3BvaW50ZXItY3Vyc29yJylcclxuICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBjaGFydC5fdmFycy5sZWdlbmRBcnJvd0NvbG9yKVxyXG4gICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsMCknKVxyXG4gICAgICAgIC5hdHRyKCdwb2ludHMnLCAnMCw3LjUsIDE1LDAsIDE1LDE1JylcclxuICAgICAgICAub24oJ2NsaWNrJywgKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoY2hhcnQuX3ZhcnMubGVnZW5kSW5kZXggPj0gMSkge1xyXG4gICAgICAgICAgICAgICAgY2hhcnQuX3ZhcnMubGVnZW5kSW5kZXgtLTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzdmcuc2VsZWN0QWxsKCcubGVnZW5kJykucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIGxldCBsZWdlbmRFbGVtZW50cyA9IGdlbmVyYXRlTGVnZW5kRWxlbWVudHMoY2hhcnQsIGxlZ2VuZERhdGEsIGRyYXdGdW5jKTtcclxuICAgICAgICAgICAgYXR0YWNoQ2xpY2tFdmVudHNUb0xlZ2VuZChjaGFydCwgbGVnZW5kRWxlbWVudHMsIGRyYXdGdW5jLCBsZWdlbmREYXRhKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5hdHRyKHtcclxuICAgICAgICAgICAgZGlzcGxheTogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoYXJ0Ll92YXJzLmxlZ2VuZEluZGV4ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdub25lJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiAnYWxsJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIC8vQ3JlYXRlcyBwYWdlIG51bWJlciBmb3IgY2Fyb3VzZWwgbmF2aWdhdGlvblxyXG4gICAgbGVnZW5kUG9seWdvbi5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgIC5hdHRyKCdpZCcsICdsZWdlbmQtdGV4dC1pbmRleCcpXHJcbiAgICAgICAgLmF0dHIoJ3gnLCAzNSlcclxuICAgICAgICAuYXR0cigneScsIDEyLjUpXHJcbiAgICAgICAgLnN0eWxlKCd0ZXh0LWFuY2hvcicsICdzdGFydCcpXHJcbiAgICAgICAgLnN0eWxlKCdmb250LXNpemUnLCBjaGFydC5fdmFycy5mb250U2l6ZSlcclxuICAgICAgICAudGV4dCgoKSA9PiAoY2hhcnQuX3ZhcnMubGVnZW5kSW5kZXggKyAxKSArICcgLyAnICsgKGNoYXJ0Ll92YXJzLmxlZ2VuZEluZGV4TWF4ICsgMSkpXHJcbiAgICAgICAgLmF0dHIoe1xyXG4gICAgICAgICAgICBkaXNwbGF5OiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hhcnQuX3ZhcnMubGVnZW5kSW5kZXhNYXggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ25vbmUnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdhbGwnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgLy9DcmVhdGVzIHJpZ2h0IG5hdmlnYXRpb24gYXJyb3cgZm9yIGNhcm91c2VsXHJcbiAgICBsZWdlbmRQb2x5Z29uLmFwcGVuZCgncG9seWdvbicpXHJcbiAgICAgICAgLmF0dHIoJ2lkJywgJ3JpZ2h0Q2hldnJvbicpXHJcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3BvaW50ZXItY3Vyc29yJylcclxuICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBjaGFydC5fdmFycy5sZWdlbmRBcnJvd0NvbG9yKVxyXG4gICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDg1LDApJylcclxuICAgICAgICAuYXR0cigncG9pbnRzJywgJzE1LDcuNSwgMCwwLCAwLDE1JylcclxuICAgICAgICAub24oJ2NsaWNrJywgKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoY2hhcnQuX3ZhcnMubGVnZW5kSW5kZXggPCBjaGFydC5fdmFycy5sZWdlbmRJbmRleE1heCkge1xyXG4gICAgICAgICAgICAgICAgY2hhcnQuX3ZhcnMubGVnZW5kSW5kZXgrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzdmcuc2VsZWN0QWxsKCcubGVnZW5kJykucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIGxldCBsZWdlbmRFbGVtZW50cyA9IGdlbmVyYXRlTGVnZW5kRWxlbWVudHMoY2hhcnQsIGxlZ2VuZERhdGEsIGRyYXdGdW5jKTtcclxuICAgICAgICAgICAgYXR0YWNoQ2xpY2tFdmVudHNUb0xlZ2VuZChjaGFydCwgbGVnZW5kRWxlbWVudHMsIGRyYXdGdW5jLCBsZWdlbmREYXRhKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5hdHRyKHtcclxuICAgICAgICAgICAgZGlzcGxheTogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoYXJ0Ll92YXJzLmxlZ2VuZEluZGV4ID09PSBjaGFydC5fdmFycy5sZWdlbmRJbmRleE1heCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnbm9uZSc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2FsbCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAvL0NlbnRlcnMgdGhlIGxlZ2VuZCBwb2x5Z29ucyBpbiB0aGUgcGFuZWxcclxuICAgIGlmIChsZWdlbmRQb2x5Z29uKSB7XHJcbiAgICAgICAgbGV0IGxlZ2VuZFBvbHlnb25XaWR0aCA9IGxlZ2VuZFBvbHlnb24ubm9kZSgpLmdldEJCb3goKS53aWR0aDtcclxuICAgICAgICBsZWdlbmRQb2x5Z29uLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArICgoY29udGFpbmVyLndpZHRoIC0gbGVnZW5kUG9seWdvbldpZHRoKSAvIDIpICsgJywnICsgKGNvbnRhaW5lci5oZWlnaHQgKyAxMDUpICsgJyknKTtcclxuICAgIH1cclxufVxyXG5cclxuXHJcbi8qKmdldFBsb3REYXRhXHJcbiAqXHJcbiAqIFJldHVybnMgb25seSBkYXRhIHZhbHVlcyB0byBiZSBwbG90dGVkOyBpbnB1dCBpcyB0aGUgZGF0YSBvYmplY3RcclxuICogQHBhcmFtcyBvYmplY3REYXRhLCBjaGFydFxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0UGxvdERhdGEob2JqZWN0RGF0YSwgY2hhcnQpIHtcclxuICAgIGxldCBkYXRhID0gW10sXHJcbiAgICAgICAgb2JqRGF0YU5ldyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqZWN0RGF0YSkpOy8vQ29weSBvZiBiYXJEYXRhXHJcbiAgICBmb3IgKGxldCBvYmpFbGUgb2Ygb2JqRGF0YU5ldykge1xyXG4gICAgICAgIGxldCBncm91cCA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGxlZ2VuZEVsZSBvZiBjaGFydC5jdXJyZW50RGF0YS5sZWdlbmREYXRhKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqRWxlW2xlZ2VuZEVsZV0gIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICBncm91cC5wdXNoKG9iakVsZVtsZWdlbmRFbGVdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBkYXRhLnB1c2goZ3JvdXApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRhdGE7XHJcbn1cclxuXHJcbi8qKmdldFBvc0NhbGN1bGF0aW9uc1xyXG4gKkhvbGRzIHRoZSBsb2dpYyBmb3IgcG9zaXRpb25pbmcgYWxsIGJhcnMgb24gYSBiYXIgY2hhcnQgKGRlcGVuZHMgb24gdG9vbERhdGEpXHJcbiAqXHJcbiAqIEBwYXJhbXMgc3ZnLCBjaGFydERhdGEsIG9wdGlvbnMsIHhBeGlzRGF0YSwgeUF4aXNEYXRhLCBjb250YWluZXJcclxuICogQHJldHVybnMge3t9fVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0UG9zQ2FsY3VsYXRpb25zKGNoYXJ0RGF0YSwgX3ZhcnMsIHhBeGlzRGF0YSwgeUF4aXNEYXRhLCBjb250YWluZXIsIGNoYXJ0KSB7XHJcbiAgICBsZXQgeCA9IGp2Q2hhcnRzLmdldEF4aXNTY2FsZSgneCcsIHhBeGlzRGF0YSwgY29udGFpbmVyLCBfdmFycyksXHJcbiAgICAgICAgeSA9IGp2Q2hhcnRzLmdldEF4aXNTY2FsZSgneScsIHlBeGlzRGF0YSwgY29udGFpbmVyLCBfdmFycyksXHJcbiAgICAgICAgc2NhbGVGYWN0b3IgPSAxLFxyXG4gICAgICAgIGRhdGEgPSBbXSxcclxuICAgICAgICBzaXplID0gMCxcclxuICAgICAgICBwb3NpdGlvbkZ1bmN0aW9ucyA9IHt9O1xyXG5cclxuICAgIGZvciAobGV0IGl0ZW0gaW4gY2hhcnQuY3VycmVudERhdGEuZGF0YVRhYmxlKSB7XHJcbiAgICAgICAgaWYgKGl0ZW0gIT09ICdsYWJlbCcgJiYgaXRlbS5pbmRleE9mKCd0b29sdGlwJykgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIHNpemUrKztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZm9yIChsZXQgY2hhcnRFbGUgb2YgY2hhcnREYXRhKSB7XHJcbiAgICAgICAgbGV0IHZhbCA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGtleSBpbiBjaGFydEVsZSkge1xyXG4gICAgICAgICAgICBpZiAoY2hhcnRFbGUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgdmFsLnB1c2goY2hhcnRFbGVba2V5XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZGF0YS5wdXNoKHZhbC5zbGljZSgxLCBjaGFydEVsZS5sZW5ndGgpKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoX3ZhcnMucm90YXRlQXhpcyA9PT0gdHJ1ZSAmJiBfdmFycy5zdGFja1RvZ2dsZSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIHBvc2l0aW9uRnVuY3Rpb25zLnN0YXJ0eCA9ICgpID0+IDA7XHJcbiAgICAgICAgcG9zaXRpb25GdW5jdGlvbnMuc3RhcnR5ID0gKCkgPT4gMDtcclxuICAgICAgICBwb3NpdGlvbkZ1bmN0aW9ucy5zdGFydHdpZHRoID0gKCkgPT4gMDtcclxuICAgICAgICBwb3NpdGlvbkZ1bmN0aW9ucy5zdGFydGhlaWdodCA9ICgpID0+IHkuYmFuZHdpZHRoKCkgKiAwLjk1O1xyXG4gICAgICAgIHBvc2l0aW9uRnVuY3Rpb25zLnggPSAoZCwgaSwgaikgPT4ge1xyXG4gICAgICAgICAgICBsZXQgaW5jcmVtZW50ID0gMDsvL01vdmUgdGhlIHggdXAgYnkgdGhlIHZhbHVlcyB0aGF0IGNvbWUgYmVmb3JlIGl0XHJcbiAgICAgICAgICAgIGZvciAobGV0IGsgPSBpIC0gMTsgayA+PSAwOyBrLS0pIHtcclxuICAgICAgICAgICAgICAgIGlmICghaXNOYU4oaltrXS5fX2RhdGFfXykpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbmNyZW1lbnQgKz0galtrXS5fX2RhdGFfXztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4geChpbmNyZW1lbnQpID09PSAwID8gMSA6IHgoaW5jcmVtZW50KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHBvc2l0aW9uRnVuY3Rpb25zLnkgPSAoKSA9PiAwO1xyXG4gICAgICAgIHBvc2l0aW9uRnVuY3Rpb25zLndpZHRoID0gZCA9PiBNYXRoLmFicyh4KDApIC0geChkKSk7XHJcbiAgICAgICAgcG9zaXRpb25GdW5jdGlvbnMuaGVpZ2h0ID0gKCkgPT4geS5iYW5kd2lkdGgoKSAqIDAuOTU7XHJcbiAgICB9IGVsc2UgaWYgKF92YXJzLnJvdGF0ZUF4aXMgPT09IHRydWUgJiYgX3ZhcnMuc3RhY2tUb2dnbGUgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgcG9zaXRpb25GdW5jdGlvbnMuc3RhcnR4ID0gKCkgPT4gMDtcclxuICAgICAgICBwb3NpdGlvbkZ1bmN0aW9ucy5zdGFydHkgPSAoZCwgaSkgPT4geS5iYW5kd2lkdGgoKSAvIHNpemUgKiBpO1xyXG4gICAgICAgIHBvc2l0aW9uRnVuY3Rpb25zLnN0YXJ0d2lkdGggPSAoKSA9PiAwO1xyXG4gICAgICAgIHBvc2l0aW9uRnVuY3Rpb25zLnN0YXJ0aGVpZ2h0ID0gKCkgPT4gKHkuYmFuZHdpZHRoKCkgLyBzaXplICogMC45NSkgKiBzY2FsZUZhY3RvcjtcclxuICAgICAgICBwb3NpdGlvbkZ1bmN0aW9ucy54ID0gZCA9PiB4KDApIC0geChkKSA+IDAgPyB4KGQpIDogeCgwKTtcclxuICAgICAgICBwb3NpdGlvbkZ1bmN0aW9ucy55ID0gKGQsIGkpID0+IHkuYmFuZHdpZHRoKCkgLyBzaXplICogaTtcclxuICAgICAgICBwb3NpdGlvbkZ1bmN0aW9ucy53aWR0aCA9IGQgPT4gTWF0aC5hYnMoeCgwKSAtIHgoZCkpO1xyXG4gICAgICAgIHBvc2l0aW9uRnVuY3Rpb25zLmhlaWdodCA9ICgpID0+ICh5LmJhbmR3aWR0aCgpIC8gc2l6ZSAqIDAuOTUpICogc2NhbGVGYWN0b3I7XHJcbiAgICB9IGVsc2UgaWYgKF92YXJzLnJvdGF0ZUF4aXMgPT09IGZhbHNlICYmIF92YXJzLnN0YWNrVG9nZ2xlID09PSB0cnVlKSB7XHJcbiAgICAgICAgcG9zaXRpb25GdW5jdGlvbnMuc3RhcnR4ID0gKCkgPT4gMDtcclxuICAgICAgICBwb3NpdGlvbkZ1bmN0aW9ucy5zdGFydHkgPSAoKSA9PiBjb250YWluZXIuaGVpZ2h0O1xyXG4gICAgICAgIHBvc2l0aW9uRnVuY3Rpb25zLnN0YXJ0d2lkdGggPSAoKSA9PiAoeC5iYW5kd2lkdGgoKSAqIDAuOTUpICogc2NhbGVGYWN0b3I7XHJcbiAgICAgICAgcG9zaXRpb25GdW5jdGlvbnMuc3RhcnRoZWlnaHQgPSAoKSA9PiAwO1xyXG4gICAgICAgIHBvc2l0aW9uRnVuY3Rpb25zLnggPSAoKSA9PiAwO1xyXG4gICAgICAgIHBvc2l0aW9uRnVuY3Rpb25zLnkgPSAoZCwgaSwgaikgPT4ge1xyXG4gICAgICAgICAgICBsZXQgaW5jcmVtZW50ID0gMDsvL01vdmUgdGhlIHkgdXAgYnkgdGhlIHZhbHVlcyB0aGF0IGNvbWUgYmVmb3JlIGl0XHJcbiAgICAgICAgICAgIGZvciAobGV0IGsgPSBpIC0gMTsgayA+PSAwOyBrLS0pIHtcclxuICAgICAgICAgICAgICAgIGlmICghaXNOYU4oaltrXS5fX2RhdGFfXykpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbmNyZW1lbnQgKz0galtrXS5fX2RhdGFfXztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4geShwYXJzZUZsb2F0KGQpICsgaW5jcmVtZW50KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHBvc2l0aW9uRnVuY3Rpb25zLndpZHRoID0gKCkgPT4gKHguYmFuZHdpZHRoKCkgKiAwLjk1KSAqIHNjYWxlRmFjdG9yO1xyXG4gICAgICAgIHBvc2l0aW9uRnVuY3Rpb25zLmhlaWdodCA9IGQgPT4gY29udGFpbmVyLmhlaWdodCAtIHkoZCk7XHJcbiAgICB9IGVsc2UgaWYgKF92YXJzLnJvdGF0ZUF4aXMgPT09IGZhbHNlICYmIF92YXJzLnN0YWNrVG9nZ2xlID09PSBmYWxzZSkge1xyXG4gICAgICAgIHBvc2l0aW9uRnVuY3Rpb25zLnN0YXJ0eCA9IChkLCBpKSA9PiB4LmJhbmR3aWR0aCgpIC8gc2l6ZSAqIGk7XHJcbiAgICAgICAgcG9zaXRpb25GdW5jdGlvbnMuc3RhcnR5ID0gKCkgPT4gY29udGFpbmVyLmhlaWdodDtcclxuICAgICAgICBwb3NpdGlvbkZ1bmN0aW9ucy5zdGFydHdpZHRoID0gKCkgPT4geC5iYW5kd2lkdGgoKSAvIHNpemUgKiAwLjk1O1xyXG4gICAgICAgIHBvc2l0aW9uRnVuY3Rpb25zLnN0YXJ0aGVpZ2h0ID0gKCkgPT4gMDtcclxuICAgICAgICBwb3NpdGlvbkZ1bmN0aW9ucy54ID0gKGQsIGkpID0+IHguYmFuZHdpZHRoKCkgLyBzaXplICogaTtcclxuICAgICAgICBwb3NpdGlvbkZ1bmN0aW9ucy55ID0gZCA9PiB5KDApIC0geShkKSA+IDAgPyB5KGQpIDogeSgwKTtcclxuICAgICAgICBwb3NpdGlvbkZ1bmN0aW9ucy53aWR0aCA9ICgpID0+IHguYmFuZHdpZHRoKCkgLyBzaXplICogMC45NTtcclxuICAgICAgICBwb3NpdGlvbkZ1bmN0aW9ucy5oZWlnaHQgPSBkID0+IE1hdGguYWJzKHkoMCkgLSB5KGQpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBwb3NpdGlvbkZ1bmN0aW9ucztcclxufVxyXG5cclxuLyoqZ2V0Q29sb3JzXHJcbiAqXHJcbiAqIGdldHMgdGhlIGNvbG9ycyB0byBhcHBseSB0byB0aGUgc3BlY2lmaWMgY2hhcnRcclxuICogQHBhcmFtcyBjb2xvck9iaiwgaW5kZXgsIGxhYmVsXHJcbiAqIEByZXR1cm5zIHt7fX1cclxuICovXHJcbmZ1bmN0aW9uIGdldENvbG9ycyhjb2xvck9iaiwgcGFyYW1JbmRleCwgbGFiZWwpIHtcclxuICAgIGxldCBpbmRleCA9IHBhcmFtSW5kZXgsXHJcbiAgICAgICAgY2xlYW5lZENvbG9ycztcclxuXHJcbiAgICAvL2xvZ2ljIHRvIHJldHVybiB0aGUgY29sb3IgaWYgdGhlIGNvbG9yT2JqIHBhc3NlZCBpblxyXG4gICAgLy9pcyBhbiBvYmplY3Qgd2l0aCB0aGUgbGFiZWwgYmVpbmcgdGhlIGtleVxyXG4gICAgaWYgKHR5cGVvZiBsYWJlbCAhPT0gJ3VuZGVmaW5lZCcgJiYgY29sb3JPYmouaGFzT3duUHJvcGVydHkobGFiZWwpICYmIGNvbG9yT2JqW2xhYmVsXSkge1xyXG4gICAgICAgIHJldHVybiBjb2xvck9ialtsYWJlbF07XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGNvbG9yT2JqKSkge1xyXG4gICAgICAgIGNsZWFuZWRDb2xvcnMgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBrIGluIGNvbG9yT2JqKSB7XHJcbiAgICAgICAgICAgIGlmIChjb2xvck9iai5oYXNPd25Qcm9wZXJ0eShrKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbG9yT2JqW2tdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xlYW5lZENvbG9ycy5wdXNoKGNvbG9yT2JqW2tdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY2xlYW5lZENvbG9ycyA9IGNvbG9yT2JqO1xyXG4gICAgfVxyXG5cclxuICAgIC8vbG9naWMgdG8gcmV0dXJuIGEgcmVwZWF0aW5nIHNldCBvZiBjb2xvcnMgYXNzdW1pbmcgdGhhdFxyXG4gICAgLy90aGUgdXNlciBjaGFuZ2VkIGRhdGEgKGV4OiBmbGlwIHNlcmllcyBvbiBiYXIgY2hhcnQpXHJcbiAgICBpZiAoIWNsZWFuZWRDb2xvcnNbaW5kZXhdKSB7XHJcbiAgICAgICAgd2hpbGUgKGluZGV4ID4gY2xlYW5lZENvbG9ycy5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgIGluZGV4ID0gaW5kZXggLSBjbGVhbmVkQ29sb3JzLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY2xlYW5lZENvbG9yc1tpbmRleF07XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBnZXRBeGlzU2NhbGUod2hpY2hBeGlzLCBheGlzRGF0YSwgY29udGFpbmVyLCBfdmFycywgcGFkZGluZ1R5cGUpIHtcclxuICAgIGxldCBsZWZ0UGFkZGluZyA9IDAuNCxcclxuICAgICAgICByaWdodFBhZGRpbmcgPSAwLjIsXHJcbiAgICAgICAgYXhpc1NjYWxlLFxyXG4gICAgICAgIGF4aXMsXHJcbiAgICAgICAgbWluRGF0ZSxcclxuICAgICAgICBtYXhEYXRlO1xyXG5cclxuICAgIGlmIChwYWRkaW5nVHlwZSA9PT0gJ25vLXBhZGRpbmcnKSB7XHJcbiAgICAgICAgbGVmdFBhZGRpbmcgPSAwO1xyXG4gICAgICAgIHJpZ2h0UGFkZGluZyA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgd2hpY2hBeGlzID09PSAneCcgPyBheGlzID0gY29udGFpbmVyLndpZHRoIDogYXhpcyA9IGNvbnRhaW5lci5oZWlnaHQ7XHJcblxyXG4gICAgaWYgKGF4aXNEYXRhLmRhdGFUeXBlID09PSAnREFURScpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF4aXNEYXRhLnZhbHVlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBheGlzRGF0YS52YWx1ZXNbaV0gPSBuZXcgRGF0ZShheGlzRGF0YS52YWx1ZXNbaV0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbWF4RGF0ZSA9IE1hdGgubWF4LmFwcGx5KG51bGwsIGF4aXNEYXRhLnZhbHVlcyk7XHJcbiAgICAgICAgbWluRGF0ZSA9IE1hdGgubWluLmFwcGx5KG51bGwsIGF4aXNEYXRhLnZhbHVlcyk7XHJcblxyXG4gICAgICAgIGF4aXNTY2FsZSA9IGQzLnNjYWxlVGltZSgpLmRvbWFpbihbbmV3IERhdGUobWluRGF0ZSksIG5ldyBEYXRlKG1heERhdGUpXSkucmFuZ2VSb3VuZChbMCwgYXhpc10pO1xyXG4gICAgfSBlbHNlIGlmIChheGlzRGF0YS5kYXRhVHlwZSA9PT0gJ1NUUklORycpIHtcclxuICAgICAgICBheGlzU2NhbGUgPSBkMy5zY2FsZUJhbmQoKVxyXG4gICAgICAgICAgICAuZG9tYWluKGF4aXNEYXRhLnZhbHVlcylcclxuICAgICAgICAgICAgLnJhbmdlKFswLCBheGlzXSlcclxuICAgICAgICAgICAgLnBhZGRpbmdJbm5lcihsZWZ0UGFkZGluZylcclxuICAgICAgICAgICAgLnBhZGRpbmdPdXRlcihyaWdodFBhZGRpbmcpO1xyXG4gICAgfSBlbHNlIGlmIChheGlzRGF0YS5kYXRhVHlwZSA9PT0gJ05VTUJFUicpIHtcclxuICAgICAgICBsZXQgZG9tYWluO1xyXG4gICAgICAgIGlmIChfdmFycy54UmV2ZXJzZWQgfHwgX3ZhcnMueVJldmVyc2VkKSB7XHJcbiAgICAgICAgICAgIGlmICgoX3ZhcnMueFJldmVyc2VkICYmIHdoaWNoQXhpcyA9PT0gJ3gnKSB8fCAod2hpY2hBeGlzID09PSAneScgJiYgIV92YXJzLnlSZXZlcnNlZCkpIHtcclxuICAgICAgICAgICAgICAgIGRvbWFpbiA9IFtheGlzRGF0YS5tYXgsIGF4aXNEYXRhLm1pbl07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKChfdmFycy55UmV2ZXJzZWQgJiYgd2hpY2hBeGlzID09PSAneScpIHx8ICh3aGljaEF4aXMgPT09ICd4JyAmJiAhX3ZhcnMueFJldmVyc2VkKSkge1xyXG4gICAgICAgICAgICAgICAgZG9tYWluID0gW2F4aXNEYXRhLm1pbiwgYXhpc0RhdGEubWF4XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHdoaWNoQXhpcyA9PT0gJ3gnID8gZG9tYWluID0gW2F4aXNEYXRhLm1pbiwgYXhpc0RhdGEubWF4XSA6IGRvbWFpbiA9IFtheGlzRGF0YS5tYXgsIGF4aXNEYXRhLm1pbl07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoX3ZhcnMuaGFzT3duUHJvcGVydHkoJ2F4aXNUeXBlJykgJiYgX3ZhcnMuYXhpc1R5cGUgPT09ICdMb2dhcml0aG1pYycpIHtcclxuICAgICAgICAgICAgZG9tYWluWzFdID0gMC4xO1xyXG4gICAgICAgICAgICBheGlzU2NhbGUgPSBkMy5zY2FsZUxvZygpLmJhc2UoMTApLmRvbWFpbihkb21haW4pLnJhbmdlUm91bmQoWzAsIGF4aXNdKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBheGlzU2NhbGUgPSBkMy5zY2FsZUxpbmVhcigpLmRvbWFpbihkb21haW4pLnJhbmdlUm91bmQoWzAsIGF4aXNdKTtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0F4aXMgaXMgbm90IGEgdmFsaWQgZGF0YSB0eXBlJyk7XHJcbiAgICAgICAgLy90aHJvdyBuZXcgRXJyb3IoJ0F4aXMgaXMgbm90IGEgdmFsaWQgZGF0YSB0eXBlJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXhpc1NjYWxlO1xyXG59XHJcblxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIERhdGEgZnVuY3Rpb25zICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtzdHJpbmd9IGxhYmVsIC0gVGhlIGZpZWxkIHRoYXQgaXMgY2hlY2tlZCBmb3IgdHlwZVxyXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVRhYmxlS2V5cyAtIE9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBkYXRhIHR5cGUgZm9yIGVhY2ggY29sdW1uIG9mIGRhdGFcclxuICovXHJcbmZ1bmN0aW9uIGdldERhdGFUeXBlRnJvbUtleXMobGFiZWwsIGRhdGFUYWJsZUtleXMsIGRlZmF1bHRUeXBlID0gJ1NUUklORycpIHtcclxuICAgIGxldCB0eXBlID0gZGVmYXVsdFR5cGU7XHJcblxyXG4gICAgZm9yIChsZXQga2V5IG9mIGRhdGFUYWJsZUtleXMpIHtcclxuICAgICAgICAvL1JlcGxhY2UgdW5kZXJzY29yZXMgd2l0aCBzcGFjZXNcclxuICAgICAgICBpZiAoa2V5Lm5hbWUucmVwbGFjZSgvXy9nLCAnICcpID09PSBsYWJlbC5yZXBsYWNlKC9fL2csICcgJykpIHtcclxuICAgICAgICAgICAgaWYgKGtleS5oYXNPd25Qcm9wZXJ0eSgndHlwZScpKSB7XHJcbiAgICAgICAgICAgICAgICB0eXBlID0gKGtleS50eXBlICsgJycpLnRvVXBwZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ1NUUklORycpIHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlID0gJ1NUUklORyc7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdEQVRFJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSAnREFURSc7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdOVU1CRVInKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9ICdOVU1CRVInO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlID0gJ05VTUJFUic7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0eXBlO1xyXG59XHJcblxyXG4vKipzZXRCYXJMaW5lTGVnZW5kRGF0YVxyXG4gKiAgZ2V0cyBsZWdlbmQgaW5mbyBmcm9tIGNoYXJ0IERhdGFcclxuICpcclxuICogQHBhcmFtcyBkYXRhLCB0eXBlXHJcbiAqIEByZXR1cm5zIFtdIG9mIGxlZ2VuZCB0ZXh0XHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRCYXJMaW5lTGVnZW5kRGF0YShkYXRhKSB7XHJcbiAgICBsZXQgbGVnZW5kQXJyYXkgPSBbXTtcclxuICAgIGZvciAobGV0IGl0ZW0gaW4gZGF0YS5kYXRhVGFibGUpIHtcclxuICAgICAgICBpZiAoZGF0YS5kYXRhVGFibGUuaGFzT3duUHJvcGVydHkoaXRlbSkpIHtcclxuICAgICAgICAgICAgaWYgKGl0ZW0gIT09ICdsYWJlbCcpIHtcclxuICAgICAgICAgICAgICAgIGxlZ2VuZEFycmF5LnB1c2goZGF0YS5kYXRhVGFibGVbaXRlbV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxlZ2VuZEFycmF5O1xyXG59XHJcblxyXG4vKipzZXRDaGFydENvbG9yc1xyXG4gKiAgY2xlYW5zIGluY29taW5nIGNvbG9ycyBmb3IgY29uc2lzdGVuY3lcclxuICpcclxuICogQHBhcmFtcyBjb2xvckFycmF5LCBsZWdlbmREYXRhXHJcbiAqIEByZXR1cm5zIG9iamVjdCB3aXRoIGNvbG9yc1xyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIHNldENoYXJ0Q29sb3JzKHRvb2xEYXRhLCBsZWdlbmREYXRhLCBkZWZhdWx0Q29sb3JBcnJheSkge1xyXG4gICAgLy9mdW5jdGlvbiBoYW5kbGVzIDMgY29sb3IgaW5wdXRzXHJcbiAgICAvL3Rvb2xEYXRhIGFzIGFuIGFycmF5IGluIHRvb2xEYXRhXHJcbiAgICAvL3Rvb2xEYXRhIGFzIGFuIG9iamVjdFxyXG4gICAgLy90b29sRGF0YSBhcyAnbm9uZSdcclxuICAgIC8vYW55IG90aGVyIGNhc2Ugd2lsbCByZXN1bHQgaW4gdXNpbmcgZGVmYXVsdENvbG9yQXJyYXlcclxuXHJcbiAgICBsZXQgY29sb3JzID0ge30sXHJcbiAgICAgICAgdXNlZENvbG9ycyA9IFtdLFxyXG4gICAgICAgIHVuYWNjb3VudGVkTGVnZW5kRWxlbWVudHMgPSBbXSxcclxuICAgICAgICB0b29sRGF0YUFzQXJyYXk7XHJcblxyXG4gICAgLy90b29sRGF0YSBpcyBhcnJheVxyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodG9vbERhdGEpKSB7XHJcbiAgICAgICAgaWYgKHRvb2xEYXRhLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgY29sb3JzID0gY3JlYXRlQ29sb3JzV2l0aERlZmF1bHQobGVnZW5kRGF0YSwgdG9vbERhdGEpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbG9ycyA9IGNyZWF0ZUNvbG9yc1dpdGhEZWZhdWx0KGxlZ2VuZERhdGEsIGRlZmF1bHRDb2xvckFycmF5KTtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKHRvb2xEYXRhID09PSBPYmplY3QodG9vbERhdGEpKSB7XHJcbiAgICAgICAgZm9yIChsZXQgbGVnZW5kRWxlIG9mIGxlZ2VuZERhdGEpIHtcclxuICAgICAgICAgICAgaWYgKHRvb2xEYXRhLmhhc093blByb3BlcnR5KGxlZ2VuZEVsZSkpIHtcclxuICAgICAgICAgICAgICAgIHVzZWRDb2xvcnMucHVzaCh0b29sRGF0YVtsZWdlbmRFbGVdKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHVuYWNjb3VudGVkTGVnZW5kRWxlbWVudHMucHVzaChsZWdlbmRFbGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vY2hlY2sgaWYgb2JqZWN0IGhhcyBkZXNpcmVkIGtleXNcclxuICAgICAgICBpZiAodXNlZENvbG9ycy5sZW5ndGggPT09IGxlZ2VuZERhdGEubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGNvbG9ycyA9IHRvb2xEYXRhO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodXNlZENvbG9ycy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHRvb2xEYXRhQXNBcnJheSA9IE9iamVjdC52YWx1ZXModG9vbERhdGEpO1xyXG4gICAgICAgICAgICBpZiAodG9vbERhdGFBc0FycmF5Lmxlbmd0aCA+IGxlZ2VuZERhdGEubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBjb2xvcnMgPSBjcmVhdGVDb2xvcnNXaXRoRGVmYXVsdChsZWdlbmREYXRhLCB0b29sRGF0YUFzQXJyYXkpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29sb3JzID0gY3JlYXRlQ29sb3JzV2l0aERlZmF1bHQobGVnZW5kRGF0YSwgZGVmYXVsdENvbG9yQXJyYXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdG9vbERhdGFBc0FycmF5ID0gT2JqZWN0LnZhbHVlcyh0b29sRGF0YSk7XHJcbiAgICAgICAgICAgIGlmICh0b29sRGF0YUFzQXJyYXkubGVuZ3RoID4gbGVnZW5kRGF0YS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGNvbG9ycyA9IGNyZWF0ZUNvbG9yc1dpdGhEZWZhdWx0KGxlZ2VuZERhdGEsIHRvb2xEYXRhQXNBcnJheSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb2xvcnMgPSBjcmVhdGVDb2xvcnNXaXRoRGVmYXVsdChsZWdlbmREYXRhLCBkZWZhdWx0Q29sb3JBcnJheSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbG9ycyA9IGNyZWF0ZUNvbG9yc1dpdGhEZWZhdWx0KGxlZ2VuZERhdGEsIGRlZmF1bHRDb2xvckFycmF5KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY29sb3JzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVDb2xvcnNXaXRoRGVmYXVsdChsZWdlbmREYXRhLCBjb2xvcnMpIHtcclxuICAgIGxldCBtYXBwZWRDb2xvcnMgPSB7fSxcclxuICAgICAgICBjb3VudCA9IDA7XHJcbiAgICBmb3IgKGxldCBsZWdlbmRFbGUgb2YgbGVnZW5kRGF0YSkge1xyXG4gICAgICAgIGlmIChjb3VudCA+IGNvbG9ycy5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgIGNvdW50ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbWFwcGVkQ29sb3JzW2xlZ2VuZEVsZV0gPSBjb2xvcnNbY291bnRdO1xyXG4gICAgICAgIGNvdW50Kys7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWFwcGVkQ29sb3JzO1xyXG59XHJcblxyXG4vKipjbGVhblRvb2xEYXRhXHJcbiAqICBjbGVhbnMgaW5jb21pbmcgdG9vbERhdGEgZm9yIGNvbnNpc3RlbmN5XHJcbiAqXHJcbiAqIEBwYXJhbSB0b29sRGF0YVxyXG4gKiBAcmV0dXJucyBvYmplY3Qgd2l0aCB0b29sZGF0YVxyXG4gKi9cclxuZnVuY3Rpb24gY2xlYW5Ub29sRGF0YShvcHRpb25zID0ge30sIGVkaXRPcHRpb25zID0ge30pIHtcclxuICAgIGxldCBkYXRhID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcbiAgICBpZiAoIWRhdGEuaGFzT3duUHJvcGVydHkoJ3JvdGF0ZUF4aXMnKSkge1xyXG4gICAgICAgIGRhdGEucm90YXRlQXhpcyA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkoJ3N0YWNrVG9nZ2xlJykpIHtcclxuICAgICAgICBpZiAoZGF0YS5zdGFja1RvZ2dsZSA9PT0gJ3N0YWNrLWRhdGEnIHx8IGRhdGEuc3RhY2tUb2dnbGUgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgZGF0YS5zdGFja1RvZ2dsZSA9IHRydWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZGF0YS5zdGFja1RvZ2dsZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZGF0YS5zdGFja1RvZ2dsZSA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkoJ2NvbG9ycycpKSB7XHJcbiAgICAgICAgZGF0YS5jb2xvciA9IGRhdGEuY29sb3JzO1xyXG4gICAgfVxyXG4gICAgaWYgKCFkYXRhLmhhc093blByb3BlcnR5KCd0aHJlc2hvbGRzJykpIHtcclxuICAgICAgICBkYXRhLnRocmVzaG9sZHMgPSBbXTtcclxuICAgIH1cclxuXHJcbiAgICAvL1RoZXNlIGFyZSB1c2VkIGluIHNldHRpbmcgZHluYW1pYyBtYXJnaW5zIG9uIHRoZSB5IEF4aXMgaW4ganZDaGFydHNcclxuICAgIGlmIChlZGl0T3B0aW9ucyAmJiBlZGl0T3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgneUF4aXMnKSAmJiBlZGl0T3B0aW9ucy55QXhpcy5oYXNPd25Qcm9wZXJ0eSgnZWRpdGFibGUtdGV4dC1zaXplJykpIHtcclxuICAgICAgICBkYXRhLnlMYWJlbEZvbnRTaXplID0gZWRpdE9wdGlvbnMueUF4aXNbJ2VkaXRhYmxlLXRleHQtc2l6ZSddO1xyXG4gICAgICAgIGRhdGEueUxhYmVsRm9ybWF0ID0gZWRpdE9wdGlvbnMueUF4aXNbJ2VkaXRhYmxlLW51bS1mb3JtYXQnXTtcclxuICAgIH1cclxuICAgIHJldHVybiBkYXRhO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRNYXhXaWR0aEZvckF4aXNEYXRhKGF4aXMsIGF4aXNEYXRhLCBfdmFycywgZGltZW5zaW9ucywgbWFyZ2luLCBjaGFydERpdikge1xyXG4gICAgbGV0IG1heEF4aXNUZXh0ID0gJycsXHJcbiAgICAgICAgZm9ybWF0VHlwZSxcclxuICAgICAgICBkdW1teVNWRyxcclxuICAgICAgICBheGlzRHVtbXksXHJcbiAgICAgICAgd2lkdGg7XHJcbiAgICAvL0R5bmFtaWMgbGVmdCBtYXJnaW4gZm9yIGNoYXJ0cyB3aXRoIHkgYXhpc1xyXG4gICAgaWYgKF92YXJzLnJvdGF0ZUF4aXMpIHtcclxuICAgICAgICAvL2dldCBsZW5ndGggb2YgbG9uZ2VzdCB0ZXh0IGxhYmVsIGFuZCBtYWtlIHRoZSBheGlzIGJhc2VkIG9mZiB0aGF0XHJcbiAgICAgICAgbGV0IG1heFN0cmluZyA9ICcnLFxyXG4gICAgICAgICAgICBoZWlnaHQgPSBwYXJzZUludChkaW1lbnNpb25zLmhlaWdodCwgMTApIC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b207XHJcblxyXG4gICAgICAgIC8vY2hlY2sgaWYgbGFiZWxzIHNob3VsZCBiZSBzaG93blxyXG4gICAgICAgIGlmIChoZWlnaHQgIT09IDAgJiYgaGVpZ2h0IC8gYXhpc0RhdGEudmFsdWVzLmxlbmd0aCA8IHBhcnNlSW50KF92YXJzLmZvbnRTaXplLCAxMCkpIHtcclxuICAgICAgICAgICAgYXhpc0RhdGEuaGlkZVZhbHVlcyA9IHRydWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgYXhpc1ZhbHVlIG9mIGF4aXNEYXRhLnZhbHVlcykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRTdHIgPSBheGlzVmFsdWUudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50U3RyLmxlbmd0aCA+IG1heFN0cmluZy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBtYXhTdHJpbmcgPSBjdXJyZW50U3RyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG1heEF4aXNUZXh0ID0gbWF4U3RyaW5nO1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoISFfdmFycy55TGFiZWxGb3JtYXQgfHwgISFfdmFycy54TGFiZWxGb3JtYXQpIHtcclxuICAgICAgICBsZXQgbGFiZWxGb3JtYXQgPSBfdmFycy55TGFiZWxGb3JtYXQsXHJcbiAgICAgICAgICAgIGV4cHJlc3Npb247XHJcbiAgICAgICAgaWYgKGF4aXMgPT09ICd4Jykge1xyXG4gICAgICAgICAgICBsYWJlbEZvcm1hdCA9IF92YXJzLnhMYWJlbEZvcm1hdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvcm1hdFR5cGUgPSBqdkZvcm1hdFZhbHVlVHlwZShheGlzRGF0YS52YWx1ZXMpO1xyXG4gICAgICAgIGV4cHJlc3Npb24gPSBnZXRGb3JtYXRFeHByZXNzaW9uKGxhYmVsRm9ybWF0KTtcclxuXHJcbiAgICAgICAgaWYgKGV4cHJlc3Npb24gIT09ICcnKSB7XHJcbiAgICAgICAgICAgIG1heEF4aXNUZXh0ID0gZXhwcmVzc2lvbihheGlzRGF0YS5tYXgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG1heEF4aXNUZXh0ID0ganZGb3JtYXRWYWx1ZShheGlzRGF0YS5tYXgpO1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZm9ybWF0VHlwZSA9IGp2Rm9ybWF0VmFsdWVUeXBlKGF4aXNEYXRhLnZhbHVlcyk7XHJcbiAgICAgICAgaWYgKCFheGlzRGF0YS5oYXNPd25Qcm9wZXJ0eSgnbWF4JykpIHtcclxuICAgICAgICAgICAgbGV0IG1heExlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGF4aXNWYWx1ZSBvZiBheGlzRGF0YS52YWx1ZXMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChheGlzVmFsdWUgJiYgYXhpc1ZhbHVlLmxlbmd0aCA+IG1heExlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1heExlbmd0aCA9IGF4aXNWYWx1ZS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF4QXhpc1RleHQgPSBheGlzVmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBtYXhBeGlzVGV4dCA9IGp2Rm9ybWF0VmFsdWUoYXhpc0RhdGEubWF4LCBmb3JtYXRUeXBlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy9pZiAodHlwZSA9PT0gJ2hlYXRtYXAnKSB7XHJcbiAgICAvLy8vYWxzbyBuZWVkIHRvIGNoZWNrIHdpZHRoIG9mIGxhYmVsXHJcbiAgICAvL2lmIChtYXhBeGlzVGV4dC5sZW5ndGggPCBheGlzRGF0YS5sYWJlbC5sZW5ndGggKyA1KSB7XHJcbiAgICAvLy8vbmVlZCBhZGRlZCBzcGFjZVxyXG4gICAgLy9pZiAoYXhpcyA9PT0gJ3gnKSB7XHJcbiAgICAvL21heEF4aXNUZXh0ID0gYXhpc0RhdGEubGFiZWw7XHJcbiAgICAvL30gZWxzZSB7XHJcbiAgICAvL21heEF4aXNUZXh0ID0gYXhpc0RhdGEubGFiZWwgKyAnRXh0cmEnO1xyXG4gICAgLy99XHJcbiAgICAvL31cclxuICAgIC8vfVxyXG5cclxuICAgIC8vQ3JlYXRlIGR1bW15IHN2ZyB0byBwbGFjZSBtYXggc2l6ZWQgdGV4dCBlbGVtZW50IG9uXHJcbiAgICBkdW1teVNWRyA9IGNoYXJ0RGl2LmFwcGVuZCgnc3ZnJykuYXR0cignY2xhc3MnLCAnZHVtbXktc3ZnJyk7XHJcblxyXG4gICAgLy9DcmVhdGUgZHVtbXkgdGV4dCBlbGVtZW50XHJcbiAgICBheGlzRHVtbXkgPSBkdW1teVNWR1xyXG4gICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgIC5hdHRyKCdmb250LXNpemUnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChheGlzID09PSAneScgJiYgX3ZhcnMueUxhYmVsRm9udFNpemUgIT09ICdub25lJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF92YXJzLnlMYWJlbEZvbnRTaXplO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChheGlzID09PSAneCcgJiYgX3ZhcnMueExhYmVsRm9udFNpemUgIT09ICdub25lJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF92YXJzLnhMYWJlbEZvbnRTaXplO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBfdmFycy5mb250U2l6ZTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5hdHRyKCd4JywgMClcclxuICAgICAgICAuYXR0cigneScsIDApXHJcbiAgICAgICAgLnRleHQobWF4QXhpc1RleHQpO1xyXG5cclxuICAgIC8vQ2FsY3VsYXRlIHRoZSB3aWR0aCBvZiB0aGUgZHVtbXkgdGV4dFxyXG4gICAgd2lkdGggPSBheGlzRHVtbXkubm9kZSgpLmdldEJCb3goKS53aWR0aDtcclxuICAgIC8vUmVtb3ZlIHRoZSBzdmcgYW5kIHRleHQgZWxlbWVudFxyXG4gICAgY2hhcnREaXYuc2VsZWN0KCcuZHVtbXktc3ZnJykucmVtb3ZlKCk7XHJcbiAgICByZXR1cm4gd2lkdGg7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldERpc3BsYXlWYWx1ZXNFbGVtZW50KG9iamVjdCwgZGF0YVRhYmxlQWxpZ24sIHR5cGUpIHtcclxuICAgIGxldCB2YWx1ZXNBcnJheSA9IFtdO1xyXG5cclxuICAgIGlmICh0eXBlID09PSAnYmFyJyB8fCB0eXBlID09PSAncGllJyB8fCB0eXBlID09PSAnbGluZScgfHwgdHlwZSA9PT0gJ2FyZWEnKSB7XHJcbiAgICAgICAgZm9yIChsZXQga2V5IGluIGRhdGFUYWJsZUFsaWduKSB7XHJcbiAgICAgICAgICAgIGlmIChkYXRhVGFibGVBbGlnbi5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoa2V5LmluZGV4T2YoJ3ZhbHVlJykgPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlc0FycmF5LnB1c2gob2JqZWN0W2RhdGFUYWJsZUFsaWduW2tleV1dKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZm9yIChsZXQga2V5IGluIG9iamVjdCkge1xyXG4gICAgICAgICAgICBpZiAob2JqZWN0Lmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlc0FycmF5LnB1c2gob2JqZWN0W2tleV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbHVlc0FycmF5O1xyXG59XHJcblxyXG4vKipnZXRaU2NhbGVcclxuICpcclxuICogZ2V0cyB0aGUgc2NhbGUgZm9yIHRoZSB6IGF4aXNcclxuICogQHBhcmFtcyB6QXhpc0RhdGEsIGNvbnRhaW5lciwgcGFkZGluZ1xyXG4gKiBAcmV0dXJucyB7e319XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRaU2NhbGUoekF4aXNEYXRhLCBjb250YWluZXIsIF92YXJzKSB7XHJcbiAgICBsZXQgekF4aXNTY2FsZSA9IGQzLnNjYWxlTGluZWFyKClcclxuICAgICAgICAuZG9tYWluKFtkMy5taW4oekF4aXNEYXRhLnZhbHVlcyksIGQzLm1heCh6QXhpc0RhdGEudmFsdWVzKV0pXHJcbiAgICAgICAgLnJhbmdlUm91bmQoW192YXJzLk5PREVfTUlOX1NJWkUsIF92YXJzLk5PREVfTUFYX1NJWkVdKVxyXG4gICAgICAgIC5uaWNlKCk7XHJcbiAgICByZXR1cm4gekF4aXNTY2FsZTtcclxufVxyXG5cclxuLyoqZ2VuZXJhdGVFdmVudEdyb3Vwc1xyXG4gKlxyXG4gKlxyXG4gKiBAcGFyYW1zIGNoYXJ0Q29udGFpbmVyLCBiYXJEYXRhLCBjaGFydFxyXG4gKi9cclxuZnVuY3Rpb24gZ2VuZXJhdGVFdmVudEdyb3VwcyhjaGFydENvbnRhaW5lciwgYmFyRGF0YSwgY2hhcnQpIHtcclxuICAgIGxldCBjb250YWluZXIgPSBjaGFydC5jb25maWcuY29udGFpbmVyLFxyXG4gICAgICAgIGRhdGFUb1Bsb3QgPSBqdkNoYXJ0cy5nZXRQbG90RGF0YShiYXJEYXRhLCBjaGFydCksXHJcbiAgICAgICAgZXZlbnRHcm91cHM7XHJcblxyXG4gICAgLy9JbnZpc2libGUgcmVjdGFuZ2xlcyBvbiBzY3JlZW4gdGhhdCByZXByZXNlbnQgYmFyIGdyb3Vwcy4gVXNlZCB0byBzaG93L2hpZGUgdG9vbCB0aXBzIG9uIGhvdmVyXHJcbiAgICBldmVudEdyb3VwcyA9IGNoYXJ0Q29udGFpbmVyXHJcbiAgICAgICAgLmRhdGEoZGF0YVRvUGxvdClcclxuICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgIC5hcHBlbmQoJ3JlY3QnKVxyXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICdldmVudC1yZWN0JylcclxuICAgICAgICAvL3NldHMgdGhlIHggcG9zaXRpb24gb2YgdGhlIGJhclxyXG4gICAgICAgIC5hdHRyKCd4JywgKGQsIGkpID0+IGNoYXJ0Ll92YXJzLnJvdGF0ZUF4aXMgPyAwIDogKGNvbnRhaW5lci53aWR0aCAvIGJhckRhdGEubGVuZ3RoICogaSkpXHJcbiAgICAgICAgLy9zZXRzIHRoZSB5IHBvc2l0aW9uIG9mIHRoZSBiYXJcclxuICAgICAgICAuYXR0cigneScsIChkLCBpKSA9PiBjaGFydC5fdmFycy5yb3RhdGVBeGlzID8gKGNvbnRhaW5lci5oZWlnaHQgLyBiYXJEYXRhLmxlbmd0aCAqIGkpIDogMClcclxuICAgICAgICAvL3NldHMgdGhlIHdpZHRoIHBvc2l0aW9uIG9mIHRoZSBiYXJcclxuICAgICAgICAuYXR0cignd2lkdGgnLCAoKSA9PiBjaGFydC5fdmFycy5yb3RhdGVBeGlzID8gY29udGFpbmVyLndpZHRoIDogKGNvbnRhaW5lci53aWR0aCAvIGJhckRhdGEubGVuZ3RoKSlcclxuICAgICAgICAvL3NldHMgdGhlIGhlaWdodCBwb3NpdGlvbiBvZiB0aGUgYmFyXHJcbiAgICAgICAgLmF0dHIoJ2hlaWdodCcsICgpID0+IGNoYXJ0Ll92YXJzLnJvdGF0ZUF4aXMgPyAoY29udGFpbmVyLmhlaWdodCAvIGJhckRhdGEubGVuZ3RoKSA6IGNvbnRhaW5lci5oZWlnaHQpXHJcbiAgICAgICAgLmF0dHIoJ2ZpbGwnLCAndHJhbnNwYXJlbnQnKVxyXG4gICAgICAgIC5hdHRyKCdjbGFzcycsIChkLCBpKSA9PiAnZXZlbnQtcmVjdCBlZGl0YWJsZS1iYXIgYmFyLWNvbC0nICsgU3RyaW5nKGJhckRhdGFbaV1bY2hhcnQuY3VycmVudERhdGEuZGF0YVRhYmxlLmxhYmVsXSkucmVwbGFjZSgvXFxzL2csICdfJykucmVwbGFjZSgvXFwuL2csICdfZG90XycpKTtcclxuXHJcbiAgICByZXR1cm4gZXZlbnRHcm91cHM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdlbmVyYXRlVGhyZXNob2xkTGVnZW5kKGNoYXJ0KSB7XHJcbiAgICBsZXQgc3ZnID0gY2hhcnQuc3ZnLFxyXG4gICAgICAgIGNvbG9yTGVnZW5kRGF0YSA9IFtdLFxyXG4gICAgICAgIGdMZWdlbmQsXHJcbiAgICAgICAgbGVnZW5kO1xyXG4gICAgaWYgKGNoYXJ0Ll92YXJzLnRocmVzaG9sZHMgIT09ICdub25lJykge1xyXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgT2JqZWN0LmtleXMoY2hhcnQuX3ZhcnMudGhyZXNob2xkcykubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgY29sb3JMZWdlbmREYXRhLnB1c2goY2hhcnQuX3ZhcnMudGhyZXNob2xkc1tqXS50aHJlc2hvbGROYW1lKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZ0xlZ2VuZCA9IHN2Zy5hcHBlbmQoJ2cnKVxyXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICd0aHJlc2hvbGRMZWdlbmRDb250YWluZXInKTtcclxuXHJcbiAgICBsZWdlbmQgPSBnTGVnZW5kLnNlbGVjdEFsbCgnLnRocmVzaG9sZExlZ2VuZCcpXHJcbiAgICAgICAgLmRhdGEoY29sb3JMZWdlbmREYXRhKVxyXG4gICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3RocmVzaG9sZExlZ2VuZCcpXHJcbiAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIChkLCBpKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBoZWlnaHQgPSAxOSxcclxuICAgICAgICAgICAgICAgIG9mZnNldCA9IDE5ICogY29sb3JMZWdlbmREYXRhLmxlbmd0aCAvIDIsXHJcbiAgICAgICAgICAgICAgICBob3J6ID0gLTIgKiAxMixcclxuICAgICAgICAgICAgICAgIHZlcnQgPSBpICogaGVpZ2h0IC0gb2Zmc2V0O1xyXG4gICAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgaG9yeiArICcsJyArIHZlcnQgKyAnKSc7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgbGVnZW5kLmFwcGVuZCgncmVjdCcpXHJcbiAgICAgICAgLmF0dHIoJ3dpZHRoJywgMTIpXHJcbiAgICAgICAgLmF0dHIoJ2hlaWdodCcsIDEyKVxyXG4gICAgICAgIC5zdHlsZSgnZmlsbCcsIChkLCBpKSA9PiBjaGFydC5fdmFycy50aHJlc2hvbGRzW2ldLnRocmVzaG9sZENvbG9yKTtcclxuXHJcbiAgICBsZWdlbmQuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAuYXR0cigneCcsIDI0KVxyXG4gICAgICAgIC5hdHRyKCd5JywgOClcclxuICAgICAgICAuYXR0cignZm9udC1zaXplJywgJy43NWVtJylcclxuICAgICAgICAudGV4dChkID0+IGQpO1xyXG5cclxuICAgIC8vQ2VudGVycyB0aGUgbGVnZW5kIGluIHRoZSBwYW5lbFxyXG4gICAgaWYgKGdMZWdlbmQpIHtcclxuICAgICAgICBsZXQgbGVnZW5kV2lkdGggPSBnTGVnZW5kLm5vZGUoKS5nZXRCQm94KCkud2lkdGg7XHJcbiAgICAgICAgZ0xlZ2VuZC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyAoY2hhcnQuY29uZmlnLmNvbnRhaW5lci53aWR0aCAtIGxlZ2VuZFdpZHRoKSArICcsJyArICgxMCAqIGNvbG9yTGVnZW5kRGF0YS5sZW5ndGgpICsgJyknKTtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gYXR0YWNoQ2xpY2tFdmVudHNUb0xlZ2VuZChjaGFydCwgbGVnZW5kRWxlbWVudHMsIGRyYXdGdW5jKSB7XHJcbiAgICAvL0FkZGluZyB0aGUgY2xpY2sgZXZlbnQgdG8gbGVnZW5kIHJlY3RhbmdsZXMgZm9yIHRvZ2dsaW5nIG9uL29mZlxyXG4gICAgbGVnZW5kRWxlbWVudHNcclxuICAgICAgICAub24oJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBsZXQgc2VsZWN0ZWRSZWN0ID0gZDMuc2VsZWN0KHRoaXMpLFxyXG4gICAgICAgICAgICAgICAgZGF0YUhlYWRlcnM7XHJcblxyXG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWRSZWN0Ll9ncm91cHNbMF1bMF0uYXR0cmlidXRlcy5vcGFjaXR5LnZhbHVlICE9PSAnMC4yJykge1xyXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRSZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ29wYWNpdHknLCAnMC4yJyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzZWxlY3RlZFJlY3RcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignb3BhY2l0eScsICcxJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vR2V0cyB0aGUgaGVhZGVycyBvZiB0aGUgZGF0YSB0byBiZSBkcmF3blxyXG4gICAgICAgICAgICBkYXRhSGVhZGVycyA9IHVwZGF0ZURhdGFGcm9tTGVnZW5kKGxlZ2VuZEVsZW1lbnRzLl9ncm91cHMpO1xyXG4gICAgICAgICAgICAvL1NldHMgdGhlIGxlZ2VuZERhdGEgdG8gdGhlIHVwZGF0ZWQgaGVhZGVyc1xyXG4gICAgICAgICAgICBpZiAoY2hhcnQuX3ZhcnMuc2VyaWVzRmxpcHBlZCkge1xyXG4gICAgICAgICAgICAgICAgY2hhcnQuX3ZhcnMuZmxpcHBlZExlZ2VuZEhlYWRlcnMgPSBkYXRhSGVhZGVycztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNoYXJ0Ll92YXJzLmxlZ2VuZEhlYWRlcnMgPSBkYXRhSGVhZGVycztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9QbG90cyB0aGUgZGF0YVxyXG4gICAgICAgICAgICBjaGFydC5fdmFycy50cmFuc2l0aW9uVGltZSA9IDgwMDsvL0tlZXAgdHJhbnNpdGlvbiBmb3IgdG9nZ2xpbmcgbGVnZW5kIGVsZW1lbnRzXHJcbiAgICAgICAgICAgIGlmIChjaGFydC5fdmFycy5zZXJpZXNGbGlwcGVkKSB7XHJcbiAgICAgICAgICAgICAgICBjaGFydFtkcmF3RnVuY10oY2hhcnQuZmxpcHBlZERhdGEpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY2hhcnRbZHJhd0Z1bmNdKGNoYXJ0LmRhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjaGFydC5hcHBseUVkaXRNb2RlKSB7XHJcbiAgICAgICAgICAgICAgICBjaGFydC5hcHBseUVkaXRNb2RlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxufVxyXG5cclxuLyoqZ2VuZXJhdGVWZXJ0aWNhbExlZ2VuZEVsZW1lbnRzXHJcbiAqXHJcbiAqIENyZWF0ZXMgdGhlIGxlZ2VuZCBlbGVtZW50cy0tcmVjdGFuZ2xlcyBhbmQgbGFiZWxzXHJcbiAqIEBwYXJhbXMgY2hhcnQsIGxlZ2VuZERhdGEsIGRyYXdGdW5jXHJcbiAqL1xyXG5mdW5jdGlvbiBnZW5lcmF0ZVZlcnRpY2FsTGVnZW5kRWxlbWVudHMoY2hhcnQsIGxlZ2VuZERhdGEsIGRyYXdGdW5jKSB7XHJcbiAgICBsZXQgc3ZnID0gY2hhcnQuc3ZnLFxyXG4gICAgICAgIGxlZ2VuZCxcclxuICAgICAgICBsZWdlbmREYXRhTGVuZ3RoID0gbGVnZW5kRGF0YS5sZW5ndGgsXHJcbiAgICAgICAgbGVnZW5kRWxlbWVudFRvZ2dsZUFycmF5LFxyXG4gICAgICAgIGxlZ2VuZFJlY3RhbmdsZXMsXHJcbiAgICAgICAgbGVnZW5kVGV4dDtcclxuXHJcbiAgICBjaGFydC5fdmFycy5ncmlkU2l6ZSA9IDIwO1xyXG5cclxuICAgIGlmICghY2hhcnQuX3ZhcnMubGVnZW5kSW5kZXgpIHtcclxuICAgICAgICBjaGFydC5fdmFycy5sZWdlbmRJbmRleCA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFjaGFydC5fdmFycy5sZWdlbmRJbmRleE1heCkge1xyXG4gICAgICAgIGNoYXJ0Ll92YXJzLmxlZ2VuZEluZGV4TWF4ID0gTWF0aC5mbG9vcihsZWdlbmREYXRhTGVuZ3RoIC8gY2hhcnQuX3ZhcnMubGVnZW5kTWF4IC0gMC4wMSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy9DaGVjayB0byBzZWUgaWYgbGVnZW5kIGVsZW1lbnQgdG9nZ2xlIGFycmF5IG5lZWRzIHRvIGJlIHNldFxyXG4gICAgaWYgKGNoYXJ0Ll92YXJzLmxlZ2VuZEluZGV4TWF4ID49IDApIHtcclxuICAgICAgICBpZiAoIWNoYXJ0Ll92YXJzLmxlZ2VuZEhlYWRlcnMpIHtcclxuICAgICAgICAgICAgY2hhcnQuX3ZhcnMubGVnZW5kSGVhZGVycyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobGVnZW5kRGF0YSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGVnZW5kRWxlbWVudFRvZ2dsZUFycmF5ID0gZ2V0TGVnZW5kRWxlbWVudFRvZ2dsZUFycmF5KGNoYXJ0Ll92YXJzLmxlZ2VuZEhlYWRlcnMsIGxlZ2VuZERhdGEpO1xyXG4gICAgfVxyXG5cclxuICAgIGxlZ2VuZCA9IHN2Zy5hcHBlbmQoJ2cnKVxyXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICdsZWdlbmQnKVxyXG4gICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyAxOCArICcsJyArIDIwICsgJyknKTtcclxuXHJcbiAgICAvL0FkZGluZyBjb2xvcmVkIHJlY3RhbmdsZXMgdG8gdGhlIGxlZ2VuZFxyXG4gICAgbGVnZW5kUmVjdGFuZ2xlcyA9IGxlZ2VuZC5zZWxlY3RBbGwoJ3JlY3QnKVxyXG4gICAgICAgIC5kYXRhKGxlZ2VuZERhdGEpXHJcbiAgICAgICAgLmVudGVyKClcclxuICAgICAgICAuYXBwZW5kKCdyZWN0JylcclxuICAgICAgICAuYXR0cignY2xhc3MnLCAnbGVnZW5kUmVjdCcpXHJcbiAgICAgICAgLmF0dHIoJ3gnLCAnMycpXHJcbiAgICAgICAgLmF0dHIoJ3knLCAoZCwgaSkgPT4gKGNoYXJ0Ll92YXJzLmdyaWRTaXplKSAqIChpICUgY2hhcnQuX3ZhcnMubGVnZW5kTWF4KSAqIDEuMSlcclxuICAgICAgICAuYXR0cignd2lkdGgnLCBjaGFydC5fdmFycy5ncmlkU2l6ZSlcclxuICAgICAgICAuYXR0cignaGVpZ2h0JywgY2hhcnQuX3ZhcnMuZ3JpZFNpemUpXHJcbiAgICAgICAgLmF0dHIoJ2ZpbGwnLCAoZCwgaSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoKCFsZWdlbmRFbGVtZW50VG9nZ2xlQXJyYXkgJiYgIWNoYXJ0Ll92YXJzLnNlcmllc0ZsaXBwZWQpIHx8IChjaGFydC5fdmFycy5zZXJpZXNGbGlwcGVkICYmICFsZWdlbmRFbGVtZW50VG9nZ2xlQXJyYXkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0Q29sb3JzKGNoYXJ0Ll92YXJzLmNvbG9yLCBpLCBsZWdlbmREYXRhW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoKCFjaGFydC5fdmFycy5zZXJpZXNGbGlwcGVkICYmIGxlZ2VuZEVsZW1lbnRUb2dnbGVBcnJheVtpXS50b2dnbGUgPT09IHRydWUpIHx8XHJcbiAgICAgICAgICAgICAgICAoY2hhcnQuX3ZhcnMuc2VyaWVzRmxpcHBlZCAmJiBsZWdlbmRFbGVtZW50VG9nZ2xlQXJyYXlbaV0udG9nZ2xlID09PSB0cnVlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldENvbG9ycyhjaGFydC5fdmFycy5jb2xvciwgaSwgbGVnZW5kRGF0YVtpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNoYXJ0Ll92YXJzLmVtcHR5TGVnZW5kU3F1YXJlO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmF0dHIoJ2Rpc3BsYXknLCAoZCwgaSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoaSA+PSAoY2hhcnQuX3ZhcnMubGVnZW5kSW5kZXggKiBjaGFydC5fdmFycy5sZWdlbmRNYXgpICYmIGkgPD0gKChjaGFydC5fdmFycy5sZWdlbmRJbmRleCAqIGNoYXJ0Ll92YXJzLmxlZ2VuZE1heCkgKyAoY2hhcnQuX3ZhcnMubGVnZW5kTWF4IC0gMSkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2FsbCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuICdub25lJztcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5hdHRyKCdvcGFjaXR5JywgJzEnKTtcclxuXHJcbiAgICAvL0FkZGluZyB0ZXh0IGxhYmVscyBmb3IgZWFjaCByZWN0YW5nbGUgaW4gbGVnZW5kXHJcbiAgICBsZWdlbmRUZXh0ID0gbGVnZW5kLnNlbGVjdEFsbCgndGV4dCcpXHJcbiAgICAgICAgLmRhdGEobGVnZW5kRGF0YSlcclxuICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgIC5hdHRyKCdjbGFzcycsIChkLCBpKSA9PiAnbGVnZW5kVGV4dCBlZGl0YWJsZSBlZGl0YWJsZS10ZXh0IGVkaXRhYmxlLWNvbnRlbnQgZWRpdGFibGUtbGVnZW5kLScgKyBpKVxyXG4gICAgICAgIC5hdHRyKCd4JywgY2hhcnQuX3ZhcnMuZ3JpZFNpemUgKyA3KVxyXG4gICAgICAgIC5hdHRyKCd5JywgKGQsIGkpID0+IChjaGFydC5fdmFycy5ncmlkU2l6ZSkgKiAoaSAlIGNoYXJ0Ll92YXJzLmxlZ2VuZE1heCkgKiAxLjEgKyAxMClcclxuICAgICAgICAuYXR0cigndGV4dC1hbmNob3InLCAnc3RhcnQnKVxyXG4gICAgICAgIC5hdHRyKCdkeScsICcwLjM1ZW0nKSAvL1ZlcnRpY2FsbHkgYWxpZ24gd2l0aCBub2RlXHJcbiAgICAgICAgLmF0dHIoJ2ZpbGwnLCBjaGFydC5fdmFycy5mb250Q29sb3IpXHJcbiAgICAgICAgLmF0dHIoJ2ZvbnQtc2l6ZScsIGNoYXJ0Ll92YXJzLmZvbnRTaXplKVxyXG4gICAgICAgIC5hdHRyKCdkaXNwbGF5JywgKGQsIGkpID0+IHtcclxuICAgICAgICAgICAgaWYgKGkgPj0gKGNoYXJ0Ll92YXJzLmxlZ2VuZEluZGV4ICogY2hhcnQuX3ZhcnMubGVnZW5kTWF4KSAmJiBpIDw9ICgoY2hhcnQuX3ZhcnMubGVnZW5kSW5kZXggKiBjaGFydC5fdmFycy5sZWdlbmRNYXgpICsgKGNoYXJ0Ll92YXJzLmxlZ2VuZE1heCAtIDEpKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdhbGwnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAnbm9uZSc7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAudGV4dCgoZCwgaSkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgZWxlbWVudE5hbWUgPSBsZWdlbmREYXRhW2ldO1xyXG4gICAgICAgICAgICBpZiAoZWxlbWVudE5hbWUubGVuZ3RoID4gMjApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50TmFtZS5zdWJzdHJpbmcoMCwgMTkpICsgJy4uLic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnROYW1lO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIC8vQWRkaW5nIGluZm8gYm94IHRvIGxlZ2VuZCBlbGVtZW50cyB3aGVuIGhvdmVyaW5nIG92ZXJcclxuICAgIGxlZ2VuZFRleHRcclxuICAgICAgICAuZGF0YShsZWdlbmREYXRhKVxyXG4gICAgICAgIC5hcHBlbmQoJ3N2Zzp0aXRsZScpXHJcbiAgICAgICAgLnRleHQoZCA9PiBkKTtcclxuXHJcbiAgICAvL09ubHkgY3JlYXRlIGNhcm91c2VsIGlmIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgZXhjZWVkcyBvbmUgbGVnZW5kIFwicGFnZVwiXHJcbiAgICBpZiAoY2hhcnQuX3ZhcnMubGVnZW5kSW5kZXhNYXggPiAwKSB7XHJcbiAgICAgICAgY3JlYXRlVmVydGljYWxDYXJvdXNlbChjaGFydCwgbGVnZW5kRGF0YSwgZHJhd0Z1bmMpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBsZWdlbmRSZWN0YW5nbGVzO1xyXG59XHJcblxyXG4vKipjcmVhdGVWZXJ0aWNhbENhcm91c2VsXHJcbiAqXHJcbiAqIERyYXdzIHRoZSB2ZXJ0aWNhbCBsZWdlbmQgY2Fyb3VzZWxcclxuICogQHBhcmFtcyBjaGFydCwgbGVnZW5kRGF0YSwgZHJhd0Z1bmNcclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVZlcnRpY2FsQ2Fyb3VzZWwoY2hhcnQsIGxlZ2VuZERhdGEsIGRyYXdGdW5jKSB7XHJcbiAgICBsZXQgc3ZnID0gY2hhcnQuc3ZnLFxyXG4gICAgICAgIGxlZ2VuZFBvbHlnb247XHJcblxyXG4gICAgLy9BZGRpbmcgY2Fyb3VzZWwgdG8gbGVnZW5kXHJcbiAgICBzdmcuc2VsZWN0QWxsKCcubGVnZW5kLWNhcm91c2VsJykucmVtb3ZlKCk7XHJcbiAgICBzdmcuc2VsZWN0QWxsKCcjbGVnZW5kLXRleHQtaW5kZXgnKS5yZW1vdmUoKTtcclxuXHJcbiAgICBsZWdlbmRQb2x5Z29uID0gc3ZnLmFwcGVuZCgnZycpXHJcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2xlZ2VuZC1jYXJvdXNlbCcpO1xyXG5cclxuICAgIC8vQ3JlYXRlcyBsZWZ0IG5hdmlnYXRpb24gYXJyb3cgZm9yIGNhcm91c2VsXHJcbiAgICBsZWdlbmRQb2x5Z29uLmFwcGVuZCgncG9seWdvbicpXHJcbiAgICAgICAgLmF0dHIoJ2lkJywgJ2xlZnRDaGV2cm9uJylcclxuICAgICAgICAuYXR0cignY2xhc3MnLCAncG9pbnRlci1jdXJzb3InKVxyXG4gICAgICAgIC5zdHlsZSgnZmlsbCcsIGNoYXJ0Ll92YXJzLmxlZ2VuZEFycm93Q29sb3IpXHJcbiAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwnICsgKChjaGFydC5fdmFycy5sZWdlbmRNYXggKiBjaGFydC5fdmFycy5ncmlkU2l6ZSkgKyA1MCkgKyAnKScpXHJcbiAgICAgICAgLmF0dHIoJ3BvaW50cycsICcwLDcuNSwgMTUsMCwgMTUsMTUnKVxyXG4gICAgICAgIC5vbignY2xpY2snLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChjaGFydC5fdmFycy5sZWdlbmRJbmRleCA+PSAxKSB7XHJcbiAgICAgICAgICAgICAgICBjaGFydC5fdmFycy5sZWdlbmRJbmRleC0tO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN2Zy5zZWxlY3RBbGwoJy5sZWdlbmQnKS5yZW1vdmUoKTtcclxuICAgICAgICAgICAgbGV0IGxlZ2VuZEVsZW1lbnRzID0gZ2VuZXJhdGVWZXJ0aWNhbExlZ2VuZEVsZW1lbnRzKGNoYXJ0LCBsZWdlbmREYXRhLCBkcmF3RnVuYyk7XHJcbiAgICAgICAgICAgIGF0dGFjaENsaWNrRXZlbnRzVG9MZWdlbmQoY2hhcnQsIGxlZ2VuZEVsZW1lbnRzLCBkcmF3RnVuYywgbGVnZW5kRGF0YSk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuYXR0cih7XHJcbiAgICAgICAgICAgIGRpc3BsYXk6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChjaGFydC5fdmFycy5sZWdlbmRJbmRleCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnbm9uZSc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2FsbCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAvL0NyZWF0ZXMgcGFnZSBudW1iZXIgZm9yIGNhcm91c2VsIG5hdmlnYXRpb25cclxuICAgIGxlZ2VuZFBvbHlnb24uYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAuYXR0cignaWQnLCAnbGVnZW5kLXRleHQtaW5kZXgnKVxyXG4gICAgICAgIC5hdHRyKCd4JywgMzUpXHJcbiAgICAgICAgLmF0dHIoJ3knLCAyNDIuNSlcclxuICAgICAgICAuc3R5bGUoJ3RleHQtYW5jaG9yJywgJ3N0YXJ0JylcclxuICAgICAgICAuc3R5bGUoJ2ZvbnQtc2l6ZScsIGNoYXJ0Ll92YXJzLmZvbnRTaXplKVxyXG4gICAgICAgIC50ZXh0KCgpID0+IChjaGFydC5fdmFycy5sZWdlbmRJbmRleCArIDEpICsgJyAvICcgKyAoY2hhcnQuX3ZhcnMubGVnZW5kSW5kZXhNYXggKyAxKSlcclxuICAgICAgICAuYXR0cih7XHJcbiAgICAgICAgICAgIGRpc3BsYXk6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChjaGFydC5fdmFycy5sZWdlbmRJbmRleE1heCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnbm9uZSc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2FsbCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAvL0NyZWF0ZXMgcmlnaHQgbmF2aWdhdGlvbiBhcnJvdyBmb3IgY2Fyb3VzZWxcclxuICAgIGxlZ2VuZFBvbHlnb24uYXBwZW5kKCdwb2x5Z29uJylcclxuICAgICAgICAuYXR0cignaWQnLCAncmlnaHRDaGV2cm9uJylcclxuICAgICAgICAuYXR0cignY2xhc3MnLCAncG9pbnRlci1jdXJzb3InKVxyXG4gICAgICAgIC5zdHlsZSgnZmlsbCcsIGNoYXJ0Ll92YXJzLmxlZ2VuZEFycm93Q29sb3IpXHJcbiAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoODUsJyArICgoY2hhcnQuX3ZhcnMubGVnZW5kTWF4ICogY2hhcnQuX3ZhcnMuZ3JpZFNpemUpICsgNTApICsgJyknKVxyXG4gICAgICAgIC5hdHRyKCdwb2ludHMnLCAnMTUsNy41LCAwLDAsIDAsMTUnKVxyXG4gICAgICAgIC5vbignY2xpY2snLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChjaGFydC5fdmFycy5sZWdlbmRJbmRleCA8IGNoYXJ0Ll92YXJzLmxlZ2VuZEluZGV4TWF4KSB7XHJcbiAgICAgICAgICAgICAgICBjaGFydC5fdmFycy5sZWdlbmRJbmRleCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN2Zy5zZWxlY3RBbGwoJy5sZWdlbmQnKS5yZW1vdmUoKTtcclxuICAgICAgICAgICAgbGV0IGxlZ2VuZEVsZW1lbnRzID0gZ2VuZXJhdGVWZXJ0aWNhbExlZ2VuZEVsZW1lbnRzKGNoYXJ0LCBsZWdlbmREYXRhLCBkcmF3RnVuYyk7XHJcbiAgICAgICAgICAgIGF0dGFjaENsaWNrRXZlbnRzVG9MZWdlbmQoY2hhcnQsIGxlZ2VuZEVsZW1lbnRzLCBkcmF3RnVuYywgbGVnZW5kRGF0YSk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuYXR0cih7XHJcbiAgICAgICAgICAgIGRpc3BsYXk6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChjaGFydC5fdmFycy5sZWdlbmRJbmRleCA9PT0gY2hhcnQuX3ZhcnMubGVnZW5kSW5kZXhNYXgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ25vbmUnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdhbGwnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbn1cclxuXHJcbi8qKmNvbnZlcnRUYWJsZVRvVHJlZVxyXG4gKlxyXG4gKiBDb252ZXJ0cyB0YWJsZSBkYXRhIHRvIHRyZWUgc3RydWN0dXJlXHJcbiAqIEBwYXJhbXMgZGF0YSwgZGF0YVRhYmxlLCBudW1lcmljQ2hlY2tcclxuICovXHJcbmZ1bmN0aW9uIGNvbnZlcnRUYWJsZVRvVHJlZShkYXRhLCBkYXRhVGFibGUsIGxhc3ROb2RlQXNWYWx1ZSkge1xyXG4gICAgdmFyIGFsbEhhc2ggPSB7fSxcclxuICAgICAgICBsaXN0ID0gW10sXHJcbiAgICAgICAgcm9vdE1hcCA9IHt9LFxyXG4gICAgICAgIGN1cnJlbnRNYXAgPSB7fSxcclxuICAgICAgICB0YWJsZUhlYWRlcnMgPSBbXSxcclxuICAgICAgICBjb3VudDtcclxuICAgIGlmIChkYXRhVGFibGUpIHtcclxuICAgICAgICBmb3IgKGxldCBoZWFkZXIgaW4gZGF0YVRhYmxlKSB7XHJcbiAgICAgICAgICAgIGlmIChoZWFkZXIgIT09ICd2YWx1ZScgJiYgaGVhZGVyLmluZGV4T2YoJ3Rvb2x0aXAnKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHRhYmxlSGVhZGVycy5wdXNoKGRhdGFUYWJsZVtoZWFkZXJdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGF0YVRhYmxlLnZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRhYmxlSGVhZGVycy5wdXNoKGRhdGFUYWJsZS52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZvciAobGV0IGRhdGFFbGUgb2YgZGF0YSkgeyAvL2FsbCBvZiB0aGlzIGlzIHRvIGNoYW5nZSBpdCB0byBhIHRyZWUgc3RydWN0dXJlIGFuZCB0aGVuIGNhbGwgbWFrZVRyZWUgdG8gc3RydWN0dXJlIHRoZSBkYXRhIGFwcHJvcHJpYXRlbHkgZm9yIHRoaXMgdml6XHJcbiAgICAgICAgY291bnQgPSAwO1xyXG4gICAgICAgIGZvciAobGV0IGhlYWRlciBvZiB0YWJsZUhlYWRlcnMpIHtcclxuICAgICAgICAgICAgaWYgKGhlYWRlciAhPT0gJycpIHtcclxuICAgICAgICAgICAgICAgIGlmICghZGF0YUVsZVtoZWFkZXIucmVwbGFjZSgvW19dL2csICcgJyldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YUVsZVtoZWFkZXIucmVwbGFjZSgvW19dL2csICcgJyldID0gJ05VTExfVkFMVUUnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRWYWx1ZSA9IGRhdGFFbGVbaGVhZGVyLnJlcGxhY2UoL1tfXS9nLCAnICcpXS50b1N0cmluZygpLnJlcGxhY2UoL1tcIl0vZywgJycpLFxyXG4gICAgICAgICAgICAgICAgICAgIG5leHRNYXAgPSB7fTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoY291bnQgPT09IDApIHsgLy93aWxsIHRha2UgY2FyZSBvZiB0aGUgZmlyc3QgbGV2ZWwgYW5kIHB1dCBpbnRvIHJvb3RtYXAgaWYgaXQgZG9lc250IGFscmVhZHkgZXhpc3QgaW4gcm9vdG1hcFxyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRNYXAgPSByb290TWFwW2N1cnJlbnRWYWx1ZV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50TWFwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRNYXAgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcm9vdE1hcFtjdXJyZW50VmFsdWVdID0gY3VycmVudE1hcDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dE1hcCA9IGN1cnJlbnRNYXA7XHJcbiAgICAgICAgICAgICAgICAgICAgY291bnQrKztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dE1hcCA9IGN1cnJlbnRNYXBbY3VycmVudFZhbHVlXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIW5leHRNYXApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dE1hcCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50TWFwW2N1cnJlbnRWYWx1ZV0gPSBuZXh0TWFwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50TWFwID0gbmV4dE1hcDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG1ha2VUcmVlKHJvb3RNYXAsIGxpc3QsIGxhc3ROb2RlQXNWYWx1ZSk7XHJcbiAgICBhbGxIYXNoLm5hbWUgPSAncm9vdCc7XHJcbiAgICBhbGxIYXNoLmNoaWxkcmVuID0gbGlzdDtcclxuICAgIHJldHVybiBhbGxIYXNoO1xyXG59XHJcblxyXG4vKiptYWtlVHJlZVxyXG4gKlxyXG4gKiBSZWN1cml2ZSBmdW5jdGlvbiB0byBidWlsZCB0cmVlXHJcbiAqIEBwYXJhbXMgbWFwLCBsaXN0LCBpc051bWVyaWNcclxuICovXHJcbmZ1bmN0aW9uIG1ha2VUcmVlKG1hcCwgbGlzdCwgbGFzdE5vZGVBc1ZhbHVlKSB7XHJcbiAgICB2YXIgY2hpbGRTZXQgPSBbXTtcclxuICAgIGZvciAobGV0IGtleSBpbiBtYXApIHtcclxuICAgICAgICBpZiAobWFwLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICAgICAgbGV0IGNoaWxkTWFwID0gbWFwW2tleV0sXHJcbiAgICAgICAgICAgICAgICBkYXRhTWFwID0ge30sXHJcbiAgICAgICAgICAgICAgICBjaGlsZEV4aXN0cyA9IGNoaWxkTWFwICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGNoaWxkTWFwKS5sZW5ndGggPiAwLFxyXG4gICAgICAgICAgICAgICAgbnVtZXJpY0NoZWNrID0gbGFzdE5vZGVBc1ZhbHVlICYmIE9iamVjdC5rZXlzKGNoaWxkTWFwKS5sZW5ndGggPT09IDEgJiYgIWlzTmFOKE9iamVjdC5rZXlzKGNoaWxkTWFwKVswXSk7XHJcbiAgICAgICAgICAgIGRhdGFNYXAubmFtZSA9IGtleTtcclxuICAgICAgICAgICAgaWYgKCFjaGlsZEV4aXN0cyB8fCBudW1lcmljQ2hlY2spIHtcclxuICAgICAgICAgICAgICAgIGRhdGFNYXAudmFsdWUgPSBPYmplY3Qua2V5cyhjaGlsZE1hcClbMF07XHJcbiAgICAgICAgICAgICAgICBsaXN0LnB1c2goZGF0YU1hcCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkYXRhTWFwLmNoaWxkcmVuID0gY2hpbGRTZXQ7XHJcbiAgICAgICAgICAgICAgICBsaXN0LnB1c2goZGF0YU1hcCk7XHJcbiAgICAgICAgICAgICAgICBtYWtlVHJlZShjaGlsZE1hcCwgY2hpbGRTZXQsIGxhc3ROb2RlQXNWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBjaGlsZFNldCA9IFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5cclxuLyoqY29udmVydFRhYmxlVG9UcmVlbWFwXHJcbiAqXHJcbiAqIExvb3AgdGhyb3VnaCBkYXRhIHRvIG9yZ2FuaXplIGludG8gdHJlZW1hcCBmb3JtXHJcbiAqIEBwYXJhbXMgZGF0YSwgZGF0YVRhYmxlQWxnaW5cclxuICovXHJcbmZ1bmN0aW9uIGNvbnZlcnRUYWJsZVRvVHJlZW1hcChkYXRhLCBkYXRhVGFibGVBbGlnbikge1xyXG4gICAgdmFyIGFkZGVkSGVhZGVyTWFwID0ge30sXHJcbiAgICAgICAgY2hpbGRyZW5BcnJheSA9IFtdLFxyXG4gICAgICAgIHNlcmllc0luZGV4O1xyXG5cclxuICAgIGZvciAobGV0IGRhdGFFbGUgb2YgZGF0YSkge1xyXG4gICAgICAgIGxldCBzZXJpZXMgPSBkYXRhRWxlW2RhdGFUYWJsZUFsaWduLnNlcmllc107XHJcbiAgICAgICAgc2VyaWVzSW5kZXggPSBhZGRlZEhlYWRlck1hcFtzZXJpZXNdO1xyXG4gICAgICAgIGRhdGFFbGUuUGFyZW50ID0gc2VyaWVzO1xyXG4gICAgICAgIGlmIChzZXJpZXNJbmRleCkge1xyXG4gICAgICAgICAgICBjaGlsZHJlbkFycmF5W3Nlcmllc0luZGV4XS5jaGlsZHJlbi5wdXNoKGRhdGFFbGUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGFkZGVkSGVhZGVyTWFwW3Nlcmllc10gPSBjaGlsZHJlbkFycmF5Lmxlbmd0aDtcclxuICAgICAgICAgICAgY2hpbGRyZW5BcnJheS5wdXNoKHtcclxuICAgICAgICAgICAgICAgIFtkYXRhVGFibGVBbGlnbi5zZXJpZXNdOiBzZXJpZXMsXHJcbiAgICAgICAgICAgICAgICBQYXJlbnQ6ICdUb3AgTGV2ZWwnLFxyXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IFtkYXRhRWxlXVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBbZGF0YVRhYmxlQWxpZ24uc2VyaWVzXTogJ1RvcCBMZXZlbCcsXHJcbiAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuQXJyYXlcclxuICAgIH07XHJcbn1cclxuXHJcblxyXG4vL0JpbmQgZnVuY3Rpb25zIHRvIHByb3RvdHlwZSBvciBqdkNoYXJ0cyBvYmplY3RcclxuanZDaGFydHMuZ2V0Q29sb3JzID0gZ2V0Q29sb3JzO1xyXG5qdkNoYXJ0cy5zZXRCYXJMaW5lTGVnZW5kRGF0YSA9IHNldEJhckxpbmVMZWdlbmREYXRhO1xyXG5qdkNoYXJ0cy5jcmVhdGVDb2xvcnNXaXRoRGVmYXVsdCA9IGNyZWF0ZUNvbG9yc1dpdGhEZWZhdWx0O1xyXG5qdkNoYXJ0cy5nZXRaU2NhbGUgPSBnZXRaU2NhbGU7XHJcbmp2Q2hhcnRzLmdldExlZ2VuZEVsZW1lbnRUb2dnbGVBcnJheSA9IGdldExlZ2VuZEVsZW1lbnRUb2dnbGVBcnJheTtcclxuanZDaGFydHMuZ2VuZXJhdGVMZWdlbmRFbGVtZW50cyA9IGdlbmVyYXRlTGVnZW5kRWxlbWVudHM7XHJcbmp2Q2hhcnRzLnVwZGF0ZURhdGFGcm9tTGVnZW5kID0gdXBkYXRlRGF0YUZyb21MZWdlbmQ7XHJcbmp2Q2hhcnRzLmNyZWF0ZUNhcm91c2VsID0gY3JlYXRlQ2Fyb3VzZWw7XHJcbmp2Q2hhcnRzLmdlbmVyYXRlVGhyZXNob2xkTGVnZW5kID0gZ2VuZXJhdGVUaHJlc2hvbGRMZWdlbmQ7XHJcbmp2Q2hhcnRzLmF0dGFjaENsaWNrRXZlbnRzVG9MZWdlbmQgPSBhdHRhY2hDbGlja0V2ZW50c1RvTGVnZW5kO1xyXG5qdkNoYXJ0cy5nZW5lcmF0ZVZlcnRpY2FsTGVnZW5kRWxlbWVudHMgPSBnZW5lcmF0ZVZlcnRpY2FsTGVnZW5kRWxlbWVudHM7XHJcbmp2Q2hhcnRzLmNyZWF0ZVZlcnRpY2FsQ2Fyb3VzZWwgPSBjcmVhdGVWZXJ0aWNhbENhcm91c2VsO1xyXG5qdkNoYXJ0cy5nZXRUb2dnbGVkRGF0YSA9IGdldFRvZ2dsZWREYXRhO1xyXG5qdkNoYXJ0cy5nZXRQbG90RGF0YSA9IGdldFBsb3REYXRhO1xyXG5qdkNoYXJ0cy5nZXRQb3NDYWxjdWxhdGlvbnMgPSBnZXRQb3NDYWxjdWxhdGlvbnM7XHJcbmp2Q2hhcnRzLnNldEJhckxpbmVMZWdlbmREYXRhID0gc2V0QmFyTGluZUxlZ2VuZERhdGE7XHJcbmp2Q2hhcnRzLmp2Rm9ybWF0VmFsdWUgPSBqdkZvcm1hdFZhbHVlO1xyXG5qdkNoYXJ0cy5nZXRGb3JtYXRFeHByZXNzaW9uID0gZ2V0Rm9ybWF0RXhwcmVzc2lvbjtcclxuanZDaGFydHMuZ2VuZXJhdGVFdmVudEdyb3VwcyA9IGdlbmVyYXRlRXZlbnRHcm91cHM7XHJcbmp2Q2hhcnRzLmp2Rm9ybWF0VmFsdWVUeXBlID0ganZGb3JtYXRWYWx1ZVR5cGU7XHJcbmp2Q2hhcnRzLmdldEF4aXNTY2FsZSA9IGdldEF4aXNTY2FsZTtcclxuanZDaGFydHMuc2V0Q2hhcnRDb2xvcnMgPSBzZXRDaGFydENvbG9ycztcclxuanZDaGFydHMuZ2V0RGF0YVR5cGVGcm9tS2V5cyA9IGdldERhdGFUeXBlRnJvbUtleXM7XHJcbmp2Q2hhcnRzLmNsZWFuVG9vbERhdGEgPSBjbGVhblRvb2xEYXRhO1xyXG5qdkNoYXJ0cy5jb252ZXJ0VGFibGVUb1RyZWUgPSBjb252ZXJ0VGFibGVUb1RyZWU7XHJcbmp2Q2hhcnRzLmNvbnZlcnRUYWJsZVRvVHJlZW1hcCA9IGNvbnZlcnRUYWJsZVRvVHJlZW1hcDtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ganZDaGFydHM7XHJcbiIsIi8qKiogIGp2Q29tbWVudCAqKiovXHJcbid1c2Utc3RyaWN0JztcclxuLyoqXHJcbiogQG5hbWUganZDb21tZW50XHJcbiogQGRlc2MgQ29uc3RydWN0b3IgZm9yIEpWIENvbW1lbnQgLSBjcmVhdGVzIGNvbW1lbnRzIGZvciBhIGp2IHZpc3VhbGl6YXRpb24gYW5kIGV4ZWN1dGVzIGEgY2FsbGJhY2sgZm9yIHRoZSBjb21tZW50cyB0byBiZSBzYXZlZFxyXG4qIEBwYXJhbSB7b2JqZWN0fSBjb25maWdPYmogLSBjb25zdHJ1Y3RvciBvYmplY3QgY29udGFpbmluZyB0aGUganZDaGFydCBhbmQgb3RoZXIgb3B0aW9uc1xyXG4qIEByZXR1cm4ge3VuZGVmaW5lZH0gLSBubyByZXR1cm5cclxuKi9cclxuZnVuY3Rpb24ganZDb21tZW50KGNvbmZpZ09iaikge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgdmFyIGNvbW1lbnRPYmogPSB0aGlzO1xyXG4gICAgY29tbWVudE9iai5jaGFydERpdiA9IGNvbmZpZ09iai5jaGFydERpdjtcclxuICAgIGNvbW1lbnRPYmouc2hvd0NvbW1lbnRzID0gZmFsc2U7XHJcbiAgICBjb21tZW50T2JqLmNvbW1lbnRzID0gY29uZmlnT2JqLmNvbW1lbnRzID8gY29uZmlnT2JqLmNvbW1lbnRzIDoge307XHJcbiAgICBjb21tZW50T2JqLmRpc2FibGVkID0gZmFsc2U7XHJcbiAgICBjb21tZW50T2JqLmRyYXdDb21tZW50Tm9kZXMoKTtcclxuICAgIGNvbW1lbnRPYmoub25TYXZlQ2FsbGJhY2sgPSBjb25maWdPYmoub25TYXZlQ2FsbGJhY2s7XHJcbiAgICBjb21tZW50T2JqLmdldE1vZGUgPSBjb25maWdPYmouZ2V0TW9kZTtcclxufVxyXG5cclxuanZDb21tZW50LnByb3RvdHlwZS5jcmVhdGVNb3ZlTGlzdGVuZXIgPSBjcmVhdGVNb3ZlTGlzdGVuZXI7XHJcbmp2Q29tbWVudC5wcm90b3R5cGUudXBkYXRlUG9zaXRpb24gPSB1cGRhdGVQb3NpdGlvbjtcclxuanZDb21tZW50LnByb3RvdHlwZS5tYWtlQ29tbWVudCA9IG1ha2VDb21tZW50O1xyXG5qdkNvbW1lbnQucHJvdG90eXBlLnJlbW92ZUNvbW1lbnQgPSByZW1vdmVDb21tZW50O1xyXG5qdkNvbW1lbnQucHJvdG90eXBlLmRyYXdDb21tZW50Tm9kZXMgPSBkcmF3Q29tbWVudE5vZGVzO1xyXG5qdkNvbW1lbnQucHJvdG90eXBlLmRyYXdDb21tZW50ID0gZHJhd0NvbW1lbnQ7XHJcbmp2Q29tbWVudC5wcm90b3R5cGUuZG91YmxlQ2xpY2sgPSBkb3VibGVDbGljaztcclxuanZDb21tZW50LnByb3RvdHlwZS5vdmVybGF5RGl2UG9zaXRpb24gPSBvdmVybGF5RGl2UG9zaXRpb247XHJcblxyXG4vKipcclxuKiBAbmFtZSBjcmVhdGVNb3ZlTGlzdGVuZXJcclxuKiBAZGVzYyBjcmVhdGVzIHRoZSBtb3VzZW1vdmUgbGlzdGVuZXIgdG8gZGV0ZXJtaW5lIGlmIHRoZSB1c2VyIG1vdmVzIG9yIHJlc2l6ZXMgYSBjb21tZW50XHJcbiogQHBhcmFtIHtvYmplY3R9IGNvbW1lbnROb2RlIC0gY29tbWVudCB0aGF0IHRoZSB1c2VyIGNsaWNrZWQgb25cclxuKiBAcmV0dXJuIHt1bmRlZmluZWR9IC0gbm8gcmV0dXJuXHJcbiovXHJcbmZ1bmN0aW9uIGNyZWF0ZU1vdmVMaXN0ZW5lcihjb21tZW50Tm9kZSkge1xyXG4gICAgdmFyIGNvbW1lbnRPYmogPSB0aGlzLFxyXG4gICAgICAgIHRpbWVNb3VzZURvd24gPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgIGNvbW1lbnRPYmouY2hhcnREaXYub24oJ21vdXNlbW92ZScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvL21vdXNlIG1vdmUgaGFwcGVuZCB0b28gcXVpY2tseSwgY2hyb21lIGJ1Z1xyXG4gICAgICAgIHZhciB0aW1lTW91c2VNb3ZlID0gbmV3IERhdGUoKS5nZXRUaW1lKCksXHJcbiAgICAgICAgICAgIG5vZGUgPSBjb21tZW50Tm9kZS5ub2RlKCksXHJcbiAgICAgICAgICAgIG1vdXNlID0gZDMubW91c2Uobm9kZSksXHJcbiAgICAgICAgICAgIG1vdXNlT25DaGFydERpdiA9IGQzLm1vdXNlKGNvbW1lbnRPYmouY2hhcnREaXYubm9kZSgpKSxcclxuICAgICAgICAgICAgcmVzaXplTm9kZTtcclxuICAgICAgICBpZiAodGltZU1vdXNlRG93biArIDEwID4gdGltZU1vdXNlTW92ZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vc2V0IHRoZSBtb3ZlZCBub2RlLCBzbyB3ZSBrbm93IHRvIGRvIGEgbW91c2UgdXAgZXZlbnRcclxuICAgICAgICBjb21tZW50T2JqLm1vdmVkID0gY29tbWVudE5vZGU7XHJcblxyXG4gICAgICAgIC8vcmVzaXplIGluIHRoZSByaWdodCBjb3JuZXIgb2YgdGhlIGNvbW1lbnRcclxuICAgICAgICBpZiAoY29tbWVudE5vZGUuc2VsZWN0KCcuY29tbWVudC1wYWRkaW5nJykuX2dyb3Vwc1swXVswXSAmJiAoKG1vdXNlWzBdICsgMTUgPiBub2RlLmNsaWVudFdpZHRoICYmIG1vdXNlWzFdICsgMTUgPiBub2RlLmNsaWVudEhlaWdodCkgfHwgY29tbWVudE9iai5tb3ZlZC5tb3VzZSkpIHtcclxuICAgICAgICAgICAgaWYgKCFjb21tZW50T2JqLm1vdmVkLm1vdXNlKSB7XHJcbiAgICAgICAgICAgICAgICByZXNpemVOb2RlID0gY29tbWVudE5vZGUuc2VsZWN0KCcuY29tbWVudC1wYWRkaW5nJyk7XHJcbiAgICAgICAgICAgICAgICByZXNpemVOb2RlLnN0eWxlKCd3aWR0aCcsICdhdXRvJyk7XHJcbiAgICAgICAgICAgICAgICByZXNpemVOb2RlLnN0eWxlKCdoZWlnaHQnLCAnYXV0bycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vc2V0IHRoZSBtb3VzZSBldmVudCBzbyB3ZSBjYW4gdXBkYXRlIHRoZSBsb2NhdGlvbiBvbiBtb3VzZSB1cFxyXG4gICAgICAgICAgICBjb21tZW50T2JqLm1vdmVkLm1vdXNlID0gbW91c2U7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy9tb3ZlIHRoZSBjb21tZW50IG5vZGUgYXJvdW5kIHRoZSB2aXN1YWxcclxuICAgICAgICAgICAgaWYgKGNvbW1lbnROb2RlLl9ncm91cHNbMF1bMF0ubm9kZU5hbWUgPT09ICd0ZXh0Jykge1xyXG4gICAgICAgICAgICAgICAgY29tbWVudE9iai5jaGFydERpdi5zZWxlY3QoJy5jb21tZW50Ym94LXJlYWRvbmx5JykucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29tbWVudE5vZGVcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgnbGVmdCcsIG1vdXNlT25DaGFydERpdlswXSArICdweCcpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3RvcCcsIG1vdXNlT25DaGFydERpdlsxXSArICdweCcpO1xyXG4gICAgICAgICAgICBjb21tZW50Tm9kZVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBtb3VzZU9uQ2hhcnREaXZbMF0pXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIG1vdXNlT25DaGFydERpdlsxXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4qIEBuYW1lIHVwZGF0ZVBvc2l0aW9uXHJcbiogQGRlc2MgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB1c2VyIGRyYWdnZWQgYSBjb21tZW50IG9uIHRoZSBzY3JlZW4gb3IgdXBkYXRlZCBpdHMgc2l6ZSBhbmQgdGhlbiBjcmVhdGVzIHRoZSBhcHByb3ByaWF0ZSBzYXZlIGZ1bmN0aW9uXHJcbiogQHJldHVybiB7dW5kZWZpbmVkfSAtIG5vIHJldHVyblxyXG4qL1xyXG5mdW5jdGlvbiB1cGRhdGVQb3NpdGlvbigpIHtcclxuICAgIGxldCBjb21tZW50T2JqID0gdGhpcyxcclxuICAgICAgICBub2RlVG9VcGRhdGUgPSBjb21tZW50T2JqLm1vdmVkLl9ncm91cHNbMF1bMF0sXHJcbiAgICAgICAgbm9kZUlkID0gbm9kZVRvVXBkYXRlLmlkLnNwbGl0KCdub2RlJylbMV0sXHJcbiAgICAgICAgY29tbWVudCA9IGNvbW1lbnRPYmouY29tbWVudHMubGlzdFtub2RlSWRdLFxyXG4gICAgICAgIHgsXHJcbiAgICAgICAgeTtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KGNvbW1lbnRPYmoubW92ZWQubW91c2UpKSB7XHJcbiAgICAgICAgY29tbWVudC5iaW5kaW5nLndpZHRoID0gY29tbWVudE9iai5tb3ZlZC5tb3VzZVswXTtcclxuICAgICAgICBjb21tZW50LmJpbmRpbmcuaGVpZ2h0ID0gY29tbWVudE9iai5tb3ZlZC5tb3VzZVsxXTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgeCA9IE1hdGgucm91bmQobm9kZVRvVXBkYXRlLmdldEF0dHJpYnV0ZSgneCcpKTtcclxuICAgICAgICB5ID0gTWF0aC5yb3VuZChub2RlVG9VcGRhdGUuZ2V0QXR0cmlidXRlKCd5JykpO1xyXG4gICAgICAgIGNvbW1lbnQuYmluZGluZyA9IHtcclxuICAgICAgICAgICAgJ3gnOiB4LFxyXG4gICAgICAgICAgICAneSc6IHksXHJcbiAgICAgICAgICAgICd4Q2hhcnRBcmVhJzogY29tbWVudE9iai5jaGFydERpdi5fZ3JvdXBzWzBdWzBdLmNsaWVudFdpZHRoLFxyXG4gICAgICAgICAgICAneUNoYXJ0QXJlYSc6IGNvbW1lbnRPYmouY2hhcnREaXYuX2dyb3Vwc1swXVswXS5jbGllbnRIZWlnaHQsXHJcbiAgICAgICAgICAgICdjdXJyZW50WCc6IHgsXHJcbiAgICAgICAgICAgICdjdXJyZW50WSc6IHksXHJcbiAgICAgICAgICAgICdzaG93QXNNYXJrZXInOiBjb21tZW50LmJpbmRpbmcuc2hvd0FzTWFya2VyLFxyXG4gICAgICAgICAgICAnaGVpZ2h0JzogY29tbWVudC5iaW5kaW5nLmhlaWdodCxcclxuICAgICAgICAgICAgJ3dpZHRoJzogY29tbWVudC5iaW5kaW5nLndpZHRoXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBjb21tZW50T2JqLm9uU2F2ZUNhbGxiYWNrKGNvbW1lbnQsIG5vZGVJZCwgJ2VkaXQnKTtcclxufVxyXG5cclxuLyoqXHJcbiogQG5hbWUgbWFrZUNvbW1lbnRcclxuKiBAZGVzYyBjcmVhdGVzIHRoZSBjb21tZW50IGVudHJ5IGJveCBvbiB0aGUgc2NyZWVuIGFuZCBhdHRhY2hlcyBsaXN0ZW5lcnMgdG8gdGhlIHNhdmUgZGVsZXRlIGFuZCBjYW5jZWwgb3B0aW9uc1xyXG4qIEBwYXJhbSB7b2JqZWN0fSBldmVudCAtIGV2ZW50IHRoYXQgaG9sZHMgdGhlIG1vdXNlIHBvc2l0aW9uIGZvciB3aGVyZSB0aGUgdXNlciB3YW50cyB0byBwbGFjZSB0aGUgY29tbWVudFxyXG4qIEByZXR1cm4ge3VuZGVmaW5lZH0gLSBubyByZXR1cm5cclxuKi9cclxuZnVuY3Rpb24gbWFrZUNvbW1lbnQoZXZlbnQpIHtcclxuICAgIGlmICh0aGlzLmNoYXJ0RGl2LnNlbGVjdCgnLmNvbW1lbnRib3gnKS5fZ3JvdXBzWzBdWzBdIHx8IHRoaXMuY2hhcnREaXYuc2VsZWN0KCcuY29tbWVudGJveC1lZGl0JykuX2dyb3Vwc1swXVswXSkge1xyXG4gICAgICAgIC8vZG9udCBjcmVhdGUgbmV3IGNvbW1lbnRcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGNvbW1lbnRPYmogPSB0aGlzLFxyXG4gICAgICAgIHggPSBwYXJzZUludChkMy5tb3VzZShldmVudClbMF0sIDEwKSxcclxuICAgICAgICB5ID0gcGFyc2VJbnQoZDMubW91c2UoZXZlbnQpWzFdLCAxMCksXHJcbiAgICAgICAgY29tbWVudEhlaWdodCA9IDE0NSxcclxuICAgICAgICBjb21tZW50V2lkdGggPSAyMDAsXHJcbiAgICAgICAgLy9jYWxjdWxhdGUgcG9zaXRpb24gb2Ygb3ZlcmxheSBkaXZcclxuICAgICAgICBwb3NpdGlvbiA9IGNvbW1lbnRPYmoub3ZlcmxheURpdlBvc2l0aW9uKGNvbW1lbnRXaWR0aCwgY29tbWVudEhlaWdodCwgeCwgeSksXHJcbiAgICAgICAgY29tbWVudFR5cGUgPSAnc3ZnTWFpbic7XHJcblxyXG4gICAgY29tbWVudE9iai5jaGFydERpdi5zZWxlY3RBbGwoJy5jb21tZW50Ym94LXJlYWRvbmx5JykucmVtb3ZlKCk7XHJcblxyXG4gICAgY29tbWVudE9iai5zaG93Q29tbWVudHMgPSBmYWxzZTtcclxuICAgIGNvbW1lbnRPYmouY2hhcnREaXYuYXBwZW5kKCdkaXYnKVxyXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICdjb21tZW50Ym94JylcclxuICAgICAgICAuYXR0cignaWQnLCAnY29tbWVudGJveCcpXHJcbiAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMSlcclxuICAgICAgICAuaHRtbChcIjxkaXYgY2xhc3M9J3RpdGxlJz48Yj5BZGQgTmV3IENvbW1lbnQ8L2I+PC9kaXY+XCIgK1xyXG4gICAgICAgIFwiPHRleHRhcmVhIHBsYWNlaG9sZGVyPSdFbnRlciBjb21tZW50Li4uJyBmb3JtPSdjb21tZW50Zm9ybScgY2xhc3M9J2NvbW1lbnQtdGV4dGFyZWEnIHN0eWxlPSd3aWR0aDoxNTVweDsgaGVpZ2h0OiA5MHB4OycgbmFtZT0nY29tbWVudCcgaWQgPSAndGV4dGFyZWExJz48L3RleHRhcmVhPlwiICtcclxuICAgICAgICBcIjxicj48aW5wdXQgdHlwZT0nY2hlY2tCb3gnIGNsYXNzPSdjb21tZW50Ym94LWRpc3BsYXknIGlkID0nZGlzcGxheSc+IERpc3BsYXkgYXMgbWFya2VyXCIgK1xyXG4gICAgICAgIFwiPGJyPjxidXR0b24gY2xhc3M9J2NvbW1lbnRib3gtY2xvc2UnIGlkID0nY2FuY2VsJz48aSBjbGFzcz0nZmEgZmEtY2xvc2UnPjwvaT48L2J1dHRvbj5cIiArXHJcbiAgICAgICAgXCI8YnV0dG9uIGNsYXNzPSdzbXNzLWJ0biBjb21tZW50Ym94LXN1Ym1pdCcgaWQgPSAnc3VibWl0Jz5TdWJtaXQgQ29tbWVudDwvYnV0dG9uPlwiKVxyXG4gICAgICAgIC5zdHlsZSgncG9zaXRpb24nLCAnYWJzb2x1dGUnKVxyXG4gICAgICAgIC5zdHlsZSgnbGVmdCcsIHBvc2l0aW9uLnggKyAncHgnKVxyXG4gICAgICAgIC5zdHlsZSgndG9wJywgcG9zaXRpb24ueSArICdweCcpO1xyXG5cclxuICAgIC8vQXV0b2ZvY3VzIG9uIHRoZSB0ZXh0IGFyZWFcclxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0ZXh0YXJlYTEnKS5mb2N1cygpO1xyXG5cclxuICAgIGNvbW1lbnRPYmouY2hhcnREaXYuc2VsZWN0QWxsKCcuY29tbWVudGJveCcpLnNlbGVjdCgnI2NhbmNlbCcpXHJcbiAgICAgICAgLm9uKCdjbGljay5kZWxldGUnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGNvbW1lbnRPYmoucmVtb3ZlQ29tbWVudCgpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIGNvbW1lbnRPYmouY2hhcnREaXYuc2VsZWN0QWxsKCcuY29tbWVudGJveCcpLnNlbGVjdCgnI3N1Ym1pdCcpXHJcbiAgICAgICAgLm9uKCdjbGljay5zYXZlJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBsZXQgY29tbWVudFRleHQgPSBjb21tZW50T2JqLmNoYXJ0RGl2LnNlbGVjdCgnI2NvbW1lbnRib3gnKS5zZWxlY3QoJyN0ZXh0YXJlYTEnKS5fZ3JvdXBzWzBdWzBdLnZhbHVlLFxyXG4gICAgICAgICAgICAgICAgc2hvd0FzTWFya2VyID0gY29tbWVudE9iai5jaGFydERpdi5zZWxlY3QoJyNjb21tZW50Ym94Jykuc2VsZWN0KCcjZGlzcGxheScpLl9ncm91cHNbMF1bMF0uY2hlY2tlZCxcclxuICAgICAgICAgICAgICAgIG5ld0NvbW1lbnRPYmo7XHJcblxyXG4gICAgICAgICAgICBuZXdDb21tZW50T2JqID0ge1xyXG4gICAgICAgICAgICAgICAgJ2NvbW1lbnRUZXh0JzogY29tbWVudFRleHQsXHJcbiAgICAgICAgICAgICAgICAnZ3JvdXBJRCc6ICdncm91cDAnLFxyXG4gICAgICAgICAgICAgICAgJ3R5cGUnOiBjb21tZW50VHlwZSxcclxuICAgICAgICAgICAgICAgICdiaW5kaW5nJzoge1xyXG4gICAgICAgICAgICAgICAgICAgICd4JzogeCxcclxuICAgICAgICAgICAgICAgICAgICAneSc6IHksXHJcbiAgICAgICAgICAgICAgICAgICAgJ3hDaGFydEFyZWEnOiBjb21tZW50T2JqLmNoYXJ0RGl2Ll9ncm91cHNbMF1bMF0uY2xpZW50V2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgJ3lDaGFydEFyZWEnOiBjb21tZW50T2JqLmNoYXJ0RGl2Ll9ncm91cHNbMF1bMF0uY2xpZW50SGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgICdjdXJyZW50WCc6IHgsXHJcbiAgICAgICAgICAgICAgICAgICAgJ2N1cnJlbnRZJzogeSxcclxuICAgICAgICAgICAgICAgICAgICAnc2hvd0FzTWFya2VyJzogc2hvd0FzTWFya2VyID8gJ3RydWUnIDogJ2ZhbHNlJyxcclxuICAgICAgICAgICAgICAgICAgICAnaGVpZ2h0JzogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgJ3dpZHRoJzogZmFsc2VcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29tbWVudE9iai5jaGFydERpdi5zZWxlY3QoJy5jb21tZW50Ym94JykucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIGlmIChpc05hTihjb21tZW50T2JqLmNvbW1lbnRzLm1heElkKSkge1xyXG4gICAgICAgICAgICAgICAgY29tbWVudE9iai5jb21tZW50cy5tYXhJZCA9IC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbW1lbnRPYmoub25TYXZlQ2FsbGJhY2sobmV3Q29tbWVudE9iaiwgKytjb21tZW50T2JqLmNvbW1lbnRzLm1heElkLCAnYWRkJyk7XHJcbiAgICAgICAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4qIEBuYW1lIHJlbW92ZUNvbW1lbnRcclxuKiBAZGVzYyBmdW5jdGlvbiB0byByZW1vdmUgY29tbWVudCBlbnRyeSBib3hcclxuKiBAcmV0dXJuIHt1bmRlZmluZWR9IC0gbm8gcmV0dXJuXHJcbiovXHJcbmZ1bmN0aW9uIHJlbW92ZUNvbW1lbnQoKSB7XHJcbiAgICB2YXIgY29tbWVudE9iaiA9IHRoaXM7XHJcbiAgICBjb21tZW50T2JqLmNoYXJ0RGl2LnNlbGVjdEFsbCgnLmNvbW1lbnRib3gnKS5yZW1vdmUoKTtcclxufVxyXG5cclxuLyoqXHJcbiogQG5hbWUgZHJhd0NvbW1lbnROb2Rlc1xyXG4qIEBkZXNjIGZ1bmN0aW9uIHRvIGRyYXcgYSBhbGwgY29tbWVudHMgb24gdGhlIHZpc3VhbFxyXG4qIEByZXR1cm4ge3VuZGVmaW5lZH0gLSBubyByZXR1cm5cclxuKi9cclxuZnVuY3Rpb24gZHJhd0NvbW1lbnROb2RlcygpIHtcclxuICAgIHZhciBjb21tZW50T2JqID0gdGhpcyxcclxuICAgICAgICBjb21tZW50cyA9IGNvbW1lbnRPYmouY29tbWVudHMubGlzdDtcclxuXHJcbiAgICBjb21tZW50T2JqLmNoYXJ0RGl2LnNlbGVjdEFsbCgnLm1pbi1jb21tZW50JykucmVtb3ZlKCk7XHJcblxyXG4gICAgZm9yIChsZXQgaWQgaW4gY29tbWVudHMpIHtcclxuICAgICAgICBpZiAoY29tbWVudHMuaGFzT3duUHJvcGVydHkoaWQpKSB7XHJcbiAgICAgICAgICAgIGNvbW1lbnRPYmouZHJhd0NvbW1lbnQoY29tbWVudHNbaWRdLCBpZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuKiBAbmFtZSBkcmF3Q29tbWVudFxyXG4qIEBkZXNjIGZ1bmN0aW9uIHRvIGRyYXcgYSBzaW5nbGUgY29tbWVudCBvbiB0aGUgdmlzdWFsXHJcbiogQHBhcmFtIHtvYmplY3R9IGNvbW1lbnQgLSBkYXRhIHVzZWQgdG8gcGFpbiB0aGUgY29tbWVudFxyXG4qIEBwYXJhbSB7bnVtYmVyfSBpZCAtIGlkIG9mIHRoZSBzcGVjaWZpYyBjb21tZW50XHJcbiogQHJldHVybiB7dW5kZWZpbmVkfSAtIG5vIHJldHVyblxyXG4qL1xyXG5mdW5jdGlvbiBkcmF3Q29tbWVudChjb21tZW50LCBpZCkge1xyXG4gICAgaWYgKHR5cGVvZiB0aGlzLmNoYXJ0RGl2Ll9ncm91cHMgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ0NvbW1lbnQgZGF0YSBpcyBpbiBvbGQgZm9ybWF0LCB3aWxsIG5vdCBkaXNwbGF5IG9yIGNoYXJ0IGRpdiBkb2VzbnQgZXhpc3QnKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFjb21tZW50LmJpbmRpbmcgfHwgIXRoaXMuY2hhcnREaXYuX2dyb3Vwc1swXVswXSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdDb21tZW50IGRhdGEgaXMgaW4gb2xkIGZvcm1hdCwgd2lsbCBub3QgZGlzcGxheSBvciBjaGFydCBkaXYgZG9lc250IGV4aXN0Jyk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBjb21tZW50T2JqID0gdGhpcyxcclxuICAgICAgICBjaGFydERpdiA9IGNvbW1lbnRPYmouY2hhcnREaXYsXHJcbiAgICAgICAgYmluZGluZyA9IGNvbW1lbnQuYmluZGluZyxcclxuICAgICAgICBjaGFydEFyZWFXaWR0aCA9IGNoYXJ0RGl2Ll9ncm91cHNbMF1bMF0uY2xpZW50V2lkdGgsXHJcbiAgICAgICAgY2hhcnRBcmVhSGVpZ2h0ID0gY2hhcnREaXYuX2dyb3Vwc1swXVswXS5jbGllbnRIZWlnaHQsXHJcbiAgICAgICAgeCA9IChiaW5kaW5nLnggLyBiaW5kaW5nLnhDaGFydEFyZWEgKiBjaGFydEFyZWFXaWR0aCksXHJcbiAgICAgICAgeSA9IChiaW5kaW5nLnkgLyBiaW5kaW5nLnlDaGFydEFyZWEgKiBjaGFydEFyZWFIZWlnaHQpLFxyXG4gICAgICAgIHN0eWxlU3RyaW5nID0gJycsXHJcbiAgICAgICAgdGV4dCA9ICcnLFxyXG4gICAgICAgIHJlc2l6ZSA9IGZhbHNlO1xyXG5cclxuICAgIGJpbmRpbmcuY3VycmVudFggPSAoYmluZGluZy54IC8gYmluZGluZy54Q2hhcnRBcmVhICogY2hhcnRBcmVhV2lkdGgpO1xyXG4gICAgYmluZGluZy5jdXJyZW50WSA9IChiaW5kaW5nLnkgLyBiaW5kaW5nLnlDaGFydEFyZWEgKiBjaGFydEFyZWFIZWlnaHQpO1xyXG5cclxuICAgIGlmIChjb21tZW50LmJpbmRpbmcuc2hvd0FzTWFya2VyID09PSAnZmFsc2UnKSB7XHJcbiAgICAgICAgaWYgKGNvbW1lbnQuYmluZGluZy53aWR0aCAmJiBjb21tZW50LmJpbmRpbmcuaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIHN0eWxlU3RyaW5nID0gXCJzdHlsZT0nd2lkdGg6IFwiICsgY29tbWVudC5iaW5kaW5nLndpZHRoICsgJ3B4OyBoZWlnaHQ6ICcgKyBjb21tZW50LmJpbmRpbmcuaGVpZ2h0ICsgXCJweCdcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbW1lbnQuY29tbWVudFRleHQuaW5kZXhPZignPGlmcmFtZScpID4gLTEgfHwgY29tbWVudC5jb21tZW50VGV4dC5pbmRleE9mKCc8aW1nJykgPiAtMSB8fCBjb21tZW50LmNvbW1lbnRUZXh0LmluZGV4T2YoJzxzdmcnKSA+IC0xKSB7XHJcbiAgICAgICAgICAgIC8vY29udGFpbnMgZWxlbnRzIHRoYXQgc2hvdWxkIHJlc2l6ZVxyXG4gICAgICAgICAgICB0ZXh0ID0gXCI8ZGl2IGNsYXNzPSdjb21tZW50LXBhZGRpbmcgdGV4dCdcIiArIHN0eWxlU3RyaW5nICsgXCI+PGRpdiBjbGFzcz0ndXNlci1jb21tZW50Jz5cIiArIGNvbW1lbnQuY29tbWVudFRleHQgKyAnPC9kaXY+PC9kaXY+JztcclxuICAgICAgICAgICAgcmVzaXplID0gdHJ1ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0ZXh0ID0gJzxkaXYgY2xhc3M9XCJ0ZXh0IGVkaXRhYmxlIGVkaXRhYmxlLXRleHQgZWRpdGFibGUtY29tbWVudC0nICsgaWQgKyAnXCI+JyArIGNvbW1lbnQuY29tbWVudFRleHQgKyAnPGRpdi8+JztcclxuICAgICAgICB9XHJcbiAgICAgICAgY2hhcnREaXYuYXBwZW5kKCdkaXYnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbWluLWNvbW1lbnQnKVxyXG4gICAgICAgICAgICAuYXR0cignaWQnLCAnbm9kZScgKyBpZClcclxuICAgICAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMSlcclxuICAgICAgICAgICAgLnN0eWxlKCdwb3NpdGlvbicsICdhYnNvbHV0ZScpXHJcbiAgICAgICAgICAgIC8vLnN0eWxlKFwiYm9yZGVyXCIsIFwiMXB4IHNvbGlkIGJsYWNrXCIpXHJcbiAgICAgICAgICAgIC5odG1sKHRleHQpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnbGVmdCcsIHggKyAncHgnKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ3RvcCcsIHkgKyAncHgnKVxyXG4gICAgICAgICAgICAub24oJ2RibGNsaWNrLmNvbW1lbnQnLCBmdW5jdGlvbiAoKSB7Ly9FZGl0IHRleHQgb3IgZGVsZXRlIHRoZSBjb21tZW50XHJcbiAgICAgICAgICAgICAgICBjb21tZW50T2JqLmRvdWJsZUNsaWNrKHRoaXMsIHgsIHkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICBpZiAocmVzaXplKSB7XHJcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSBkMy5zZWxlY3QoJy51c2VyLWNvbW1lbnQnKTtcclxuICAgICAgICAgICAgcmVzY2FsZShwYXJlbnQsIHBhcmVudC5ub2RlKCkpO1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY2hhcnREaXYuc2VsZWN0KCdzdmcnKS5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbWluLWNvbW1lbnQnKVxyXG4gICAgICAgICAgICAuYXR0cignaWQnLCAnbm9kZScgKyBpZClcclxuICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCAnI2U2ZTZlNicpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4JywgeClcclxuICAgICAgICAgICAgLmF0dHIoJ3knLCB5KVxyXG4gICAgICAgICAgICAuYXR0cignZm9udC1mYW1pbHknLCAnRm9udEF3ZXNvbWUnKVxyXG4gICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgJ2RhcmtncmF5JylcclxuICAgICAgICAgICAgLmF0dHIoJ2ZvbnQtc2l6ZScsICcxNXB4JylcclxuICAgICAgICAgICAgLnRleHQoJ1xcdWYwZTUnKVxyXG4gICAgICAgICAgICAuYXR0cignb3BhY2l0eScsIDEpXHJcbiAgICAgICAgICAgIC5vbignZGJsY2xpY2suY29tbWVudCcsIGZ1bmN0aW9uICgpIHsvL0VkaXQgdGV4dCBvciBkZWxldGUgdGhlIGNvbW1lbnRcclxuICAgICAgICAgICAgICAgIGNvbW1lbnRPYmouZG91YmxlQ2xpY2sodGhpcywgeCwgeSk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5vbignbW91c2VlbnRlci5jb21tZW50JywgZnVuY3Rpb24gKCkgey8vU2hvdyBob3ZlciBvdmVyIGJveCB3aGVuIG1vdXNlIGVudGVycyBub2RlXHJcbiAgICAgICAgICAgICAgICBpZiAoY29tbWVudE9iai5zaG93Q29tbWVudHMgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbW1lbnRUZXh0ID0gJycsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnRIZWlnaHQgPSA4MCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudFdpZHRoID0gMTg1LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiBpbiBjb21tZW50T2JqLmNvbW1lbnRzLmxpc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGgucm91bmQoY29tbWVudE9iai5jb21tZW50cy5saXN0W2pdLmJpbmRpbmcuY3VycmVudFgpID09PSBNYXRoLnJvdW5kKHRoaXMueC5iYXNlVmFsWzBdLnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGgucm91bmQoY29tbWVudE9iai5jb21tZW50cy5saXN0W2pdLmJpbmRpbmcuY3VycmVudFkpID09PSBNYXRoLnJvdW5kKHRoaXMueS5iYXNlVmFsWzBdLnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnRUZXh0ID0gY29tbWVudE9iai5jb21tZW50cy5saXN0W2pdLmNvbW1lbnRUZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggPSBjb21tZW50T2JqLmNvbW1lbnRzLmxpc3Rbal0uYmluZGluZy5jdXJyZW50WDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5ID0gY29tbWVudE9iai5jb21tZW50cy5saXN0W2pdLmJpbmRpbmcuY3VycmVudFk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSBjb21tZW50T2JqLm92ZXJsYXlEaXZQb3NpdGlvbihjb21tZW50V2lkdGgsIGNvbW1lbnRIZWlnaHQsIHgsIHkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjaGFydERpdi5hcHBlbmQoJ2RpdicpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdjb21tZW50Ym94LXJlYWRvbmx5JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdwb3NpdGlvbicsICdhYnNvbHV0ZScpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5odG1sKFwiPHRleHRhcmVhIHJlYWRvbmx5IHJvd3M9JzQnIGNvbHM9JzI3JyBjbGFzcz0ndGV4dGFyZWEnIG5hbWU9J2NvbW1lbnQnPlwiICsgY29tbWVudFRleHQgKyAnPC90ZXh0YXJlYT4nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ2xlZnQnLCBwb3NpdGlvbi54ICsgJ3B4JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCd0b3AnLCBwb3NpdGlvbi55ICsgJ3B4Jyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5vbignbW91c2VvdXQuY29tbWVudCcsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vUmVtb3ZlIGhvdmVyIG92ZXIgYm94IHdoZW4gbW91c2UgbW92ZXMgYXdheVxyXG4gICAgICAgICAgICAgICAgaWYgKGNvbW1lbnRPYmouc2hvd0NvbW1lbnRzID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0RGl2LnNlbGVjdCgnLmNvbW1lbnRib3gtcmVhZG9ubHknKS5yZW1vdmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4qIEBuYW1lIHJlc2NhbGVcclxuKiBAZGVzYyBzZXRzIHRoZSBjaGlsZHJlbiBvZiB0aGUgZWxlIHBhcmFtIHRvIDEwMCBwZXJjZW50IGhlaWdodCBhbmQgd2lkdGhcclxuKiBAcGFyYW0ge2Qzbm9kZX0gZWxlIC0gbm9kZSB0byBzdGFydCByZWN1cnNpdmUgZnVuY3Rpb25cclxuKiBAcGFyYW0ge2h0bWxOb2RlfSBjb21tZW50Tm9kZSAtIHVudXNlZCBwYXJlbnQgbm9kZSB0aGF0IGNhbiBiZSB1c2VkIHRvIGNhbGN1YWx0ZSBwZXJjZW50IGhlaWdodCBhbmQgd2lkdGhzXHJcbiogQHJldHVybiB7dW5kZWZpbmVkfSAtIG5vIHJldHVyblxyXG4qL1xyXG5mdW5jdGlvbiByZXNjYWxlKGVsZSwgY29tbWVudE5vZGUpIHtcclxuICAgIHZhciBub2RlID0gZWxlLm5vZGUoKSxcclxuICAgICAgICB3aWR0aCA9IDEwMCxcclxuICAgICAgICBoZWlnaHQgPSAxMDA7XHJcbiAgICAvL3dpZHRoID0gbm9kZS5jbGllbnRXaWR0aCAvIGNvbW1lbnROb2RlLmNsaWVudFdpZHRoICogMTAwO1xyXG4gICAgLy9oZWlnaHQgPSBub2RlLmNsaWVudEhlaWdodCAvIGNvbW1lbnROb2RlLmNsaWVudEhlaWdodCAqIDEwMDtcclxuICAgIC8vaWYgKHdpZHRoID4gMTAwKSB7XHJcbiAgICAvL3dpZHRoID0gMTAwO1xyXG4gICAgLy99XHJcblxyXG4gICAgLy9pZiAoaGVpZ2h0ID4gMTAwKSB7XHJcbiAgICAvL2hlaWdodCA9IDEwMDtcclxuICAgIC8vfVxyXG5cclxuICAgIGVsZS5zdHlsZSgnd2lkdGgnLCB3aWR0aCArICclJyk7XHJcbiAgICBlbGUuc3R5bGUoJ2hlaWdodCcsIGhlaWdodCArICclJyk7XHJcbiAgICBmb3IgKGxldCBjaGlsZCBvZiBub2RlLmNoaWxkTm9kZXMpIHtcclxuICAgICAgICByZXNjYWxlKGQzLnNlbGVjdChjaGlsZCksIGNvbW1lbnROb2RlKTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiogQG5hbWUgZG91YmxlQ2xpY2tcclxuKiBAZGVzYyBjbGljayBmdW5jdGlvbiBhZnRlciB0aGUgdXNlciBjbGlja3Mgb24gYW4gZXhpc3RpbmcgY29tbWVudFxyXG4qIEBwYXJhbSB7b2JqZWN0fSBjb21tZW50Tm9kZSAtIGN1cnJlbnQgY29tbWVudCB0aGF0IHRoZSB1c2VyIGNsaWNrZWRcclxuKiBAcGFyYW0ge251bWJlcn0geCAtIHggcG9zaXRpb24gb2YgdGhlIGNsaWNrIGV2ZW50XHJcbiogQHBhcmFtIHtudW1iZXJ9IHkgLSB5IHBvc2l0aW9uIG9mIHRoZSBjbGljayBldmVudFxyXG4qIEByZXR1cm4ge3VuZGVmaW5lZH0gLSBubyByZXR1cm5cclxuKi9cclxuZnVuY3Rpb24gZG91YmxlQ2xpY2soY29tbWVudE5vZGUsIHgsIHkpIHtcclxuICAgIGlmICh0aGlzLmNoYXJ0RGl2LnNlbGVjdCgnLmNvbW1lbnRib3gtZWRpdCcpLl9ncm91cHNbMF1bMF0gfHwgdGhpcy5nZXRNb2RlKCkgIT09ICdjb21tZW50LW1vZGUnKSB7XHJcbiAgICAgICAgLy9kb250IGNyZWF0ZSBuZXcgY29tbWVudFxyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGxldCBjb21tZW50T2JqID0gdGhpcyxcclxuICAgICAgICBjaGFydERpdiA9IGNvbW1lbnRPYmouY2hhcnREaXYsXHJcbiAgICAgICAgY3VycmVudENvbW1lbnQgPSBjb21tZW50Tm9kZS5pZC5zcGxpdCgnbm9kZScpWzFdLFxyXG4gICAgICAgIGNvbW1lbnRUZXh0ID0gY29tbWVudE9iai5jb21tZW50cy5saXN0W2N1cnJlbnRDb21tZW50XS5jb21tZW50VGV4dCxcclxuICAgICAgICBjb21tZW50SGVpZ2h0ID0gMTQ1LFxyXG4gICAgICAgIGNvbW1lbnRXaWR0aCA9IDIwMCxcclxuICAgICAgICBwb3NpdGlvbiA9IGNvbW1lbnRPYmoub3ZlcmxheURpdlBvc2l0aW9uKGNvbW1lbnRXaWR0aCwgY29tbWVudEhlaWdodCwgeCwgeSk7XHJcblxyXG4gICAgY29tbWVudE9iai5zaG93Q29tbWVudHMgPSBmYWxzZTtcclxuICAgIGNoYXJ0RGl2LnNlbGVjdEFsbCgnLmNvbW1lbnRib3gtcmVhZG9ubHknKS5yZW1vdmUoKTtcclxuICAgIGNoYXJ0RGl2LnNlbGVjdEFsbCgnLmNvbW1lbnRib3gtZWRpdCcpLnJlbW92ZSgpO1xyXG4gICAgY2hhcnREaXYuc2VsZWN0QWxsKCcuY29tbWVudGJveCcpLnJlbW92ZSgpO1xyXG5cclxuICAgIGNoYXJ0RGl2LmFwcGVuZCgnZGl2JylcclxuICAgICAgICAuYXR0cignY2xhc3MnLCAnY29tbWVudGJveC1lZGl0JylcclxuICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAxKVxyXG4gICAgICAgIC5zdHlsZSgnbGVmdCcsIHBvc2l0aW9uLnggKyAncHgnKVxyXG4gICAgICAgIC5zdHlsZSgndG9wJywgcG9zaXRpb24ueSArICdweCcpXHJcbiAgICAgICAgLnN0eWxlKCdwb3NpdGlvbicsICdhYnNvbHV0ZScpXHJcbiAgICAgICAgLmh0bWwoXCI8ZGl2IGNsYXNzPSd0aXRsZSc+PGI+RWRpdCBDb21tZW50PC9iPjwvZGl2PlwiICtcclxuICAgICAgICBcIjx0ZXh0YXJlYSBpZD0nZWRpdCcgY2xhc3M9J2NvbW1lbnQtdGV4dGFyZWEnIHN0eWxlPSd3aWR0aDoxNTVweDsgaGVpZ2h0OiA5MHB4OycgbmFtZT0nY29tbWVudCc+XCIgKyBjb21tZW50VGV4dCArICc8L3RleHRhcmVhPicgK1xyXG4gICAgICAgIFwiPGJyPjxpbnB1dCB0eXBlPSdjaGVja0JveCcgY2xhc3M9J2NvbW1lbnRib3gtZGlzcGxheScgaWQgPSdkaXNwbGF5Jz4gRGlzcGxheSBhcyBtYXJrZXJcIiArXHJcbiAgICAgICAgXCI8YnI+PGJ1dHRvbiBjbGFzcz0nY29tbWVudGJveC1jbG9zZScgaWQgPSdjYW5jZWwtZWRpdCc+PGkgY2xhc3M9J2ZhIGZhLWNsb3NlJz48L2k+PC9idXR0b24+XCIgK1xyXG4gICAgICAgIFwiPGJ1dHRvbiBjbGFzcz0nc21zcy1idG4nIGlkID0nZGVsZXRlJz5EZWxldGU8L2J1dHRvbj5cIiArXHJcbiAgICAgICAgXCI8YnV0dG9uIGNsYXNzPSdzbXNzLWJ0bicgaWQgPSAnc2F2ZSc+U2F2ZTwvYnV0dG9uPlwiKTtcclxuXHJcbiAgICBjaGFydERpdi5zZWxlY3QoJy5jb21tZW50Ym94LWVkaXQnKS5zZWxlY3QoJyNkaXNwbGF5JykuX2dyb3Vwc1swXVswXS5jaGVja2VkID0gY29tbWVudE9iai5jb21tZW50cy5saXN0W2N1cnJlbnRDb21tZW50XS5iaW5kaW5nLnNob3dBc01hcmtlciA9PT0gJ3RydWUnO1xyXG5cclxuICAgIGNoYXJ0RGl2LnNlbGVjdEFsbCgnLmNvbW1lbnRib3gtZWRpdCcpLnNlbGVjdCgnI2RlbGV0ZScpXHJcbiAgICAgICAgLm9uKCdjbGljay5kZWxldGUnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGNoYXJ0RGl2LnNlbGVjdCgnLmNvbW1lbnRib3gtZWRpdCcpLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICBjaGFydERpdi5zZWxlY3QoJy5jb21tZW50Ym94LXJlYWRvbmx5JykucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIGNoYXJ0RGl2LnNlbGVjdCgnI25vZGUnICsgY3VycmVudENvbW1lbnQpLmF0dHIoJ2Rpc3BsYXknLCAnbm9uZScpO1xyXG4gICAgICAgICAgICAvL3JlZHJhdyBjb21tZW50IG5vZGVzIHdpdGggbmV3IGluZGV4ZXNcclxuICAgICAgICAgICAgY29tbWVudE9iai5vblNhdmVDYWxsYmFjayhjb21tZW50T2JqLmNvbW1lbnRzLmxpc3RbY3VycmVudENvbW1lbnRdLCBjdXJyZW50Q29tbWVudCwgJ3JlbW92ZScpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIGNoYXJ0RGl2LnNlbGVjdEFsbCgnLmNvbW1lbnRib3gtZWRpdCcpLnNlbGVjdCgnI3NhdmUnKVxyXG4gICAgICAgIC5vbignY2xpY2suc2F2ZScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgbGV0IHRleHQgPSBjaGFydERpdi5zZWxlY3QoJy5jb21tZW50Ym94LWVkaXQnKS5zZWxlY3QoJyNlZGl0JykuX2dyb3Vwc1swXVswXS52YWx1ZSxcclxuICAgICAgICAgICAgICAgIHNob3dBc01hcmtlciA9IGNoYXJ0RGl2LnNlbGVjdCgnLmNvbW1lbnRib3gtZWRpdCcpLnNlbGVjdCgnI2Rpc3BsYXknKS5fZ3JvdXBzWzBdWzBdLmNoZWNrZWQ7XHJcbiAgICAgICAgICAgIGNvbW1lbnRPYmouY29tbWVudHMubGlzdFtjdXJyZW50Q29tbWVudF0uY29tbWVudFRleHQgPSB0ZXh0O1xyXG4gICAgICAgICAgICBjb21tZW50T2JqLmNvbW1lbnRzLmxpc3RbY3VycmVudENvbW1lbnRdLmJpbmRpbmcuc2hvd0FzTWFya2VyID0gc2hvd0FzTWFya2VyID8gJ3RydWUnIDogJ2ZhbHNlJztcclxuICAgICAgICAgICAgY2hhcnREaXYuc2VsZWN0KCcuY29tbWVudGJveC1yZWFkb25seScpLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICBjaGFydERpdi5zZWxlY3QoJy5jb21tZW50Ym94LWVkaXQnKS5yZW1vdmUoKTtcclxuICAgICAgICAgICAgY29tbWVudE9iai5vblNhdmVDYWxsYmFjayhjb21tZW50T2JqLmNvbW1lbnRzLmxpc3RbY3VycmVudENvbW1lbnRdLCBjdXJyZW50Q29tbWVudCwgJ2VkaXQnKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICBjaGFydERpdi5zZWxlY3RBbGwoJy5jb21tZW50Ym94LWVkaXQnKS5zZWxlY3QoJyNjYW5jZWwtZWRpdCcpXHJcbiAgICAgICAgLm9uKCdjbGljay5jYW5jZWwtZWRpdCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY2hhcnREaXYuc2VsZWN0KCcuY29tbWVudGJveC1yZWFkb25seScpLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICBjaGFydERpdi5zZWxlY3QoJy5jb21tZW50Ym94LWVkaXQnKS5yZW1vdmUoKTtcclxuICAgICAgICB9KTtcclxufVxyXG5cclxuXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIFV0aWxpdHkgZnVuY3Rpb25zICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcbi8qKlxyXG4qIEBuYW1lIG92ZXJsYXlEaXZQb3NpdGlvblxyXG4qIEBkZXNjIGZ1bmN0aW9uIHRvIGRldGVybWluZSB0aGUgcGxhY2VtZW50IG9mIHRoZSBkaXYgb24gdGhlIHZpc3VhbFxyXG4qIEBwYXJhbSB7bnVtYmVyfSBkaXZXaWR0aCAtIHdpZHRoIG9mIHRoZSBjb21tZW50IGVudHJ5IGJveFxyXG4qIEBwYXJhbSB7bnVtYmVyfSBkaXZIZWlnaHQgLSBoZWlnaHQgb2YgdGhlIGNvbW1lbnQgZW50cnkgYm94XHJcbiogQHBhcmFtIHtudW1iZXJ9IG1vdXNlWCAtIHggcG9zaXRpb24gb2YgdGhlIGNsaWNrIGV2ZW50XHJcbiogQHBhcmFtIHtudW1iZXJ9IG1vdXNlWSAtIHkgcG9zaXRpb24gb2YgdGhlIGNsaWNrIGV2ZW50XHJcbiogQHJldHVybiB7b2JqZWN0fSAtIHBvc2l0aW9uIG9mIGRpdlxyXG4qL1xyXG5mdW5jdGlvbiBvdmVybGF5RGl2UG9zaXRpb24oZGl2V2lkdGgsIGRpdkhlaWdodCwgbW91c2VYLCBtb3VzZVkpIHtcclxuICAgIGxldCBlZGl0T2JqID0gdGhpcyxcclxuICAgICAgICBwb3NpdGlvbiA9IHtcclxuICAgICAgICAgICAgeDogbW91c2VYLFxyXG4gICAgICAgICAgICB5OiBtb3VzZVkgKyAxMFxyXG4gICAgICAgIH07XHJcbiAgICBpZiAobW91c2VYID4gcGFyc2VJbnQoZWRpdE9iai5jaGFydERpdi5zdHlsZSgnd2lkdGgnKSwgMTApIC8gMikge1xyXG4gICAgICAgIHBvc2l0aW9uLnggPSBtb3VzZVggLSBkaXZXaWR0aDtcclxuICAgIH1cclxuICAgIGlmIChtb3VzZVkgLSBkaXZIZWlnaHQgLSAxMCA+IDApIHtcclxuICAgICAgICBwb3NpdGlvbi55ID0gbW91c2VZIC0gZGl2SGVpZ2h0IC0gMTA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcG9zaXRpb247XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ganZDb21tZW50O1xyXG4iLCIvKioqICBqdkVkaXQgKioqL1xyXG4ndXNlIHN0cmljdCc7XHJcbnZhciBlZGl0VGVtcGxhdGUgPSByZXF1aXJlKCcuL2VkaXRPcHRpb25zVGVtcGxhdGUuanMnKTtcclxuXHJcbi8qKlxyXG4qIEBuYW1lIGp2RWRpdFxyXG4qIEBkZXNjIENvbnN0cnVjdG9yIGZvciBKViBFZGl0IC0gY3JlYXRlcyBlZGl0cyB0byBhIGp2IHZpc3VhbGl6YXRpb24gYW5kIGV4ZWN1dGVzIGEgY2FsbGJhY2sgZm9yIHRoZSBlZGl0IG9wdGlvbnMgdG8gYmUgc2F2ZWRcclxuKiBAcGFyYW0ge29iamVjdH0gY29uZmlnT2JqIC0gY29uc3RydWN0b3Igb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGp2Q2hhcnQgYW5kIG90aGVyIG9wdGlvbnNcclxuKiBAcmV0dXJuIHt1bmRlZmluZWR9IC0gbm8gcmV0dXJuXHJcbiovXHJcbmZ1bmN0aW9uIGp2RWRpdChjb25maWdPYmopIHtcclxuICAgIHZhciBlZGl0T2JqID0gdGhpcztcclxuICAgIGVkaXRPYmouY2hhcnREaXYgPSBjb25maWdPYmouY2hhcnREaXY7XHJcbiAgICBlZGl0T2JqLnZpek9wdGlvbnMgPSBjb25maWdPYmoudml6T3B0aW9ucyA/IGNvbmZpZ09iai52aXpPcHRpb25zIDoge307XHJcbiAgICBlZGl0T2JqLmNoYXJ0RGl2LnNlbGVjdEFsbCgnLmVkaXQtZGl2JykucmVtb3ZlKCk7XHJcbiAgICBlZGl0T2JqLmVkaXREaXYgPSBlZGl0T2JqLmNoYXJ0RGl2LmFwcGVuZCgnZGl2JykuYXR0cignY2xhc3MnLCAnZWRpdC1kaXYnKTtcclxuICAgIGVkaXRPYmoub25TYXZlQ2FsbGJhY2sgPSBjb25maWdPYmoub25TYXZlQ2FsbGJhY2s7XHJcbn1cclxuXHJcbmp2RWRpdC5wcm90b3R5cGUuZGlzcGxheUVkaXQgPSBkaXNwbGF5RWRpdDtcclxuanZFZGl0LnByb3RvdHlwZS5jaGFuZ2VGb250U2l6ZSA9IGNoYW5nZUZvbnRTaXplO1xyXG5qdkVkaXQucHJvdG90eXBlLnN1Ym1pdEVkaXRNb2RlID0gc3VibWl0RWRpdE1vZGU7XHJcbmp2RWRpdC5wcm90b3R5cGUuYXBwbHlFZGl0TW9kZSA9IGFwcGx5RWRpdE1vZGU7XHJcbmp2RWRpdC5wcm90b3R5cGUuYXBwbHlBbGxFZGl0cyA9IGFwcGx5QWxsRWRpdHM7XHJcbmp2RWRpdC5wcm90b3R5cGUucmVtb3ZlRWRpdCA9IHJlbW92ZUVkaXQ7XHJcbmp2RWRpdC5wcm90b3R5cGUub3ZlcmxheURpdlBvc2l0aW9uID0gb3ZlcmxheURpdlBvc2l0aW9uO1xyXG5cclxuLyoqXHJcbiogQG5hbWUgZGlzcGxheUVkaXRcclxuKiBAZGVzYyBEaXNwbGF5cyB0aGUgZWRpdCBkaXYsIGdyYWJiaW5nIGl0IGZyb20gdGhlIHRlbXBsYXRlXHJcbiogQHBhcmFtIHthcnJheX0gbW91c2UgLSBtb3VzZSBsb2NhdGlvbiBvZiB0aGUgY2xpY2sgZXZlbnQsIHVzZWQgdG8gcGxhY2UgdGhlIGVkaXQgbW9kZSBkaXYgb24gdGhlIHZpc3VhbFxyXG4qIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zIC0gY3NzIGNsYXNzIG9mIGNsaWNrZWQgZWxlbWVudCwgcHJvdmlkZXMgdGhlIG9wdGlvbnMgdGhhdCBhcmUgZWRpdGFibGUgYnkgZWRpdCBtb2RlXHJcbiogQHJldHVybiB7dW5kZWZpbmVkfSAtIG5vIHJldHVyblxyXG4qL1xyXG5mdW5jdGlvbiBkaXNwbGF5RWRpdChtb3VzZSwgb3B0aW9ucykge1xyXG4gICAgdmFyIGVkaXRPYmogPSB0aGlzLFxyXG4gICAgICAgIG1vdXNlWCA9IG1vdXNlWzBdLFxyXG4gICAgICAgIG1vdXNlWSA9IG1vdXNlWzFdLFxyXG4gICAgICAgIG9wdGlvblZhbHVlcyA9IFtdLFxyXG4gICAgICAgIGl0ZW1Ub0NoYW5nZSA9ICcnLFxyXG4gICAgICAgIGVkaXRPcHRpb25FbGVtZW50LFxyXG4gICAgICAgIGVkaXRIZWlnaHQgPSBwYXJzZUZsb2F0KGVkaXRPYmouZWRpdERpdi5zdHlsZSgnaGVpZ2h0JykpLFxyXG4gICAgICAgIGVkaXRXaWR0aCA9IHBhcnNlRmxvYXQoZWRpdE9iai5lZGl0RGl2LnN0eWxlKCd3aWR0aCcpKSxcclxuICAgICAgICBwb3NpdGlvbjtcclxuXHJcbiAgICAvL3JldHVybiBpZiB5b3UgY2xpY2sgb24gdGhlIHNhbWUgZWxlbWVudCB0d2ljZSwgbm8gbmVlZCB0byBkaXNwbGF5IGEgc2Vjb25kIGVkaXQgZGl2IGlmIHRoZSBjdXJyZW50IG9uZSBpcyBzdGlsbCBvcGVuXHJcbiAgICBpZiAoZWRpdE9iai5lZGl0T3B0aW9ucyA9PT0gb3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGVkaXRPYmouZWRpdERpdi5odG1sKCcnKTtcclxuICAgIGVkaXRPYmouZWRpdE9wdGlvbnMgPSBvcHRpb25zO1xyXG5cclxuICAgIC8vYXNzaWduIGh0bWwgdG8gZWRpdERpdiAoYmFzaWNhbGx5IGRpc3BsYXlzIHRoZSBkaXYpXHJcbiAgICBlZGl0T2JqLmVkaXREaXYuaHRtbChlZGl0VGVtcGxhdGUpO1xyXG5cclxuICAgIC8vb3B0aW9uVmFsdWVzIC0gYW4gYXJyYXkgb2Ygc3RyaW5ncy5cclxuICAgIC8vU3RyaW5nIGlzIHRoZSBpZCB0byB0aGUgZWxlbWVudCBpbiB0aGUgZWRpdERpdiBmb3JtLlxyXG4gICAgLy9UaGlzIHN0cmluZyBjb250YWlucyB0aGUgc3BlY2lmaWMgb3B0aW9uIHRoYXQgaXMgYmVpbmcgY2hhbmdlZFxyXG5cclxuICAgIC8vaXRlbVRvQ2hhbmdlXHJcbiAgICAvL1N0cmluZyB0aGF0IGlzIHRoZSBjbGFzcyBvZiB0aGUgc3ZnIGVsZW1lbnQgdG8gYmUgY2hhbmdlZCBvbiB0aGUgdml6IGl0c2VsZlxyXG4gICAgZWRpdE9wdGlvbkVsZW1lbnQgPSBlZGl0T2JqLmVkaXREaXYuc2VsZWN0KCcjZWRpdC1vcHRpb24tZWxlbWVudCcpO1xyXG5cclxuICAgIC8vaWYgc3RhdGVtZW50cyB0byBkZXRlcm1pbmUgd2hpY2ggZWRpdCBvcHRpb25zIHRvIGRpc3BsYXlcclxuICAgIGlmIChvcHRpb25zLmluZGV4T2YoJ2VkaXRhYmxlLXlBeGlzJykgPj0gMCkge1xyXG4gICAgICAgIGVkaXRPcHRpb25FbGVtZW50Lmh0bWwoJyZuYnNwO2ZvciBZIEF4aXMnKTtcclxuICAgICAgICBlZGl0T3B0aW9uRWxlbWVudC5zdHlsZSgndmlzaWJpbGl0eScsICd2aXNpYmxlJyk7XHJcbiAgICAgICAgaXRlbVRvQ2hhbmdlID0gJ3lBeGlzJztcclxuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5pbmRleE9mKCdlZGl0YWJsZS14QXhpcycpID49IDApIHtcclxuICAgICAgICBlZGl0T3B0aW9uRWxlbWVudC5odG1sKCcmbmJzcDtmb3IgWCBBeGlzJyk7XHJcbiAgICAgICAgZWRpdE9wdGlvbkVsZW1lbnQuc3R5bGUoJ3Zpc2liaWxpdHknLCAndmlzaWJsZScpO1xyXG4gICAgICAgIGl0ZW1Ub0NoYW5nZSA9ICd4QXhpcyc7XHJcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuaW5kZXhPZigneUxhYmVsJykgPj0gMCkge1xyXG4gICAgICAgIGVkaXRPcHRpb25FbGVtZW50Lmh0bWwoJyZuYnNwO2ZvciBZIExhYmVsJyk7XHJcbiAgICAgICAgZWRpdE9wdGlvbkVsZW1lbnQuc3R5bGUoJ3Zpc2liaWxpdHknLCAndmlzaWJsZScpO1xyXG4gICAgICAgIGl0ZW1Ub0NoYW5nZSA9ICd5TGFiZWwnO1xyXG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmluZGV4T2YoJ3hMYWJlbCcpID49IDApIHtcclxuICAgICAgICBlZGl0T3B0aW9uRWxlbWVudC5odG1sKCcmbmJzcDtmb3IgWCBMYWJlbCcpO1xyXG4gICAgICAgIGVkaXRPcHRpb25FbGVtZW50LnN0eWxlKCd2aXNpYmlsaXR5JywgJ3Zpc2libGUnKTtcclxuICAgICAgICBpdGVtVG9DaGFuZ2UgPSAneExhYmVsJztcclxuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5pbmRleE9mKCdsZWdlbmRUZXh0JykgPj0gMCkge1xyXG4gICAgICAgIGVkaXRPcHRpb25FbGVtZW50Lmh0bWwoJyZuYnNwO2ZvciBMZWdlbmQgSXRlbScpO1xyXG4gICAgICAgIGVkaXRPcHRpb25FbGVtZW50LnN0eWxlKCd2aXNpYmlsaXR5JywgJ3Zpc2libGUnKTtcclxuICAgICAgICBpdGVtVG9DaGFuZ2UgPSBvcHRpb25zLnN1YnN0cmluZyhvcHRpb25zLmluZGV4T2YoJ2VkaXRhYmxlLWxlZ2VuZC0nKSkuc3BsaXQoJyAnKVswXTtcclxuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5pbmRleE9mKCdlZGl0YWJsZS1iYXInKSA+PSAwKSB7XHJcbiAgICAgICAgZWRpdE9wdGlvbkVsZW1lbnQuaHRtbCgnJm5ic3A7Zm9yIEJhciBDaGFydCcpO1xyXG4gICAgICAgIGVkaXRPcHRpb25FbGVtZW50LnN0eWxlKCd2aXNpYmlsaXR5JywgJ3Zpc2libGUnKTtcclxuICAgICAgICBlZGl0T2JqLmVkaXREaXYuc2VsZWN0KCcuZWRpdGFibGUtYmFyJykuc3R5bGUoJ2Rpc3BsYXknLCAnYmxvY2snKTtcclxuICAgICAgICBvcHRpb25WYWx1ZXMucHVzaCgnZWRpdGFibGUtYmFyJyk7XHJcbiAgICAgICAgaXRlbVRvQ2hhbmdlID0gb3B0aW9ucy5zdWJzdHJpbmcob3B0aW9ucy5pbmRleE9mKCdiYXItY29sLScpKS5zcGxpdCgnICcpWzBdO1xyXG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmluZGV4T2YoJ2VkaXRhYmxlLXBpZScpID49IDApIHtcclxuICAgICAgICBlZGl0T3B0aW9uRWxlbWVudC5odG1sKCcmbmJzcDtmb3IgUGllIFNsaWNlJyk7XHJcbiAgICAgICAgZWRpdE9wdGlvbkVsZW1lbnQuc3R5bGUoJ3Zpc2liaWxpdHknLCAndmlzaWJsZScpO1xyXG4gICAgICAgIGVkaXRPYmouZWRpdERpdi5zZWxlY3QoJy5lZGl0YWJsZS1waWUnKS5zdHlsZSgnZGlzcGxheScsICdibG9jaycpO1xyXG4gICAgICAgIG9wdGlvblZhbHVlcy5wdXNoKCdlZGl0YWJsZS1waWUnKTtcclxuICAgICAgICBpdGVtVG9DaGFuZ2UgPSBvcHRpb25zLnN1YnN0cmluZyhvcHRpb25zLmluZGV4T2YoJ3BpZS1zbGljZS0nKSkuc3BsaXQoJyAnKVswXTtcclxuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5pbmRleE9mKCdlZGl0YWJsZS1zY2F0dGVyJykgPj0gMCkge1xyXG4gICAgICAgIGVkaXRPcHRpb25FbGVtZW50Lmh0bWwoJyZuYnNwO2ZvciBTY2F0dGVyIFBsb3QnKTtcclxuICAgICAgICBlZGl0T3B0aW9uRWxlbWVudC5zdHlsZSgndmlzaWJpbGl0eScsICd2aXNpYmxlJyk7XHJcbiAgICAgICAgZWRpdE9iai5lZGl0RGl2LnNlbGVjdCgnLmVkaXRhYmxlLXNjYXR0ZXInKS5zdHlsZSgnZGlzcGxheScsICdibG9jaycpO1xyXG4gICAgICAgIG9wdGlvblZhbHVlcy5wdXNoKCdlZGl0YWJsZS1zY2F0dGVyJyk7XHJcbiAgICAgICAgaXRlbVRvQ2hhbmdlID0gb3B0aW9ucy5zdWJzdHJpbmcob3B0aW9ucy5pbmRleE9mKCdzY2F0dGVyLWNpcmNsZS0nKSkuc3BsaXQoJyAnKVswXTtcclxuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5pbmRleE9mKCdlZGl0YWJsZS1idWJibGUnKSA+PSAwKSB7XHJcbiAgICAgICAgZWRpdE9wdGlvbkVsZW1lbnQuaHRtbCgnJm5ic3A7Zm9yIEJ1YmJsZSBDaGFydCcpO1xyXG4gICAgICAgIGVkaXRPcHRpb25FbGVtZW50LnN0eWxlKCd2aXNpYmlsaXR5JywgJ3Zpc2libGUnKTtcclxuICAgICAgICBlZGl0T2JqLmVkaXREaXYuc2VsZWN0KCcuZWRpdGFibGUtYnViYmxlJykuc3R5bGUoJ2Rpc3BsYXknLCAnYmxvY2snKTtcclxuICAgICAgICBvcHRpb25WYWx1ZXMucHVzaCgnZWRpdGFibGUtYnViYmxlJyk7XHJcbiAgICAgICAgaXRlbVRvQ2hhbmdlID0gb3B0aW9ucy5zdWJzdHJpbmcob3B0aW9ucy5pbmRleE9mKCdidWJibGUtJykpLnNwbGl0KCcgJylbMF07XHJcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuaW5kZXhPZignZWRpdGFibGUtYm94JykgPj0gMCkge1xyXG4gICAgICAgIGVkaXRPcHRpb25FbGVtZW50Lmh0bWwoJyZuYnNwO2ZvciBCb3ggYW5kIFdoaXNrZXIgUGxvdCcpO1xyXG4gICAgICAgIGVkaXRPcHRpb25FbGVtZW50LnN0eWxlKCd2aXNpYmlsaXR5JywgJ3Zpc2libGUnKTtcclxuICAgICAgICBlZGl0T2JqLmVkaXREaXYuc2VsZWN0KCcuZWRpdGFibGUtYm94Jykuc3R5bGUoJ2Rpc3BsYXknLCAnYmxvY2snKTtcclxuICAgICAgICBvcHRpb25WYWx1ZXMucHVzaCgnZWRpdGFibGUtYm94Jyk7XHJcbiAgICAgICAgaXRlbVRvQ2hhbmdlID0gb3B0aW9ucy5zdWJzdHJpbmcob3B0aW9ucy5pbmRleE9mKCdib3gtJykpLnNwbGl0KCcgJylbMF07XHJcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuaW5kZXhPZignZWRpdGFibGUtY29tbWVudCcpID49IDApIHtcclxuICAgICAgICBlZGl0T3B0aW9uRWxlbWVudC5odG1sKCcmbmJzcDtmb3IgQ29tbWVudCcpO1xyXG4gICAgICAgIGVkaXRPcHRpb25FbGVtZW50LnN0eWxlKCd2aXNpYmlsaXR5JywgJ3Zpc2libGUnKTtcclxuICAgICAgICBpdGVtVG9DaGFuZ2UgPSBvcHRpb25zLnN1YnN0cmluZyhvcHRpb25zLmluZGV4T2YoJ2VkaXRhYmxlLWNvbW1lbnQtJykpLnNwbGl0KCcgJylbMF07XHJcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuaW5kZXhPZignZWRpdGFibGUtc3ZnJykgPj0gMCkge1xyXG4gICAgICAgIGVkaXRPcHRpb25FbGVtZW50Lmh0bWwoJyZuYnNwO2ZvciBBbGwgVGV4dCcpO1xyXG4gICAgICAgIGVkaXRPcHRpb25FbGVtZW50LnN0eWxlKCd2aXNpYmlsaXR5JywgJ3Zpc2libGUnKTtcclxuICAgICAgICBlZGl0T2JqLmVkaXREaXYuc2VsZWN0KCcuZWRpdGFibGUtdGV4dC1zaXplLWJ1dHRvbnMnKS5zdHlsZSgnZGlzcGxheScsICdibG9jaycpO1xyXG4gICAgICAgIG9wdGlvblZhbHVlcy5wdXNoKCdlZGl0YWJsZS10ZXh0LXNpemUnKTtcclxuICAgICAgICBpdGVtVG9DaGFuZ2UgPSAnc3ZnJztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ1N0aWxsIG5lZWQgdG8gYWRkIG9wdGlvbiB0byBkaXNwbGF5IGVkaXQnKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAob3B0aW9ucy5pbmRleE9mKCdlZGl0YWJsZS1udW0nKSA+PSAwKSB7XHJcbiAgICAgICAgZWRpdE9iai5lZGl0RGl2LnNlbGVjdCgnLmVkaXRhYmxlLW51bS1mb3JtYXQnKS5zdHlsZSgnZGlzcGxheScsICdibG9jaycpO1xyXG4gICAgICAgIG9wdGlvblZhbHVlcy5wdXNoKCdlZGl0YWJsZS1udW0tZm9ybWF0Jyk7XHJcbiAgICB9XHJcbiAgICBpZiAob3B0aW9ucy5pbmRleE9mKCdlZGl0YWJsZS10ZXh0JykgPj0gMCkge1xyXG4gICAgICAgIGVkaXRPYmouZWRpdERpdi5zZWxlY3QoJy5lZGl0YWJsZS10ZXh0LWNvbG9yJykuc3R5bGUoJ2Rpc3BsYXknLCAnYmxvY2snKTtcclxuICAgICAgICBvcHRpb25WYWx1ZXMucHVzaCgnZWRpdGFibGUtdGV4dC1jb2xvcicpO1xyXG4gICAgICAgIGVkaXRPYmouZWRpdERpdi5zZWxlY3QoJy5lZGl0YWJsZS10ZXh0LXNpemUnKS5zdHlsZSgnZGlzcGxheScsICdibG9jaycpO1xyXG4gICAgICAgIG9wdGlvblZhbHVlcy5wdXNoKCdlZGl0YWJsZS10ZXh0LXNpemUnKTtcclxuICAgIH1cclxuICAgIGlmIChvcHRpb25zLmluZGV4T2YoJ2VkaXRhYmxlLWNvbnRlbnQnKSA+PSAwKSB7XHJcbiAgICAgICAgZWRpdE9iai5lZGl0RGl2LnNlbGVjdCgnLmVkaXRhYmxlLWNvbnRlbnQnKS5zdHlsZSgnZGlzcGxheScsICdibG9jaycpO1xyXG4gICAgICAgIG9wdGlvblZhbHVlcy5wdXNoKCdlZGl0YWJsZS1jb250ZW50Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy9wb3B1bGF0ZSBlZGl0IGRpdiB3aXRoIGluaXRpYWwgdmFsdWVzXHJcbiAgICBpZiAoZWRpdE9iai52aXpPcHRpb25zW2l0ZW1Ub0NoYW5nZV0pIHtcclxuICAgICAgICBwb3B1bGF0ZVNlbGVjdGlvbnNFZGl0TW9kZShlZGl0T2JqLmVkaXREaXYsIGVkaXRPYmoudml6T3B0aW9uc1tpdGVtVG9DaGFuZ2VdKTtcclxuICAgIH1cclxuICAgIGVkaXRPYmouZWRpdERpdlxyXG4gICAgICAgIC5zdHlsZSgnZGlzcGxheScsICdibG9jaycpXHJcbiAgICAgICAgLnN0eWxlKCdsZWZ0JywgMCArICdweCcpXHJcbiAgICAgICAgLnN0eWxlKCd0b3AnLCAwICsgJ3B4Jyk7XHJcblxyXG4gICAgLy9jYWxjdWxhdGUgcG9zaXRpb24gb2Ygb3ZlcmxheSBkaXZcclxuICAgIGVkaXRIZWlnaHQgPSBwYXJzZUZsb2F0KGVkaXRPYmouZWRpdERpdi5zdHlsZSgnaGVpZ2h0JykpO1xyXG4gICAgZWRpdFdpZHRoID0gcGFyc2VGbG9hdChlZGl0T2JqLmVkaXREaXYuc3R5bGUoJ3dpZHRoJykpO1xyXG4gICAgcG9zaXRpb24gPSBlZGl0T2JqLm92ZXJsYXlEaXZQb3NpdGlvbihlZGl0V2lkdGgsIGVkaXRIZWlnaHQsIG1vdXNlWCwgbW91c2VZKTtcclxuXHJcbiAgICAvL3Nob3cgdGhlIG5ldyBlZGl0IGRpdlxyXG4gICAgZWRpdE9iai5lZGl0RGl2XHJcbiAgICAgICAgLnN0eWxlKCdsZWZ0JywgcG9zaXRpb24ueCArICdweCcpXHJcbiAgICAgICAgLnN0eWxlKCd0b3AnLCBwb3NpdGlvbi55ICsgJ3B4Jyk7XHJcblxyXG4gICAgLy9hZGQgc3VibWl0LCBkZWZhdWx0LCBhbmQgZXhpdCBsaXN0ZW5lcnMgdG8gdGhlIGRpdlxyXG4gICAgZWRpdE9iai5lZGl0RGl2LnNlbGVjdCgnI3N1Ym1pdEVkaXRNb2RlJykub24oJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGVkaXRPYmouc3VibWl0RWRpdE1vZGUob3B0aW9uVmFsdWVzLCBpdGVtVG9DaGFuZ2UpO1xyXG4gICAgICAgIGVkaXRPYmoucmVtb3ZlRWRpdCgpO1xyXG4gICAgfSk7XHJcbiAgICBlZGl0T2JqLmVkaXREaXYuc2VsZWN0KCcjc3VibWl0RWRpdE1vZGVEZWZhdWx0Jykub24oJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGVkaXRPYmouc3VibWl0RWRpdE1vZGUob3B0aW9uVmFsdWVzLCBpdGVtVG9DaGFuZ2UsIHRydWUpO1xyXG4gICAgICAgIGVkaXRPYmoucmVtb3ZlRWRpdCgpO1xyXG4gICAgfSk7XHJcbiAgICBlZGl0T2JqLmVkaXREaXYuc2VsZWN0KCcjZXhpdEVkaXRNb2RlJykub24oJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGVkaXRPYmoucmVtb3ZlRWRpdCgpO1xyXG4gICAgfSk7XHJcbiAgICBlZGl0T2JqLmZvbnRTaXplSW5jcmVtZW50ID0gMDtcclxuXHJcbiAgICAvL0NsaWNrIGV2ZW50cyBmb3IgaW5jcmVhc2UvZGVjcmVhc2UgZm9udCBzaXplIGJ1dHRvbnNcclxuICAgIGVkaXRPYmouZWRpdERpdi5zZWxlY3QoJyNpbmNyZWFzZUZvbnRTaXplJykub24oJ2NsaWNrJywgaW5jcmVhc2VGb250U2l6ZS5iaW5kKGVkaXRPYmopKTtcclxuICAgIGVkaXRPYmouZWRpdERpdi5zZWxlY3QoJyNkZWNyZWFzZUZvbnRTaXplJykub24oJ2NsaWNrJywgZGVjcmVhc2VGb250U2l6ZS5iaW5kKGVkaXRPYmopKTtcclxufVxyXG5cclxuLyoqXHJcbiogQG5hbWUgaW5jcmVhc2VGb250U2l6ZVxyXG4qIEBkZXNjIEluY3JlYXNlcyBmb250IHNpemUgYnkgYW4gaW5jcmVtZW50XHJcbiogQHJldHVybiB7dW5kZWZpbmVkfSAtIG5vIHJldHVyblxyXG4qL1xyXG5mdW5jdGlvbiBpbmNyZWFzZUZvbnRTaXplKCkge1xyXG4gICAgdmFyIGVkaXRPYmogPSB0aGlzLFxyXG4gICAgICAgIGZvbnRJbmNyZW1lbnQgPSAxLFxyXG4gICAgICAgIG1heFNpemUgPSAyODtcclxuICAgIGlmIChlZGl0T2JqLmZvbnRTaXplSW5jcmVtZW50IDwgbWF4U2l6ZSkge1xyXG4gICAgICAgIGVkaXRPYmouY2hhbmdlRm9udFNpemUoZm9udEluY3JlbWVudCk7XHJcbiAgICAgICAgZWRpdE9iai5mb250U2l6ZUluY3JlbWVudCsrO1xyXG4gICAgICAgIGVkaXRPYmoudml6T3B0aW9ucy50ZXh0ID0geyAnZWRpdGFibGUtdGV4dC1pbmNyZW1lbnQnOiBlZGl0T2JqLmZvbnRTaXplSW5jcmVtZW50IH07XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4qIEBuYW1lIGRlY3JlYXNlRm9udFNpemVcclxuKiBAZGVzYyBEZWNyZWFzZXMgZm9udCBzaXplIGJ5IGFuIGluY3JlbWVudFxyXG4qIEByZXR1cm4ge3VuZGVmaW5lZH0gLSBubyByZXR1cm5cclxuKi9cclxuZnVuY3Rpb24gZGVjcmVhc2VGb250U2l6ZSgpIHtcclxuICAgIHZhciBlZGl0T2JqID0gdGhpcyxcclxuICAgICAgICBmb250RGVjcmVtZW50ID0gLTEsXHJcbiAgICAgICAgbWluU2l6ZSA9IC0xMjtcclxuICAgIC8vbWluIHNpemUgaXMgbmVnIDEyIGJlY2F1c2UgZGVmYXVsdCBzaXplIGlzIDEycHggb24gb3VyIGNoYXJ0c1xyXG4gICAgaWYgKGVkaXRPYmouZm9udFNpemVJbmNyZW1lbnQgPiBtaW5TaXplKSB7XHJcbiAgICAgICAgZWRpdE9iai5jaGFuZ2VGb250U2l6ZShmb250RGVjcmVtZW50KTtcclxuICAgICAgICBlZGl0T2JqLmZvbnRTaXplSW5jcmVtZW50LS07XHJcbiAgICAgICAgZWRpdE9iai52aXpPcHRpb25zLnRleHQgPSB7ICdlZGl0YWJsZS10ZXh0LWluY3JlbWVudCc6IGVkaXRPYmouZm9udFNpemVJbmNyZW1lbnQgfTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiogQG5hbWUgY2hhbmdlRm9udFNpemVcclxuKiBAZGVzYyBJbmNyZWFzZXMgb3IgZGVjcmVhc2VzIGZvbnQgc2l6ZSBieSBhIGNlcnRhaW4gaW5jcmVtZW50XHJcbiogQHBhcmFtIHtpbnRlZ2VyfSBpbmNyZW1lbnQgLSBudW1iZXIgb2YgaW5jcmVtZW50XHJcbiogQHJldHVybiB7dW5kZWZpbmVkfSAtIG5vIHJldHVyblxyXG4qL1xyXG5mdW5jdGlvbiBjaGFuZ2VGb250U2l6ZShpbmNyZW1lbnQpIHtcclxuICAgIHZhciBlZGl0T2JqID0gdGhpcztcclxuICAgIGVkaXRPYmouY2hhcnREaXYuc2VsZWN0QWxsKCd0ZXh0JykuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdXBkYXRlRm9udCh0aGlzLCBpbmNyZW1lbnQpO1xyXG4gICAgfSk7XHJcbiAgICBlZGl0T2JqLmNoYXJ0RGl2LnNlbGVjdEFsbCgnLnRleHQnKS5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB1cGRhdGVGb250KHRoaXMsIGluY3JlbWVudCk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiogQG5hbWUgdXBkYXRlRm9udFxyXG4qIEBkZXNjIGNoYW5nZXMgdGhlIHNpemUgb2YgdGhlIGZvbnQgYnkgYSBnaXZlbiBpbmNyZW1lbnRcclxuKiBAcGFyYW0ge2h0bWxOb2RlfSB0aGlzRGl2IC0gbm9kZSB0byBjaGFuZ2UgZm9udCBzaXplXHJcbiogQHBhcmFtIHtpbnRlZ2VyfSBpbmNyZW1lbnQgLSBudW1iZXIgb2YgaW5jcmVtZW50XHJcbiogQHJldHVybiB7dW5kZWZpbmVkfSAtIG5vIHJldHVyblxyXG4qL1xyXG5mdW5jdGlvbiB1cGRhdGVGb250KHRoaXNEaXYsIGluY3JlbWVudCkge1xyXG4gICAgdmFyIG5ld1NpemUsXHJcbiAgICAgICAgdGV4dFNpemUgPSAxMjtcclxuICAgIGlmICh0aGlzRGl2ICYmIHRoaXNEaXYuZ2V0QXR0cmlidXRlKCdmb250LXNpemUnKSkge1xyXG4gICAgICAgIHRleHRTaXplID0gdGhpc0Rpdi5nZXRBdHRyaWJ1dGUoJ2ZvbnQtc2l6ZScpO1xyXG4gICAgICAgIG5ld1NpemUgPSBwYXJzZUludCh0ZXh0U2l6ZSwgMTApICsgaW5jcmVtZW50O1xyXG4gICAgICAgIHRoaXNEaXYuc2V0QXR0cmlidXRlKCdmb250LXNpemUnLCBuZXdTaXplICsgJ3B4Jyk7XHJcbiAgICB9IGVsc2UgaWYgKHRoaXNEaXYpIHtcclxuICAgICAgICB0ZXh0U2l6ZSA9IHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXNEaXYsIG51bGwpLmdldFByb3BlcnR5VmFsdWUoJ2ZvbnQtc2l6ZScpLCAxMCkgKyBpbmNyZW1lbnQ7XHJcbiAgICAgICAgdGhpc0Rpdi5zdHlsZS5mb250U2l6ZSA9ICB0ZXh0U2l6ZSArICdweCc7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4qIEBuYW1lIHBvcHVsYXRlU2VsZWN0aW9uc0VkaXRNb2RlXHJcbiogQGRlc2MgSW5pdGlhbGx5IHBvcHVsYXRlcyB0aGUgZWRpdERpdiBpZiB0aGVyZSBhcmUgdml6T3B0aW9uc1xyXG4qIEBwYXJhbSB7aHRtbE5vZGV9IGVkaXREaXYgLSBlZGl0IG1vZGUgb3B0aW9ucyBkaXZcclxuKiBAcGFyYW0ge29iamVjdH0gdml6T3B0aW9ucyAtIGN1cnJlbnQgdXNlciBvcHRpb25zIHRvIGFwcGx5IHRvIHRoZSBlZGl0IGRpdlxyXG4qIEByZXR1cm4ge3VuZGVmaW5lZH0gLSBubyByZXR1cm5cclxuKi9cclxuZnVuY3Rpb24gcG9wdWxhdGVTZWxlY3Rpb25zRWRpdE1vZGUoZWRpdERpdiwgdml6T3B0aW9ucykge1xyXG4gICAgZm9yIChsZXQgb3B0aW9uIGluIHZpek9wdGlvbnMpIHtcclxuICAgICAgICBpZiAodml6T3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShvcHRpb24pKSB7XHJcbiAgICAgICAgICAgIGxldCBzZWxlY3RlZE9iamVjdCA9IGVkaXREaXYuc2VsZWN0KCcjJyArIG9wdGlvbikuX2dyb3Vwc1swXVswXTtcclxuICAgICAgICAgICAgLy9kZWZhdWx0IGNvbG9yIGlucHV0cyB0byBncmF5XHJcbiAgICAgICAgICAgIGlmICh2aXpPcHRpb25zW29wdGlvbl0gPT09ICdkZWZhdWx0Jykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkT2JqZWN0LnR5cGUgPT09ICdjb2xvcicpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWRPYmplY3QuaWQuaW5kZXhPZigndGV4dCcpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZE9iamVjdC52YWx1ZSA9ICcjMDAwMDAwJztcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZE9iamVjdC52YWx1ZSA9ICcjYWFhYWFhJztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzZWxlY3RlZE9iamVjdC52YWx1ZSA9IHZpek9wdGlvbnNbb3B0aW9uXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiogQG5hbWUgc3VibWl0RWRpdE1vZGVcclxuKiBAZGVzYyBjYWxscyBzYXZlIGNhbGxiYWNrIG9uIGVkaXQgbW9kZSB3aXRoIGVkaXQgb3B0aW9uc1xyXG4qIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25WYWx1ZXMgLSBuZXcgdXNlciBvcHRpb25zIHRvIHNhdmVcclxuKiBAcGFyYW0ge29iamVjdH0gcG9zc2libGVJdGVtVG9DaGFuZ2UgLSBpdGVtIHRoYXQgdGhlIHVzZXIgY2xpY2tlZCAobWlnaHQgbm90IGJlIHRoZSBhY3R1YWwgaXRlbSB0byB1cGRhdGUpXHJcbiogQHBhcmFtIHtvYmplY3R9IGRlZmF1bHRCdG5DbGlja2VkIC0gcmVzZXQgdml6IG9wdGlvbiB0byBkZWZhdWx0XHJcbiogQHJldHVybiB7dW5kZWZpbmVkfSAtIG5vIHJldHVyblxyXG4qL1xyXG5mdW5jdGlvbiBzdWJtaXRFZGl0TW9kZShvcHRpb25WYWx1ZXMsIHBvc3NpYmxlSXRlbVRvQ2hhbmdlLCBkZWZhdWx0QnRuQ2xpY2tlZCkge1xyXG4gICAgbGV0IGVkaXRPYmogPSB0aGlzLFxyXG4gICAgICAgIG9wdGlvbkFycmF5ID0gb3B0aW9uVmFsdWVzLFxyXG4gICAgICAgIHNlbGVjdGVkRWRpdE9wdGlvbnMgPSB7fSxcclxuICAgICAgICBlZGl0VmFsdWUsXHJcbiAgICAgICAgc2VsZWN0ZWRPYmosXHJcbiAgICAgICAgaXRlbVRvQ2hhbmdlID0gcG9zc2libGVJdGVtVG9DaGFuZ2U7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcHRpb25BcnJheS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChvcHRpb25BcnJheVtpXS5pbmRleE9mKCdlZGl0YWJsZS1sZWdlbmQnKSA+IDApIHtcclxuICAgICAgICAgICAgLy9jaGFuZ2UgaXRlbSB0byBjaGFuZ2UgZm9yIGxlZ2VuZCBlbGVtZW50c1xyXG4gICAgICAgICAgICBpdGVtVG9DaGFuZ2UgPSBvcHRpb25BcnJheVtpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2VsZWN0ZWRPYmogPSBlZGl0T2JqLmVkaXREaXYuc2VsZWN0KCcjJyArIG9wdGlvbkFycmF5W2ldKTtcclxuICAgICAgICAvL3NlZSBpZiBzZWxlY3RlZCBvYmplY3QgZXhpc3RzXHJcbiAgICAgICAgaWYgKHNlbGVjdGVkT2JqICYmIHNlbGVjdGVkT2JqLl9ncm91cHNbMF0gJiYgc2VsZWN0ZWRPYmouX2dyb3Vwc1swXVswXSkge1xyXG4gICAgICAgICAgICBlZGl0VmFsdWUgPSBzZWxlY3RlZE9iai5fZ3JvdXBzWzBdWzBdLnZhbHVlO1xyXG4gICAgICAgICAgICAvL2dldCBzZWxlY3RlZCBvcHRpb24gZnJvbSBlZGl0IGRpdlxyXG4gICAgICAgICAgICBpZiAob3B0aW9uQXJyYXlbaV0gPT09ICdlZGl0YWJsZS1jb250ZW50JyAmJiBlZGl0VmFsdWUgPT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICAvL2RvbnQgYWRkIGFuIGVtcHR5IHN0cmluZyB0byB0aGUgdml6IG9wdGlvbnMgZm9yIGVkaXRhYmxlIGNvbnRlbnRcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNlbGVjdGVkRWRpdE9wdGlvbnNbb3B0aW9uQXJyYXlbaV1dID0gZWRpdFZhbHVlO1xyXG4gICAgICAgICAgICBpZiAoKCFzZWxlY3RlZEVkaXRPcHRpb25zW29wdGlvbkFycmF5W2ldXSkgJiYgb3B0aW9uQXJyYXlbaV0uaW5kZXhPZignY29udGVudCcpIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRFZGl0T3B0aW9uc1tvcHRpb25BcnJheVtpXV0gPSAnZGVmYXVsdCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGRlZmF1bHRCdG5DbGlja2VkKSB7XHJcbiAgICAgICAgaWYgKGl0ZW1Ub0NoYW5nZSA9PT0gJ3N2ZycpIHtcclxuICAgICAgICAgICAgZGVsZXRlIGVkaXRPYmoudml6T3B0aW9ucy50ZXh0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZWxldGUgZWRpdE9iai52aXpPcHRpb25zW2l0ZW1Ub0NoYW5nZV07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGVkaXRPYmoudml6T3B0aW9uc1tpdGVtVG9DaGFuZ2VdID0gc2VsZWN0ZWRFZGl0T3B0aW9ucztcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXRlbVRvQ2hhbmdlID09PSAnc3ZnJykge1xyXG4gICAgICAgIGRlbGV0ZSBlZGl0T2JqLnZpek9wdGlvbnMuc3ZnO1xyXG4gICAgfVxyXG5cclxuICAgIC8vc2F2ZSB2aXpPcHRpb25zXHJcbiAgICBlZGl0T2JqLm9uU2F2ZUNhbGxiYWNrKGVkaXRPYmoudml6T3B0aW9ucyk7XHJcbn1cclxuXHJcbi8qKlxyXG4qIEBuYW1lIGFwcGx5RWRpdE1vZGVcclxuKiBAZGVzYyBhcHBsaWVzIGluZGl2aWR1YWwgdml6IG9wdGlvbiBvbiB0aGUgdmlzdWFsXHJcbiogQHBhcmFtIHtzdHJpbmd9IGl0ZW1Ub0NoYW5nZSAtIHZpeiBvcHRpb24gdG8gdXBkYXRlXHJcbiogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSB2aXogb3B0aW9uIHByb3BlcnRpZXNcclxuKiBAcmV0dXJuIHt1bmRlZmluZWR9IC0gbm8gcmV0dXJuXHJcbiovXHJcbmZ1bmN0aW9uIGFwcGx5RWRpdE1vZGUoaXRlbVRvQ2hhbmdlLCBvcHRpb25zKSB7XHJcbiAgICB2YXIgZWRpdE9iaiA9IHRoaXMsXHJcbiAgICAgICAgb2JqZWN0ID0gZWRpdE9iai5jaGFydERpdi5zZWxlY3QoJy4nICsgaXRlbVRvQ2hhbmdlKSxcclxuICAgICAgICBvYmplY3RHcm91cHMgPSBvYmplY3QuX2dyb3VwcyxcclxuICAgICAgICBvYmplY3RUYWdOYW1lID0gb2JqZWN0R3JvdXBzWzBdWzBdID8gb2JqZWN0R3JvdXBzWzBdWzBdLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA6IG51bGw7XHJcblxyXG4gICAgaWYgKGl0ZW1Ub0NoYW5nZSA9PT0gJ3RleHQnKSB7XHJcbiAgICAgICAgLy9kbyBzb21ldGhpbmcgaWYgaXQgaXMgYWxsIHRoZSB0ZXh0IHRoYXQgaXMgYmVpbmcgY2hhbmdlZFxyXG4gICAgICAgIG9iamVjdCA9IGVkaXRPYmouY2hhcnREaXYuc2VsZWN0QWxsKCd0ZXh0Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy9vcHRpb25zIGJ5IHRhZ05hbWVcclxuICAgIGlmIChvYmplY3RUYWdOYW1lID09PSAnZycpIHtcclxuICAgICAgICBvYmplY3QgPSBlZGl0T2JqLmNoYXJ0RGl2LnNlbGVjdCgnLicgKyBpdGVtVG9DaGFuZ2UpLnNlbGVjdEFsbCgndGV4dCcpO1xyXG4gICAgfSBlbHNlIGlmIChvYmplY3RUYWdOYW1lID09PSAncmVjdCcpIHtcclxuICAgICAgICBpZiAob3B0aW9uc1snZWRpdGFibGUtYmFyJ10pIHtcclxuICAgICAgICAgICAgb2JqZWN0LmF0dHIoJ2ZpbGwnLCBvcHRpb25zWydlZGl0YWJsZS1iYXInXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcHRpb25zWydlZGl0YWJsZS1ib3gnXSkge1xyXG4gICAgICAgICAgICBvYmplY3QuYXR0cignZmlsbCcsIG9wdGlvbnNbJ2VkaXRhYmxlLWJveCddKTtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKG9iamVjdFRhZ05hbWUgPT09ICdjaXJjbGUnKSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnNbJ2VkaXRhYmxlLXNjYXR0ZXInXSkge1xyXG4gICAgICAgICAgICBvYmplY3QuYXR0cignZmlsbCcsIG9wdGlvbnNbJ2VkaXRhYmxlLXNjYXR0ZXInXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcHRpb25zWydlZGl0YWJsZS1idWJibGUnXSkge1xyXG4gICAgICAgICAgICBvYmplY3QuYXR0cignZmlsbCcsIG9wdGlvbnNbJ2VkaXRhYmxlLWJ1YmJsZSddKTtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKG9iamVjdFRhZ05hbWUgPT09ICdwYXRoJykge1xyXG4gICAgICAgIGlmIChvcHRpb25zWydlZGl0YWJsZS1waWUnXSkge1xyXG4gICAgICAgICAgICBvYmplY3QuYXR0cignZmlsbCcsIG9wdGlvbnNbJ2VkaXRhYmxlLXBpZSddKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy9zdGFuZGFyZCBvcHRpb25zXHJcbiAgICAvL0lmIGEgdGV4dCBpbmNyZW1lbnQgZXhpc3RzLCBhcHBseSBpdCBiYXNlZCBvbiB0aGUgc2lnbiBvZiB0aGUgdmFyaWFibGVcclxuICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KCdlZGl0YWJsZS10ZXh0LWluY3JlbWVudCcpKSB7XHJcbiAgICAgICAgZWRpdE9iai5jaGFuZ2VGb250U2l6ZShvcHRpb25zWydlZGl0YWJsZS10ZXh0LWluY3JlbWVudCddKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnZWRpdGFibGUtdGV4dC1zaXplJykpIHtcclxuICAgICAgICBvYmplY3Quc3R5bGUoJ2ZvbnQtc2l6ZScsIG9wdGlvbnNbJ2VkaXRhYmxlLXRleHQtc2l6ZSddICsgJ3B4Jyk7XHJcbiAgICB9XHJcbiAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnZWRpdGFibGUtdGV4dC1jb2xvcicpKSB7XHJcbiAgICAgICAgb2JqZWN0LnN0eWxlKCdmaWxsJywgb3B0aW9uc1snZWRpdGFibGUtdGV4dC1jb2xvciddKTtcclxuICAgICAgICBvYmplY3Quc3R5bGUoJ2NvbG9yJywgb3B0aW9uc1snZWRpdGFibGUtdGV4dC1jb2xvciddKTtcclxuICAgIH1cclxuICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KCdlZGl0YWJsZS1udW0tZm9ybWF0JykpIHtcclxuICAgICAgICBsZXQgZXhwcmVzc2lvbiA9IGdldEZvcm1hdEV4cHJlc3Npb24ob3B0aW9uc1snZWRpdGFibGUtbnVtLWZvcm1hdCddKTtcclxuICAgICAgICBvYmplY3RcclxuICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxyXG4gICAgICAgICAgICAudGV4dCgoZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc05hTihkKSAmJiB0eXBlb2YgZXhwcmVzc2lvbiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoZXhwcmVzc2lvbihkKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnZWRpdGFibGUtY29udGVudCcpKSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnNbJ2VkaXRhYmxlLWNvbnRlbnQnXS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIG9iamVjdC5odG1sKG9wdGlvbnNbJ2VkaXRhYmxlLWNvbnRlbnQnXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWRpdE9iai5yZW1vdmVFZGl0KCk7XHJcbn1cclxuXHJcbi8qKlxyXG4qIEBuYW1lIGFwcGx5QWxsRWRpdHNcclxuKiBAZGVzYyBhcHBsaWVzIGFsbCB2aXogb3B0aW9ucyBpbiB0aGUgZWRpdCBtb2RlIG9iamVjdFxyXG4qIEByZXR1cm4ge3VuZGVmaW5lZH0gLSBubyByZXR1cm5cclxuKi9cclxuZnVuY3Rpb24gYXBwbHlBbGxFZGl0cygpIHtcclxuICAgIGxldCBlZGl0T2JqID0gdGhpcztcclxuICAgIGZvciAobGV0IG9wdGlvbiBpbiBlZGl0T2JqLnZpek9wdGlvbnMpIHtcclxuICAgICAgICBpZiAoZWRpdE9iai52aXpPcHRpb25zLmhhc093blByb3BlcnR5KG9wdGlvbikgJiYgZWRpdE9iai5jaGFydERpdi5zZWxlY3Qob3B0aW9uKSkge1xyXG4gICAgICAgICAgICBlZGl0T2JqLmFwcGx5RWRpdE1vZGUob3B0aW9uLCBlZGl0T2JqLnZpek9wdGlvbnNbb3B0aW9uXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuKiBAbmFtZSByZW1vdmVFZGl0XHJcbiogQGRlc2MgcmVtb3ZlcyBlZGl0IGRpdiBmcm9tIHRoZSB2aXN1YWxcclxuKiBAcmV0dXJuIHt1bmRlZmluZWR9IC0gbm8gcmV0dXJuXHJcbiovXHJcbmZ1bmN0aW9uIHJlbW92ZUVkaXQoKSB7XHJcbiAgICBsZXQgZWRpdE9iaiA9IHRoaXM7XHJcbiAgICBpZiAoZWRpdE9iai5lZGl0RGl2KSB7XHJcbiAgICAgICAgZWRpdE9iai5lZGl0RGl2Lmh0bWwoJycpO1xyXG4gICAgICAgIGVkaXRPYmouZWRpdERpdlxyXG4gICAgICAgICAgICAuc3R5bGUoJ2Rpc3BsYXknLCAnbm9uZScpO1xyXG4gICAgfVxyXG4gICAgZWRpdE9iai5lZGl0T3B0aW9ucyA9ICcnO1xyXG59XHJcblxyXG4vKipcclxuKiBAbmFtZSBvdmVybGF5RGl2UG9zaXRpb25cclxuKiBAZGVzYyBmdW5jdGlvbiB0byBkZXRlcm1pbmUgdGhlIHBsYWNlbWVudCBvZiB0aGUgZGl2IG9uIHRoZSB2aXN1YWxcclxuKiBAcGFyYW0ge251bWJlcn0gZGl2V2lkdGggLSB3aWR0aCBvZiB0aGUgY29tbWVudCBlbnRyeSBib3hcclxuKiBAcGFyYW0ge251bWJlcn0gZGl2SGVpZ2h0IC0gaGVpZ2h0IG9mIHRoZSBjb21tZW50IGVudHJ5IGJveFxyXG4qIEBwYXJhbSB7bnVtYmVyfSBtb3VzZVggLSB4IHBvc2l0aW9uIG9mIHRoZSBjbGljayBldmVudFxyXG4qIEBwYXJhbSB7bnVtYmVyfSBtb3VzZVkgLSB5IHBvc2l0aW9uIG9mIHRoZSBjbGljayBldmVudFxyXG4qIEByZXR1cm4ge29iamVjdH0gLSBwb3NpdGlvbiBvZiBkaXZcclxuKi9cclxuZnVuY3Rpb24gb3ZlcmxheURpdlBvc2l0aW9uKGRpdldpZHRoLCBkaXZIZWlnaHQsIG1vdXNlWCwgbW91c2VZKSB7XHJcbiAgICBsZXQgZWRpdE9iaiA9IHRoaXMsXHJcbiAgICAgICAgcG9zaXRpb24gPSB7XHJcbiAgICAgICAgICAgIHg6IG1vdXNlWCxcclxuICAgICAgICAgICAgeTogbW91c2VZICsgMTBcclxuICAgICAgICB9O1xyXG4gICAgaWYgKG1vdXNlWCA+IHBhcnNlSW50KGVkaXRPYmouY2hhcnREaXYuc3R5bGUoJ3dpZHRoJyksIDEwKSAvIDIpIHtcclxuICAgICAgICBwb3NpdGlvbi54ID0gbW91c2VYIC0gZGl2V2lkdGg7XHJcbiAgICB9XHJcbiAgICBpZiAobW91c2VZIC0gZGl2SGVpZ2h0IC0gMTAgPiAwKSB7XHJcbiAgICAgICAgcG9zaXRpb24ueSA9IG1vdXNlWSAtIGRpdkhlaWdodCAtIDEwO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBvc2l0aW9uO1xyXG59XHJcblxyXG4vKipcclxuKiBAbmFtZSBnZXRGb3JtYXRFeHByZXNzaW9uXHJcbiogQGRlc2MgcmV0dXJucyB0aGUgZDMgZm9ybWF0IGV4cHJlc3Npb24gZm9yIGEgZ2l2ZW4gb3B0aW9uXHJcbiogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbiAtIHR5cGUgb2YgZGF0YSBmb3JtYXRcclxuKiBAcmV0dXJuIHtmdW5jdGlvbn0gLSBleHByZXNzaW9uXHJcbiovXHJcbmZ1bmN0aW9uIGdldEZvcm1hdEV4cHJlc3Npb24ob3B0aW9uKSB7XHJcbiAgICBsZXQgZXhwcmVzc2lvbiA9ICcnLFxyXG4gICAgICAgIHA7XHJcbiAgICBpZiAob3B0aW9uID09PSAnY3VycmVuY3knKSB7XHJcbiAgICAgICAgZXhwcmVzc2lvbiA9IGQzLmZvcm1hdCgnJCwnKTtcclxuICAgIH0gZWxzZSBpZiAob3B0aW9uID09PSAnZml4ZWRDdXJyZW5jeScpIHtcclxuICAgICAgICBleHByZXNzaW9uID0gZDMuZm9ybWF0KCcoJC4yZicpO1xyXG4gICAgfSBlbHNlIGlmIChvcHRpb24gPT09ICdwZXJjZW50Jykge1xyXG4gICAgICAgIHAgPSBNYXRoLm1heCgwLCBkMy5wcmVjaXNpb25GaXhlZCgwLjA1KSAtIDIpO1xyXG4gICAgICAgIGV4cHJlc3Npb24gPSBkMy5mb3JtYXQoJy4nICsgcCArICclJyk7XHJcbiAgICB9IGVsc2UgaWYgKG9wdGlvbiA9PT0gJ21pbGxpb25zJykge1xyXG4gICAgICAgIHAgPSBkMy5wcmVjaXNpb25QcmVmaXgoMWU1LCAxLjNlNik7XHJcbiAgICAgICAgZXhwcmVzc2lvbiA9IGQzLmZvcm1hdFByZWZpeCgnLicgKyBwLCAxLjNlNik7XHJcbiAgICB9IGVsc2UgaWYgKG9wdGlvbiA9PT0gJ2NvbW1hcycpIHtcclxuICAgICAgICBleHByZXNzaW9uID0gZDMuZm9ybWF0KCcsLjBmJyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGV4cHJlc3Npb24gPSBkMy5mb3JtYXQoJycpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGV4cHJlc3Npb247XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ganZFZGl0O1xyXG4iLCIvKioqanZFdmVudHNcclxuICogRXZlbnRpbmcgbGF5ZXIgb24gdG9wIG9mIEpWIENoYXJ0cyB0byBhbGxvdyBjdXN0b20gY2FsbGJhY2tzIHRvIGJlIGF0dGFjaGVkIHRvIG1vdXNlIGV2ZW50c1xyXG4gKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGp2Q2hhcnRzID0gcmVxdWlyZSgnLi9qdkNoYXJ0cy5qcycpLFxyXG4gICAganZDb21tZW50ID0gcmVxdWlyZSgnLi9qdkNvbW1lbnQuanMnKSxcclxuICAgIGp2RWRpdCA9IHJlcXVpcmUoJy4vanZFZGl0LmpzJyksXHJcbiAgICBqdkJydXNoID0gcmVxdWlyZSgnLi9qdkJydXNoLmpzJyk7XHJcblxyXG5qdkNoYXJ0cy5wcm90b3R5cGUuaW5pdGlhbGl6ZU1vZGVzID0gaW5pdGlhbGl6ZU1vZGVzO1xyXG5qdkNoYXJ0cy5wcm90b3R5cGUuY3JlYXRlRGVmYXVsdE1vZGUgPSBjcmVhdGVEZWZhdWx0TW9kZTtcclxuanZDaGFydHMucHJvdG90eXBlLmNyZWF0ZUNvbW1lbnRNb2RlID0gY3JlYXRlQ29tbWVudE1vZGU7XHJcbmp2Q2hhcnRzLnByb3RvdHlwZS5jcmVhdGVFZGl0TW9kZSA9IGNyZWF0ZUVkaXRNb2RlO1xyXG5qdkNoYXJ0cy5wcm90b3R5cGUuY3JlYXRlQnJ1c2hNb2RlID0gY3JlYXRlQnJ1c2hNb2RlO1xyXG5qdkNoYXJ0cy5wcm90b3R5cGUuY3JlYXRlU2VsZWN0TW9kZSA9IGNyZWF0ZVNlbGVjdE1vZGU7XHJcbmp2Q2hhcnRzLnByb3RvdHlwZS50b2dnbGVNb2RlcyA9IHRvZ2dsZU1vZGVzO1xyXG5qdkNoYXJ0cy5wcm90b3R5cGUudG9nZ2xlRGVmYXVsdE1vZGUgPSB0b2dnbGVEZWZhdWx0TW9kZTtcclxuanZDaGFydHMucHJvdG90eXBlLnRvZ2dsZUNvbW1lbnRNb2RlID0gdG9nZ2xlQ29tbWVudE1vZGU7XHJcbmp2Q2hhcnRzLnByb3RvdHlwZS50b2dnbGVFZGl0TW9kZSA9IHRvZ2dsZUVkaXRNb2RlO1xyXG5qdkNoYXJ0cy5wcm90b3R5cGUudG9nZ2xlQnJ1c2hNb2RlID0gdG9nZ2xlQnJ1c2hNb2RlO1xyXG5qdkNoYXJ0cy5wcm90b3R5cGUudG9nZ2xlU2VsZWN0TW9kZSA9IHRvZ2dsZVNlbGVjdE1vZGU7XHJcbmp2Q2hhcnRzLnByb3RvdHlwZS5hZGRCcnVzaEV2ZW50cyA9IGFkZEJydXNoRXZlbnRzO1xyXG5cclxuLyoqXHJcbiogQG5hbWUgaW5pdGlhbGl6ZU1vZGVzXHJcbiogQGRlc2MgZnVuY3Rpb24gdGhhdCBpbml0aWFsaXplcyBhbmQgY3JlYXRlcyB0aGUgY2hhcnQgdG9vbGJhclxyXG4qIEByZXR1cm4ge3VuZGVmaW5lZH0gLSBubyByZXR1cm5cclxuKi9cclxuZnVuY3Rpb24gaW5pdGlhbGl6ZU1vZGVzKCkge1xyXG4gICAgbGV0IGNoYXJ0ID0gdGhpcyxcclxuICAgICAgICBjYWxsYmFja3MgPSBjaGFydC5jb25maWcuY2FsbGJhY2tzO1xyXG5cclxuICAgIC8vY2hlY2sgaWYgY2FsbGJhY2tzIGFyZSBuZWVkZWRcclxuICAgIGlmIChjYWxsYmFja3MpIHtcclxuICAgICAgICBmb3IgKGxldCBtb2RlIGluIGNhbGxiYWNrcykge1xyXG4gICAgICAgICAgICAvL2xvb3AgdGhyb3VnaCBhbGwgdGhlIHR5cGVzIG9mIG1vZGVzIHRvIGluaXRpYWxpemUgdGhlIG1vZGUgYW5kIHJlZ2lzdGVyIHRoZSBhcHByb3ByaWF0ZSBldmVudHNcclxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrcy5oYXNPd25Qcm9wZXJ0eShtb2RlKSAmJiBjYWxsYmFja3NbbW9kZV0pIHtcclxuICAgICAgICAgICAgICAgIGxldCBjYW1lbENhc2VNb2RlID0gbW9kZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG1vZGUuc2xpY2UoMSk7XHJcbiAgICAgICAgICAgICAgICBjaGFydFttb2RlXSA9IGNoYXJ0WydjcmVhdGUnICsgY2FtZWxDYXNlTW9kZV0oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2hhcnQuZWRpdE1vZGUpIHtcclxuICAgICAgICAgICAgY2hhcnQuZWRpdE1vZGUuYXBwbHlBbGxFZGl0cygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjaGFydC50b2dnbGVNb2RlcyhjaGFydC5tb2RlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY2hhcnQuY3JlYXRlRGVmYXVsdE1vZGUoKTtcclxuICAgICAgICAvL3VzZXIgaGFzIG5vdCBkZWZpbmVkIGFueSBvdGhlciBtb2Rlcywgc28ganVzdCB1c2UgZGVmYXVsdCBtb2RlXHJcbiAgICAgICAgY2hhcnQudG9nZ2xlRGVmYXVsdE1vZGUoJ2RlZmF1bHQtbW9kZScpO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuKiBAbmFtZSBjcmVhdGVEZWZhdWx0TW9kZVxyXG4qIEBkZXNjIGZ1bmN0aW9uIHRoYXQgaW5pdGlhbGl6ZXMgYW5kIGNyZWF0ZXMgdGhlIGRlZmF1bHQgbW9kZVxyXG4qIEByZXR1cm4ge3VuZGVmaW5lZH0gLSBubyByZXR1cm5cclxuKi9cclxuZnVuY3Rpb24gY3JlYXRlRGVmYXVsdE1vZGUoKSB7XHJcbiAgICBsZXQgY2hhcnQgPSB0aGlzO1xyXG4gICAgaWYgKGNoYXJ0LmNvbmZpZy5jYWxsYmFja3MgJiYgY2hhcnQuY29uZmlnLmNhbGxiYWNrcy5kZWZhdWx0TW9kZS5vbkJydXNoKSB7XHJcbiAgICAgICAgY2hhcnQuYnJ1c2hNb2RlID0gY2hhcnQuY3JlYXRlQnJ1c2hNb2RlKGNoYXJ0LmNvbmZpZy5jYWxsYmFja3MuZGVmYXVsdE1vZGUub25CcnVzaCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4qIEBuYW1lIGNyZWF0ZUNvbW1lbnRNb2RlXHJcbiogQGRlc2MgZnVuY3Rpb24gdGhhdCBpbml0aWFsaXplcyBhbmQgY3JlYXRlcyB0aGUgY29tbWVudCBtb2RlXHJcbiogQHJldHVybiB7anZDb21tZW50fSAtIGNyZWF0ZWQgY29tbWVudCBtb2RlXHJcbiovXHJcbmZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnRNb2RlKCkge1xyXG4gICAgbGV0IGNoYXJ0ID0gdGhpcztcclxuICAgIHJldHVybiBuZXcganZDb21tZW50KHtcclxuICAgICAgICBjaGFydERpdjogY2hhcnQuY2hhcnREaXYsXHJcbiAgICAgICAgY29tbWVudHM6IGNoYXJ0LmNvbmZpZy5jb21tZW50cyB8fCB7fSxcclxuICAgICAgICBvblNhdmVDYWxsYmFjazogY2hhcnQuY29uZmlnLmNhbGxiYWNrcy5jb21tZW50TW9kZS5vblNhdmUsXHJcbiAgICAgICAgZ2V0TW9kZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gY2hhcnQubW9kZTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiogQG5hbWUgY3JlYXRlRWRpdE1vZGVcclxuKiBAZGVzYyBmdW5jdGlvbiB0aGF0IGluaXRpYWxpemVzIGFuZCBjcmVhdGVzIHRoZSBlZGl0IG1vZGVcclxuKiBAcmV0dXJuIHtqdkVkaXR9IC0gY3JlYXRlZCBlZGl0IG1vZGUgb2JqZWN0XHJcbiovXHJcbmZ1bmN0aW9uIGNyZWF0ZUVkaXRNb2RlKCkge1xyXG4gICAgbGV0IGNoYXJ0ID0gdGhpcztcclxuICAgIHJldHVybiBuZXcganZFZGl0KHtcclxuICAgICAgICBjaGFydERpdjogY2hhcnQuY2hhcnREaXYsXHJcbiAgICAgICAgdml6T3B0aW9uczogY2hhcnQuY29uZmlnLmVkaXRPcHRpb25zIHx8IHt9LFxyXG4gICAgICAgIG9uU2F2ZUNhbGxiYWNrOiBjaGFydC5jb25maWcuY2FsbGJhY2tzLmVkaXRNb2RlLm9uU2F2ZVxyXG4gICAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4qIEBuYW1lIGNyZWF0ZUJydXNoTW9kZVxyXG4qIEBkZXNjIGZ1bmN0aW9uIHRoYXQgaW5pdGlhbGl6ZXMgYW5kIGNyZWF0ZXMgdGhlIGJydXNoIG1vZGVcclxuKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1BhcmFtIC0gZnVuY3Rpb24gdGhhdCBpcyBhbiBvcHRpb25hbCBjYWxsYmFjayBmb3IgYnJ1c2ggbW9kZVxyXG4qIEByZXR1cm4ge2p2QnJ1c2h9IC0gY3JlYXRlZCBicnVzaCBtb2RlIG9iamVjdFxyXG4qL1xyXG5mdW5jdGlvbiBjcmVhdGVCcnVzaE1vZGUoY2FsbGJhY2tQYXJhbSkge1xyXG4gICAgbGV0IGNoYXJ0ID0gdGhpcyxcclxuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrUGFyYW07XHJcbiAgICBpZiAoIWNhbGxiYWNrKSB7XHJcbiAgICAgICAgaWYgKGNoYXJ0LmNvbmZpZy5jYWxsYmFja3MuYnJ1c2hNb2RlICYmIHR5cGVvZiBjaGFydC5jb25maWcuY2FsbGJhY2tzLmJydXNoTW9kZS5vbkJydXNoID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrID0gY2hhcnQuY29uZmlnLmNhbGxiYWNrcy5icnVzaE1vZGUub25CcnVzaDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnbm8gYnJ1c2ggY2FsbGJhY2ssIHBhc3MgaXQgaW50byB0aGUgY2FsbGJhY2tzIG9wdGlvbicpO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IGp2QnJ1c2goe1xyXG4gICAgICAgIGNoYXJ0RGl2OiBjaGFydC5jaGFydERpdixcclxuICAgICAgICBqdkNoYXJ0OiBjaGFydCxcclxuICAgICAgICBvbkJydXNoQ2FsbGJhY2s6IGNhbGxiYWNrXHJcbiAgICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiogQG5hbWUgY3JlYXRlU2VsZWN0TW9kZVxyXG4qIEBkZXNjIGZ1bmN0aW9uIHRoYXQgaW5pdGlhbGl6ZXMgYW5kIGNyZWF0ZXMgdGhlIHNlbGVjdCBtb2RlXHJcbiogQHJldHVybiB7Ym9vbGVhbn0gLSB0cnVlIHNpbmNlIHRoZSBjcmVhdGlvbiBvZiBhIG1vZGUgaXMgb25seSBjYWxsZWQgd2hlbiBjYWxsYmFja3MgZm9yIHRoZSBtb2RlIGV4aXN0XHJcbiovXHJcbmZ1bmN0aW9uIGNyZWF0ZVNlbGVjdE1vZGUoKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxuLyoqXHJcbiogQG5hbWUgdG9nZ2xlTW9kZXNcclxuKiBAZGVzYyBzZXRzIHRoZSBjb3JyZWN0IGV2ZW50cyBmb3IgdGhlIHNwZWNpZmljIG1vZGUgcGFyYW1cclxuKiBAcGFyYW0ge3N0cmluZ30gbW9kZSAtIHNwZWNpZmllZCBtb2RlIHRvIHRvZ2dsZSB0b1xyXG4qIEByZXR1cm4ge3VuZGVmaW5lZH0gLSBubyByZXR1cm5cclxuKi9cclxuZnVuY3Rpb24gdG9nZ2xlTW9kZXMobW9kZSkge1xyXG4gICAgbGV0IGNoYXJ0ID0gdGhpcztcclxuICAgIGNoYXJ0LnRvZ2dsZURlZmF1bHRNb2RlKG1vZGUpO1xyXG4gICAgY2hhcnQuY29tbWVudE1vZGUgJiYgY2hhcnQudG9nZ2xlQ29tbWVudE1vZGUobW9kZSk7XHJcbiAgICBjaGFydC5lZGl0TW9kZSAmJiBjaGFydC50b2dnbGVFZGl0TW9kZShtb2RlKTtcclxuICAgIGNoYXJ0LmJydXNoTW9kZSAmJiBjaGFydC50b2dnbGVCcnVzaE1vZGUobW9kZSk7XHJcbiAgICBjaGFydC5zZWxlY3RNb2RlICYmIGNoYXJ0LnRvZ2dsZVNlbGVjdE1vZGUobW9kZSk7XHJcbn1cclxuXHJcbi8qKlxyXG4qIEBuYW1lIHRvZ2dsZURlZmF1bHRNb2RlXHJcbiogQGRlc2MgdXBkYXRlcyBldmVudCBsaXN0ZW5lcnMgZm9yIGRlZmF1bHQgbW9kZVxyXG4qIEBwYXJhbSB7c3RyaW5nfSBtb2RlIC0gc3BlY2lmaWVkIG1vZGUgdG8gdG9nZ2xlIHRvXHJcbiogQHJldHVybiB7dW5kZWZpbmVkfSAtIG5vIHJldHVyblxyXG4qL1xyXG5mdW5jdGlvbiB0b2dnbGVEZWZhdWx0TW9kZShtb2RlKSB7XHJcbiAgICBsZXQgY2hhcnQgPSB0aGlzO1xyXG4gICAgaWYgKG1vZGUgPT09ICdkZWZhdWx0LW1vZGUnKSB7XHJcbiAgICAgICAgbGV0IGRlZmF1bHRNb2RlID0gY2hhcnQuY29uZmlnLmNhbGxiYWNrcyA/IGNoYXJ0LmNvbmZpZy5jYWxsYmFja3MuZGVmYXVsdE1vZGUgOiBmYWxzZSxcclxuICAgICAgICAgICAgZW50aXJlU3ZnID0gY2hhcnQuY2hhcnREaXYuc2VsZWN0KCdzdmcnKSxcclxuICAgICAgICAgICAgY2FsbGJhY2tzO1xyXG4gICAgICAgIC8vY2hhbmdlIGN1cnNvciBhbmQgc2hvdyB0b29sdGlwc1xyXG4gICAgICAgIGNoYXJ0LmNoYXJ0RGl2LnN0eWxlKCdjdXJzb3InLCAnZGVmYXVsdCcpO1xyXG4gICAgICAgIGNoYXJ0LnNob3dUb29sVGlwID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgLy9yZXR1cm4gaWYgbm8gY2FsbGJhY2tzIGV4aXN0XHJcbiAgICAgICAgaWYgKCFkZWZhdWx0TW9kZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhbGxiYWNrcyA9IHtcclxuICAgICAgICAgICAgb25Eb3VibGVDbGljazogKGV2ZW50LCBub2RlLCBtb3VzZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWZhdWx0TW9kZS5vbkRvdWJsZUNsaWNrID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJldHJ1bk9iaiA9IGNoYXJ0W2NoYXJ0LmNvbmZpZy50eXBlXS5nZXRFdmVudERhdGEuY2FsbChjaGFydCwgZXZlbnQsIG1vdXNlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXRydW5PYmouZXZlbnRUeXBlID0gJ2RvdWJsZUNsaWNrJztcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0TW9kZS5vbkRvdWJsZUNsaWNrKHJldHJ1bk9iaik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG9uQ2xpY2s6IChldmVudCwgbm9kZSwgbW91c2UpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGVmYXVsdE1vZGUub25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCByZXRydW5PYmogPSBjaGFydFtjaGFydC5jb25maWcudHlwZV0uZ2V0RXZlbnREYXRhLmNhbGwoY2hhcnQsIGV2ZW50LCBtb3VzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0cnVuT2JqLmV2ZW50VHlwZSA9ICdjbGljayc7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdE1vZGUub25DbGljayhyZXRydW5PYmopO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgaWYgKGRlZmF1bHRNb2RlLm9uQnJ1c2ggJiYgY2hhcnQuYnJ1c2hNb2RlKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrcy5tb3VzZWRvd24gPSBhZGRCcnVzaE1vdXNlZG93bi5iaW5kKGNoYXJ0KTtcclxuICAgICAgICAgICAgY2FsbGJhY2tzLm1vdXNldXAgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjaGFydC5jaGFydERpdi5zZWxlY3QoJ3N2ZycpLm9uKCdtb3VzZW1vdmUnLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICBjaGFydC5jaGFydERpdi5zZWxlY3QoJ3N2ZycpLnN0eWxlKCdjdXJzb3InLCAnZGVmYXVsdCcpO1xyXG4gICAgICAgICAgICAgICAgY2hhcnQuYnJ1c2hNb2RlLnJlbW92ZUJydXNoKCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlZ2lzdGVyQ2xpY2tFdmVudHMoZW50aXJlU3ZnLCBjYWxsYmFja3MpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAvL3JlbW92ZSB0b29sdGlwcyBhbmQgYW55IGhpZ2hsaWdodHNcclxuICAgICAgICBjaGFydC5zaG93VG9vbFRpcCA9IGZhbHNlO1xyXG4gICAgICAgIGNoYXJ0LnJlbW92ZUhpZ2hsaWdodCgpO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuKiBAbmFtZSB0b2dnbGVDb21tZW50TW9kZVxyXG4qIEBkZXNjIHVwZGF0ZXMgZXZlbnQgbGlzdGVuZXJzIGZvciBjb21tZW50IG1vZGVcclxuKiBAcGFyYW0ge3N0cmluZ30gbW9kZSAtIHNwZWNpZmllZCBtb2RlIHRvIHRvZ2dsZSB0b1xyXG4qIEByZXR1cm4ge3VuZGVmaW5lZH0gLSBubyByZXR1cm5cclxuKi9cclxuZnVuY3Rpb24gdG9nZ2xlQ29tbWVudE1vZGUobW9kZSkge1xyXG4gICAgbGV0IGNoYXJ0ID0gdGhpcyxcclxuICAgICAgICBjb21tZW50T2JqID0gY2hhcnQuY29tbWVudE1vZGU7XHJcbiAgICBpZiAobW9kZSA9PT0gJ2NvbW1lbnQtbW9kZScpIHtcclxuICAgICAgICBsZXQgZW50aXJlU3ZnID0gY2hhcnQuY2hhcnREaXYuc2VsZWN0KCdzdmcnKSxcclxuICAgICAgICAgICAgY2FsbGJhY2tzID0ge1xyXG4gICAgICAgICAgICAgICAgb25Eb3VibGVDbGljazogKGV2ZW50LCBub2RlLCBtb3VzZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnRPYmoubWFrZUNvbW1lbnQobm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGFydC5jb25maWcuY2FsbGJhY2tzLmNvbW1lbnRNb2RlLm9uRG91YmxlQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJldHJ1bk9iaiA9IGNoYXJ0W2NoYXJ0LmNvbmZpZy50eXBlXS5nZXRFdmVudERhdGEuY2FsbChjaGFydCwgZXZlbnQsIG1vdXNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0cnVuT2JqLmV2ZW50VHlwZSA9ICdkb3VibGVDbGljayc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJ0LmNvbmZpZy5jYWxsYmFja3MuY29tbWVudE1vZGUub25Eb3VibGVDbGljayhyZXRydW5PYmopO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBvbkNsaWNrOiAoZXZlbnQsIG5vZGUsIG1vdXNlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGFydC5jb25maWcuY2FsbGJhY2tzLmNvbW1lbnRNb2RlLm9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJldHJ1bk9iaiA9IGNoYXJ0W2NoYXJ0LmNvbmZpZy50eXBlXS5nZXRFdmVudERhdGEuY2FsbChjaGFydCwgZXZlbnQsIG1vdXNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0cnVuT2JqLmV2ZW50VHlwZSA9ICdjbGljayc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJ0LmNvbmZpZy5jYWxsYmFja3MuY29tbWVudE1vZGUub25DbGljayhyZXRydW5PYmopO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICByZWdpc3RlckNsaWNrRXZlbnRzKGVudGlyZVN2ZywgY2FsbGJhY2tzKTtcclxuICAgICAgICAvL3NldCBjdXJzb3IgZm9yIGNvbW1lbnQgbW9kZVxyXG4gICAgICAgIGNoYXJ0LmNoYXJ0RGl2LnN0eWxlKCdjdXJzb3InLCAncG9pbnRlcicpO1xyXG4gICAgICAgIC8vYWRkIG1vdmVtZW50bGlzdGVuZXJzXHJcbiAgICAgICAgY2hhcnQuY2hhcnREaXYuc2VsZWN0QWxsKCcubWluLWNvbW1lbnQnKVxyXG4gICAgICAgICAgICAub24oJ21vdXNlZG93bicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIC8vbG9naWMgdG8gbW92ZSBjb21tZW50c1xyXG4gICAgICAgICAgICAgICAgY29tbWVudE9iai5jcmVhdGVNb3ZlTGlzdGVuZXIoZDMuc2VsZWN0KHRoaXMpKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLm9uKCdtb3VzZXVwJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbW1lbnRPYmoubW92ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb21tZW50T2JqLnVwZGF0ZVBvc2l0aW9uKGNvbW1lbnRPYmopO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29tbWVudE9iai5tb3ZlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgY2hhcnQuY2hhcnREaXYub24oJ21vdXNlbW92ZScsIGZhbHNlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbW1lbnRPYmoucmVtb3ZlQ29tbWVudCgpO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuKiBAbmFtZSB0b2dnbGVFZGl0TW9kZVxyXG4qIEBkZXNjIHVwZGF0ZXMgZXZlbnQgbGlzdGVuZXJzIGZvciBlZGl0IG1vZGVcclxuKiBAcGFyYW0ge3N0cmluZ30gbW9kZSAtIHNwZWNpZmllZCBtb2RlIHRvIHRvZ2dsZSB0b1xyXG4qIEByZXR1cm4ge3VuZGVmaW5lZH0gLSBubyByZXR1cm5cclxuKi9cclxuZnVuY3Rpb24gdG9nZ2xlRWRpdE1vZGUobW9kZSkge1xyXG4gICAgbGV0IGNoYXJ0ID0gdGhpcyxcclxuICAgICAgICBlZGl0T2JqID0gY2hhcnQuZWRpdE1vZGUsXHJcbiAgICAgICAgZW50aXJlU3ZnID0gZWRpdE9iai5jaGFydERpdi5zZWxlY3QoJ3N2ZycpO1xyXG4gICAgaWYgKG1vZGUgPT09ICdlZGl0LW1vZGUnKSB7XHJcbiAgICAgICAgZWRpdE9iai5jaGFydERpdi5zdHlsZSgnY3Vyc29yJywgJ2RlZmF1bHQnKTtcclxuICAgICAgICBlbnRpcmVTdmcuc2VsZWN0QWxsKCcuZXZlbnQtcmVjdCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdkaXNwbGF5JywgJ25vbmUnKTtcclxuXHJcbiAgICAgICAgbGV0IGNhbGxiYWNrcyA9IHtcclxuICAgICAgICAgICAgb25Eb3VibGVDbGljazogKGV2ZW50LCBub2RlLCBtb3VzZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGFydC5jb25maWcuY2FsbGJhY2tzLmVkaXRNb2RlLm9uRG91YmxlQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcmV0cnVuT2JqID0gY2hhcnRbY2hhcnQuY29uZmlnLnR5cGVdLmdldEV2ZW50RGF0YS5jYWxsKGNoYXJ0LCBldmVudCwgbW91c2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHJ1bk9iai5ldmVudFR5cGUgPSAnZG91YmxlQ2xpY2snO1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0LmNvbmZpZy5jYWxsYmFja3MuZWRpdE1vZGUub25Eb3VibGVDbGljayhyZXRydW5PYmopO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBvbkNsaWNrOiAoZXZlbnQsIG5vZGUsIG1vdXNlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvL2VkaXQgbW9kZSBldmVudHNcclxuICAgICAgICAgICAgICAgIC8vZ29pbmcgdG8gYmUgbW91c2VvdmVyIHRvIGhpZ2hsaWdodCBvcHRpb25zIGZvciB3aGF0ZXZlciBwaWVjZSB5b3UgaG92ZXIgb3ZlclxyXG4gICAgICAgICAgICAgICAgbGV0IGNsYXNzVGV4dCA9IGQzLnNlbGVjdChldmVudC50YXJnZXQpLmF0dHIoJ2NsYXNzJyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2xhc3NUZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNsYXNzVGV4dC5pbmRleE9mKCdlZGl0YWJsZScpID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdE9iai5kaXNwbGF5RWRpdChtb3VzZSwgY2xhc3NUZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGFydC5jb25maWcuY2FsbGJhY2tzLmVkaXRNb2RlLm9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcmV0cnVuT2JqID0gY2hhcnRbY2hhcnQuY29uZmlnLnR5cGVdLmdldEV2ZW50RGF0YS5jYWxsKGNoYXJ0LCBldmVudCwgbW91c2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHJ1bk9iai5ldmVudFR5cGUgPSAnY2xpY2snO1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0LmNvbmZpZy5jYWxsYmFja3MuZWRpdE1vZGUub25DbGljayhyZXRydW5PYmopO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvL2NsZWFyIHN2ZyBsaXN0ZW5lcnNcclxuICAgICAgICByZWdpc3RlckNsaWNrRXZlbnRzKGVudGlyZVN2Zyk7XHJcbiAgICAgICAgLy9hZGQgY2hhcnQgZGl2IGxldmVsIGxpc3RlbmVyc1xyXG4gICAgICAgIHJlZ2lzdGVyQ2xpY2tFdmVudHMoZWRpdE9iai5jaGFydERpdiwgY2FsbGJhY2tzKTtcclxuXHJcbiAgICAgICAgZWRpdE9iai5jaGFydERpdi5zZWxlY3RBbGwoJy5lZGl0YWJsZScpLmNsYXNzZWQoJ3BvaW50ZXInLCB0cnVlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy9jbGVhciBjaGFydCBkaXYgbGV2ZWwgbGlzdGVuZXJzXHJcbiAgICAgICAgcmVnaXN0ZXJDbGlja0V2ZW50cyhlZGl0T2JqLmNoYXJ0RGl2KTtcclxuICAgICAgICBlZGl0T2JqLnJlbW92ZUVkaXQoKTtcclxuICAgICAgICBlbnRpcmVTdmcuc2VsZWN0QWxsKCcuZWRpdGFibGUnKS5jbGFzc2VkKCdwb2ludGVyJywgZmFsc2UpO1xyXG4gICAgICAgIGVudGlyZVN2Zy5zZWxlY3RBbGwoJy5ldmVudC1yZWN0JylcclxuICAgICAgICAgICAgLmF0dHIoJ2Rpc3BsYXknLCAnYmxvY2snKTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiogQG5hbWUgdG9nZ2xlQnJ1c2hNb2RlXHJcbiogQGRlc2MgdXBkYXRlcyBldmVudCBsaXN0ZW5lcnMgZm9yIGJydXNoIG1vZGVcclxuKiBAcGFyYW0ge3N0cmluZ30gbW9kZSAtIHNwZWNpZmllZCBtb2RlIHRvIHRvZ2dsZSB0b1xyXG4qIEByZXR1cm4ge3VuZGVmaW5lZH0gLSBubyByZXR1cm5cclxuKi9cclxuZnVuY3Rpb24gdG9nZ2xlQnJ1c2hNb2RlKG1vZGUpIHtcclxuICAgIHZhciBjaGFydCA9IHRoaXM7XHJcbiAgICBpZiAobW9kZSA9PT0gJ2JydXNoLW1vZGUnICYmIGNoYXJ0LmNvbmZpZy5jYWxsYmFja3MuYnJ1c2hNb2RlKSB7XHJcbiAgICAgICAgY2hhcnQuYWRkQnJ1c2hFdmVudHMoKTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiogQG5hbWUgdG9nZ2xlU2VsZWN0TW9kZVxyXG4qIEBkZXNjIHVwZGF0ZXMgZXZlbnQgbGlzdGVuZXJzIGZvciBzZWxlY3QgbW9kZVxyXG4qIEBwYXJhbSB7c3RyaW5nfSBtb2RlIC0gc3BlY2lmaWVkIG1vZGUgdG8gdG9nZ2xlIHRvXHJcbiogQHJldHVybiB7dW5kZWZpbmVkfSAtIG5vIHJldHVyblxyXG4qL1xyXG5mdW5jdGlvbiB0b2dnbGVTZWxlY3RNb2RlKG1vZGUpIHtcclxuICAgIHZhciBjaGFydCA9IHRoaXM7XHJcbiAgICBpZiAobW9kZSA9PT0gJ3NlbGVjdC1tb2RlJykge1xyXG4gICAgICAgIGxldCBjYWxsYmFja3MgPSB7XHJcbiAgICAgICAgICAgIG9uRG91YmxlQ2xpY2s6IChldmVudCwgbm9kZSwgbW91c2UpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2hhcnQuY29uZmlnLmNhbGxiYWNrcy5zZWxlY3RNb2RlLm9uRG91YmxlQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcmV0cnVuT2JqID0gY2hhcnRbY2hhcnQuY29uZmlnLnR5cGVdLmdldEV2ZW50RGF0YS5jYWxsKGNoYXJ0LCBldmVudCwgbW91c2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHJ1bk9iai5ldmVudFR5cGUgPSAnZG91YmxlQ2xpY2snO1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0LmNvbmZpZy5jYWxsYmFja3Muc2VsZWN0TW9kZS5vbkRvdWJsZUNsaWNrKHJldHJ1bk9iaik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG9uQ2xpY2s6IChldmVudCwgbm9kZSwgbW91c2UpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2hhcnQuY29uZmlnLmNhbGxiYWNrcy5zZWxlY3RNb2RlLm9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcmV0cnVuT2JqID0gY2hhcnRbY2hhcnQuY29uZmlnLnR5cGVdLmdldEV2ZW50RGF0YS5jYWxsKGNoYXJ0LCBldmVudCwgbW91c2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHJ1bk9iai5ldmVudFR5cGUgPSAnY2xpY2snO1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0LmNvbmZpZy5jYWxsYmFja3Muc2VsZWN0TW9kZS5vbkNsaWNrKHJldHJ1bk9iaik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJlZ2lzdGVyQ2xpY2tFdmVudHMoY2hhcnQuY2hhcnREaXYuc2VsZWN0KCdzdmcnKSwgY2FsbGJhY2tzKTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiogQG5hbWUgYWRkQnJ1c2hFdmVudHNcclxuKiBAZGVzYyByZWdpc3RlcnMgZXZlbnRzIGZvciBicnVzaCBtb2RlXHJcbiogQHJldHVybiB7dW5kZWZpbmVkfSAtIG5vIHJldHVyblxyXG4qL1xyXG5mdW5jdGlvbiBhZGRCcnVzaEV2ZW50cygpIHtcclxuICAgIGxldCBjaGFydCA9IHRoaXMsXHJcbiAgICAgICAgZW50aXJlU3ZnID0gY2hhcnQuY2hhcnREaXYuc2VsZWN0KCdzdmcnKSxcclxuICAgICAgICBjYWxsYmFja3MgPSB7XHJcbiAgICAgICAgICAgIG1vdXNlZG93bjogYWRkQnJ1c2hNb3VzZWRvd24uYmluZChjaGFydCksXHJcbiAgICAgICAgICAgIG1vdXNldXA6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNoYXJ0LmNoYXJ0RGl2LnNlbGVjdCgnc3ZnJykub24oJ21vdXNlbW92ZScsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIGNoYXJ0LmJydXNoTW9kZS5yZW1vdmVCcnVzaCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIHJlZ2lzdGVyQ2xpY2tFdmVudHMoZW50aXJlU3ZnLCBjYWxsYmFja3MpO1xyXG59XHJcblxyXG4vKipcclxuKiBAbmFtZSBhZGRCcnVzaE1vdXNlZG93blxyXG4qIEBkZXNjIGNyZWF0ZXMgbW91c2Vkb3duIGV2ZW50IGZvciBicnVzaCBtb2RlXHJcbiogQHJldHVybiB7dW5kZWZpbmVkfSAtIG5vIHJldHVyblxyXG4qL1xyXG5mdW5jdGlvbiBhZGRCcnVzaE1vdXNlZG93bigpIHtcclxuICAgIHZhciBjaGFydCA9IHRoaXMsXHJcbiAgICAgICAgYnJ1c2hTdGFydGVkID0gZmFsc2UsXHJcbiAgICAgICAgYnJ1c2hDb250YWluZXIgPSBjaGFydC5jaGFydERpdi5zZWxlY3QoJy4nICsgY2hhcnQuY29uZmlnLnR5cGUgKyAnLWNvbnRhaW5lcicpLm5vZGUoKSxcclxuICAgICAgICBlbnRpcmVTdmcgPSBjaGFydC5jaGFydERpdi5zZWxlY3QoJ3N2ZycpLFxyXG4gICAgICAgIHRpbWVNb3VzZURvd24gPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgIGVudGlyZVN2Zy5vbignbW91c2Vtb3ZlJywgKCkgPT4ge1xyXG4gICAgICAgIHZhciB0aW1lTW91c2VNb3ZlID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgICAgICAgaWYgKHRpbWVNb3VzZURvd24gPiB0aW1lTW91c2VNb3ZlIC0gMTApIHtcclxuICAgICAgICAgICAgLy9tb3VzZSBtb3ZlIGhhcHBlbmQgdG9vIHF1aWNrbHksIGNocm9tZSBidWdcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYnJ1c2hTdGFydGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGNvbnRhaW5lckJveCxcclxuICAgICAgICAgICAgeCxcclxuICAgICAgICAgICAgeSxcclxuICAgICAgICAgICAgbW91c2U7XHJcbiAgICAgICAgaWYgKGJydXNoQ29udGFpbmVyID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgY2hhcnQuYnJ1c2hNb2RlLnN0YXJ0QnJ1c2goZDMuZXZlbnQpO1xyXG4gICAgICAgICAgICBicnVzaFN0YXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lckJveCA9IGJydXNoQ29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgICAgICBtb3VzZSA9IGQzLm1vdXNlKGVudGlyZVN2Zy5ub2RlKCkpO1xyXG4gICAgICAgICAgICB4ID0gbW91c2VbMF07XHJcbiAgICAgICAgICAgIHkgPSBtb3VzZVsxXTtcclxuXHJcbiAgICAgICAgICAgIGlmICh4IDwgY29udGFpbmVyQm94LnJpZ2h0ICYmIHkgPCBjb250YWluZXJCb3guYm90dG9tICYmIHggPiBjb250YWluZXJCb3gubGVmdCAmJiB5ID4gY29udGFpbmVyQm94LnRvcCkge1xyXG4gICAgICAgICAgICAgICAgY2hhcnQuYnJ1c2hNb2RlLnN0YXJ0QnJ1c2goZDMuZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgYnJ1c2hTdGFydGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcblxyXG4vKipcclxuKiBAbmFtZSByZWdpc3RlckNsaWNrRXZlbnRzXHJcbiogQGRlc2MgcmVnaXN0ZXIgaGFuZGxlciBmb3IganYgZXZlbnRzXHJcbiogQHBhcmFtIHtkM2VsZW1lbnR9IHN2ZyAtIGQzIHNlbGVjdGVkIGVsZW1lbnQgdG8gYmluZCBldmVudHMgb25cclxuKiBAcGFyYW0ge29iamVjdH0gbGlzdGVuZXJzIC0gY2FsbGJhY2tzIHRvIHJ1biBmb3IgZWFjaCB0eXBlIG9mIGNsaWNrIGV2ZW50XHJcbiogQHJldHVybiB7dW5kZWZpbmVkfSAtIG5vIHJldHVyblxyXG4qL1xyXG5mdW5jdGlvbiByZWdpc3RlckNsaWNrRXZlbnRzKHN2ZywgeyBvbkNsaWNrID0gbnVsbCwgb25Eb3VibGVDbGljayA9IG51bGwsIG1vdXNlZG93biA9IG51bGwsIG1vdXNldXAgPSBudWxsIH0gPSB7fSkge1xyXG4gICAgLy91c2luZyBkZWZhdWx0IHBhcmFtZXRlcnMgdG8gc2hvdyBhdmFpbGFibGUgcGFydHMgb2YgdGhlIGNhbGxiYWNrcyBvYmplY3RcclxuICAgIHZhciBkb3duLFxyXG4gICAgICAgIHRvbGVyYW5jZSA9IDUsXHJcbiAgICAgICAgd2FpdCA9IG51bGw7XHJcblxyXG4gICAgc3ZnLm9uKCdtb3VzZWRvd24nLCBmYWxzZSk7XHJcbiAgICBzdmcub24oJ21vdXNldXAnLCBmYWxzZSk7XHJcbiAgICBzdmcub24oJ21vdXNlbW92ZScsIGZhbHNlKTtcclxuXHJcbiAgICBzdmcub24oJ21vdXNlZG93bicsICgpID0+IHtcclxuICAgICAgICBkb3duID0gZDMubW91c2Uoc3ZnLm5vZGUoKSk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBtb3VzZWRvd24gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgbW91c2Vkb3duKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgc3ZnLm9uKCdtb3VzZXVwJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgbW91c2V1cCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICBtb3VzZXVwKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghb25Eb3VibGVDbGljaykge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIG9uQ2xpY2soZDMuZXZlbnQsIHRoaXMsIGQzLm1vdXNlKHRoaXMpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkaXN0KGRvd24sIGQzLm1vdXNlKHN2Zy5ub2RlKCkpKSA+IHRvbGVyYW5jZSkge1xyXG4gICAgICAgICAgICAvL2RyYWcgbm90IGNsaWNrIHNvIHJldHVyblxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh3YWl0KSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQod2FpdCk7XHJcbiAgICAgICAgICAgIHdhaXQgPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9uRG91YmxlQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIG9uRG91YmxlQ2xpY2soZDMuZXZlbnQsIHRoaXMsIGQzLm1vdXNlKHRoaXMpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHdhaXQgPSB3aW5kb3cuc2V0VGltZW91dCgoKGUsIG1vdXNlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrKGUsIHRoaXMsIG1vdXNlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgd2FpdCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLy9kMy5ldmVudCBhbmQgZDMubW91c2UgYm90aCBsb3NlIHRoZWlyIHNjb3BlIGluIGEgdGltZW91dCBhbmQgbm8gbG9uZ2VyIHJldHVybiB0aGUgZXhwZWN0ZWQgdmFsdWUsIHNvIGJpbmRpbmcgaXMgbmVjZXNzYXJ5XHJcbiAgICAgICAgICAgIH0pKGQzLmV2ZW50LCBkMy5tb3VzZSh0aGlzKSksIDI1MCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4qIEBuYW1lIGRpc3RcclxuKiBAZGVzYyBldWNsaWRlYW4gZGlzdGFuY2UgdG8gZGV0ZXJtaW5lIGlmIHRoZSBtb3VzZSBtb3ZlZCBpbiBiZXR3ZWVuIGNsaWNrcyBmb3IgZG91YmxlIGNsaWNrXHJcbiogQHBhcmFtIHthcnJheX0gYSAtIHBvaW50IGFcclxuKiBAcGFyYW0ge2FycmF5fSBiIC0gcG9pbnQgYlxyXG4qIEByZXR1cm4ge251bWJlcn0gLSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcclxuKi9cclxuZnVuY3Rpb24gZGlzdChhLCBiKSB7XHJcbiAgICBpZiAoYSAmJiBiICYmIEFycmF5LmlzQXJyYXkoYSkgJiYgQXJyYXkuaXNBcnJheShiKSkge1xyXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coYVswXSAtIGJbMF0sIDIpLCBNYXRoLnBvdyhhWzFdIC0gYlsxXSwgMikpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIDA7XHJcbn1cclxuIiwiLyoqKiAganZFZGl0ICoqKi9cclxuZnVuY3Rpb24ganZTZWxlY3QoY29uZmlnT2JqKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICB2YXIgc2VsZWN0T2JqID0gdGhpcztcclxuICAgIHNlbGVjdE9iai5jaGFydERpdiA9IGNvbmZpZ09iai5jaGFydERpdjtcclxuICAgIHNlbGVjdE9iai5qdkNoYXJ0ID0gY29uZmlnT2JqLmp2Q2hhcnQ7XHJcbiAgICBzZWxlY3RPYmouc2luZ2xlQ2xpY2tDYWxsYmFjayA9IGNvbmZpZ09iai5zaW5nbGVDbGlja0NhbGxiYWNrO1xyXG4gICAgc2VsZWN0T2JqLmRvdWJsZUNsaWNrQ2FsbGJhY2sgPSBjb25maWdPYmouZG91YmxlQ2xpY2tDYWxsYmFjaztcclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNpbmdsZUNsaWNrKHNlbGVjdE9iaiwgZXZlbnQpIHtcclxuICAgIGlmICh0eXBlb2Ygc2VsZWN0T2JqLnNpbmdsZUNsaWNrQ2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICBzZWxlY3RPYmouc2luZ2xlQ2xpY2tDYWxsYmFjayhldmVudCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZGJsY2xpY2soc2VsZWN0T2JqLCBldmVudCkge1xyXG4gICAgaWYgKHR5cGVvZiBzZWxlY3RPYmouZG91YmxlQ2xpY2tDYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIHNlbGVjdE9iai5kb3VibGVDbGlja0NhbGxiYWNrKGV2ZW50KTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBTZWxlY3QgTW9kZSBGdW5jdGlvbnMgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBqdlNlbGVjdDtcclxuIiwiLyoqKiAganZUaXAgKioqL1xyXG5cclxuZnVuY3Rpb24ganZUaXAoY29uZmlnT2JqKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICBsZXQgdGlwID0gdGhpcyxcclxuICAgICAgICBkZWZhdWx0Q29uZmlnID0ge1xyXG4gICAgICAgICAgICB0eXBlOiAnc2ltcGxlJ1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgdGlwLnRpcENvbmZpZyA9IGNvbmZpZ09iai50aXBDb25maWcgfHwgZGVmYXVsdENvbmZpZztcclxuICAgIHRpcC5jaGFydERpdiA9IGNvbmZpZ09iai5jaGFydERpdjtcclxuXHJcbiAgICAvL0NyZWF0ZSBpbml0aWFsIGRpdlxyXG4gICAgdGlwLmNoYXJ0RGl2LnNlbGVjdCgnLmp2LXRvb2x0aXAnKS5yZW1vdmUoKTtcclxuXHJcbiAgICB0aXAuY2hhcnREaXYuYXBwZW5kKCdkaXYnKVxyXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICd0b29sdGlwIGp2LXRvb2x0aXAnKVxyXG4gICAgICAgIC5zdHlsZSgncG9pbnRlci1ldmVudHMnLCAnbm9uZScpO1xyXG59XHJcblxyXG5qdlRpcC5wcm90b3R5cGUuc2hvd1RpcCA9IHNob3dUaXA7XHJcbmp2VGlwLnByb3RvdHlwZS5oaWRlVGlwID0gaGlkZVRpcDtcclxuanZUaXAucHJvdG90eXBlLmdlbmVyYXRlU2ltcGxlVGlwID0gZ2VuZXJhdGVTaW1wbGVUaXA7XHJcblxyXG5mdW5jdGlvbiBzaG93VGlwKHRyYW5zaXRpb25EdXJhdGlvbiA9IDUwKSB7XHJcbiAgICBsZXQgdGlwID0gdGhpcyxcclxuICAgICAgICBsZWZ0ID0gJ2F1dG8nLFxyXG4gICAgICAgIHRvcCA9ICdhdXRvJyxcclxuICAgICAgICBtb3VzZSA9IGQzLm1vdXNlKHRpcC5jaGFydERpdi5zZWxlY3QoJ3N2ZycpLm5vZGUoKSksXHJcbiAgICAgICAgLy9Mb2dpYyB0byBkZXRlcm1pbmUgd2hlcmUgdG9vbHRpcCB3aWxsIGJlIHBsYWNlZCBvbiBwYWdlXHJcbiAgICAgICAgbGVmdE9mTW91c2UgPSBtb3VzZVswXSA+ICh0aXAuY2hhcnREaXYuX2dyb3Vwc1swXVswXS5jbGllbnRXaWR0aCAvIDIpLFxyXG4gICAgICAgIHRvcE9mTW91c2UgPSBtb3VzZVsxXSA8ICh0aXAuY2hhcnREaXYuX2dyb3Vwc1swXVswXS5jbGllbnRIZWlnaHQgLyAyKSxcclxuICAgICAgICB0b29sdGlwSGVpZ2h0ID0gdGlwLnRvb2xUaXAuX2dyb3Vwc1swXVswXS5jbGllbnRIZWlnaHQgPT09IDAgPyA3NSA6IHRpcC50b29sVGlwLl9ncm91cHNbMF1bMF0uY2xpZW50SGVpZ2h0LFxyXG4gICAgICAgIHRvb2x0aXBXaWR0aCA9IHRpcC50b29sVGlwLl9ncm91cHNbMF1bMF0uY2xpZW50V2lkdGgsXHJcbiAgICAgICAgdDtcclxuXHJcbiAgICBpZiAobGVmdE9mTW91c2UpIHtcclxuICAgICAgICBpZiAodG9vbHRpcFdpZHRoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRvb2x0aXBXaWR0aCA9IDI1MDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGVmdCA9IG1vdXNlWzBdIC0gdG9vbHRpcFdpZHRoO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBsZWZ0ID0gbW91c2VbMF07XHJcbiAgICB9XHJcbiAgICBpZiAodG9wT2ZNb3VzZSkge1xyXG4gICAgICAgIHRvcCA9IG1vdXNlWzFdO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAodG9vbHRpcEhlaWdodCA9PT0gMCkge1xyXG4gICAgICAgICAgICB0b29sdGlwSGVpZ2h0ID0gNzU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRvcCA9IG1vdXNlWzFdIC0gdG9vbHRpcEhlaWdodDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWxlZnRPZk1vdXNlICYmIHRvcE9mTW91c2UpIHtcclxuICAgICAgICBsZWZ0ID0gbW91c2VbMF0gKyAxMztcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy9DT09MIENVUlNPUiwgYSBmdW5jdGlvbiBvZiB0aGUgaGVpZ2h0IGFuZCB3aWR0aCBvZiB0aGUgY29udGFpbmVyXHJcbiAgICAvL3ZhciBjb250YWluZXIgPSB0aXAuY2hhcnREaXYuc2VsZWN0KCcuYmFyLWNvbnRhaW5lcicpLm5vZGUoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgIC8vc3ZnTW91c2UgPSBkMy5tb3VzZSh0aXAuY2hhcnREaXYuc2VsZWN0KCcuYmFyLWNvbnRhaW5lcicpLm5vZGUoKSk7XHJcblxyXG4gICAgLy92YXIgdG9vbHRpcEhlaWdodCA9IHRpcC50b29sVGlwLl9ncm91cHNbMF1bMF0uY2xpZW50SGVpZ2h0ID09PSAwID8gNzUgOiB0aXAudG9vbFRpcC5fZ3JvdXBzWzBdWzBdLmNsaWVudEhlaWdodDtcclxuICAgIC8vdG9wID0gbW91c2VbMV0gLSAodG9vbHRpcEhlaWdodCAqIHN2Z01vdXNlWzFdIC8gY29udGFpbmVyLmhlaWdodCk7XHJcblxyXG4gICAgLy92YXIgdG9vbHRpcFdpZHRoID0gdGlwLnRvb2xUaXAuX2dyb3Vwc1swXVswXS5jbGllbnRXaWR0aDtcclxuICAgIC8vbGVmdCA9IG1vdXNlWzBdIC0gKHRvb2x0aXBXaWR0aCAqIHN2Z01vdXNlWzBdIC8gY29udGFpbmVyLndpZHRoKTtcclxuXHJcbiAgICAvL1NUSUNLWSBDVVJTT1IgSU4gVEhFIEJPVFRPTSBSSUdIVFxyXG4gICAgLy90b3AgPSBtb3VzZVsxXTtcclxuICAgIC8vbGVmdCA9IG1vdXNlWzBdO1xyXG4gICAgLy9zZXQgbWF4IGxlZnRcclxuICAgIC8vaWYobGVmdCA+IGNvbnRhaW5lci53aWR0aCAtIHRvb2x0aXBXaWR0aCArIGNvbnRhaW5lci5sZWZ0KSB7XHJcbiAgICAvL2xlZnQgPSBjb250YWluZXIud2lkdGggLSB0b29sdGlwV2lkdGggKyBjb250YWluZXIubGVmdDtcclxuICAgIC8vfVxyXG5cclxuICAgIC8vLy9zZXQgbWF4IHRvcFxyXG4gICAgLy9pZiAodG9wID4gY29udGFpbmVyLmhlaWdodCAtIHRvb2x0aXBIZWlnaHQgKyBjb250YWluZXIudG9wKSB7XHJcbiAgICAvL3RvcCA9IGNvbnRhaW5lci5oZWlnaHQgLSB0b29sdGlwSGVpZ2h0ICsgY29udGFpbmVyLnRvcDtcclxuICAgIC8vfVxyXG5cclxuICAgIHQgPSBkMy50cmFuc2l0aW9uKClcclxuICAgICAgICAuZHVyYXRpb24odHJhbnNpdGlvbkR1cmF0aW9uKVxyXG4gICAgICAgIC5lYXNlKGQzLmVhc2VMaW5lYXIpO1xyXG5cclxuICAgIHRpcC50b29sVGlwXHJcbiAgICAgICAgLnRyYW5zaXRpb24odClcclxuICAgICAgICAuc3R5bGUoJ2xlZnQnLCBsZWZ0ICsgJ3B4JylcclxuICAgICAgICAuc3R5bGUoJ3RvcCcsIHRvcCArICdweCcpXHJcbiAgICAgICAgLnN0eWxlKCdkaXNwbGF5JywgJ2Jsb2NrJylcclxuICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAxKTtcclxufVxyXG5cclxuZnVuY3Rpb24gaGlkZVRpcCgpIHtcclxuICAgIGxldCB0aXAgPSB0aGlzLFxyXG4gICAgICAgIHQgPSBkMy50cmFuc2l0aW9uKClcclxuICAgICAgICAgICAgLmR1cmF0aW9uKCcxMDAnKVxyXG4gICAgICAgICAgICAuZWFzZShkMy5lYXNlTGluZWFyKTtcclxuICAgIGlmICh0aXAudG9vbFRpcCkge1xyXG4gICAgICAgIHRpcC50b29sVGlwLnRyYW5zaXRpb24odCkuc3R5bGUoJ2Rpc3BsYXknLCAnbm9uZScpO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICBEZWNsYXJlIGp2IHRpcCBjb21wb25lbnRzICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcbnZhciBqdkhyID0gJzxociBzdHlsZT1cXCdtYXJnaW46M3B4IDAgM3B4IDA7XFwnLz4nO1xyXG5cclxuZnVuY3Rpb24gZ2V0VmFsdWVDb250ZW50KGl0ZW0sIHZhbHVlLCBjb2xvclRpbGUpIHtcclxuICAgIGxldCB2YWx1ZVN0cmluZyA9IHZhbHVlID8gYDogJHt2YWx1ZX1gIDogJycsXHJcbiAgICAgICAgY29sb3JUaWxlU3RyaW5nID0gY29sb3JUaWxlID8gY29sb3JUaWxlIDogJyc7XHJcbiAgICByZXR1cm4gYDxzcGFuIGNsYXNzPSdqdi10aXAtY29udGVudCBqdi10aXAtc2lkZS1tYXJnaW5zJz4ke2NvbG9yVGlsZVN0cmluZ30ke2l0ZW19JHt2YWx1ZVN0cmluZ308L3NwYW4+PGJyLz5gO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRUaXRsZVRlbXBsYXRlKGRhdGFPYmopIHtcclxuICAgIHJldHVybiBgPGRpdiBjbGFzcz0ndGl0bGUganYtdG9wLW1hcmdpbiBqdi1pbmxpbmUnPjxiPiR7ZGF0YU9iai50aXRsZX08L2I+PC9kaXY+JHtqdkhyfWA7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldENvbG9yVGlsZShjb2xvcikge1xyXG4gICAgaWYgKGNvbG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIGA8ZGl2IGNsYXNzPSdkMy10b29sdGlwLWNpcmNsZSBqdi1pbmxpbmUganYtdGlwLXNpZGUtbWFyZ2lucycgc3R5bGU9J2JhY2tncm91bmQ6JHtjb2xvcn0nPjwvZGl2PmA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gXCI8ZGl2IGNsYXNzPSdqdi1pbmxpbmUganYtdGlwLXNpZGUtbWFyZ2lucyc+XCI7XHJcbn1cclxuXHJcblxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBWaXogU3BlY2lmaWMgRnVuY3Rpb25zICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcbmZ1bmN0aW9uIGdlbmVyYXRlU2ltcGxlVGlwKGRhdGFPYmosIGRhdGFUYWJsZSkge1xyXG4gICAgbGV0IHRpcCA9IHRoaXMsXHJcbiAgICAgICAgdG9vbHRpcEh0bWwgPSAnJztcclxuXHJcbiAgICBpZiAoZGF0YU9iai5oYXNPd25Qcm9wZXJ0eSgndGl0bGUnKSAmJiBkYXRhT2JqLnRpdGxlID09PSAnJykge1xyXG4gICAgICAgIGRhdGFPYmoudGl0bGUgPSAnRW1wdHknO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChkYXRhT2JqLnZpeiA9PT0gJ2NsdXN0ZXJzJyB8fCBkYXRhT2JqLnZpeiA9PT0gJ2NpcmNsZXZpZXdwbG90JyB8fCBkYXRhT2JqLnZpeiA9PT0gJ3NjYXR0ZXJwbG90JyB8fCBkYXRhT2JqLnZpeiA9PT0gJ3RyZWVtYXAnIHx8IGRhdGFPYmoudml6ID09PSAnc2luZ2xlYXhpcycpIHtcclxuICAgICAgICB0b29sdGlwSHRtbCA9IGdlbmVyYXRlU2luZ2xlQ29sb3JIVE1MKGRhdGFPYmosIGRhdGFUYWJsZSk7XHJcbiAgICB9IGVsc2UgaWYgKGRhdGFPYmoudml6ID09PSAncmFkaWFsJyB8fCBkYXRhT2JqLnZpeiA9PT0gJ3BpZScpIHtcclxuICAgICAgICB0b29sdGlwSHRtbCA9IGdlbmVyYXRlUGllSFRNTChkYXRhT2JqLCBkYXRhVGFibGUpO1xyXG4gICAgfSBlbHNlIGlmIChkYXRhT2JqLnZpeiA9PT0gJ2NpcmNsZXBhY2snIHx8IGRhdGFPYmoudml6ID09PSAnc3VuYnVyc3QnKSB7XHJcbiAgICAgICAgdG9vbHRpcEh0bWwgPSBnZW5lcmF0ZVBhY2tIVE1MKGRhdGFPYmosIGRhdGFUYWJsZSk7XHJcbiAgICB9IGVsc2UgaWYgKGRhdGFPYmoudml6ID09PSAnaGVhdG1hcCcgfHwgZGF0YU9iai52aXogPT09ICdjbG91ZCcpIHtcclxuICAgICAgICB0b29sdGlwSHRtbCA9IGdlbmVyYXRlSGVhdG1hcEhUTUwoZGF0YU9iaiwgZGF0YVRhYmxlKTtcclxuICAgIH0gZWxzZSBpZiAoZGF0YU9iai52aXogPT09ICdzYW5rZXknKSB7XHJcbiAgICAgICAgdG9vbHRpcEh0bWwgPSBnZW5lcmF0ZVNhbmtleUhUTUwoZGF0YU9iaiwgZGF0YVRhYmxlKTtcclxuICAgIH0gZWxzZSBpZiAoZGF0YU9iai52aXogPT09ICdidWJibGUnKSB7XHJcbiAgICAgICAgdG9vbHRpcEh0bWwgPSBnZW5lcmF0ZUJ1YmJsZUhUTUwoZGF0YU9iaik7XHJcbiAgICB9IGVsc2UgaWYgKGRhdGFPYmoudml6ID09PSAnYm94d2hpc2tlcicpIHtcclxuICAgICAgICB0b29sdGlwSHRtbCA9IGdlbmVyYXRlQm94SFRNTChkYXRhT2JqKTtcclxuICAgIH0gZWxzZSBpZiAoZGF0YU9iai52aXogPT09ICdjbHVzdGVyZ3JhbScpIHtcclxuICAgICAgICB0b29sdGlwSHRtbCA9IGdlbmVyYXRlQ2x1c3RlcmdyYW1IVE1MKGRhdGFPYmopO1xyXG4gICAgfSAgZWxzZSBpZiAoZGF0YU9iai52aXogPT09ICdnYW50dCcpIHtcclxuICAgICAgICB0b29sdGlwSHRtbCA9IGdlbmVyYXRlR2FudHRIVE1MKGRhdGFPYmosIGRhdGFUYWJsZSk7XHJcbiAgICB9ZWxzZSB7XHJcbiAgICAgICAgdG9vbHRpcEh0bWwgPSBnZW5lcmF0ZVNpbXBsZUhUTUwoZGF0YU9iaiwgZGF0YVRhYmxlKTtcclxuICAgIH1cclxuXHJcbiAgICAvL2FkZCBjb250ZW50IHRvIHRvb2x0aXBcclxuICAgIHRpcC50b29sVGlwID0gdGlwLmNoYXJ0RGl2LnNlbGVjdCgnLnRvb2x0aXAnKVxyXG4gICAgICAgIC5odG1sKHRvb2x0aXBIdG1sKTtcclxuXHJcbiAgICAvL3BhaW50IHRoZSB0b29sdGlwXHJcbiAgICB0aXAuc2hvd1RpcCgwKTtcclxuXHJcbiAgICByZXR1cm4gdGlwLnRvb2x0aXA7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdlbmVyYXRlU2ltcGxlSFRNTChkYXRhT2JqKSB7XHJcbiAgICBsZXQgdG9vbHRpcFRleHQ7XHJcbiAgICB0b29sdGlwVGV4dCA9IGA8ZGl2PjxkaXYgY2xhc3M9J3RpdGxlIGp2LXRpcC1jb250YWluZXIganYtdGlwLXNpZGUtbWFyZ2lucyBqdi10b3AtbWFyZ2luJz48Yj4ke2RhdGFPYmoudGl0bGV9PC9iPjwvZGl2PiR7anZIcn1gO1xyXG5cclxuICAgIGZvciAobGV0IGl0ZW0gaW4gZGF0YU9iai50aXBEYXRhKSB7XHJcbiAgICAgICAgdG9vbHRpcFRleHQgKz0gZ2V0VmFsdWVDb250ZW50KGl0ZW0sIGZvcm1hdFZhbHVlKGRhdGFPYmoudGlwRGF0YVtpdGVtXSksIGdldENvbG9yVGlsZShkYXRhT2JqLmNvbG9yW2l0ZW1dKSk7XHJcbiAgICB9XHJcbiAgICB0b29sdGlwVGV4dCArPSAnPC9kaXY+JztcclxuICAgIHJldHVybiB0b29sdGlwVGV4dDtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2VuZXJhdGVTaW5nbGVDb2xvckhUTUwoZGF0YU9iaiwgZGF0YVRhYmxlKSB7XHJcbiAgICBsZXQgdG9vbHRpcFRleHQsXHJcbiAgICAgICAgdG9vbHRpcENvbG9yLFxyXG4gICAgICAgIHNob3dDb2xvckNpcmNsZSA9IHRydWUsXHJcbiAgICAgICAgY29sb3JDaXJjbGUgPSAnJztcclxuXHJcbiAgICBpZiAoISFkYXRhT2JqLmNvbG9yW2RhdGFPYmouZGF0YVtkYXRhVGFibGUuc2VyaWVzXV0pIHtcclxuICAgICAgICB0b29sdGlwQ29sb3IgPSBkYXRhT2JqLmNvbG9yW2RhdGFPYmouZGF0YVtkYXRhVGFibGUuc2VyaWVzXV07XHJcbiAgICB9IGVsc2UgaWYgKCEhZGF0YU9iai5jb2xvcltkYXRhVGFibGUubGFiZWxdICYmIGRhdGFPYmoudml6ICE9PSAnc2luZ2xlYXhpcycpIHtcclxuICAgICAgICB0b29sdGlwQ29sb3IgPSBkYXRhT2JqLmNvbG9yW2RhdGFUYWJsZS5sYWJlbF07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHNob3dDb2xvckNpcmNsZSA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzaG93Q29sb3JDaXJjbGUpIHtcclxuICAgICAgICBjb2xvckNpcmNsZSA9IGdldENvbG9yVGlsZSh0b29sdGlwQ29sb3IpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBjb2xvckNpcmNsZSA9IGdldENvbG9yVGlsZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHRvb2x0aXBUZXh0ID0gYDxkaXYgY2xhc3M9J2p2LWlubGluZSc+JHtjb2xvckNpcmNsZX08ZGl2IGNsYXNzPSd0aXRsZSBqdi10aXAtc2lkZS1tYXJnaW5zIGp2LWlubGluZSBqdi10b3AtbWFyZ2luJz48Yj4ke2RhdGFPYmoudGl0bGV9PC9iPjwvZGl2PiR7anZIcn1gO1xyXG5cclxuICAgIGZvciAobGV0IGl0ZW0gaW4gZGF0YU9iai50aXBEYXRhKSB7XHJcbiAgICAgICAgdG9vbHRpcFRleHQgKz0gZ2V0VmFsdWVDb250ZW50KGl0ZW0sIGZvcm1hdFZhbHVlKGRhdGFPYmoudGlwRGF0YVtpdGVtXSkpO1xyXG4gICAgfVxyXG4gICAgdG9vbHRpcFRleHQgKz0gJzwvZGl2Pic7XHJcbiAgICByZXR1cm4gdG9vbHRpcFRleHQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdlbmVyYXRlUGFja0hUTUwoZGF0YU9iaikge1xyXG4gICAgbGV0IHRvb2x0aXBUZXh0O1xyXG4gICAgdG9vbHRpcFRleHQgPSBgPGRpdiBjbGFzcz0nanYtaW5saW5lJz5cclxuICAgICAgICAke2dldENvbG9yVGlsZShkYXRhT2JqLmRhdGEuY29sb3IpfVxyXG4gICAgICAgICR7Z2V0VGl0bGVUZW1wbGF0ZShkYXRhT2JqKX1gO1xyXG5cclxuICAgIGZvciAobGV0IGl0ZW0gaW4gZGF0YU9iai50aXBEYXRhKSB7XHJcbiAgICAgICAgdG9vbHRpcFRleHQgKz0gZ2V0VmFsdWVDb250ZW50KGl0ZW0sIGZvcm1hdFZhbHVlKGRhdGFPYmoudGlwRGF0YVtpdGVtXSkpO1xyXG4gICAgfVxyXG4gICAgdG9vbHRpcFRleHQgKz0gJzwvZGl2Pic7XHJcbiAgICByZXR1cm4gdG9vbHRpcFRleHQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdlbmVyYXRlQnViYmxlSFRNTChkYXRhT2JqKSB7XHJcbiAgICBsZXQgdG9vbHRpcFRleHQ7XHJcbiAgICB0b29sdGlwVGV4dCA9IGA8ZGl2IGNsYXNzPSdqdi1pbmxpbmUnPlxyXG4gICAgICAgICR7Z2V0Q29sb3JUaWxlKGRhdGFPYmouZGF0YS5jb2xvcil9XHJcbiAgICAgICAgJHtnZXRUaXRsZVRlbXBsYXRlKGRhdGFPYmopfWA7XHJcblxyXG4gICAgZm9yIChsZXQgaXRlbSBpbiBkYXRhT2JqLnRpcERhdGEpIHtcclxuICAgICAgICBpZiAoaXRlbSA9PT0gJ2NvbG9yJykge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdG9vbHRpcFRleHQgKz0gZ2V0VmFsdWVDb250ZW50KGl0ZW0sIGZvcm1hdFZhbHVlKGRhdGFPYmoudGlwRGF0YVtpdGVtXSkpO1xyXG4gICAgfVxyXG4gICAgdG9vbHRpcFRleHQgKz0gJzwvZGl2Pic7XHJcbiAgICByZXR1cm4gdG9vbHRpcFRleHQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdlbmVyYXRlQm94SFRNTChkYXRhT2JqKSB7XHJcbiAgICBsZXQgdG9vbHRpcFRleHQ7XHJcbiAgICB0b29sdGlwVGV4dCA9ICc8ZGl2IGNsYXNzPVwianYtaW5saW5lXCI+JztcclxuXHJcbiAgICBmb3IgKGxldCBpdGVtIGluIGRhdGFPYmoudGlwRGF0YSkge1xyXG4gICAgICAgIGlmIChkYXRhT2JqLnRpcERhdGEuaGFzT3duUHJvcGVydHkoaXRlbSkpIHtcclxuICAgICAgICAgICAgdG9vbHRpcFRleHQgKz0gZ2V0VmFsdWVDb250ZW50KGl0ZW0sIGZvcm1hdFZhbHVlKGRhdGFPYmoudGlwRGF0YVtpdGVtXSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHRvb2x0aXBUZXh0ICs9ICc8L2Rpdj4nO1xyXG4gICAgcmV0dXJuIHRvb2x0aXBUZXh0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZW5lcmF0ZUhlYXRtYXBIVE1MKGRhdGFPYmopIHtcclxuICAgIGxldCB0b29sdGlwVGV4dDtcclxuICAgIGlmIChkYXRhT2JqLnhBeGlzQ2F0KSB7XHJcbiAgICAgICAgdG9vbHRpcFRleHQgPSBgPGRpdiBjbGFzcz0nanYtaW5saW5lJz5cclxuICAgICAgICAgICAgJHtnZXRDb2xvclRpbGUoZGF0YU9iai5jb2xvcil9YCArXHJcbiAgICAgICAgICAgIFwiPGRpdiBjbGFzcz0ndGl0bGUganYtdG9wLW1hcmdpbiBqdi1pbmxpbmUnPjxiPlwiICsgZGF0YU9iai5kYXRhLnhBeGlzTmFtZSArIFwiPC9iPjwvZGl2PjxociBzdHlsZT0nbWFyZ2luOjNweCAwIDNweCAwOycvPlwiO1xyXG5cclxuICAgICAgICB0b29sdGlwVGV4dCArPSBcIjxzcGFuIGNsYXNzPSdqdi10aXAtY29udGVudCBqdi10aXAtc2lkZS1tYXJnaW5zJz5cIiArIGRhdGFPYmoueEF4aXNDYXQgKyAnPC9zcGFuPjxici8+JztcclxuICAgICAgICB0b29sdGlwVGV4dCArPSAnPC9kaXY+JztcclxuICAgICAgICByZXR1cm4gdG9vbHRpcFRleHQ7XHJcbiAgICB9IGVsc2UgaWYgKGRhdGFPYmoueUF4aXNDYXQpIHtcclxuICAgICAgICB0b29sdGlwVGV4dCA9IGA8ZGl2IGNsYXNzPSdqdi1pbmxpbmUnPlxyXG4gICAgICAgICAgICAke2dldENvbG9yVGlsZShkYXRhT2JqLmNvbG9yKX1gICtcclxuICAgICAgICAgICAgXCI8ZGl2IGNsYXNzPSd0aXRsZSBqdi10b3AtbWFyZ2luIGp2LWlubGluZSc+PGI+XCIgKyBkYXRhT2JqLmRhdGEueUF4aXNOYW1lICsgXCI8L2I+PC9kaXY+PGhyIHN0eWxlPSdtYXJnaW46M3B4IDAgM3B4IDA7Jy8+XCI7XHJcblxyXG4gICAgICAgIHRvb2x0aXBUZXh0ICs9IFwiPHNwYW4gY2xhc3M9J2p2LXRpcC1jb250ZW50IGp2LXRpcC1zaWRlLW1hcmdpbnMnPlwiICsgZGF0YU9iai55QXhpc0NhdCArICc8L3NwYW4+PGJyLz4nO1xyXG4gICAgICAgIHRvb2x0aXBUZXh0ICs9ICc8L2Rpdj4nO1xyXG4gICAgICAgIHJldHVybiB0b29sdGlwVGV4dDtcclxuICAgIH1cclxuICAgIHRvb2x0aXBUZXh0ID0gYDxkaXYgY2xhc3M9J2p2LWlubGluZSc+XHJcbiAgICAgICAgICAgICR7Z2V0Q29sb3JUaWxlKGRhdGFPYmouY29sb3IpfVxyXG4gICAgICAgICAgICAke2dldFRpdGxlVGVtcGxhdGUoZGF0YU9iail9YDtcclxuXHJcbiAgICBmb3IgKGxldCBpdGVtIGluIGRhdGFPYmoudGlwRGF0YSkge1xyXG4gICAgICAgIHRvb2x0aXBUZXh0ICs9IGdldFZhbHVlQ29udGVudChpdGVtLCBmb3JtYXRWYWx1ZShkYXRhT2JqLnRpcERhdGFbaXRlbV0pKTtcclxuICAgIH1cclxuICAgIHRvb2x0aXBUZXh0ICs9ICc8L2Rpdj4nO1xyXG4gICAgcmV0dXJuIHRvb2x0aXBUZXh0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZW5lcmF0ZUNsdXN0ZXJncmFtSFRNTChkYXRhT2JqKSB7XHJcbiAgICBsZXQgdG9vbHRpcFRleHQ7XHJcbiAgICBkYXRhT2JqLnRpdGxlID0gZGF0YU9iai50aXRsZS5yZXBsYWNlKC9fL2csICcgJyk7XHJcbiAgICB0b29sdGlwVGV4dCA9IGA8ZGl2IGNsYXNzPSdqdi1pbmxpbmUnPlxyXG4gICAgJHtnZXRDb2xvclRpbGUoZGF0YU9iai5jb2xvcil9XHJcbiAgICAke2dldFRpdGxlVGVtcGxhdGUoZGF0YU9iail9YDtcclxuXHJcbiAgICBmb3IgKGxldCBpdGVtIGluIGRhdGFPYmoudGlwRGF0YSkge1xyXG4gICAgICAgIHRvb2x0aXBUZXh0ICs9IGdldFZhbHVlQ29udGVudChpdGVtLCBmb3JtYXRWYWx1ZShkYXRhT2JqLnRpcERhdGFbaXRlbV0pKTtcclxuICAgIH1cclxuICAgIHRvb2x0aXBUZXh0ICs9ICc8L2Rpdj4nO1xyXG5cclxuICAgIHJldHVybiB0b29sdGlwVGV4dDtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2VuZXJhdGVHYW50dEhUTUwoZGF0YU9iaiwgZGF0YVRhYmxlKSB7XHJcbiAgICB2YXIgdG9vbHRpcFRleHQ7XHJcblxyXG4gICAgZGF0YU9iai50aXRsZSA9IGRhdGFPYmoudGl0bGUucmVwbGFjZSgvXy9nLFwiIFwiKTtcclxuXHJcbiAgICB0b29sdGlwVGV4dCA9IGA8ZGl2IGNsYXNzPSdqdi1pbmxpbmUnPlxyXG4gICAgJHtnZXRUaXRsZVRlbXBsYXRlKGRhdGFPYmopfWA7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDE7IGk8PWRhdGFPYmouZGF0YS5sZW5ndGg7IGkrKykgeyAgICAgICAgXHJcbiAgICAgICAgdmFyIHN0YXJ0VmFsdWUgPSBkYXRhT2JqLnRpcERhdGFbZGF0YVRhYmxlW1wic3RhcnQgXCIgKyBpXV07XHJcbiAgICAgICAgdmFyIGVuZFZhbHVlID0gZGF0YU9iai50aXBEYXRhW2RhdGFUYWJsZVtcImVuZCBcIiArIGldXTtcclxuICAgICAgICB2YXIgZHVyYXRpb25WYWx1ZSA9IGRhdGFPYmoudGlwRGF0YVtcIkR1cmF0aW9uIFwiICsgaV07XHJcbiAgICAgICAgaWYgKGR1cmF0aW9uVmFsdWUgIT09IFwiMCBkYXlzXCIgJiYgZHVyYXRpb25WYWx1ZSAhPSBudWxsICYmIHN0YXJ0VmFsdWUgIT0gbnVsbCAmJiBlbmRWYWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGVuZFZhbHVlID0gZW5kVmFsdWUuc3Vic3RyaW5nKDAsMTApO1xyXG4gICAgICAgICAgICBzdGFydFZhbHVlID0gc3RhcnRWYWx1ZS5zdWJzdHJpbmcoMCwxMCk7XHJcbiAgICAgICAgICAgIHZhciBpdGVtID0gZGF0YVRhYmxlW1wic3RhcnQgXCIgKyBpXTtcclxuICAgICAgICAgICAgLy8gaWYgKGl0ZW0uc3Vic3RyaW5nKDAsNikgPT09IFwiU3RhcnQgXCIpIHtcclxuICAgICAgICAgICAgLy8gICAgIGl0ZW0gPSBpdGVtLnN1YnN0cmluZyg2KTtcclxuICAgICAgICAgICAgLy8gfVxyXG5cclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gc3RhcnRWYWx1ZSArIFwiIHRvIFwiICsgZW5kVmFsdWU7XHJcbiAgICAgICAgICAgIHRvb2x0aXBUZXh0ICs9IGdldFZhbHVlQ29udGVudChpdGVtLCB2YWx1ZSwgZ2V0Q29sb3JUaWxlKGRhdGFPYmouY29sb3JbZGF0YVRhYmxlW1wic3RhcnQgXCIraV1dKSk7XHJcbiAgICAgICAgICAgIHRvb2x0aXBUZXh0ICs9IGdldFZhbHVlQ29udGVudChcIiZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwO0R1cmF0aW9uXCIsIGR1cmF0aW9uVmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHRvb2x0aXBUZXh0ICs9IFwiPC9kaXY+XCI7XHJcbiAgICAgICAgXHJcbiAgICByZXR1cm4gdG9vbHRpcFRleHQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdlbmVyYXRlUGllSFRNTChkYXRhT2JqLCBkYXRhVGFibGUpIHtcclxuICAgIGxldCB0b29sdGlwVGV4dDtcclxuICAgIHRvb2x0aXBUZXh0ID0gYDxkaXYgY2xhc3M9J2p2LWlubGluZSc+XHJcbiAgICAke2dldENvbG9yVGlsZShkYXRhT2JqLmNvbG9yW2RhdGFPYmouZGF0YS5sYWJlbF0pfVxyXG4gICAgJHtnZXRUaXRsZVRlbXBsYXRlKGRhdGFPYmopfWA7XHJcblxyXG4gICAgZm9yIChsZXQgaXRlbSBpbiBkYXRhT2JqLnRpcERhdGEpIHtcclxuICAgICAgICB0b29sdGlwVGV4dCArPSBnZXRWYWx1ZUNvbnRlbnQoZGF0YVRhYmxlW2l0ZW1dLCBmb3JtYXRWYWx1ZShkYXRhT2JqLnRpcERhdGFbaXRlbV0pKTtcclxuICAgIH1cclxuICAgIHRvb2x0aXBUZXh0ICs9ICc8L2Rpdj4nO1xyXG4gICAgcmV0dXJuIHRvb2x0aXBUZXh0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZW5lcmF0ZVNhbmtleUhUTUwoZGF0YU9iaikge1xyXG4gICAgbGV0IHRvb2x0aXBUZXh0O1xyXG4gICAgdG9vbHRpcFRleHQgPSBgPGRpdiBjbGFzcz0nanYtaW5saW5lJz4ke2dldFRpdGxlVGVtcGxhdGUoZGF0YU9iail9YDtcclxuXHJcbiAgICBmb3IgKGxldCBpdGVtIGluIGRhdGFPYmoudGlwRGF0YSkge1xyXG4gICAgICAgIHRvb2x0aXBUZXh0ICs9IGdldFZhbHVlQ29udGVudChkYXRhT2JqLnZhbHVlTmFtZSwgZm9ybWF0VmFsdWUoZGF0YU9iai50aXBEYXRhW2l0ZW1dKSk7XHJcbiAgICB9XHJcbiAgICB0b29sdGlwVGV4dCArPSAnPC9kaXY+JztcclxuICAgIHJldHVybiB0b29sdGlwVGV4dDtcclxufVxyXG5cclxuZnVuY3Rpb24gZm9ybWF0VmFsdWUodmFsKSB7XHJcbiAgICBpZiAoIWlzTmFOKHZhbCkpIHtcclxuICAgICAgICBsZXQgZm9ybWF0TnVtYmVyID0gZDMuZm9ybWF0KCcsLjBmJyk7XHJcbiAgICAgICAgaWYgKHZhbCA+PSAxMDAwMDAwKSB7XHJcbiAgICAgICAgICAgIC8vbWlsbGlvbnNcclxuICAgICAgICAgICAgLy92YXIgcCA9IGQzLnByZWNpc2lvblByZWZpeCgxZTUsIDEuM2U2KTtcclxuICAgICAgICAgICAgLy9mb3JtYXROdW1iZXIgPSBkMy5mb3JtYXRQcmVmaXgoXCIuXCIgKyBwLCAxLjNlNik7XHJcbiAgICAgICAgICAgIGZvcm1hdE51bWJlciA9IGQzLmZvcm1hdCgnLC4yZicpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodmFsIDw9IDEwMCkge1xyXG4gICAgICAgICAgICAvLzIgZGVjaW1hbHNcclxuICAgICAgICAgICAgZm9ybWF0TnVtYmVyID0gZDMuZm9ybWF0KCcsLjJmJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmb3JtYXROdW1iZXIodmFsKTtcclxuICAgIH1cclxuICAgIHJldHVybiB2YWw7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ganZUaXA7XHJcbiIsIid1c2Ugc3RyaWN0JztcclxudmFyIGp2Q2hhcnRzID0gcmVxdWlyZSgnLi9qdkNoYXJ0cy5qcycpO1xyXG5cclxuanZDaGFydHMucHJvdG90eXBlLmdldERlZmF1bHRPcHRpb25zID0gZ2V0RGVmYXVsdE9wdGlvbnM7XHJcblxyXG5mdW5jdGlvbiBnZXREZWZhdWx0T3B0aW9ucyh1c2VyT3B0aW9ucyA9IHt9KSB7XHJcbiAgICB2YXIgX3ZhcnMgPSB7fTtcclxuXHJcbiAgICAvL0dlbmVyYWwgU3R5bGVzL0F0dHJpYnV0ZXNcclxuICAgIC8vQ09OU1QgdmFyaWFibGVzIC0gdHJ5IHRvIG5vdCB1c2UgaW4ganZDaGFydHMgYXMgdGhleSBkbyBub3QgaGF2ZSBtdWNoIGNvbnRleHRcclxuICAgIF92YXJzLkdSQVkgPSAnI2NjY2NjYyc7XHJcbiAgICBfdmFycy5XSElURSA9ICcjRkZGRkZGJztcclxuICAgIF92YXJzLkJMQUNLID0gJyMwMDAwMDAnO1xyXG4gICAgX3ZhcnMuU01BTExfU1RST0tFX1dJRFRIID0gJzFweCc7XHJcbiAgICBfdmFycy5saWdodCA9ICcjQkJCQkJCJztcclxuICAgIF92YXJzLnN0cm9rZVdpZHRoID0gJzJweCc7XHJcblxyXG4gICAgLy9BY3Rpb24gQXR0cmlidXRlc1xyXG4gICAgX3ZhcnMuaGlnaGxpZ2h0Qm9yZGVyQ29sb3IgPSBfdmFycy5CTEFDSztcclxuICAgIF92YXJzLmhpZ2hsaWdodEJvcmRlcldpZHRoID0gJzJweCc7XHJcblxyXG4gICAgLy9Db21wb25lbnQgU3BlY2lmaWMgU3R5bGVzL0F0dHJpYnV0ZXNcclxuICAgIF92YXJzLnRocmVzaG9sZHMgPSAnbm9uZSc7IC8vaWYgbm90IG5vbmUsIGV4cGVjdGVkIHRvIGJlIGFuIGFycmF5XHJcbiAgICBfdmFycy50aHJlc2hvbGRMZWdlbmQgPSBmYWxzZTtcclxuICAgIF92YXJzLmJhY2tncm91bmRDb2xvciA9ICdub25lJztcclxuICAgIF92YXJzLmF4aXNDb2xvciA9IF92YXJzLkdSQVk7XHJcbiAgICBfdmFycy5heGlzV2lkdGggPSBfdmFycy5zdHJva2VXaWR0aDtcclxuICAgIF92YXJzLmdyaWRMaW5lU3Ryb2tlV2lkdGggPSBfdmFycy5TTUFMTF9TVFJPS0VfV0lEVEg7XHJcbiAgICBfdmFycy5kaXNwbGF5VmFsdWVzID0gZmFsc2U7XHJcbiAgICBfdmFycy50b2dnbGVMZWdlbmQgPSBmYWxzZTtcclxuXHJcbiAgICAvL192YXJzLmxlZ2VuZEFycm93Q29sb3IgPSAnYzJjMmQ2JztcclxuICAgIC8vX3ZhcnMubGVnZW5kQXJyb3dDb2xvciA9ICcwMDAwMDAnO1xyXG4gICAgX3ZhcnMubGVnZW5kQXJyb3dDb2xvciA9ICdlN2U3ZTcnO1xyXG5cclxuICAgIF92YXJzLmxlZ2VuZE1heCA9IDk7XHJcbiAgICBfdmFycy5ncmlkU2l6ZSA9IDEyO1xyXG4gICAgX3ZhcnMueFJldmVyc2VkID0gZmFsc2U7XHJcbiAgICBfdmFycy55UmV2ZXJzZWQgPSBmYWxzZTtcclxuXHJcbiAgICAvL2ZvbnQgc3R5bGVzXHJcbiAgICBfdmFycy5mb250U2l6ZSA9ICcxMnB4JztcclxuICAgIF92YXJzLmZvbnRDb2xvciA9IF92YXJzLkJMQUNLO1xyXG4gICAgX3ZhcnMueExhYmVsRm9udFNpemUgPSAnbm9uZSc7XHJcbiAgICBfdmFycy55TGFiZWxGb250U2l6ZSA9ICdub25lJztcclxuXHJcbiAgICAvL0hlYXRtYXAgU3BlY2lmaWMgU3R5bGVzL0F0dHJpYnV0ZXNcclxuICAgIF92YXJzLmNvbG9yID0gJyNmZjAwMDAnO1xyXG4gICAgX3ZhcnMudG9nZ2xlTGVnZW5kID0gZmFsc2U7XHJcbiAgICBfdmFycy5idWNrZXRzID0gJzEwJztcclxuICAgIF92YXJzLm9wYWNpdHkgPSAnMTAnO1xyXG4gICAgX3ZhcnMuY29sb3JMYWJlbCA9ICdub25lJztcclxuICAgIF92YXJzLm1pbiA9ICcwJztcclxuICAgIF92YXJzLm1heCA9ICcxMCc7XHJcbiAgICBfdmFycy5kb21haW5BcnJheSA9ICcnO1xyXG4gICAgX3ZhcnMuc3RlcCA9ICcxJztcclxuICAgIF92YXJzLnF1YW50aWxlcyA9IHRydWU7XHJcbiAgICBfdmFycy5oZWF0TGVnZW5kU3BhY2luZyA9IDI7XHJcbiAgICBfdmFycy5oZWF0R3JpZFNpemUgPSAyMDtcclxuICAgIF92YXJzLmNvbG9ycyA9IFtcclxuICAgICAgICAnI2ZiZjJkMicsXHJcbiAgICAgICAgJyNmZGVkYjUnLFxyXG4gICAgICAgICcjZmVlN2EwJyxcclxuICAgICAgICAnI2ZmZGE4NCcsXHJcbiAgICAgICAgJyNmZmM2NjUnLFxyXG4gICAgICAgICcjZmViNDRlJyxcclxuICAgICAgICAnI2ZlYTc0MycsXHJcbiAgICAgICAgJyNmZDliM2YnLFxyXG4gICAgICAgICcjZmQ4YzNjJyxcclxuICAgICAgICAnI2ZkNzczNScsXHJcbiAgICAgICAgJyNmZDYwMmYnLFxyXG4gICAgICAgICcjZmI0YjI5JyxcclxuICAgICAgICAnI2Y0MzcyMycsXHJcbiAgICAgICAgJyNlYTI0MWUnLFxyXG4gICAgICAgICcjZTAxNjFjJyxcclxuICAgICAgICAnI2Q2MGIyMCcsXHJcbiAgICAgICAgJyNjODAzMjQnLFxyXG4gICAgICAgICcjYjEwMDI2JyxcclxuICAgICAgICAnIzg3MDAyNScsXHJcbiAgICAgICAgJyM2MjAwMjMnXHJcbiAgICBdO1xyXG4gICAgX3ZhcnMuY2x1c3RlckNvbG9ycyA9IFtcclxuICAgICAgICAnIzAwMDA5QycsXHJcbiAgICAgICAgJyMwMDMzOTknLFxyXG4gICAgICAgICcjMDAyRkE3JyxcclxuICAgICAgICAnIzJBNTJCRScsXHJcbiAgICAgICAgJyMwMDAwRkYnLFxyXG4gICAgICAgICcjOEM5MkFDJyxcclxuICAgICAgICAnIzkyQTFDRicsXHJcbiAgICAgICAgJyNDNEMzRDAnLFxyXG4gICAgICAgICcjQ0NDQ0ZGJyxcclxuICAgICAgICAnI0Y4RjhGRicsXHJcbiAgICAgICAgJyNGRkZBRkEnLFxyXG4gICAgICAgICcjRjRDMkMyJyxcclxuICAgICAgICAnI0ZGNjk2MScsXHJcbiAgICAgICAgJyNGRjVDNUMnLFxyXG4gICAgICAgICcjRkYxQzAwJyxcclxuICAgICAgICAnI0ZGMDgwMCcsXHJcbiAgICAgICAgJyNGRjAwMDAnLFxyXG4gICAgICAgICcjQ0Q1QzVDJyxcclxuICAgICAgICAnI0UzNDIzNCcsXHJcbiAgICAgICAgJyNENzNCM0UnXHJcbiAgICBdO1xyXG5cclxuICAgIC8vcGllIHNwZWNpZmljXHJcbiAgICBfdmFycy5waWVCb3JkZXIgPSBfdmFycy5XSElURTtcclxuICAgIF92YXJzLnBpZUJvcmRlcldpZHRoID0gX3ZhcnMuU01BTExfU1RST0tFX1dJRFRIO1xyXG4gICAgX3ZhcnMucGllVGV4dENvbG9yID0gX3ZhcnMuV0hJVEU7XHJcbiAgICBfdmFycy5lbXB0eUxlZ2VuZFNxdWFyZSA9IF92YXJzLldISVRFO1xyXG5cclxuICAgIC8vbGluZSBzcGVjaWZpY1xyXG4gICAgX3ZhcnMubGluZUN1cnZlVHlwZSA9ICdMaW5lYXInO1xyXG5cclxuICAgIC8vYmFyIHNwZWNpZmljXHJcbiAgICBfdmFycy5kaXNwbGF5VmFsdWVzU3RhY2tBc1BlcmNlbnQgPSBmYWxzZTtcclxuICAgIF92YXJzLmRpc3BsYXlWYWx1ZXNTdGFja1RvdGFsID0gZmFsc2U7XHJcbiAgICBfdmFycy5kaXNwbGF5WUF4aXNMYWJlbCA9IHRydWU7XHJcblxyXG4gICAgLy9zY2F0dGVyIHNwZWNpZmljXHJcbiAgICBfdmFycy50b2dnbGVaID0gdHJ1ZTtcclxuICAgIF92YXJzLmxpbmVHdWlkZSA9IHRydWU7XHJcblxyXG4gICAgLy9zaW5nbGUgYXhpcyBzcGVjaWZpY1xyXG4gICAgX3ZhcnMuc2luZ2xlQXhpc0ZpbGxIb3ZlckNvbG9yID0gJ3JlZCc7XHJcblxyXG4gICAgT2JqZWN0LmFzc2lnbihfdmFycywgdXNlck9wdGlvbnMpO1xyXG4gICAgcmV0dXJuIF92YXJzO1xyXG59XHJcbiIsIid1c2Ugc3RyaWN0JztcclxudmFyIGp2Q2hhcnRzID0gcmVxdWlyZSgnLi4vdmlzdWFscy9qdkxpbmUuanMnKTtcclxuXHJcbmp2Q2hhcnRzLnByb3RvdHlwZS5hcmVhID0ge1xyXG4gICAgcGFpbnQ6IHBhaW50LFxyXG4gICAgc2V0RGF0YTogc2V0RGF0YSxcclxuICAgIGdldEV2ZW50RGF0YTogZ2V0RXZlbnREYXRhXHJcbn07XHJcblxyXG5qdkNoYXJ0cy5wcm90b3R5cGUuZmlsbEFyZWEgPSBmaWxsQXJlYTtcclxuXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogTGluZSBmdW5jdGlvbnMgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuLyoqc2V0TGluZURhdGFcclxuICogIGdldHMgbGluZSBkYXRhIGFuZCBhZGRzIGl0IHRvIHRoZSBjaGFydCBvYmplY3RcclxuICpcclxuICogQHBhcmFtcyBkYXRhLCBkYXRhVGFibGUsIGNvbG9yc1xyXG4gKi9cclxuZnVuY3Rpb24gc2V0RGF0YSgpIHtcclxuICAgIHZhciBjaGFydCA9IHRoaXM7XHJcbiAgICAvL3NvcnQgY2hhcnQgZGF0YSBpZiB0aGVyZSBpcyBhIHNvcnQgdHlwZSBhbmQgbGFiZWwgaW4gdGhlIF92YXJzXHJcbiAgICBpZiAoY2hhcnQuX3ZhcnMuc29ydFR5cGUpIHtcclxuICAgICAgICBpZiAoY2hhcnQuX3ZhcnMuc29ydExhYmVsICYmIGNoYXJ0Ll92YXJzLnNvcnRUeXBlICE9PSAnZGVmYXVsdCcpIHtcclxuICAgICAgICAgICAgY2hhcnQub3JnYW5pemVDaGFydERhdGEoY2hhcnQuX3ZhcnMuc29ydExhYmVsLCBjaGFydC5fdmFycy5zb3J0VHlwZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vcmVtb3ZlIGlmIHdlIGFkZCBub24gbGluZWFyIHRvIGFyZWEgY2hhcnRcclxuICAgIGNoYXJ0Ll92YXJzLmxpbmVDdXJ2ZVR5cGUgPSAnTGluZWFyJztcclxuXHJcbiAgICBjaGFydC5kYXRhLmxlZ2VuZERhdGEgPSBzZXRCYXJMaW5lTGVnZW5kRGF0YShjaGFydC5kYXRhKTtcclxuICAgIGNoYXJ0LmRhdGEueEF4aXNEYXRhID0gY2hhcnQuc2V0QXhpc0RhdGEoJ3gnLCBjaGFydC5kYXRhKTtcclxuICAgIGNoYXJ0LmRhdGEueUF4aXNEYXRhID0gY2hhcnQuc2V0QXhpc0RhdGEoJ3knLCBjaGFydC5kYXRhKTtcclxuXHJcbiAgICBpZiAoY2hhcnQuX3ZhcnMuc2VyaWVzRmxpcHBlZCkge1xyXG4gICAgICAgIGNoYXJ0LnNldEZsaXBwZWRTZXJpZXMoY2hhcnQuZGF0YS5kYXRhVGFibGVLZXlzKTtcclxuICAgICAgICBjaGFydC5mbGlwcGVkRGF0YS5jb2xvciA9IGp2Q2hhcnRzLnNldENoYXJ0Q29sb3JzKGNoYXJ0Ll92YXJzLmNvbG9yLCBjaGFydC5mbGlwcGVkRGF0YS5sZWdlbmREYXRhLCBjaGFydC5jb2xvcnMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vZGVmaW5lIGNvbG9yIG9iamVjdCBmb3IgY2hhcnREYXRhXHJcbiAgICBjaGFydC5kYXRhLmNvbG9yID0ganZDaGFydHMuc2V0Q2hhcnRDb2xvcnMoY2hhcnQuX3ZhcnMuY29sb3IsIGNoYXJ0LmRhdGEubGVnZW5kRGF0YSwgY2hhcnQuY29sb3JzKTtcclxufVxyXG5cclxuLyoqc2V0QmFyTGluZUxlZ2VuZERhdGFcclxuICogIGdldHMgbGVnZW5kIGluZm8gZnJvbSBjaGFydCBEYXRhXHJcbiAqXHJcbiAqIEBwYXJhbXMgZGF0YSwgdHlwZVxyXG4gKiBAcmV0dXJucyBbXSBvZiBsZWdlbmQgdGV4XHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRCYXJMaW5lTGVnZW5kRGF0YShkYXRhKSB7XHJcbiAgICB2YXIgbGVnZW5kQXJyYXkgPSBbXTtcclxuICAgIGZvciAobGV0IGl0ZW0gaW4gZGF0YS5kYXRhVGFibGUpIHtcclxuICAgICAgICBpZiAoZGF0YS5kYXRhVGFibGUuaGFzT3duUHJvcGVydHkoaXRlbSkpIHtcclxuICAgICAgICAgICAgaWYgKGl0ZW0gIT09ICdsYWJlbCcgJiYgaXRlbS5pbmRleE9mKCd0b29sdGlwJykgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBsZWdlbmRBcnJheS5wdXNoKGRhdGEuZGF0YVRhYmxlW2l0ZW1dKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBsZWdlbmRBcnJheTtcclxufVxyXG4vKipwYWludExpbmVDaGFydFxyXG4gKlxyXG4gKiBUaGUgaW5pdGlhbCBzdGFydGluZyBwb2ludCBmb3IgbGluZSBjaGFydCwgYmVnaW5zIHRoZSBkcmF3aW5nIHByb2Nlc3MuIE11c3QgYWxyZWFkeSBoYXZlIHRoZSBkYXRhIHN0b3JlZCBpbiB0aGUgY2hhcnRcclxuICogb2JqZWN0XHJcbiAqL1xyXG5mdW5jdGlvbiBwYWludCgpIHtcclxuICAgIHZhciBjaGFydCA9IHRoaXMsXHJcbiAgICAgICAgLy9Vc2VzIHRoZSBvcmlnaW5hbCBkYXRhIGFuZCB0aGVuIG1hbmlwdWxhdGVzIGl0IGJhc2VkIG9uIGFueSBleGlzdGluZyBvcHRpb25zXHJcbiAgICAgICAgZGF0YU9iaiA9IGNoYXJ0LmdldEJhckRhdGFGcm9tT3B0aW9ucygpO1xyXG5cclxuICAgIC8vYXNzaWduIGN1cnJlbnQgZGF0YSB3aGljaCBpcyB1c2VkIGJ5IGFsbCBiYXIgY2hhcnQgb3BlcmF0aW9uc1xyXG4gICAgY2hhcnQuY3VycmVudERhdGEgPSBkYXRhT2JqO1xyXG5cclxuICAgIC8vT3ZlcndyaXRlIGFueSBwcmUtZXhpc3Rpbmcgem9vbVxyXG4gICAgY2hhcnQuY29uZmlnLnpvb21FdmVudCA9IG51bGw7XHJcblxyXG4gICAgLy9nZW5lcmF0ZSBzdmcgZHluYW1pY2FsbHkgYmFzZWQgb24gbGVnZW5kIGRhdGFcclxuICAgIGNoYXJ0LmdlbmVyYXRlU1ZHKGRhdGFPYmoubGVnZW5kRGF0YSk7XHJcbiAgICBjaGFydC5nZW5lcmF0ZVhBeGlzKGRhdGFPYmoueEF4aXNEYXRhKTtcclxuICAgIGNoYXJ0LmdlbmVyYXRlWUF4aXMoZGF0YU9iai55QXhpc0RhdGEpO1xyXG4gICAgY2hhcnQuZ2VuZXJhdGVMZWdlbmQoZGF0YU9iai5sZWdlbmREYXRhLCAnZ2VuZXJhdGVMaW5lJyk7XHJcblxyXG4gICAgaWYgKHR5cGVvZiBkYXRhT2JqLnhBeGlzU2NhbGUudGlja3MgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICBjaGFydC5mb3JtYXRYQXhpc0xhYmVscyhkYXRhT2JqLnhBeGlzU2NhbGUudGlja3MoKS5sZW5ndGgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBjaGFydC5mb3JtYXRYQXhpc0xhYmVscyhkYXRhT2JqLnhBeGlzU2NhbGUuZG9tYWluKCkubGVuZ3RoKTtcclxuICAgIH1cclxuXHJcbiAgICBjaGFydC5nZW5lcmF0ZUxpbmUoZGF0YU9iaik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEV2ZW50RGF0YShldmVudCkge1xyXG4gICAgdmFyIGNoYXJ0ID0gdGhpcztcclxuICAgIGlmIChldmVudC50YXJnZXQuY2xhc3NMaXN0LnZhbHVlLnNwbGl0KCdiYXItY29sLScpWzFdKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgW2NoYXJ0LmN1cnJlbnREYXRhLmRhdGFUYWJsZS5sYWJlbF06IFtldmVudC50YXJnZXQuY2xhc3NMaXN0LnZhbHVlLnNwbGl0KCdiYXItY29sLScpWzFdLnJlcGxhY2UoL18vZywgJyAnKS5yZXBsYWNlKC9fZG90Xy9nLCAnLicpXVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBub2RlOiBldmVudC50YXJnZXRcclxuICAgICAgICB9O1xyXG4gICAgfSBlbHNlIGlmIChldmVudC50YXJnZXQuY2xhc3NMaXN0LnZhbHVlLmluZGV4T2YoJ2FyZWEtY29udGFpbmVyJykgPiAtMSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGRhdGE6IHt9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZGF0YTogZmFsc2VcclxuICAgIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gZmlsbEFyZWEobGluZURhdGEpIHtcclxuICAgIHZhciBjaGFydCA9IHRoaXMsXHJcbiAgICAgICAgc3ZnID0gY2hhcnQuc3ZnLFxyXG4gICAgICAgIHhBeGlzRGF0YSA9IGNoYXJ0LmN1cnJlbnREYXRhLnhBeGlzRGF0YSxcclxuICAgICAgICB5QXhpc0RhdGEgPSBjaGFydC5jdXJyZW50RGF0YS55QXhpc0RhdGEsXHJcbiAgICAgICAgbGVnZW5kRGF0YSA9IGNoYXJ0LmN1cnJlbnREYXRhLmxlZ2VuZERhdGEsXHJcbiAgICAgICAgY29udGFpbmVyID0gY2hhcnQuY29uZmlnLmNvbnRhaW5lcixcclxuICAgICAgICBjb2xvcnMgPSBjaGFydC5fdmFycy5jb2xvcixcclxuICAgICAgICB4ID0ganZDaGFydHMuZ2V0QXhpc1NjYWxlKCd4JywgeEF4aXNEYXRhLCBjb250YWluZXIsIGNoYXJ0Ll92YXJzLCAnbm8tcGFkZGluZycpLFxyXG4gICAgICAgIHkgPSBqdkNoYXJ0cy5nZXRBeGlzU2NhbGUoJ3knLCB5QXhpc0RhdGEsIGNvbnRhaW5lciwgY2hhcnQuX3ZhcnMsICduby1wYWRkaW5nJyksXHJcbiAgICAgICAgYXJlYSxcclxuICAgICAgICBkYXRhID0ge307XHJcblxyXG4gICAgLy9JZiBhIGxlZ2VuZCBlbGVtZW50IGlzIHRvZ2dsZWQgb2ZmLCB1c2UgdGhlIG5ldyBsaXN0IG9mIGhlYWRlcnNcclxuICAgIGlmIChjaGFydC5fdmFycy5oYXNPd25Qcm9wZXJ0eSgnbGVnZW5kSGVhZGVycycpKSB7XHJcbiAgICAgICAgbGVnZW5kRGF0YSA9IGNoYXJ0Ll92YXJzLmxlZ2VuZEhlYWRlcnM7XHJcbiAgICB9XHJcbiAgICAvL0lmIGF4aXMgYXJlIG5vcm1hbFxyXG4gICAgaWYgKCFjaGFydC5fdmFycy5yb3RhdGVBeGlzKSB7XHJcbiAgICAgICAgYXJlYSA9IGQzLmFyZWEoKVxyXG4gICAgICAgICAgICAueChkID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChkLnggPT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHgoJ0VNUFRZX1NUUklORycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHgoZC54KTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLnkwKGNvbnRhaW5lci5oZWlnaHQpXHJcbiAgICAgICAgICAgIC55MShkID0+IHkoZC55KSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGFyZWEgPSBkMy5hcmVhKClcclxuICAgICAgICAgICAgLnkoZCA9PiB5KGQueSkpXHJcbiAgICAgICAgICAgIC54MSgwKVxyXG4gICAgICAgICAgICAueDAoZCA9PiB4KGQueCkpO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAobGV0IGRhdGFFbGUgb2YgbGluZURhdGEpIHtcclxuICAgICAgICBmb3IgKGxldCBsZWdlbmRFbGUgb2YgbGVnZW5kRGF0YSkge1xyXG4gICAgICAgICAgICBpZiAobGVnZW5kRWxlLnRvZ2dsZSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIC8vRG9uJ3Qgd3JpdGUgYW55dGhpbmcgdG8gZGF0YVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFkYXRhW2xlZ2VuZEVsZV0pIHtcclxuICAgICAgICAgICAgICAgIGRhdGFbbGVnZW5kRWxlXSA9IFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghY2hhcnQuX3ZhcnMucm90YXRlQXhpcykge1xyXG4gICAgICAgICAgICAgICAgZGF0YVtsZWdlbmRFbGVdLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICd4JzogZGF0YUVsZVt4QXhpc0RhdGEubGFiZWxdLFxyXG4gICAgICAgICAgICAgICAgICAgICd5JzogcGFyc2VGbG9hdChkYXRhRWxlW2xlZ2VuZEVsZV0pXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRhdGFbbGVnZW5kRWxlXS5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAneSc6IGRhdGFFbGVbeUF4aXNEYXRhLmxhYmVsXSxcclxuICAgICAgICAgICAgICAgICAgICAneCc6IHBhcnNlRmxvYXQoZGF0YUVsZVtsZWdlbmRFbGVdKVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc3ZnLnNlbGVjdEFsbCgnLmFyZWEnKS5yZW1vdmUoKTtcclxuICAgIGZvciAobGV0IGtleSBpbiBkYXRhKSB7XHJcbiAgICAgICAgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICAgICAgICBzdmcuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAgICAgICAgIC5kYXR1bShkYXRhW2tleV0pXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJ0Ll92YXJzLmNvbG9yTGluZSA9PSB0cnVlICYmIGNoYXJ0Ll92YXJzLnRocmVzaG9sZHMgIT0gJ25vbmUnICYmIGNoYXJ0Ll92YXJzLmNvbG9yQ2hhcnQgIT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdhcmVhIGFyZWEtdGhyZXNob2xkJztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdhcmVhJztcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZCcsIGFyZWEpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZmlsbCcsIGp2Q2hhcnRzLmdldENvbG9ycyhjb2xvcnMsIG51bGwsIGtleSkpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignb3BhY2l0eScsIDAuNilcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAoKSA9PiBjaGFydC5fdmFycy5yb3RhdGVBeGlzID8gYHRyYW5zbGF0ZSgwLCAke2NvbnRhaW5lci5oZWlnaHQgLyBsaW5lRGF0YS5sZW5ndGggLyAyfSlgIDogYHRyYW5zbGF0ZSgke2NvbnRhaW5lci53aWR0aCAvIGxpbmVEYXRhLmxlbmd0aCAvIDJ9LCAwKWApXHJcbiAgICAgICAgICAgICAgICAuYXR0cigncG9pbnRlci1ldmVudHMnLCAnbm9uZScpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBqdkNoYXJ0cztcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIganZDaGFydHMgPSByZXF1aXJlKCcuLi9qdkNoYXJ0cy5qcycpO1xyXG5cclxuanZDaGFydHMucHJvdG90eXBlLmJhciA9IHtcclxuICAgIHBhaW50OiBwYWludCxcclxuICAgIHNldERhdGE6IHNldERhdGEsXHJcbiAgICBnZXRFdmVudERhdGE6IGdldEV2ZW50RGF0YSxcclxuICAgIGhpZ2hsaWdodEZyb21FdmVudERhdGE6IGhpZ2hsaWdodEZyb21FdmVudERhdGFcclxufTtcclxuXHJcbmp2Q2hhcnRzLnByb3RvdHlwZS5nZW5lcmF0ZUJhclRocmVzaG9sZCA9IGdlbmVyYXRlQmFyVGhyZXNob2xkO1xyXG5qdkNoYXJ0cy5wcm90b3R5cGUuZ2VuZXJhdGVCYXJzID0gZ2VuZXJhdGVCYXJzO1xyXG5cclxuXHJcbi8qKnBhaW50XHJcbiAqXHJcbiAqIFRoZSBpbml0aWFsIHN0YXJ0aW5nIHBvaW50IGZvciBiYXIgY2hhcnQsIGJlZ2lucyB0aGUgZHJhd2luZyBwcm9jZXNzLiBNdXN0IGFscmVhZHkgaGF2ZSB0aGUgZGF0YSBzdG9yZWQgaW4gdGhlIGNoYXJ0XHJcbiAqIG9iamVjdFxyXG4gKi9cclxuZnVuY3Rpb24gcGFpbnQodHJhbnNpdGlvblRpbWUgPSA4MDApIHtcclxuICAgIGxldCBjaGFydCA9IHRoaXMsXHJcbiAgICAgICAgLy9Vc2VzIHRoZSBvcmlnaW5hbCBkYXRhIGFuZCB0aGVuIG1hbmlwdWxhdGVzIGl0IGJhc2VkIG9uIGFueSBleGlzdGluZyBvcHRpb25zXHJcbiAgICAgICAgZGF0YU9iaiA9IGNoYXJ0LmdldEJhckRhdGFGcm9tT3B0aW9ucygpO1xyXG5cclxuICAgIGlmICh0cmFuc2l0aW9uVGltZSB8fCB0cmFuc2l0aW9uVGltZSA9PT0gMCkge1xyXG4gICAgICAgIGNoYXJ0Ll92YXJzLnRyYW5zaXRpb25UaW1lID0gdHJhbnNpdGlvblRpbWU7XHJcbiAgICB9IGVsc2UgaWYgKCFjaGFydC5fdmFycy50cmFuc2l0aW9uVGltZSkge1xyXG4gICAgICAgIGNoYXJ0Ll92YXJzLnRyYW5zaXRpb25UaW1lID0gODAwO1xyXG4gICAgfVxyXG5cclxuICAgIC8vYXNzaWduIGN1cnJlbnQgZGF0YSB3aGljaCBpcyB1c2VkIGJ5IGFsbCBiYXIgY2hhcnQgb3BlcmF0aW9uc1xyXG4gICAgY2hhcnQuY3VycmVudERhdGEgPSBkYXRhT2JqO1xyXG5cclxuICAgIC8vZ2VuZXJhdGUgc3ZnIGR5bmFtaWNhbGx5IGJhc2VkIG9uIGxlZ2VuZCBkYXRhXHJcbiAgICBjaGFydC5nZW5lcmF0ZVNWRyhkYXRhT2JqLmxlZ2VuZERhdGEpO1xyXG4gICAgY2hhcnQuZ2VuZXJhdGVYQXhpcyhkYXRhT2JqLnhBeGlzRGF0YSk7XHJcbiAgICBjaGFydC5nZW5lcmF0ZVlBeGlzKGRhdGFPYmoueUF4aXNEYXRhKTtcclxuICAgIGNoYXJ0LmdlbmVyYXRlTGVnZW5kKGRhdGFPYmoubGVnZW5kRGF0YSwgJ2dlbmVyYXRlQmFycycpO1xyXG4gICAgY2hhcnQuZ2VuZXJhdGVCYXJzKGRhdGFPYmopO1xyXG5cclxuICAgIGlmICh0eXBlb2YgZGF0YU9iai54QXhpc1NjYWxlLnRpY2tzID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgY2hhcnQuZm9ybWF0WEF4aXNMYWJlbHMoZGF0YU9iai54QXhpc1NjYWxlLnRpY2tzKCkubGVuZ3RoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY2hhcnQuZm9ybWF0WEF4aXNMYWJlbHMoZGF0YU9iai54QXhpc1NjYWxlLmRvbWFpbigpLmxlbmd0aCk7XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG4vKipTZXRzIHRoZSBkYXRhIGZvciB0aGUgYmFyIGNoYXJ0IHByaW9yIHRvIHBhaW50aW5nXHJcbiAqICBAZnVuY3Rpb25cclxuICogQHBhcmFtcyB7T2JqZWN0fSBkYXRhIC0gRGF0YSBwYXNzZWQgaW50byB0aGUgY2hhcnRcclxuICogQHBhcmFtcyB7T2JqZWN0fSBkYXRhVGFibGUgLSBTaG93cyB3aGljaCBkYXRhIGNvbHVtbiBpcyBhc3NvY2lhdGVkIHdpdGggZWFjaCBmaWVsZCBpbiB2aXN1YWwgcGFuZWxcclxuICogQHBhcmFtcyB7T2JqZWN0fSBkYXRhVGFibGVLZXlzIC0gQ29udGFpbnMgdGhlIGRhdGEgdHlwZSBmb3IgZWFjaCBjb2x1bW4gb2YgZGF0YVxyXG4gKiBAcGFyYW1zIHtPYmplY3R9IGNvbG9ycyAtIENvbG9ycyBvYmplY3QgdXNlZCB0byBjb2xvciB0aGUgYmFyc1xyXG4gKi9cclxuZnVuY3Rpb24gc2V0RGF0YSgpIHtcclxuICAgIGxldCBjaGFydCA9IHRoaXM7XHJcbiAgICAvL3NvcnQgY2hhcnQgZGF0YSBpZiB0aGVyZSBpcyBhIHNvcnQgdHlwZSBhbmQgbGFiZWwgaW4gdGhlIF92YXJzXHJcbiAgICBpZiAoY2hhcnQuX3ZhcnMuaGFzT3duUHJvcGVydHkoJ3NvcnRUeXBlJykgJiYgY2hhcnQuX3ZhcnMuc29ydFR5cGUpIHtcclxuICAgICAgICBpZiAoY2hhcnQuX3ZhcnMuc29ydExhYmVsICYmIGNoYXJ0Ll92YXJzLnNvcnRUeXBlICE9PSAnZGVmYXVsdCcpIHtcclxuICAgICAgICAgICAgY2hhcnQub3JnYW5pemVDaGFydERhdGEoY2hhcnQuX3ZhcnMuc29ydExhYmVsLCBjaGFydC5fdmFycy5zb3J0VHlwZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2hhcnQuZGF0YS5sZWdlbmREYXRhID0gc2V0QmFyTGluZUxlZ2VuZERhdGEoY2hhcnQuZGF0YSk7XHJcbiAgICBjaGFydC5kYXRhLnhBeGlzRGF0YSA9IGNoYXJ0LnNldEF4aXNEYXRhKCd4JywgY2hhcnQuZGF0YSk7XHJcbiAgICBjaGFydC5kYXRhLnlBeGlzRGF0YSA9IGNoYXJ0LnNldEF4aXNEYXRhKCd5JywgY2hhcnQuZGF0YSk7XHJcbiAgICBpZiAoY2hhcnQuX3ZhcnMuc2VyaWVzRmxpcHBlZCkge1xyXG4gICAgICAgIGNoYXJ0LnNldEZsaXBwZWRTZXJpZXMoY2hhcnQuZGF0YS5kYXRhVGFibGVLZXlzKTtcclxuICAgICAgICBjaGFydC5mbGlwcGVkRGF0YS5jb2xvciA9IGp2Q2hhcnRzLnNldENoYXJ0Q29sb3JzKGNoYXJ0Ll92YXJzLmNvbG9yLCBjaGFydC5mbGlwcGVkRGF0YS5sZWdlbmREYXRhLCBjaGFydC5jb2xvcnMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vZGVmaW5lIGNvbG9yIG9iamVjdCBmb3IgY2hhcnREYXRhXHJcbiAgICBjaGFydC5kYXRhLmNvbG9yID0ganZDaGFydHMuc2V0Q2hhcnRDb2xvcnMoY2hhcnQuX3ZhcnMuY29sb3IsIGNoYXJ0LmRhdGEubGVnZW5kRGF0YSwgY2hhcnQuY29sb3JzKTtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIGdldEV2ZW50RGF0YShldmVudCkge1xyXG4gICAgdmFyIGNoYXJ0ID0gdGhpcztcclxuICAgIGlmIChldmVudC50YXJnZXQuY2xhc3NMaXN0LnZhbHVlLnNwbGl0KCdiYXItY29sLScpWzFdKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgW2NoYXJ0LmN1cnJlbnREYXRhLmRhdGFUYWJsZS5sYWJlbF06IFtldmVudC50YXJnZXQuY2xhc3NMaXN0LnZhbHVlLnNwbGl0KCdiYXItY29sLScpWzFdLnJlcGxhY2UoL18vZywgJyAnKS5yZXBsYWNlKC9fZG90Xy9nLCAnLicpXVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBub2RlOiBldmVudC50YXJnZXRcclxuICAgICAgICB9O1xyXG4gICAgfSBlbHNlIGlmIChldmVudC50YXJnZXQuY2xhc3NMaXN0LnZhbHVlLmluZGV4T2YoJ2Jhci1jb250YWluZXInKSA+IC0xKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZGF0YToge31cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBkYXRhOiBmYWxzZVxyXG4gICAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gaGlnaGxpZ2h0RnJvbUV2ZW50RGF0YShldmVudCkge1xyXG4gICAgbGV0IGNoYXJ0ID0gdGhpcyxcclxuICAgICAgICBsYWJlbCA9IGV2ZW50LmRhdGFbY2hhcnQuY3VycmVudERhdGEuZGF0YVRhYmxlLmxhYmVsXVswXSxcclxuICAgICAgICBjc3NDbGFzcyA9ICcuaGlnaGxpZ2h0LWNsYXNzLScgKyBsYWJlbC5yZXBsYWNlKC9cXHMvZywgJ18nKS5yZXBsYWNlKC9cXC4vZywgJ19kb3RfJyksXHJcbiAgICAgICAgbm9kZSA9IGNoYXJ0LnN2Zy5zZWxlY3RBbGwoY3NzQ2xhc3MpO1xyXG5cclxuICAgIGNoYXJ0LnN2Zy5zZWxlY3QoJy5iYXItY29udGFpbmVyJykuc2VsZWN0QWxsKCdyZWN0JylcclxuICAgICAgICAuYXR0cignc3Ryb2tlJywgMClcclxuICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgMCk7XHJcbiAgICAvL2hpZ2hsaWdodCBuZWNlc3NhcnkgYmFyc1xyXG4gICAgbm9kZVxyXG4gICAgICAgIC5hdHRyKCdzdHJva2UnLCBjaGFydC5fdmFycy5oaWdobGlnaHRCb3JkZXJDb2xvcilcclxuICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgY2hhcnQuX3ZhcnMuaGlnaGxpZ2h0Qm9yZGVyV2lkdGgpO1xyXG59XHJcblxyXG4vKipzZXRCYXJMaW5lTGVnZW5kRGF0YVxyXG4gKiAgZ2V0cyBsZWdlbmQgaW5mbyBmcm9tIGNoYXJ0IERhdGFcclxuICpcclxuICogQHBhcmFtcyBkYXRhLCB0eXBlXHJcbiAqIEByZXR1cm5zIFtdIG9mIGxlZ2VuZCB0ZXh0XHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRCYXJMaW5lTGVnZW5kRGF0YShkYXRhKSB7XHJcbiAgICB2YXIgbGVnZW5kQXJyYXkgPSBbXTtcclxuICAgIGZvciAobGV0IGl0ZW0gaW4gZGF0YS5kYXRhVGFibGUpIHtcclxuICAgICAgICBpZiAoZGF0YS5kYXRhVGFibGUuaGFzT3duUHJvcGVydHkoaXRlbSkpIHtcclxuICAgICAgICAgICAgaWYgKGl0ZW0gIT09ICdsYWJlbCcgJiYgaXRlbS5pbmRleE9mKCd0b29sdGlwJykgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBsZWdlbmRBcnJheS5wdXNoKGRhdGEuZGF0YVRhYmxlW2l0ZW1dKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBsZWdlbmRBcnJheTtcclxufVxyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBCYXIgZnVuY3Rpb25zICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuZnVuY3Rpb24gZ2VuZXJhdGVCYXJUaHJlc2hvbGQoKSB7XHJcbiAgICB2YXIgY2hhcnQgPSB0aGlzLFxyXG4gICAgICAgIHN2ZyA9IGNoYXJ0LnN2ZyxcclxuICAgICAgICB3aWR0aCA9IGNoYXJ0LmNvbmZpZy5jb250YWluZXIud2lkdGgsXHJcbiAgICAgICAgaGVpZ2h0ID0gY2hhcnQuY29uZmlnLmNvbnRhaW5lci5oZWlnaHQsXHJcbiAgICAgICAgdGhyZXNob2xkcyA9IGNoYXJ0Ll92YXJzLnRocmVzaG9sZHMsXHJcbiAgICAgICAgbGVuZ3RoID0gdGhyZXNob2xkcyAhPT0gJ25vbmUnID8gT2JqZWN0LmtleXModGhyZXNob2xkcykubGVuZ3RoIDogMCxcclxuICAgICAgICB4ID0gY2hhcnQuY3VycmVudERhdGEueEF4aXNTY2FsZSxcclxuICAgICAgICB5ID0gY2hhcnQuY3VycmVudERhdGEueUF4aXNTY2FsZTtcclxuXHJcbiAgICBpZiAodGhyZXNob2xkcyAhPT0gJ25vbmUnKSB7XHJcbiAgICAgICAgbGV0IHRocmVzaG9sZFJlY3RzLFxyXG4gICAgICAgICAgICB0aHJlc2hvbGQ7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aHJlc2hvbGQgPSB0aHJlc2hvbGRzW2ldO1xyXG4gICAgICAgICAgICBpZiAoIWNoYXJ0Ll92YXJzLnhBeGlzVGhyZXNob2xkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hhcnQuX3ZhcnMucm90YXRlQXhpcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFydC5fdmFycy55TWluID09PSAnbm9uZScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3ZnLmFwcGVuZCgnbGluZScpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsIHRocmVzaG9sZC50aHJlc2hvbGRDb2xvcilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsIHgodGhyZXNob2xkLnRocmVzaG9sZCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneTEnLCAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgeCh0aHJlc2hvbGQudGhyZXNob2xkKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIGhlaWdodClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2UtZGFzaGFycmF5JywgKCczLCAzJykpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhyZXNob2xkLnRocmVzaG9sZCA+IGNoYXJ0Ll92YXJzLnlNaW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3ZnLmFwcGVuZCgnbGluZScpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsIHRocmVzaG9sZC50aHJlc2hvbGRDb2xvcilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsIHgodGhyZXNob2xkLnRocmVzaG9sZCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneTEnLCAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgeCh0aHJlc2hvbGQudGhyZXNob2xkKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIGhlaWdodClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2UtZGFzaGFycmF5JywgKCczLCAzJykpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hhcnQuX3ZhcnMueU1pbiA9PT0gJ25vbmUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ZnLmFwcGVuZCgnbGluZScpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgdGhyZXNob2xkLnRocmVzaG9sZENvbG9yKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneDEnLCAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneTEnLCB5KHRocmVzaG9sZC50aHJlc2hvbGQpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneDInLCB3aWR0aClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kyJywgeSh0aHJlc2hvbGQudGhyZXNob2xkKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZS1kYXNoYXJyYXknLCAoJzMsIDMnKSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRocmVzaG9sZC50aHJlc2hvbGQgPiBjaGFydC5fdmFycy55TWluKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ZnLmFwcGVuZCgnbGluZScpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgdGhyZXNob2xkLnRocmVzaG9sZENvbG9yKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneDEnLCAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneTEnLCB5KHRocmVzaG9sZC50aHJlc2hvbGQpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneDInLCB3aWR0aClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kyJywgeSh0aHJlc2hvbGQudGhyZXNob2xkKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZS1kYXNoYXJyYXknLCAoJzMsIDMnKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChjaGFydC5fdmFycy5jb2xvckNoYXJ0ID09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIHRocmVzaG9sZFJlY3RzID0gZDMuc2VsZWN0QWxsKCdyZWN0LnJlY3QtJyArIGkpO1xyXG4gICAgICAgICAgICAgICAgdGhyZXNob2xkUmVjdHMuYXR0cignZmlsbCcsIHRocmVzaG9sZC50aHJlc2hvbGRDb2xvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKmdlbmVyYXRlQmFyc1xyXG4gKlxyXG4gKiBEb2VzIHRoZSBhY3R1YWwgcGFpbnRpbmcgb2YgYmFycyBvbiB0aGUgYmFyIGNoYXJ0XHJcbiAqIEBwYXJhbXMgYmFyRGF0YVxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIGdlbmVyYXRlQmFycyhiYXJEYXRhKSB7XHJcbiAgICB2YXIgY2hhcnQgPSB0aGlzLFxyXG4gICAgICAgIHN2ZyA9IGNoYXJ0LnN2ZyxcclxuXHJcbiAgICAgICAgLy9Vc2VkIHRvIGRyYXcgbGluZSB0aGF0IGFwcGVhcnMgd2hlbiB0b29sIHRpcHMgYXJlIHZpc2libGVcclxuICAgICAgICB0aXBMaW5lWCA9IDAsXHJcbiAgICAgICAgdGlwTGluZVdpZHRoID0gMCxcclxuICAgICAgICB0aXBMaW5lSGVpZ2h0ID0gMCxcclxuICAgICAgICB0aXBMaW5lWSA9IDAsXHJcbiAgICAgICAgLy9BZGQgbG9naWMgdG8gZmlsdGVyIGJhcmRhdGFcclxuICAgICAgICBkYXRhSGVhZGVycyA9IGJhckRhdGEubGVnZW5kRGF0YSxcclxuICAgICAgICBiYXJzLFxyXG4gICAgICAgIGJhckRhdGFOZXcsXHJcbiAgICAgICAgZXZlbnRHcm91cHM7XHJcblxyXG4gICAgLy9SZW1vdmVzIGFueSBleGlzdGluZyBiYXIgY29udGFpbmVycyBhbmQgY3JlYXRlcyBhIG5ldyBvbmVcclxuICAgIHN2Zy5zZWxlY3RBbGwoJ2cuYmFyLWNvbnRhaW5lcicpLnJlbW92ZSgpO1xyXG5cclxuICAgIGJhcnMgPSBzdmcuYXBwZW5kKCdnJylcclxuICAgICAgICAuYXR0cignY2xhc3MnLCAnYmFyLWNvbnRhaW5lcicpXHJcbiAgICAgICAgLnNlbGVjdEFsbCgnZycpO1xyXG5cclxuICAgIGlmIChjaGFydC5fdmFycy5zZXJpZXNGbGlwcGVkICYmIGNoYXJ0Ll92YXJzLmZsaXBwZWRMZWdlbmRIZWFkZXJzKSB7XHJcbiAgICAgICAgZGF0YUhlYWRlcnMgPSBjaGFydC5fdmFycy5mbGlwcGVkTGVnZW5kSGVhZGVycztcclxuICAgIH0gZWxzZSBpZiAoY2hhcnQuX3ZhcnMubGVnZW5kSGVhZGVycykge1xyXG4gICAgICAgIGRhdGFIZWFkZXJzID0gY2hhcnQuX3ZhcnMubGVnZW5kSGVhZGVycztcclxuICAgIH1cclxuXHJcbiAgICBjaGFydC5fdmFycy5sZWdlbmRIZWFkZXJzID0gZGF0YUhlYWRlcnM7XHJcblxyXG4gICAgYmFyRGF0YU5ldyA9IGp2Q2hhcnRzLmdldFRvZ2dsZWREYXRhKGJhckRhdGEsIGRhdGFIZWFkZXJzKTtcclxuXHJcbiAgICBnZW5lcmF0ZUJhckdyb3VwcyhiYXJzLCBiYXJEYXRhTmV3LCBjaGFydCk7XHJcblxyXG4gICAgZXZlbnRHcm91cHMgPSBqdkNoYXJ0cy5nZW5lcmF0ZUV2ZW50R3JvdXBzKGJhcnMsIGJhckRhdGFOZXcsIGNoYXJ0KTtcclxuXHJcbiAgICAvL0FkZCBsaXN0ZW5lcnNcclxuXHJcbiAgICBldmVudEdyb3Vwc1xyXG4gICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKGQsIGksIGopIHsgLy9UcmFuc2l0aW9ucyBpbiBEMyBkb24ndCBzdXBwb3J0IHRoZSAnb24nIGZ1bmN0aW9uIFRoZXkgb25seSBleGlzdCBvbiBzZWxlY3Rpb25zLiBTbyBuZWVkIHRvIG1vdmUgdGhhdCBldmVudCBsaXN0ZW5lciBhYm92ZSB0cmFuc2l0aW9uIGFuZCBhZnRlciBhcHBlbmRcclxuICAgICAgICAgICAgaWYgKGNoYXJ0LnNob3dUb29sVGlwKSB7XHJcbiAgICAgICAgICAgICAgICAvL0dldCB0aXAgZGF0YVxyXG4gICAgICAgICAgICAgICAgbGV0IHRpcERhdGEgPSBjaGFydC5zZXRUaXBEYXRhKGQsIGkpLFxyXG4gICAgICAgICAgICAgICAgICAgIG1vdXNlSXRlbSA9IGQzLnNlbGVjdCh0aGlzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL0RyYXcgdGlwIGxpbmVcclxuICAgICAgICAgICAgICAgIGNoYXJ0LnRpcC5nZW5lcmF0ZVNpbXBsZVRpcCh0aXBEYXRhLCBjaGFydC5kYXRhLmRhdGFUYWJsZSk7XHJcbiAgICAgICAgICAgICAgICBjaGFydC50aXAuZCA9IGQ7XHJcbiAgICAgICAgICAgICAgICBjaGFydC50aXAuaSA9IGk7XHJcbiAgICAgICAgICAgICAgICBzdmcuc2VsZWN0QWxsKCcudGlwLWxpbmUnKS5yZW1vdmUoKTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aXBMaW5lWCA9IG1vdXNlSXRlbS5ub2RlKCkuZ2V0QkJveCgpLng7XHJcbiAgICAgICAgICAgICAgICB0aXBMaW5lV2lkdGggPSBtb3VzZUl0ZW0ubm9kZSgpLmdldEJCb3goKS53aWR0aDtcclxuICAgICAgICAgICAgICAgIHRpcExpbmVIZWlnaHQgPSBtb3VzZUl0ZW0ubm9kZSgpLmdldEJCb3goKS5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICB0aXBMaW5lWSA9IG1vdXNlSXRlbS5ub2RlKCkuZ2V0QkJveCgpLnk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9EcmF3IGxpbmUgaW4gY2VudGVyIG9mIGV2ZW50LXJlY3RcclxuICAgICAgICAgICAgICAgIHN2Z1xyXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2xpbmUnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICd0aXAtbGluZScpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gxJywgKCkgPT4gY2hhcnQuX3ZhcnMucm90YXRlQXhpcyA/IDAgOiB0aXBMaW5lWCArIHRpcExpbmVXaWR0aCAvIDIpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgKCkgPT4gY2hhcnQuX3ZhcnMucm90YXRlQXhpcyA/IHRpcExpbmVXaWR0aCA6IHRpcExpbmVYICsgdGlwTGluZVdpZHRoIC8gMilcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneTEnLCAoKSA9PiBjaGFydC5fdmFycy5yb3RhdGVBeGlzID8gdGlwTGluZVkgKyB0aXBMaW5lSGVpZ2h0IC8gMiA6IDApXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kyJywgKCkgPT4gY2hhcnQuX3ZhcnMucm90YXRlQXhpcyA/IHRpcExpbmVZICsgdGlwTGluZUhlaWdodCAvIDIgOiB0aXBMaW5lSGVpZ2h0KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgJ25vbmUnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdzaGFwZS1yZW5kZXJpbmcnLCAnY3Jpc3BFZGdlcycpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsICdibGFjaycpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsICcxcHgnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLm9uKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICBpZiAoY2hhcnQuc2hvd1Rvb2xUaXApIHtcclxuICAgICAgICAgICAgICAgIGlmIChjaGFydC50aXAuZCA9PT0gZCAmJiBjaGFydC50aXAuaSA9PT0gaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0LnRpcC5zaG93VGlwKCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vR2V0IHRpcCBkYXRhXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpcERhdGEgPSBjaGFydC5zZXRUaXBEYXRhKGQsIGkpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vRHJhdyB0aXAgbGluZVxyXG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0LnRpcC5nZW5lcmF0ZVNpbXBsZVRpcCh0aXBEYXRhLCBjaGFydC5kYXRhLmRhdGFUYWJsZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChjaGFydC5zaG93VG9vbFRpcCkge1xyXG4gICAgICAgICAgICAgICAgY2hhcnQudGlwLmhpZGVUaXAoKTtcclxuICAgICAgICAgICAgICAgIHN2Zy5zZWxlY3RBbGwoJ2xpbmUudGlwLWxpbmUnKS5yZW1vdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIGNoYXJ0LmRpc3BsYXlWYWx1ZXMoKTtcclxuICAgIGNoYXJ0LmdlbmVyYXRlQ2xpcFBhdGgoKTtcclxuICAgIGNoYXJ0LmdlbmVyYXRlQmFyVGhyZXNob2xkKCk7XHJcbn1cclxuXHJcbi8qKmdlbmVyYXRlQmFyR3JvdXBzXHJcbiAqXHJcbiAqIFBhaW50cyB0aGUgZ3JvdXBzIG9mIHRoZSBiYXJzXHJcbiAqIEBwYXJhbXMgY2hhcnRDb250YWluZXIsIGJhckRhdGEsIGNoYXJ0XHJcbiAqL1xyXG5mdW5jdGlvbiBnZW5lcmF0ZUJhckdyb3VwcyhjaGFydENvbnRhaW5lciwgYmFyRGF0YSwgY2hhcnQpIHtcclxuICAgIHZhciBjb250YWluZXIgPSBjaGFydC5jb25maWcuY29udGFpbmVyLFxyXG4gICAgICAgIHhBeGlzRGF0YSA9IGNoYXJ0LmN1cnJlbnREYXRhLnhBeGlzRGF0YSxcclxuICAgICAgICB5QXhpc0RhdGEgPSBjaGFydC5jdXJyZW50RGF0YS55QXhpc0RhdGEsXHJcbiAgICAgICAgY29sb3JzID0gY2hhcnQuX3ZhcnMuY29sb3IsXHJcbiAgICAgICAgeCA9IGp2Q2hhcnRzLmdldEF4aXNTY2FsZSgneCcsIHhBeGlzRGF0YSwgY29udGFpbmVyLCBjaGFydC5fdmFycyksXHJcbiAgICAgICAgeSA9IGp2Q2hhcnRzLmdldEF4aXNTY2FsZSgneScsIHlBeGlzRGF0YSwgY29udGFpbmVyLCBjaGFydC5fdmFycyksXHJcbiAgICAgICAgcG9zQ2FsYyA9IGp2Q2hhcnRzLmdldFBvc0NhbGN1bGF0aW9ucyhiYXJEYXRhLCBjaGFydC5fdmFycywgeEF4aXNEYXRhLCB5QXhpc0RhdGEsIGNvbnRhaW5lciwgY2hhcnQpLFxyXG4gICAgICAgIGRhdGFUb1Bsb3QgPSBqdkNoYXJ0cy5nZXRQbG90RGF0YShiYXJEYXRhLCBjaGFydCksXHJcbiAgICAgICAgYmFyR3JvdXBzLFxyXG4gICAgICAgIGV4dGVybmFsQ291bnRlckZvckosXHJcbiAgICAgICAgYmFycztcclxuXHJcbiAgICBpZiAoeEF4aXNEYXRhLmRhdGFUeXBlID09PSAnU1RSSU5HJyB8fCAheEF4aXNEYXRhLmhhc093blByb3BlcnR5KCdtaW4nKSkge1xyXG4gICAgICAgIC8vQ3JlYXRlcyBiYXIgZ3JvdXBzXHJcbiAgICAgICAgYmFyR3JvdXBzID0gY2hhcnRDb250YWluZXJcclxuICAgICAgICAgICAgLmRhdGEoZGF0YVRvUGxvdClcclxuICAgICAgICAgICAgLmVudGVyKClcclxuICAgICAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdiYXItZ3JvdXAnKVxyXG4gICAgICAgICAgICAvL1RyYW5zbGF0ZSB0aGUgYmFyIGdyb3VwcyBieSAob3V0ZXIgcGFkZGluZyAqIHN0ZXApIGFuZCB0aGUgd2lkdGggb2YgdGhlIGJhcnMgKGNvbnRhaW5lci53aWR0aCAvIGJhckRhdGEubGVuZ3RoICogaSlcclxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIChkLCBpKSA9PiBgdHJhbnNsYXRlKCR7eC5wYWRkaW5nT3V0ZXIoKSAqIHguc3RlcCgpICsgeC5zdGVwKCkgKiBpfSAsMClgKTtcclxuICAgIH0gZWxzZSBpZiAoeEF4aXNEYXRhLmRhdGFUeXBlID09PSAnTlVNQkVSJykge1xyXG4gICAgICAgIC8vQ3JlYXRlcyBiYXIgZ3JvdXBzXHJcbiAgICAgICAgYmFyR3JvdXBzID0gY2hhcnRDb250YWluZXJcclxuICAgICAgICAgICAgLmRhdGEoZGF0YVRvUGxvdClcclxuICAgICAgICAgICAgLmVudGVyKClcclxuICAgICAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdiYXItZ3JvdXAnKVxyXG4gICAgICAgICAgICAvL1RyYW5zbGF0ZSB0aGUgYmFyIGdyb3VwcyBieSAob3V0ZXIgcGFkZGluZyAqIHN0ZXApIGFuZCB0aGUgd2lkdGggb2YgdGhlIGJhcnMgKGNvbnRhaW5lci53aWR0aCAvIGJhckRhdGEubGVuZ3RoICogaSlcclxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIChkLCBpKSA9PiBgdHJhbnNsYXRlKDAsICR7eS5wYWRkaW5nT3V0ZXIoKSAqIHkuc3RlcCgpICsgeS5zdGVwKCkgKiBpfSApYCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy9DcmVhdGVzIGJhcnMgd2l0aGluIGJhciBncm91cHNcclxuICAgIGV4dGVybmFsQ291bnRlckZvckogPSAtMTtcclxuICAgIGJhcnMgPSBiYXJHcm91cHMuc2VsZWN0QWxsKCdyZWN0JylcclxuICAgICAgICAuZGF0YShkID0+IGQpXHJcbiAgICAgICAgLmVudGVyKClcclxuICAgICAgICAuYXBwZW5kKCdyZWN0JylcclxuICAgICAgICAuYXR0cignY2xhc3MnLCAoZCwgaSkgPT4ge1xyXG4gICAgICAgICAgICBsZXQga2V5cyA9IE9iamVjdC5rZXlzKGJhckRhdGFbMF0pLFxyXG4gICAgICAgICAgICAgICAgZmlsdGVyZWRLZXlzID0gW10sXHJcbiAgICAgICAgICAgICAgICBsYWJlbCxcclxuICAgICAgICAgICAgICAgIGxlZ2VuZFZhbCxcclxuICAgICAgICAgICAgICAgIHRocmVzaG9sZERpcjtcclxuXHJcbiAgICAgICAgICAgIGlmIChpID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBleHRlcm5hbENvdW50ZXJGb3JKKys7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBvZiBrZXlzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoa2V5ICE9PSBjaGFydC5jdXJyZW50RGF0YS5kYXRhVGFibGUubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJlZEtleXMucHVzaChrZXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsYWJlbCA9IFN0cmluZyhiYXJEYXRhW2V4dGVybmFsQ291bnRlckZvckpdW2NoYXJ0LmN1cnJlbnREYXRhLmRhdGFUYWJsZS5sYWJlbF0pLnJlcGxhY2UoL1xccy9nLCAnXycpLnJlcGxhY2UoL1xcLi9nLCAnX2RvdF8nKTtcclxuICAgICAgICAgICAgbGVnZW5kVmFsID0gU3RyaW5nKGZpbHRlcmVkS2V5c1tpXSkucmVwbGFjZSgvXFxzL2csICdfJykucmVwbGFjZSgvXFwuL2csICdfZG90XycpO1xyXG4gICAgICAgICAgICB0aHJlc2hvbGREaXI7XHJcblxyXG4gICAgICAgICAgICBpZiAoY2hhcnQuX3ZhcnMueEF4aXNUaHJlc2hvbGQpIHtcclxuICAgICAgICAgICAgICAgIHRocmVzaG9sZERpciA9IGNoYXJ0LnNldFRocmVzaG9sZChiYXJEYXRhW2V4dGVybmFsQ291bnRlckZvckpdW2NoYXJ0LmN1cnJlbnREYXRhLmRhdGFUYWJsZS5sYWJlbF0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyZXNob2xkRGlyID0gY2hhcnQuc2V0VGhyZXNob2xkKGQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYGVkaXRhYmxlIGVkaXRhYmxlLWJhciBiYXItY29sLSR7bGFiZWx9LWluZGV4LSR7bGVnZW5kVmFsfSBoaWdobGlnaHQtY2xhc3MtJHtsYWJlbH0gcmVjdCAke3RocmVzaG9sZERpcn1gO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmF0dHIoJ3gnLCAoZCwgaSkgPT4gcG9zQ2FsYy5zdGFydHgoZCwgaSkpXHJcbiAgICAgICAgLmF0dHIoJ3knLCAoZCwgaSkgPT4gcG9zQ2FsYy5zdGFydHkoZCwgaSkpXHJcbiAgICAgICAgLmF0dHIoJ3dpZHRoJywgKGQsIGkpID0+IHBvc0NhbGMuc3RhcnR3aWR0aChkLCBpKSlcclxuICAgICAgICAuYXR0cignaGVpZ2h0JywgKGQsIGkpID0+IHBvc0NhbGMuc3RhcnRoZWlnaHQoZCwgaSkpXHJcbiAgICAgICAgLmF0dHIoJ2ZpbGwnLCAoZCwgaSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoY2hhcnQuX3ZhcnMuc2VyaWVzRmxpcHBlZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGp2Q2hhcnRzLmdldENvbG9ycyhjb2xvcnMsIGksIGNoYXJ0Ll92YXJzLmZsaXBwZWRMZWdlbmRIZWFkZXJzW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4ganZDaGFydHMuZ2V0Q29sb3JzKGNvbG9ycywgaSwgY2hhcnQuX3ZhcnMubGVnZW5kSGVhZGVyc1tpXSk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuYXR0cigncngnLCAwKVxyXG4gICAgICAgIC5hdHRyKCdyeScsIDApXHJcbiAgICAgICAgLmF0dHIoJ29wYWNpdHknLCAwLjkpXHJcbiAgICAgICAgLmF0dHIoJ2NsaXAtcGF0aCcsIGQgPT4gZCA+IDMwMDAwMDAwID8gJ3VybCgjY2xpcC1hYm92ZSknIDogJ3VybCgjY2xpcC1iZWxvdyknKTtcclxuICAgIGlmIChjaGFydC5fdmFycy50cmFuc2l0aW9uVGltZSA+IDApIHtcclxuICAgICAgICBiYXJzXHJcbiAgICAgICAgICAgIC50cmFuc2l0aW9uKClcclxuICAgICAgICAgICAgLmR1cmF0aW9uKDgwMClcclxuICAgICAgICAgICAgLmVhc2UoZDMuZWFzZVBvbHlPdXQpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4JywgKGQsIGksIGopID0+IHBvc0NhbGMueChkLCBpLCBqKSlcclxuICAgICAgICAgICAgLmF0dHIoJ3knLCAoZCwgaSwgaikgPT4gcG9zQ2FsYy55KGQsIGksIGopKVxyXG4gICAgICAgICAgICAuYXR0cignd2lkdGgnLCAoZCwgaSkgPT4gcG9zQ2FsYy53aWR0aChkLCBpKSlcclxuICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIChkLCBpKSA9PiBwb3NDYWxjLmhlaWdodChkLCBpKSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGJhcnNcclxuICAgICAgICAgICAgLmF0dHIoJ3gnLCAoZCwgaSwgaikgPT4gcG9zQ2FsYy54KGQsIGksIGopKVxyXG4gICAgICAgICAgICAuYXR0cigneScsIChkLCBpLCBqKSA9PiBwb3NDYWxjLnkoZCwgaSwgaikpXHJcbiAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIChkLCBpKSA9PiBwb3NDYWxjLndpZHRoKGQsIGkpKVxyXG4gICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgKGQsIGkpID0+IHBvc0NhbGMuaGVpZ2h0KGQsIGkpKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYmFyR3JvdXBzOy8vcmV0dXJucyB0aGUgYmFyIGNvbnRhaW5lcnNcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBqdkNoYXJ0cztcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIganZDaGFydHMgPSByZXF1aXJlKCcuLi9qdkNoYXJ0cy5qcycpO1xyXG5cclxuanZDaGFydHMucHJvdG90eXBlLmJveHdoaXNrZXIgPSB7XHJcbiAgICBwYWludDogcGFpbnQsXHJcbiAgICBzZXREYXRhOiBzZXREYXRhLFxyXG4gICAgZ2V0RXZlbnREYXRhOiBnZXRFdmVudERhdGFcclxufTtcclxuXHJcbmp2Q2hhcnRzLnByb3RvdHlwZS5nZW5lcmF0ZUJveGVzID0gZ2VuZXJhdGVCb3hlcztcclxuXHJcbi8qKnNldEJveERhdGFcclxuICogIGdldHMgY2xvdWQgZGF0YSBhbmQgYWRkcyBpdCB0byB0aGUgY2hhcnQgb2JqZWN0XHJcbiAqXHJcbiAqIEBwYXJhbXMgZGF0YSwgZGF0YVRhYmxlLCBjb2xvcnNcclxuICovXHJcbmZ1bmN0aW9uIHNldERhdGEoKSB7XHJcbiAgICB2YXIgY2hhcnQgPSB0aGlzO1xyXG4gICAgY2hhcnQuZGF0YS54QXhpc0RhdGEgPSBjaGFydC5zZXRBeGlzRGF0YSgneCcsIGNoYXJ0LmRhdGEsIGNoYXJ0Ll92YXJzKTtcclxuICAgIGNoYXJ0LmRhdGEueUF4aXNEYXRhID0gY2hhcnQuc2V0QXhpc0RhdGEoJ3knLCBjaGFydC5kYXRhLCBjaGFydC5fdmFycyk7XHJcbn1cclxuXHJcbi8qKiBwYWludEJveENoYXJ0XHJcbiAqXHJcbiAqICBAZGVzYyBUaGUgaW5pdGlhbCBzdGFydGluZyBwb2ludCBmb3IgYmFyIGNoYXJ0LCBiZWdpbnMgdGhlIGRyYXdpbmcgcHJvY2Vzcy4gTXVzdCBhbHJlYWR5IGhhdmUgdGhlIGRhdGEgc3RvcmVkIGluIHRoZSBjaGFydCBvYmplY3RcclxuICovXHJcbmZ1bmN0aW9uIHBhaW50KHRyYW5zaXRpb25UaW1lKSB7XHJcbiAgICB2YXIgY2hhcnQgPSB0aGlzLFxyXG4gICAgICAgIGRhdGFPYmosXHJcbiAgICAgICAgYXhpc0RhdGE7XHJcblxyXG4gICAgaWYgKHRyYW5zaXRpb25UaW1lIHx8IHRyYW5zaXRpb25UaW1lID09PSAwKSB7XHJcbiAgICAgICAgY2hhcnQuX3ZhcnMudHJhbnNpdGlvblRpbWUgPSB0cmFuc2l0aW9uVGltZTtcclxuICAgIH0gZWxzZSBpZiAoIWNoYXJ0Ll92YXJzLnRyYW5zaXRpb25UaW1lKSB7XHJcbiAgICAgICAgY2hhcnQuX3ZhcnMudHJhbnNpdGlvblRpbWUgPSA4MDA7XHJcbiAgICB9XHJcblxyXG4gICAgZGF0YU9iaiA9IGdldEJveERhdGFGcm9tT3B0aW9ucyhjaGFydCk7XHJcbiAgICBheGlzRGF0YSA9IGNoYXJ0LmdldEJhckRhdGFGcm9tT3B0aW9ucygpO1xyXG4gICAgLy9hc3NpZ24gY3VycmVudCBkYXRhIHdoaWNoIGlzIHVzZWQgYnkgYWxsIGJhciBjaGFydCBvcGVyYXRpb25zXHJcbiAgICBpZiAoY2hhcnQuX3ZhcnMucm90YXRlQXhpcykge1xyXG4gICAgICAgIGNoYXJ0LmN1cnJlbnREYXRhID0gZGF0YU9iajtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY2hhcnQuY3VycmVudERhdGEgPSBheGlzRGF0YTtcclxuICAgIH1cclxuICAgIC8vT3ZlcndyaXRlIGFueSBwcmUtZXhpc3Rpbmcgem9vbVxyXG4gICAgY2hhcnQuY29uZmlnLnpvb21FdmVudCA9IG51bGw7XHJcbiAgICAvL2dlbmVyYXRlIHN2ZyBkeW5hbWljYWxseSBiYXNlZCBvbiBsZWdlbmQgZGF0YVxyXG4gICAgY2hhcnQuZ2VuZXJhdGVTVkcoKTtcclxuICAgIGNoYXJ0LmdlbmVyYXRlWEF4aXMoYXhpc0RhdGEueEF4aXNEYXRhKTtcclxuICAgIGNoYXJ0LmdlbmVyYXRlWUF4aXMoYXhpc0RhdGEueUF4aXNEYXRhKTtcclxuXHJcbiAgICBjaGFydC5nZW5lcmF0ZUJveGVzKGRhdGFPYmopO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRFdmVudERhdGEoKSB7XHJcbiAgICByZXR1cm4ge307XHJcbn1cclxuXHJcbi8qKiBnZXRCb3hEYXRhRnJvbU9wdGlvbnNcclxuICpcclxuICogIEBkZXNjIEFzc2lnbnMgdGhlIGNvcnJlY3QgY2hhcnQgZGF0YSB0byBjdXJyZW50IGRhdGEgdXNpbmcgdGhlIGNoYXJ0Ll92YXJzXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRCb3hEYXRhRnJvbU9wdGlvbnMoY2hhcnQpIHtcclxuICAgIC8vY3JlYXRpbmcgdGhlc2UgdHdvIGRhdGEgdmFyaWFibGVzIHRvIGF2b2lkIGhhdmluZyB0byByZWZlcmVuY2UgdGhlIGNoYXJ0IG9iamVjdCBldmVyeXRpbWVcclxuICAgIHZhciBjc3YgPSBjaGFydC5kYXRhLmNoYXJ0RGF0YSxcclxuICAgICAgICBkYXRhVGFibGUgPSBjaGFydC5kYXRhLmRhdGFUYWJsZSxcclxuICAgICAgICBtaW4gPSBJbmZpbml0eSxcclxuICAgICAgICBtYXggPSAtSW5maW5pdHksXHJcbiAgICAgICAgeUF4aXMgPSBbXSxcclxuICAgICAgICBkYXRhT2JqID0ge30sXHJcbiAgICAgICAgZGF0YSA9IHt9LFxyXG4gICAgICAgIHlBeGlzTGFiZWwgPSBkYXRhVGFibGUubGFiZWwsXHJcbiAgICAgICAgeEF4aXNMYWJlbCA9IGRhdGFUYWJsZS52YWx1ZSxcclxuICAgICAgICB4QXhpc0RhdGEsXHJcbiAgICAgICAgeUF4aXNEYXRhLFxyXG5cclxuICAgICAgICBrZXlzID0gY3N2Lm1hcChkID0+IGRbeUF4aXNMYWJlbF0pLFxyXG4gICAgICAgIGtleXMyID0gY3N2Lm1hcChkID0+IGRbeEF4aXNMYWJlbF0pLFxyXG4gICAgICAgIHVuaXF1ZSA9IGtleXMuZmlsdGVyKChpdGVtLCBpLCBhcikgPT4gYXIuaW5kZXhPZihpdGVtKSA9PT0gaSksXHJcbiAgICAgICAgdGVtcCA9IFtdO1xyXG5cclxuICAgIGZvciAobGV0IHVuaXF1ZUVsZSBvZiB1bmlxdWUpIHtcclxuICAgICAgICBsZXQgdGVtcERhdGEgPSBjc3YuZmlsdGVyKGQgPT4gZFt5QXhpc0xhYmVsXSA9PT0gdW5pcXVlRWxlKTtcclxuICAgICAgICB0ZW1wLnB1c2goW3VuaXF1ZUVsZSwgdGVtcERhdGEubWFwKGQgPT4gZFt4QXhpc0xhYmVsXSldKTtcclxuICAgIH1cclxuXHJcbiAgICBtYXggPSBNYXRoLm1heC5hcHBseShNYXRoLCBrZXlzMik7XHJcbiAgICBtaW4gPSBNYXRoLm1pbi5hcHBseShNYXRoLCBrZXlzMik7XHJcbiAgICB5QXhpcy5wdXNoKG1pbik7XHJcbiAgICB5QXhpcy5wdXNoKG1heCk7XHJcblxyXG4gICAgeEF4aXNEYXRhID0geyAnbGFiZWwnOiB5QXhpc0xhYmVsLCAnZGF0YVR5cGUnOiAnU1RSSU5HJywgJ3ZhbHVlcyc6IHVuaXF1ZSB9O1xyXG4gICAgeUF4aXNEYXRhID0geyAnbGFiZWwnOiB4QXhpc0xhYmVsLCAnZGF0YVR5cGUnOiAnTlVNQkVSJywgJ3ZhbHVlcyc6IHlBeGlzIH07XHJcblxyXG4gICAgZGF0YU9iai5jaGFydERhdGEgPSB0ZW1wO1xyXG4gICAgZGF0YU9iai5kYXRhVGFibGUgPSBkYXRhLmRhdGFUYWJsZTtcclxuICAgIGNoYXJ0Ll92YXJzLmNvbG9yID0gZGF0YS5jb2xvcjtcclxuXHJcbiAgICBkYXRhT2JqLnhBeGlzRGF0YSA9IHhBeGlzRGF0YTtcclxuICAgIGRhdGFPYmoueUF4aXNEYXRhID0geUF4aXNEYXRhO1xyXG4gICAgZGF0YSA9IHtcclxuICAgICAgICB5QXhpc0RhdGE6IGRhdGFPYmoueUF4aXNEYXRhLFxyXG4gICAgICAgIHhBeGlzRGF0YTogZGF0YU9iai54QXhpc0RhdGFcclxuICAgIH07XHJcblxyXG4gICAgaWYgKGNoYXJ0Ll92YXJzLnJvdGF0ZUF4aXMpIHtcclxuICAgICAgICBkYXRhT2JqLnhBeGlzRGF0YSA9IGRhdGEueUF4aXNEYXRhO1xyXG4gICAgICAgIGRhdGFPYmoueUF4aXNEYXRhID0gZGF0YS54QXhpc0RhdGE7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGRhdGFPYmoueEF4aXNEYXRhID0gZGF0YS54QXhpc0RhdGE7XHJcbiAgICAgICAgZGF0YU9iai55QXhpc0RhdGEgPSBkYXRhLnlBeGlzRGF0YTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZGF0YU9iajtcclxufVxyXG5cclxuLyoqIGdlbmVyYXRlQmFyc1xyXG4gKlxyXG4gKiBAZGVzYyBEb2VzIHRoZSBhY3R1YWwgcGFpbnRpbmcgb2YgYmFycyBvbiB0aGUgYmFyIGNoYXJ0XHJcbiAqIEBwYXJhbXMgYm94RGF0YVxyXG4gKi9cclxuZnVuY3Rpb24gZ2VuZXJhdGVCb3hlcyhib3hEYXRhKSB7XHJcbiAgICB2YXIgY2hhcnQgPSB0aGlzLFxyXG4gICAgICAgIHN2ZyA9IGNoYXJ0LnN2ZyxcclxuICAgICAgICBvcHRpb25zID0gY2hhcnQuX3ZhcnMsXHJcbiAgICAgICAgY29udGFpbmVyID0gY2hhcnQuY29uZmlnLmNvbnRhaW5lcixcclxuICAgICAgICBoZWlnaHQgPSBjb250YWluZXIuaGVpZ2h0LFxyXG4gICAgICAgIHdpZHRoID0gY29udGFpbmVyLndpZHRoLFxyXG4gICAgICAgIHgsXHJcbiAgICAgICAgYm94Q2hhcnQsXHJcbiAgICAgICAgbWFyZ2luID0geyB0b3A6IDAsIHJpZ2h0OiA1MCwgYm90dG9tOiA3MCwgbGVmdDogNTAgfTtcclxuXHJcbiAgICBpZiAob3B0aW9ucy5yb3RhdGVBeGlzKSB7XHJcbiAgICAgICAgeCA9IGQzLnNjYWxlQmFuZCgpXHJcbiAgICAgICAgICAgIC5kb21haW4oYm94RGF0YS5jaGFydERhdGEubWFwKGQgPT4gZFswXSkpXHJcbiAgICAgICAgICAgIC5yYW5nZVJvdW5kKFswLCBoZWlnaHRdKVxyXG4gICAgICAgICAgICAucGFkZGluZ0lubmVyKDAuNylcclxuICAgICAgICAgICAgLnBhZGRpbmdPdXRlcigwLjMpO1xyXG4gICAgICAgIGJveENoYXJ0ID0gYm94KClcclxuICAgICAgICAgICAgLndoaXNrZXJzKGlxcigxLjUpKVxyXG4gICAgICAgICAgICAuaGVpZ2h0KHdpZHRoKVxyXG4gICAgICAgICAgICAuZG9tYWluKFtib3hEYXRhLnhBeGlzRGF0YS52YWx1ZXNbMF0sIGJveERhdGEueEF4aXNEYXRhLnZhbHVlc1sxXV0pXHJcbiAgICAgICAgICAgIC5zaG93TGFiZWxzKG9wdGlvbnMuZGlzcGxheVZhbHVlcylcclxuICAgICAgICAgICAgLmZsaXBwZWQob3B0aW9ucy5yb3RhdGVBeGlzKVxyXG4gICAgICAgICAgICAuZHVyYXRpb24ob3B0aW9ucy50cmFuc2l0aW9uVGltZSlcclxuICAgICAgICAgICAgLmNoYXJ0KGNoYXJ0KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgeCA9IGQzLnNjYWxlQmFuZCgpXHJcbiAgICAgICAgICAgIC5kb21haW4oYm94RGF0YS5jaGFydERhdGEubWFwKGQgPT4gZFswXSkpXHJcbiAgICAgICAgICAgIC5yYW5nZVJvdW5kKFswLCB3aWR0aF0pXHJcbiAgICAgICAgICAgIC5wYWRkaW5nSW5uZXIoMC43KVxyXG4gICAgICAgICAgICAucGFkZGluZ091dGVyKDAuMyk7XHJcbiAgICAgICAgYm94Q2hhcnQgPSBib3goKVxyXG4gICAgICAgICAgICAud2hpc2tlcnMoaXFyKDEuNSkpXHJcbiAgICAgICAgICAgIC5oZWlnaHQoaGVpZ2h0KVxyXG4gICAgICAgICAgICAuZG9tYWluKFtib3hEYXRhLnlBeGlzRGF0YS52YWx1ZXNbMF0sIGJveERhdGEueUF4aXNEYXRhLnZhbHVlc1sxXV0pXHJcbiAgICAgICAgICAgIC5zaG93TGFiZWxzKG9wdGlvbnMuZGlzcGxheVZhbHVlcylcclxuICAgICAgICAgICAgLmZsaXBwZWQob3B0aW9ucy5yb3RhdGVBeGlzKVxyXG4gICAgICAgICAgICAuZHVyYXRpb24ob3B0aW9ucy50cmFuc2l0aW9uVGltZSlcclxuICAgICAgICAgICAgLmNoYXJ0KGNoYXJ0KTtcclxuICAgIH1cclxuICAgIC8vZHJhdyB0aGUgYm94cGxvdHNcclxuICAgIHN2Zy5hdHRyKCdjbGFzcycsICdib3h3aGlza2VyLWNvbnRhaW5lcicpXHJcbiAgICAgICAgLnNlbGVjdEFsbCgnLmJveCcpXHJcbiAgICAgICAgLmRhdGEoYm94RGF0YS5jaGFydERhdGEpXHJcbiAgICAgICAgLmVudGVyKClcclxuICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAuYXR0cignY2xhc3MnLCAnYm94LWNvbnRhaW5lcicpXHJcbiAgICAgICAgLmF0dHIoJ3N0eWxlJywgJ3BvaW50ZXItZXZlbnRzOiBhbGw7JylcclxuICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZCA9PiBvcHRpb25zLnJvdGF0ZUF4aXMgPyBgdHJhbnNsYXRlKCR7bWFyZ2luLnRvcH0sICR7eChkWzBdKX0pYCA6IGB0cmFuc2xhdGUoJHt4KGRbMF0pfSwgJHttYXJnaW4udG9wfSlgKVxyXG4gICAgICAgIC5jYWxsKGJveENoYXJ0LndpZHRoKHguYmFuZHdpZHRoKCkpKTtcclxuXHJcbiAgICBkMy5zZWxlY3RBbGwoJ3JlY3QuYm94JykuYXR0cignY2xhc3MnLCAoZCwgaSkgPT5gZWRpdGFibGUgZWRpdGFibGUtYm94IGJveC0ke2l9IGhpZ2hsaWdodC1jbGFzcy0ke2l9Ym94YCk7XHJcbiAgICBoaWRlTGFiZWxzT25PdmVybGFwKHgsIHdpZHRoLCBzdmcpO1xyXG59XHJcblxyXG4vKipcclxuICogQG5hbWUgaGlkZUxhYmVsc09uT3ZlcmxhcFxyXG4gKiBAZGVzYyBkZXRlcm1pbmVzIGlmIHRleHQgb24gZ3JhcGggc2hvdWxkIGJlIGRpc3BsYXllZCBvciBub3RcclxuICovXHJcbmZ1bmN0aW9uIGhpZGVMYWJlbHNPbk92ZXJsYXAoeCwgd2lkdGgsIHN2Zykge1xyXG4gICAgdmFyIG51bVNwYWNlc0JldHdlZW4gPSB4LmRvbWFpbigpLmxlbmd0aCAtIDEsXHJcbiAgICAgICAgdG90YWxCb3hXaWR0aCA9IHguYmFuZHdpZHRoKCkgKiB4LmRvbWFpbigpLmxlbmd0aCxcclxuICAgICAgICB3aWR0aE9mU3BhY2VzID0gKHdpZHRoIC0gdG90YWxCb3hXaWR0aCkgLyBudW1TcGFjZXNCZXR3ZWVuLFxyXG4gICAgICAgIHhBeGlzTGFiZWxMZW5ndGhMaW1pdCA9IHguYmFuZHdpZHRoKCkgKyB3aWR0aE9mU3BhY2VzLFxyXG4gICAgICAgIHRpY2tzID0gc3ZnLnNlbGVjdEFsbCgnLnhBeGlzIHRleHQnKTtcclxuXHJcbiAgICB0aWNrcy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5nZXRCQm94KCkud2lkdGggPiB4QXhpc0xhYmVsTGVuZ3RoTGltaXQpIHtcclxuICAgICAgICAgICAgc3ZnLnNlbGVjdEFsbCgnLnhBeGlzIHRleHQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3N0eWxlJywgJ2Rpc3BsYXk6bm9uZScpO1xyXG4gICAgICAgICAgICBzdmcuc2VsZWN0QWxsKCd0ZXh0LmJveCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignc3R5bGUnLCAnZGlzcGxheTpub25lJyk7XHJcbiAgICAgICAgICAgIHN2Zy5zZWxlY3RBbGwoJ3RleHQud2hpc2tlcicpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignc3R5bGUnLCAnZGlzcGxheTpub25lJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAbmFtZSBpcXJcclxuICogQGRlc2MgUmV0dXJucyBhIGZ1bmN0aW9uIHRvIGNvbXB1dGUgdGhlIGludGVycXVhcnRpbGUgcmFuZ2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBpcXIoaykge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBpKSB7XHJcbiAgICAgICAgdmFyIHExID0gZC5xdWFydGlsZXNbMF0sXHJcbiAgICAgICAgICAgIHEzID0gZC5xdWFydGlsZXNbMl0sXHJcbiAgICAgICAgICAgIGlxciA9IChxMyAtIHExKSAqIGssXHJcbiAgICAgICAgICAgIGkgPSAtMSxcclxuICAgICAgICAgICAgaiA9IGQubGVuZ3RoO1xyXG4gICAgICAgIHdoaWxlIChkWysraV0gPCBxMSAtIGlxcik7XHJcbiAgICAgICAgd2hpbGUgKGRbLS1qXSA+IHEzICsgaXFyKTtcclxuICAgICAgICByZXR1cm4gW2ksIGpdO1xyXG4gICAgfTtcclxufVxyXG5cclxuLy9JbnNwaXJlZCBieSBodHRwOi8vaW5mb3JtYXRpb25hbmR2aXN1YWxpemF0aW9uLmRlL2Jsb2cvYm94LXBsb3RcclxudmFyIGJveCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciB3aWR0aCA9IDEsXHJcbiAgICAgICAgaGVpZ2h0ID0gMSxcclxuICAgICAgICBkdXJhdGlvbiA9IDAsXHJcbiAgICAgICAgZG9tYWluID0gbnVsbCxcclxuICAgICAgICB2YWx1ZSA9IE51bWJlcixcclxuICAgICAgICB3aGlza2VycyA9IGJveFdoaXNrZXJzLFxyXG4gICAgICAgIHF1YXJ0aWxlcyA9IGJveFF1YXJ0aWxlcyxcclxuICAgICAgICBzaG93TGFiZWxzID0gdHJ1ZSwgLy93aGV0aGVyIG9yIG5vdCB0byBzaG93IHRleHQgbGFiZWxzXHJcbiAgICAgICAgbnVtQmFycyA9IDQsXHJcbiAgICAgICAgY3VyQmFyID0gMSxcclxuICAgICAgICB0aWNrRm9ybWF0ID0gbnVsbCxcclxuICAgICAgICBjaGFydCA9IHt9LFxyXG4gICAgICAgIGZsaXBwZWQgPSBmYWxzZTtcclxuXHJcbiAgICAvL0ZvciBlYWNoIHNtYWxsIG11bHRpcGxl4oCmXHJcbiAgICBmdW5jdGlvbiBib3goZykge1xyXG4gICAgICAgIGcuZWFjaChmdW5jdGlvbiAoZGF0YSwgaSkge1xyXG4gICAgICAgICAgICB2YXIgZCA9IGRhdGFbMV0uc29ydChkMy5hc2NlbmRpbmcpO1xyXG4gICAgICAgICAgICB2YXIgZyA9IGQzLnNlbGVjdCh0aGlzKSxcclxuICAgICAgICAgICAgICAgIG4gPSBkLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgIG1pbiA9IGRbMF0sXHJcbiAgICAgICAgICAgICAgICBtYXggPSBkW24gLSAxXSxcclxuICAgICAgICAgICAgICAgIG91dGxpZXJMYWJlbCA9IGRhdGFbMF07XHJcblxyXG4gICAgICAgICAgICAvL0NvbXB1dGUgcXVhcnRpbGVzLiBNdXN0IHJldHVybiBleGFjdGx5IDMgZWxlbWVudHMuXHJcbiAgICAgICAgICAgIHZhciBxdWFydGlsZURhdGEgPSBkLnF1YXJ0aWxlcyA9IHF1YXJ0aWxlcyhkKTtcclxuXHJcbiAgICAgICAgICAgIC8vQ29tcHV0ZSB3aGlza2Vycy4gTXVzdCByZXR1cm4gZXhhY3RseSAyIGVsZW1lbnRzLCBvciBudWxsLlxyXG4gICAgICAgICAgICB2YXIgd2hpc2tlckluZGljZXMgPSB3aGlza2VycyAmJiB3aGlza2Vycy5jYWxsKHRoaXMsIGQsIGkpLFxyXG4gICAgICAgICAgICAgICAgd2hpc2tlckRhdGEgPSB3aGlza2VySW5kaWNlcyAmJiB3aGlza2VySW5kaWNlcy5tYXAoZnVuY3Rpb24gKGkpIHsgcmV0dXJuIGRbaV07IH0pO1xyXG5cclxuICAgICAgICAgICAgLy9Db21wdXRlIG91dGxpZXJzLiBJZiBubyB3aGlza2VycyBhcmUgc3BlY2lmaWVkLCBhbGwgZGF0YSBhcmUgJ291dGxpZXJzJy5cclxuICAgICAgICAgICAgLy9XZSBjb21wdXRlIHRoZSBvdXRsaWVycyBhcyBpbmRpY2VzLCBzbyB0aGF0IHdlIGNhbiBqb2luIGFjcm9zcyB0cmFuc2l0aW9ucyFcclxuICAgICAgICAgICAgdmFyIG91dGxpZXJJbmRpY2VzID0gd2hpc2tlckluZGljZXNcclxuICAgICAgICAgICAgICAgID8gZDMucmFuZ2UoMCwgd2hpc2tlckluZGljZXNbMF0pLmNvbmNhdChkMy5yYW5nZSh3aGlza2VySW5kaWNlc1sxXSArIDEsIG4pKVxyXG4gICAgICAgICAgICAgICAgOiBkMy5yYW5nZShuKTtcclxuXHJcbiAgICAgICAgICAgIC8vQ29tcHV0ZSB0aGUgbmV3IHgtc2NhbGUuXHJcbiAgICAgICAgICAgIGlmIChmbGlwcGVkKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgeDEgPSBkMy5zY2FsZUxpbmVhcigpXHJcbiAgICAgICAgICAgICAgICAgICAgLmRvbWFpbihkb21haW4gJiYgZG9tYWluLmNhbGwodGhpcywgZCwgaSkgfHwgW21pbiwgbWF4XSlcclxuICAgICAgICAgICAgICAgICAgICAucmFuZ2UoWzAsIGhlaWdodF0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIHgxID0gZDMuc2NhbGVMaW5lYXIoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5kb21haW4oZG9tYWluICYmIGRvbWFpbi5jYWxsKHRoaXMsIGQsIGkpIHx8IFttaW4sIG1heF0pXHJcbiAgICAgICAgICAgICAgICAgICAgLnJhbmdlKFtoZWlnaHQsIDBdKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9SZXRyaWV2ZSB0aGUgb2xkIHgtc2NhbGUsIGlmIHRoaXMgaXMgYW4gdXBkYXRlLlxyXG4gICAgICAgICAgICB2YXIgeDAgPSB0aGlzLl9fY2hhcnRfXyB8fCBkMy5zY2FsZUxpbmVhcigpXHJcbiAgICAgICAgICAgICAgICAuZG9tYWluKFswLCBJbmZpbml0eV0pXHJcbiAgICAgICAgICAgICAgICAvLy5kb21haW4oWzAsIG1heF0pXHJcbiAgICAgICAgICAgICAgICAucmFuZ2UoeDEucmFuZ2UoKSk7XHJcblxyXG4gICAgICAgICAgICAvL1N0YXNoIHRoZSBuZXcgc2NhbGUuXHJcbiAgICAgICAgICAgIHRoaXMuX19jaGFydF9fID0geDE7XHJcblxyXG4gICAgICAgICAgICAvL05vdGU6IHRoZSBib3gsIG1lZGlhbiwgYW5kIGJveCB0aWNrIGVsZW1lbnRzIGFyZSBmaXhlZCBpbiBudW1iZXIsXHJcbiAgICAgICAgICAgIC8vc28gd2Ugb25seSBoYXZlIHRvIGhhbmRsZSBlbnRlciBhbmQgdXBkYXRlLiBJbiBjb250cmFzdCwgdGhlIG91dGxpZXJzXHJcbiAgICAgICAgICAgIC8vYW5kIG90aGVyIGVsZW1lbnRzIGFyZSB2YXJpYWJsZSwgc28gd2UgbmVlZCB0byBleGl0IHRoZW0hIFZhcmlhYmxlXHJcbiAgICAgICAgICAgIC8vZWxlbWVudHMgYWxzbyBmYWRlIGluIGFuZCBvdXQuXHJcblxyXG4gICAgICAgICAgICAvL1VwZGF0ZSBvdXRsaWVycy5cclxuICAgICAgICAgICAgdmFyIG91dGxpZXIgPSBnLnNlbGVjdEFsbCgnY2lyY2xlLm91dGxpZXInKVxyXG4gICAgICAgICAgICAgICAgLmRhdGEob3V0bGllckluZGljZXMsIE51bWJlcik7XHJcblxyXG4gICAgICAgICAgICBvdXRsaWVyID0gb3V0bGllci5lbnRlcigpLmFwcGVuZCgnZycpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGZsaXBwZWQpIHtcclxuICAgICAgICAgICAgICAgIG91dGxpZXIuaW5zZXJ0KCdjaXJjbGUnLCAndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ291dGxpZXInKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgJ3doaXRlJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigncicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdpZHRoID4gMTApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA1O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2lkdGggLyAyO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2N5Jywgd2lkdGggLyAyKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjeCcsIGZ1bmN0aW9uIChpKSB7IHJldHVybiB4MChkW2ldKTsgfSlcclxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAxZS02KVxyXG4gICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKClcclxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oZHVyYXRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2N4JywgZnVuY3Rpb24gKGkpIHsgcmV0dXJuIHgxKGRbaV0pOyB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDEpO1xyXG5cclxuICAgICAgICAgICAgICAgIG91dGxpZXIuYXBwZW5kKCd0ZXh0JykudGV4dChmdW5jdGlvbiAoaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkW2ldO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsICh3aWR0aCAvIDIpICsgNylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIGZ1bmN0aW9uIChpKSB7IHJldHVybiB4MShkW2ldKSArIDQ7IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ291dGxpZXItbGFiZWwnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdmb250LXNpemUnLCAnMTBweCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3N0eWxlJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNob3dMYWJlbHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnZGlzcGxheTpub25lOyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIG91dGxpZXIuZXhpdCgpLnRyYW5zaXRpb24oKVxyXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbihkdXJhdGlvbilcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY3gnLCBmdW5jdGlvbiAoaSkgeyByZXR1cm4geDEoZFtpXSk7IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMWUtNilcclxuICAgICAgICAgICAgICAgICAgICAucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvdXRsaWVyLmluc2VydCgnY2lyY2xlJywgJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdvdXRsaWVyJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignZmlsbCcsICd3aGl0ZScpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3InLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3aWR0aCA+IDEwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gNTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpZHRoIC8gMjtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjeCcsIHdpZHRoIC8gMilcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY3knLCBmdW5jdGlvbiAoaSkgeyByZXR1cm4geDAoZFtpXSk7IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMWUtNilcclxuICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbigpXHJcbiAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKGR1cmF0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjeScsIGZ1bmN0aW9uIChpKSB7IHJldHVybiB4MShkW2ldKTsgfSlcclxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAxKTtcclxuXHJcbiAgICAgICAgICAgICAgICBvdXRsaWVyLmFwcGVuZCgndGV4dCcpLnRleHQoZnVuY3Rpb24gKGkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZFtpXTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCAod2lkdGggLyAyKSArIDcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBmdW5jdGlvbiAoaSkgeyByZXR1cm4geDEoZFtpXSkgKyA0OyB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdvdXRsaWVyLWxhYmVsJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignZm9udC1zaXplJywgJzEwcHgnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdzdHlsZScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzaG93TGFiZWxzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2Rpc3BsYXk6bm9uZTsnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgb3V0bGllci50cmFuc2l0aW9uKClcclxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oZHVyYXRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2N5JywgZnVuY3Rpb24gKGkpIHsgcmV0dXJuIHgxKGRbaV0pOyB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDEpO1xyXG5cclxuICAgICAgICAgICAgICAgIG91dGxpZXIuZXhpdCgpLnRyYW5zaXRpb24oKVxyXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbihkdXJhdGlvbilcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY3knLCBmdW5jdGlvbiAoaSkgeyByZXR1cm4geDEoZFtpXSk7IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMWUtNilcclxuICAgICAgICAgICAgICAgICAgICAucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIG91dGxpZXJcclxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKGkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhcnQuc2hvd1Rvb2xUaXApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3V0bGllciA9IFtkW2ldXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHsgT3V0bGllcjogb3V0bGllciwgTGFiZWw6IG91dGxpZXJMYWJlbCB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0aXBEYXRhID0gY2hhcnQuc2V0VGlwRGF0YShkYXRhLCBpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJ0LnRpcC5nZW5lcmF0ZVNpbXBsZVRpcCh0aXBEYXRhLCBkYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhcnQudGlwLmQgPSBkLmRhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJ0LnRpcC5pID0gaTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFydC5zaG93VG9vbFRpcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvdXRsaWVyID0gW2RbaV1dO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0geyBPdXRsaWVyOiBvdXRsaWVyLCBMYWJlbDogb3V0bGllckxhYmVsIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpcERhdGEgPSBjaGFydC5zZXRUaXBEYXRhKGRhdGEsIGkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhcnQudGlwLmdlbmVyYXRlU2ltcGxlVGlwKHRpcERhdGEsIGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFydC50aXAuZCA9IGQuZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhcnQudGlwLmkgPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFydC5zaG93VG9vbFRpcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFydC50aXAuaGlkZVRpcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgLy9zZXQgc2VwYXJhdGUgdG9vbHRpcHMgZm9yIHF1YXJ0aWxlcyBhbmQgd2hpc2tlcnNcclxuICAgICAgICAgICAgZyA9IGcuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnaW5uZXItYm94LWNvbnRhaW5lcicpXHJcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uIChsYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFydC5zaG93VG9vbFRpcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUXVhcnRpbGVzOiBkLnF1YXJ0aWxlcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFdoaXNrZXJzOiB3aGlza2VyRGF0YSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIExhYmVsOiBsYWJlbFswXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0aXBEYXRhID0gY2hhcnQuc2V0VGlwRGF0YShkYXRhLCBpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJ0LnRpcC5nZW5lcmF0ZVNpbXBsZVRpcCh0aXBEYXRhLCBkYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhcnQudGlwLmQgPSBkLmRhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJ0LnRpcC5pID0gaTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiAobGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhcnQuc2hvd1Rvb2xUaXApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFF1YXJ0aWxlczogZC5xdWFydGlsZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBXaGlza2Vyczogd2hpc2tlckRhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBMYWJlbDogbGFiZWxbMF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGlwRGF0YSA9IGNoYXJ0LnNldFRpcERhdGEoZGF0YSwgaSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFydC50aXAuZ2VuZXJhdGVTaW1wbGVUaXAodGlwRGF0YSwgZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJ0LnRpcC5kID0gZC5kYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFydC50aXAuaSA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5vbignbW91c2VsZWF2ZScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhcnQuc2hvd1Rvb2xUaXApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhcnQudGlwLmhpZGVUaXAoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcblxyXG4gICAgICAgICAgICAvL1VwZGF0ZSBjZW50ZXIgbGluZTogdGhlIHZlcnRpY2FsIGxpbmUgc3Bhbm5pbmcgdGhlIHdoaXNrZXJzLlxyXG4gICAgICAgICAgICB2YXIgY2VudGVyID0gZy5zZWxlY3RBbGwoJ2xpbmUuY2VudGVyJylcclxuICAgICAgICAgICAgICAgIC5kYXRhKHdoaXNrZXJEYXRhID8gW3doaXNrZXJEYXRhXSA6IFtdKTtcclxuICAgICAgICAgICAgLy92ZXJ0aWNhbCBsaW5lXHJcbiAgICAgICAgICAgIGlmIChmbGlwcGVkKSB7XHJcbiAgICAgICAgICAgICAgICBjZW50ZXIuZW50ZXIoKS5pbnNlcnQoJ2xpbmUnLCAncmVjdCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2NlbnRlcicpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgd2lkdGggLyAyKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsIGZ1bmN0aW9uIChkKSB7IHJldHVybiB4MChkWzBdKTsgfSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneTInLCB3aWR0aCAvIDIpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIHgwKGRbMV0pOyB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDFlLTYpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxyXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbihkdXJhdGlvbilcclxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAxKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsIGZ1bmN0aW9uIChkKSB7IHJldHVybiB4MShkWzBdKTsgfSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDInLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4geDEoZFsxXSk7IH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGNlbnRlci50cmFuc2l0aW9uKClcclxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oZHVyYXRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDEnLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4geDEoZFswXSk7IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIHgxKGRbMV0pOyB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICBjZW50ZXIuZXhpdCgpLnRyYW5zaXRpb24oKVxyXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbihkdXJhdGlvbilcclxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAxZS02KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsIGZ1bmN0aW9uIChkKSB7IHJldHVybiB4MShkWzBdKTsgfSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDInLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4geDEoZFsxXSk7IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY2VudGVyLmVudGVyKCkuaW5zZXJ0KCdsaW5lJywgJ3JlY3QnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdjZW50ZXInKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsIHdpZHRoIC8gMilcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneTEnLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4geDAoZFswXSk7IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgd2lkdGggLyAyKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIGZ1bmN0aW9uIChkKSB7IHJldHVybiB4MChkWzFdKTsgfSlcclxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAxZS02KVxyXG4gICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKClcclxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oZHVyYXRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneTEnLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4geDEoZFswXSk7IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kyJywgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIHgxKGRbMV0pOyB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICBjZW50ZXIudHJhbnNpdGlvbigpXHJcbiAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKGR1cmF0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDEpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIHgxKGRbMF0pOyB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIGZ1bmN0aW9uIChkKSB7IHJldHVybiB4MShkWzFdKTsgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgY2VudGVyLmV4aXQoKS50cmFuc2l0aW9uKClcclxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oZHVyYXRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMWUtNilcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneTEnLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4geDEoZFswXSk7IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kyJywgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIHgxKGRbMV0pOyB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5yZW1vdmUoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGhvdmVyQXJlYSA9IGcuc2VsZWN0QWxsKCdsaW5lLmhvdmVyLWFyZWEnKVxyXG4gICAgICAgICAgICAgICAgLmRhdGEod2hpc2tlckRhdGEgPyBbd2hpc2tlckRhdGFdIDogW10pO1xyXG4gICAgICAgICAgICAvL3ZlcnRpY2FsIGxpbmVcclxuICAgICAgICAgICAgaWYgKGZsaXBwZWQpIHtcclxuICAgICAgICAgICAgICAgIGhvdmVyQXJlYS5lbnRlcigpLmluc2VydCgnbGluZScsICdyZWN0JylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnaG92ZXItYXJlYScpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgd2lkdGggLyAyKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsIGZ1bmN0aW9uIChkKSB7IHJldHVybiB4MChkWzBdKTsgfSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneTInLCB3aWR0aCAvIDIpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIHgwKGRbMV0pOyB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDApXHJcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLCB3aWR0aClcclxuICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbigpXHJcbiAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKGR1cmF0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDApXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gxJywgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIHgxKGRbMF0pOyB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MicsIGZ1bmN0aW9uIChkKSB7IHJldHVybiB4MShkWzFdKTsgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaG92ZXJBcmVhLnRyYW5zaXRpb24oKVxyXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbihkdXJhdGlvbilcclxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAwKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsIGZ1bmN0aW9uIChkKSB7IHJldHVybiB4MShkWzBdKTsgfSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDInLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4geDEoZFsxXSk7IH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGhvdmVyQXJlYS5leGl0KCkudHJhbnNpdGlvbigpXHJcbiAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKGR1cmF0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDApXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gxJywgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIHgxKGRbMF0pOyB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MicsIGZ1bmN0aW9uIChkKSB7IHJldHVybiB4MShkWzFdKTsgfSlcclxuICAgICAgICAgICAgICAgICAgICAucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBob3ZlckFyZWEuZW50ZXIoKS5pbnNlcnQoJ2xpbmUnLCAncmVjdCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2hvdmVyLWFyZWEnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsIHdpZHRoIC8gMilcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneTEnLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4geDAoZFswXSk7IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgd2lkdGggLyAyKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIGZ1bmN0aW9uIChkKSB7IHJldHVybiB4MChkWzFdKTsgfSlcclxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAwKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlLXdpZHRoJywgd2lkdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxyXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbihkdXJhdGlvbilcclxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAwKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIGZ1bmN0aW9uIChkKSB7IHJldHVybiB4MShkWzBdKTsgfSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneTInLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4geDEoZFsxXSk7IH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGhvdmVyQXJlYS50cmFuc2l0aW9uKClcclxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oZHVyYXRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneTEnLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4geDEoZFswXSk7IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kyJywgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIHgxKGRbMV0pOyB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICBob3ZlckFyZWEuZXhpdCgpLnRyYW5zaXRpb24oKVxyXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbihkdXJhdGlvbilcclxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAwKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIGZ1bmN0aW9uIChkKSB7IHJldHVybiB4MShkWzBdKTsgfSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneTInLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4geDEoZFsxXSk7IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vVXBkYXRlIGlubmVycXVhcnRpbGUgYm94LlxyXG4gICAgICAgICAgICB2YXIgYm94ID0gZy5zZWxlY3RBbGwoJ3JlY3QuYm94JylcclxuICAgICAgICAgICAgICAgIC5kYXRhKFtxdWFydGlsZURhdGFdKTtcclxuICAgICAgICAgICAgaWYgKGZsaXBwZWQpIHtcclxuICAgICAgICAgICAgICAgIGJveC5lbnRlcigpLmFwcGVuZCgncmVjdCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCAnc3RlZWxibHVlJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnYm94JylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIDApXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4geDAoZFsyXSkgLSBNYXRoLmFicyh4MChkWzBdKSAtIHgwKGRbMl0pKTsgfSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0Jywgd2lkdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIE1hdGguYWJzKHgwKGRbMF0pIC0geDAoZFsyXSkpOyB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKClcclxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oZHVyYXRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4geDEoZFsyXSkgLSBNYXRoLmFicyh4MShkWzBdKSAtIHgxKGRbMl0pKTsgfSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4gTWF0aC5hYnMoeDEoZFswXSkgLSB4MShkWzJdKSk7IH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGJveC50cmFuc2l0aW9uKClcclxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oZHVyYXRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4geDEoZFsyXSkgLSBNYXRoLmFicyh4MShkWzBdKSAtIHgxKGRbMl0pKTsgfSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4gTWF0aC5hYnMoeDEoZFswXSkgLSB4MShkWzJdKSk7IH0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYm94LmVudGVyKCkuYXBwZW5kKCdyZWN0JylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignZmlsbCcsICdzdGVlbGJsdWUnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdib3gnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgMClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIGZ1bmN0aW9uIChkKSB7IHJldHVybiB4MChkWzJdKTsgfSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCB3aWR0aClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIHgwKGRbMF0pIC0geDAoZFsyXSk7IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxyXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbihkdXJhdGlvbilcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIGZ1bmN0aW9uIChkKSB7IHJldHVybiB4MShkWzJdKTsgfSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIHgxKGRbMF0pIC0geDEoZFsyXSk7IH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGJveC50cmFuc2l0aW9uKClcclxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oZHVyYXRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4geDEoZFsyXSk7IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGZ1bmN0aW9uIChkKSB7IHJldHVybiB4MShkWzBdKSAtIHgxKGRbMl0pOyB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL1VwZGF0ZSBtZWRpYW4gbGluZS5cclxuICAgICAgICAgICAgdmFyIG1lZGlhbkxpbmUgPSBnLnNlbGVjdEFsbCgnbGluZS5tZWRpYW4nKVxyXG4gICAgICAgICAgICAgICAgLmRhdGEoW3F1YXJ0aWxlRGF0YVsxXV0pO1xyXG4gICAgICAgICAgICBpZiAoZmxpcHBlZCkge1xyXG4gICAgICAgICAgICAgICAgbWVkaWFuTGluZS5lbnRlcigpLmFwcGVuZCgnbGluZScpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ21lZGlhbicpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgMClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDEnLCB4MClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneTInLCB3aWR0aClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDInLCB4MClcclxuICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbigpXHJcbiAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKGR1cmF0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsIHgxKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MicsIHgxKTtcclxuXHJcbiAgICAgICAgICAgICAgICBtZWRpYW5MaW5lLnRyYW5zaXRpb24oKVxyXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbihkdXJhdGlvbilcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDEnLCB4MSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDInLCB4MSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBtZWRpYW5MaW5lLmVudGVyKCkuYXBwZW5kKCdsaW5lJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbWVkaWFuJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDEnLCAwKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIHgwKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MicsIHdpZHRoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIHgwKVxyXG4gICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKClcclxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oZHVyYXRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgeDEpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kyJywgeDEpO1xyXG5cclxuICAgICAgICAgICAgICAgIG1lZGlhbkxpbmUudHJhbnNpdGlvbigpXHJcbiAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKGR1cmF0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIHgxKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIHgxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL1VwZGF0ZSB3aGlza2Vycy5cclxuICAgICAgICAgICAgdmFyIHdoaXNrZXIgPSBnLnNlbGVjdEFsbCgnbGluZS53aGlza2VyJylcclxuICAgICAgICAgICAgICAgIC5kYXRhKHdoaXNrZXJEYXRhIHx8IFtdKTtcclxuICAgICAgICAgICAgaWYgKGZsaXBwZWQpIHtcclxuICAgICAgICAgICAgICAgIHdoaXNrZXIuZW50ZXIoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5pbnNlcnQoJ2xpbmUnLCAnY2lyY2xlLCB0ZXh0JylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnd2hpc2tlcicpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgMClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDEnLCB4MClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneTInLCAwICsgd2lkdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgeDApXHJcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMWUtNilcclxuICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbigpXHJcbiAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKGR1cmF0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsIHgxKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MicsIHgxKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDEpO1xyXG5cclxuICAgICAgICAgICAgICAgIHdoaXNrZXIudHJhbnNpdGlvbigpXHJcbiAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKGR1cmF0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsIHgxKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MicsIHgxKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDEpO1xyXG5cclxuICAgICAgICAgICAgICAgIHdoaXNrZXIuZXhpdCgpLnRyYW5zaXRpb24oKVxyXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbihkdXJhdGlvbilcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDEnLCB4MSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDInLCB4MSlcclxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAxZS02KVxyXG4gICAgICAgICAgICAgICAgICAgIC5yZW1vdmUoKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHdoaXNrZXIuZW50ZXIoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5pbnNlcnQoJ2xpbmUnLCAnY2lyY2xlLCB0ZXh0JylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnd2hpc2tlcicpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gxJywgMClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneTEnLCB4MClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDInLCAwICsgd2lkdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kyJywgeDApXHJcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMWUtNilcclxuICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbigpXHJcbiAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKGR1cmF0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIHgxKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIHgxKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDEpO1xyXG5cclxuICAgICAgICAgICAgICAgIHdoaXNrZXIudHJhbnNpdGlvbigpXHJcbiAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKGR1cmF0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIHgxKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIHgxKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDEpO1xyXG5cclxuICAgICAgICAgICAgICAgIHdoaXNrZXIuZXhpdCgpLnRyYW5zaXRpb24oKVxyXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbihkdXJhdGlvbilcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneTEnLCB4MSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneTInLCB4MSlcclxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAxZS02KVxyXG4gICAgICAgICAgICAgICAgICAgIC5yZW1vdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL0NvbXB1dGUgdGhlIHRpY2sgZm9ybWF0LlxyXG4gICAgICAgICAgICB2YXIgZm9ybWF0ID0gdGlja0Zvcm1hdCB8fCB4MS50aWNrRm9ybWF0KDgpO1xyXG5cclxuICAgICAgICAgICAgLy9VcGRhdGUgYm94IHRpY2tzLlxyXG4gICAgICAgICAgICB2YXIgYm94VGljayA9IGcuc2VsZWN0QWxsKCd0ZXh0LmJveCcpXHJcbiAgICAgICAgICAgICAgICAuZGF0YShxdWFydGlsZURhdGEpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGZsaXBwZWQpIHtcclxuICAgICAgICAgICAgICAgIGJveFRpY2suZW50ZXIoKS5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdib3gnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdkeCcsICcuM2VtJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignZHknLCBmdW5jdGlvbiAoZCwgaSkgeyByZXR1cm4gaSAmIDEgPyA2IDogLTYgfSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIGZ1bmN0aW9uIChkLCBpKSB7IHJldHVybiBpICYgMSA/ICsgd2lkdGggOiAwIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCB4MClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigndGV4dC1hbmNob3InLCBmdW5jdGlvbiAoZCwgaSkgeyByZXR1cm4gaSAmIDEgPyAnc3RhcnQnIDogJ2VuZCc7IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3N0eWxlJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNob3dMYWJlbHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnZGlzcGxheTogbm9uZTsnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAudGV4dChmb3JtYXQpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxyXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbihkdXJhdGlvbilcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIHgxKTtcclxuXHJcbiAgICAgICAgICAgICAgICBib3hUaWNrLnRyYW5zaXRpb24oKVxyXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbihkdXJhdGlvbilcclxuICAgICAgICAgICAgICAgICAgICAudGV4dChmb3JtYXQpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCB4MSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBib3hUaWNrLmVudGVyKCkuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnYm94JylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignZHknLCAnLjNlbScpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2R4JywgZnVuY3Rpb24gKGQsIGkpIHsgcmV0dXJuIGkgJiAxID8gNiA6IC02IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBmdW5jdGlvbiAoZCwgaSkgeyByZXR1cm4gaSAmIDEgPyArIHdpZHRoIDogMCB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgeDApXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgZnVuY3Rpb24gKGQsIGkpIHsgcmV0dXJuIGkgJiAxID8gJ3N0YXJ0JyA6ICdlbmQnOyB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdzdHlsZScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzaG93TGFiZWxzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2Rpc3BsYXk6IG5vbmU7JztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLnRleHQoZm9ybWF0KVxyXG4gICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKClcclxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oZHVyYXRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCB4MSk7XHJcblxyXG4gICAgICAgICAgICAgICAgYm94VGljay50cmFuc2l0aW9uKClcclxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oZHVyYXRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgLnRleHQoZm9ybWF0KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgeDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vVXBkYXRlIHdoaXNrZXIgdGlja3MuIFRoZXNlIGFyZSBoYW5kbGVkIHNlcGFyYXRlbHkgZnJvbSB0aGUgYm94XHJcbiAgICAgICAgICAgIC8vdGlja3MgYmVjYXVzZSB0aGV5IG1heSBvciBtYXkgbm90IGV4aXN0LCBhbmQgd2Ugd2FudCBkb24ndCB3YW50XHJcbiAgICAgICAgICAgIC8vdG8gam9pbiBib3ggdGlja3MgcHJlLXRyYW5zaXRpb24gd2l0aCB3aGlza2VyIHRpY2tzIHBvc3QtLlxyXG4gICAgICAgICAgICB2YXIgd2hpc2tlclRpY2sgPSBnLnNlbGVjdEFsbCgndGV4dC53aGlza2VyJylcclxuICAgICAgICAgICAgICAgIC5kYXRhKHdoaXNrZXJEYXRhIHx8IFtdKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChmbGlwcGVkKSB7XHJcbiAgICAgICAgICAgICAgICB3aGlza2VyVGljay5lbnRlcigpLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3doaXNrZXInKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdkeCcsICcuM2VtJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignZHknLCA2KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5Jywgd2lkdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCB4MClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignc3R5bGUnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2hvd0xhYmVscykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdkaXNwbGF5Om5vbmU7JztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLnRleHQoZm9ybWF0KVxyXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDFlLTYpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxyXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbihkdXJhdGlvbilcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIHgxKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDEpO1xyXG5cclxuICAgICAgICAgICAgICAgIHdoaXNrZXJUaWNrLnRyYW5zaXRpb24oKVxyXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbihkdXJhdGlvbilcclxuICAgICAgICAgICAgICAgICAgICAudGV4dChmb3JtYXQpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCB4MSlcclxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAxKTtcclxuXHJcbiAgICAgICAgICAgICAgICB3aGlza2VyVGljay5leGl0KCkudHJhbnNpdGlvbigpXHJcbiAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKGR1cmF0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgeDEpXHJcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMWUtNilcclxuICAgICAgICAgICAgICAgICAgICAucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB3aGlza2VyVGljay5lbnRlcigpLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3doaXNrZXInKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdkeScsICcuM2VtJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignZHgnLCA2KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4Jywgd2lkdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCB4MClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignc3R5bGUnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2hvd0xhYmVscykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdkaXNwbGF5Om5vbmU7JztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLnRleHQoZm9ybWF0KVxyXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDFlLTYpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxyXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbihkdXJhdGlvbilcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIHgxKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDEpO1xyXG5cclxuICAgICAgICAgICAgICAgIHdoaXNrZXJUaWNrLnRyYW5zaXRpb24oKVxyXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbihkdXJhdGlvbilcclxuICAgICAgICAgICAgICAgICAgICAudGV4dChmb3JtYXQpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCB4MSlcclxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAxKTtcclxuXHJcbiAgICAgICAgICAgICAgICB3aGlza2VyVGljay5leGl0KCkudHJhbnNpdGlvbigpXHJcbiAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKGR1cmF0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgeDEpXHJcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMWUtNilcclxuICAgICAgICAgICAgICAgICAgICAucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICAvL2QzLnRpbWVyLmZsdXNoKCk7XHJcbiAgICAgICAgZDMudGltZXJGbHVzaCgpO1xyXG4gICAgfVxyXG5cclxuICAgIGJveC53aWR0aCA9IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gd2lkdGg7XHJcbiAgICAgICAgd2lkdGggPSB4O1xyXG4gICAgICAgIHJldHVybiBib3g7XHJcbiAgICB9O1xyXG5cclxuICAgIGJveC5oZWlnaHQgPSBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGhlaWdodDtcclxuICAgICAgICBoZWlnaHQgPSB4O1xyXG4gICAgICAgIHJldHVybiBib3g7XHJcbiAgICB9O1xyXG5cclxuICAgIGJveC50aWNrRm9ybWF0ID0gZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aWNrRm9ybWF0O1xyXG4gICAgICAgIHRpY2tGb3JtYXQgPSB4O1xyXG4gICAgICAgIHJldHVybiBib3g7XHJcbiAgICB9O1xyXG5cclxuICAgIGJveC5kdXJhdGlvbiA9IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZHVyYXRpb247XHJcbiAgICAgICAgZHVyYXRpb24gPSB4O1xyXG4gICAgICAgIHJldHVybiBib3g7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGNvbnN0YW50KHgpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4geDtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgYm94LmRvbWFpbiA9IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZG9tYWluO1xyXG4gICAgICAgIC8vZG9tYWluID0geCA9PSBudWxsID8geCA6IGQzLmZ1bmN0b3IoeCk7XHJcbiAgICAgICAgZG9tYWluID0geCA9PSBudWxsID8geCA6IGNvbnN0YW50KHgpO1xyXG5cclxuICAgICAgICByZXR1cm4gYm94O1xyXG4gICAgfTtcclxuXHJcbiAgICBib3gudmFsdWUgPSBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIHZhbHVlID0geDtcclxuICAgICAgICByZXR1cm4gYm94O1xyXG4gICAgfTtcclxuXHJcbiAgICBib3gud2hpc2tlcnMgPSBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHdoaXNrZXJzO1xyXG4gICAgICAgIHdoaXNrZXJzID0geDtcclxuICAgICAgICByZXR1cm4gYm94O1xyXG4gICAgfTtcclxuXHJcbiAgICBib3guc2hvd0xhYmVscyA9IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2hvd0xhYmVscztcclxuICAgICAgICBzaG93TGFiZWxzID0geDtcclxuICAgICAgICByZXR1cm4gYm94O1xyXG4gICAgfTtcclxuXHJcbiAgICBib3guZmxpcHBlZCA9IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZmxpcHBlZDtcclxuICAgICAgICBmbGlwcGVkID0geDtcclxuICAgICAgICByZXR1cm4gYm94O1xyXG4gICAgfTtcclxuXHJcbiAgICBib3guY2hhcnQgPSBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNoYXJ0O1xyXG4gICAgICAgIGNoYXJ0ID0geDtcclxuICAgICAgICByZXR1cm4gYm94O1xyXG4gICAgfTtcclxuXHJcbiAgICBib3gucXVhcnRpbGVzID0gZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBxdWFydGlsZXM7XHJcbiAgICAgICAgcXVhcnRpbGVzID0geDtcclxuICAgICAgICByZXR1cm4gYm94O1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gYm94O1xyXG59O1xyXG5cclxuZnVuY3Rpb24gYm94V2hpc2tlcnMoZCkge1xyXG4gICAgcmV0dXJuIFswLCBkLmxlbmd0aCAtIDFdO1xyXG59XHJcblxyXG5mdW5jdGlvbiBib3hRdWFydGlsZXMoZCkge1xyXG4gICAgcmV0dXJuIFtcclxuICAgICAgICBkMy5xdWFudGlsZShkLCAwLjI1KSxcclxuICAgICAgICBkMy5xdWFudGlsZShkLCAwLjUpLFxyXG4gICAgICAgIGQzLnF1YW50aWxlKGQsIDAuNzUpXHJcbiAgICBdO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGp2Q2hhcnRzO1xyXG4iLCIndXNlIHN0cmljdCc7XHJcbnZhciBqdkNoYXJ0cyA9IHJlcXVpcmUoJy4uL2p2Q2hhcnRzLmpzJyk7XHJcblxyXG5qdkNoYXJ0cy5wcm90b3R5cGUuYnViYmxlID0ge1xyXG4gICAgcGFpbnQ6IHBhaW50LFxyXG4gICAgc2V0RGF0YTogc2V0RGF0YSxcclxuICAgIGdldEV2ZW50RGF0YTogZ2V0RXZlbnREYXRhXHJcbn07XHJcblxyXG5qdkNoYXJ0cy5wcm90b3R5cGUuZ2VuZXJhdGVCdWJibGUgPSBnZW5lcmF0ZUJ1YmJsZTtcclxuXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogQnViYmxlIGZ1bmN0aW9ucyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG5mdW5jdGlvbiBwYWludCh0cmFuc2l0aW9uVGltZSkge1xyXG4gICAgdmFyIGNoYXJ0ID0gdGhpcyxcclxuICAgICAgICBidWJibGVNYXJnaW5zID0ge1xyXG4gICAgICAgICAgICB0b3A6IDE1LFxyXG4gICAgICAgICAgICByaWdodDogMTUsXHJcbiAgICAgICAgICAgIGxlZnQ6IDE1LFxyXG4gICAgICAgICAgICBib3R0b206IDE1XHJcbiAgICAgICAgfTtcclxuICAgIGlmICh0cmFuc2l0aW9uVGltZSB8fCB0cmFuc2l0aW9uVGltZSA9PT0gMCkge1xyXG4gICAgICAgIGNoYXJ0Ll92YXJzLnRyYW5zaXRpb25UaW1lID0gdHJhbnNpdGlvblRpbWU7XHJcbiAgICB9IGVsc2UgaWYgKCFjaGFydC5fdmFycy50cmFuc2l0aW9uVGltZSkge1xyXG4gICAgICAgIGNoYXJ0Ll92YXJzLnRyYW5zaXRpb25UaW1lID0gODAwO1xyXG4gICAgfVxyXG4gICAgaWYgKCFjaGFydC5zbWFsbGVyRm9udFJlcGFpbnQpIHtcclxuICAgICAgICBjaGFydC5fdmFycy5mb250U2l6ZU1heCA9IDgwO1xyXG4gICAgICAgIGNoYXJ0LmN1cnJlbnREYXRhID0gY2hhcnQuZGF0YTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY2hhcnQuY3VycmVudERhdGEgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGNoYXJ0LmRhdGEpKTtcclxuICAgIH1cclxuXHJcbiAgICBjaGFydC5fdmFycy5jb2xvciA9IGNoYXJ0LmRhdGEuY29sb3I7XHJcblxyXG4gICAgLy9HZW5lcmF0ZSBTVkctbGVnZW5kIGRhdGEgaXMgdXNlZCB0byBkZXRlcm1pbmUgdGhlIHNpemUgb2YgdGhlIGJvdHRvbSBtYXJnaW4gKHNldCB0byBudWxsIGZvciBubyBsZWdlbmQpXHJcbiAgICBjaGFydC5nZW5lcmF0ZVNWRyhudWxsLCBidWJibGVNYXJnaW5zKTtcclxuICAgIGNoYXJ0LmdlbmVyYXRlVmVydGljYWxMZWdlbmQoJ2dlbmVyYXRlQnViYmxlJyk7XHJcbiAgICBjaGFydC5nZW5lcmF0ZUJ1YmJsZShjaGFydC5jdXJyZW50RGF0YSk7XHJcbn1cclxuXHJcbi8qKnNldERhdGFcclxuICogIGdldHMgQnViYmxlIGRhdGEgYW5kIGFkZHMgaXQgdG8gdGhlIGNoYXJ0IG9iamVjdFxyXG4gKlxyXG4gKiBAcGFyYW1zIGRhdGEsIGRhdGFUYWJsZSwgY29sb3JzXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXREYXRhKCkge1xyXG4gICAgdmFyIGNoYXJ0ID0gdGhpcztcclxuICAgIC8vZGVmaW5lIGNvbG9yIG9iamVjdCBmb3IgY2hhcnREYXRhXHJcbiAgICBjaGFydC5kYXRhLmxlZ2VuZERhdGEgPSBzZXRCdWJibGVMZWdlbmREYXRhKGNoYXJ0LmRhdGEpO1xyXG4gICAgY2hhcnQuZGF0YS5jb2xvciA9IGp2Q2hhcnRzLnNldENoYXJ0Q29sb3JzKGNoYXJ0Ll92YXJzLmNvbG9yLCBjaGFydC5kYXRhLmxlZ2VuZERhdGEsIGNoYXJ0LmNvbG9ycyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEV2ZW50RGF0YSgpIHtcclxuICAgIHJldHVybiB7fTtcclxufVxyXG5cclxuLyoqc2V0QnViYmxlTGVnZW5kRGF0YVxyXG4gKiAgZ2V0cyBsZWdlbmQgaW5mbyBmcm9tIGNoYXJ0IERhdGFcclxuICpcclxuICogQHBhcmFtcyBkYXRhLCB0eXBlXHJcbiAqIEByZXR1cm5zIFtdIG9mIGxlZ2VuZCB0ZXh0XHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRCdWJibGVMZWdlbmREYXRhKGRhdGEpIHtcclxuICAgIHZhciBsZWdlbmRBcnJheSA9IFtdLFxyXG4gICAgICAgIGl0ZW0gPSBkYXRhLmRhdGFUYWJsZS5sYWJlbDtcclxuXHJcbiAgICBmb3IgKGxldCB2YWx1ZSBpbiBkYXRhLmNoYXJ0RGF0YSkge1xyXG4gICAgICAgIGlmIChkYXRhLmNoYXJ0RGF0YS5oYXNPd25Qcm9wZXJ0eSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgbGV0IGxlZ2VuZEVsZW1lbnQgPSBkYXRhLmNoYXJ0RGF0YVt2YWx1ZV1baXRlbV07XHJcbiAgICAgICAgICAgIGlmIChsZWdlbmRBcnJheS5pbmRleE9mKGxlZ2VuZEVsZW1lbnQpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgbGVnZW5kQXJyYXkucHVzaChsZWdlbmRFbGVtZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbGVnZW5kQXJyYXk7XHJcbn1cclxuXHJcblxyXG4vKiogZ2VuZXJhdGVCdWJibGVcclxuICpcclxuICogcGFpbnRzIHRoZSBidWJibGUgIG9uIHRoZSBjaGFydFxyXG4gKiBAcGFyYW1zIGJ1YmJsZSBEYXRhXHJcbiAqL1xyXG5mdW5jdGlvbiBnZW5lcmF0ZUJ1YmJsZShidWJibGVEYXRhKSB7XHJcbiAgICB2YXIgY2hhcnQgPSB0aGlzLFxyXG4gICAgICAgIHN2ZyA9IGNoYXJ0LnN2ZyxcclxuICAgICAgICBjb250YWluZXIgPSBjaGFydC5jb25maWcuY29udGFpbmVyLFxyXG4gICAgICAgIHdpZHRoID0gY29udGFpbmVyLndpZHRoLFxyXG4gICAgICAgIGhlaWdodCA9IGNvbnRhaW5lci5oZWlnaHQsXHJcbiAgICAgICAgcGFjayA9IGQzLnBhY2soKS5zaXplKFt3aWR0aCwgaGVpZ2h0XSkucGFkZGluZygxLjUpLFxyXG4gICAgICAgIGxlZ2VuZERhdGEgPSBjaGFydC5kYXRhLmxlZ2VuZERhdGEsXHJcbiAgICAgICAgdmFsdWVLZXkgPSBjaGFydC5kYXRhLmRhdGFUYWJsZS52YWx1ZSxcclxuICAgICAgICBsYWJlbEtleSA9IGNoYXJ0LmRhdGEuZGF0YVRhYmxlLmxhYmVsLFxyXG4gICAgICAgIGNvbG9ycyA9IGNoYXJ0Ll92YXJzLmNvbG9yLFxyXG4gICAgICAgIGRhdGFIZWFkZXJzLFxyXG4gICAgICAgIGJ1YmJsZURhdGFOZXcsXHJcbiAgICAgICAgbGVnZW5kRWxlbWVudFRvZ2dsZUFycmF5LFxyXG4gICAgICAgIHJvb3QsXHJcbiAgICAgICAgYnViYmxlO1xyXG5cclxuICAgIGlmICghY2hhcnQuX3ZhcnMubGVnZW5kSGVhZGVycykge1xyXG4gICAgICAgIGNoYXJ0Ll92YXJzLmxlZ2VuZEhlYWRlcnMgPSBsZWdlbmREYXRhO1xyXG4gICAgfVxyXG4gICAgZGF0YUhlYWRlcnMgPSBjaGFydC5fdmFycy5sZWdlbmRIZWFkZXJzO1xyXG4gICAgaWYgKCFjaGFydC5fdmFycy5sZWdlbmRIZWFkZXJzKSB7XHJcbiAgICAgICAgY2hhcnQuX3ZhcnMubGVnZW5kSGVhZGVycyA9IGxlZ2VuZERhdGE7XHJcbiAgICB9XHJcbiAgICBidWJibGVEYXRhTmV3ID0ganZDaGFydHMuZ2V0VG9nZ2xlZERhdGEoYnViYmxlRGF0YSwgZGF0YUhlYWRlcnMpO1xyXG4gICAgbGVnZW5kRWxlbWVudFRvZ2dsZUFycmF5ID0ganZDaGFydHMuZ2V0TGVnZW5kRWxlbWVudFRvZ2dsZUFycmF5KGRhdGFIZWFkZXJzLCBsZWdlbmREYXRhKTtcclxuXHJcbiAgICBpZiAobGVnZW5kRWxlbWVudFRvZ2dsZUFycmF5KSB7XHJcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBidWJibGVEYXRhTmV3Lmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGxlZ2VuZEVsZSBvZiBsZWdlbmRFbGVtZW50VG9nZ2xlQXJyYXkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChsZWdlbmRFbGUuZWxlbWVudCA9PT0gYnViYmxlRGF0YU5ld1tqXVtsYWJlbEtleV0gJiYgbGVnZW5kRWxlLnRvZ2dsZSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBidWJibGVEYXRhTmV3LnNwbGljZShqLCAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN2Zy5zZWxlY3RBbGwoJy5idWJibGUnKS5yZW1vdmUoKTtcclxuICAgIC8vYXNzaWducyB0aGUgZGF0YSB0byBhIGhpZXJhcmNoeSB1c2luZyBwYXJlbnQtY2hpbGQgcmVsYXRpb25zaGlwc1xyXG4gICAgcm9vdCA9IGQzLmhpZXJhcmNoeSh7IGNoaWxkcmVuOiBidWJibGVEYXRhTmV3IH0pXHJcbiAgICAgICAgLnN1bShkID0+IGRbdmFsdWVLZXldKTtcclxuXHJcbiAgICBidWJibGUgPSBzdmcuc2VsZWN0QWxsKCcuYnViYmxlJylcclxuICAgICAgICAuZGF0YShwYWNrKHJvb3QpLmxlYXZlcygpKVxyXG4gICAgICAgIC5lbnRlcigpLmFwcGVuZCgnZycpXHJcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2J1YmJsZScpXHJcbiAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGQgPT4gYHRyYW5zbGF0ZSgke2QueH0sJHtkLnl9KWApO1xyXG5cclxuICAgIGJ1YmJsZS5hcHBlbmQoJ2NpcmNsZScpXHJcbiAgICAgICAgLmF0dHIoJ2ZpbGwnLCBkID0+IGp2Q2hhcnRzLmdldENvbG9ycyhjb2xvcnMsIGxlZ2VuZERhdGEuaW5kZXhPZihkLmRhdGFbbGFiZWxLZXldKSwgZC5kYXRhW2xhYmVsS2V5XSkpXHJcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgKGQsIGkpID0+IGBlZGl0YWJsZSBlZGl0YWJsZS1idWJibGUgYnViYmxlLSR7aX0gaGlnaGxpZ2h0LWNsYXNzLSR7aX1gKVxyXG4gICAgICAgIC5hdHRyKCdyJywgZCA9PiBkLnIpXHJcbiAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICBpZiAoY2hhcnQuc2hvd1Rvb2xUaXApIHtcclxuICAgICAgICAgICAgICAgIC8vR2V0IHRpcCBkYXRhXHJcbiAgICAgICAgICAgICAgICB2YXIgdGlwRGF0YSA9IGNoYXJ0LnNldFRpcERhdGEoZC5kYXRhLCBpKTtcclxuICAgICAgICAgICAgICAgIC8vRHJhdyB0aXAgbGluZVxyXG4gICAgICAgICAgICAgICAgdGlwRGF0YS5kYXRhLmNvbG9yID0ganZDaGFydHMuZ2V0Q29sb3JzKGNvbG9ycywgdGlwRGF0YS5pbmRleCwgZC5kYXRhW2xhYmVsS2V5XSk7XHJcbiAgICAgICAgICAgICAgICBjaGFydC50aXAuZ2VuZXJhdGVTaW1wbGVUaXAodGlwRGF0YSwgY2hhcnQuZGF0YS5kYXRhVGFibGUpO1xyXG4gICAgICAgICAgICAgICAgY2hhcnQudGlwLmQgPSBkLmRhdGE7XHJcbiAgICAgICAgICAgICAgICBjaGFydC50aXAuaSA9IGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICAgIC5vbignbW91c2Vtb3ZlJywgZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgaWYgKGNoYXJ0LnNob3dUb29sVGlwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hhcnQudGlwLmQgPT09IGQgJiYgY2hhcnQudGlwLmkgPT09IGkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGFydC50aXAuc2hvd1RpcCgwKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9HZXQgdGlwIGRhdGFcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGlwRGF0YSA9IGNoYXJ0LnNldFRpcERhdGEoZC5kYXRhLCBpKTtcclxuICAgICAgICAgICAgICAgICAgICAvL0RyYXcgdGlwIGxpbmVcclxuICAgICAgICAgICAgICAgICAgICBjaGFydC50aXAuZ2VuZXJhdGVTaW1wbGVUaXAodGlwRGF0YSwgY2hhcnQuZGF0YS5kYXRhVGFibGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgaWYgKGNoYXJ0LnNob3dUb29sVGlwKSB7XHJcbiAgICAgICAgICAgICAgICBjaGFydC50aXAuaGlkZVRpcCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgYnViYmxlLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2J1YmJsZS10ZXh0JylcclxuICAgICAgICAudGV4dChkID0+IGQuZGF0YVtsYWJlbEtleV0pXHJcbiAgICAgICAgLmF0dHIoJ2ZpbGwnLCAnd2hpdGUnKVxyXG4gICAgICAgIC8vaGlkZSB0ZXh0IGlmIGl0cyB0b28gd2lkZVxyXG4gICAgICAgIC5hdHRyKCdzdHlsZScsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNsaWVudFdpZHRoID4gZC5yICogMikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdkaXNwbGF5OiBub25lJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAvL2NlbnRlciB0aGUgdGV4dCBvbiB0aGUgYnViYmxlXHJcbiAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIHZhciBkaWFtZXRlciA9IGQuciAqIDIsXHJcbiAgICAgICAgICAgICAgICB0ZXh0V2lkdGggPSB0aGlzLmNsaWVudFdpZHRoLFxyXG4gICAgICAgICAgICAgICAgZW1wdHlTcGFjZSA9IGRpYW1ldGVyIC0gdGV4dFdpZHRoO1xyXG5cclxuICAgICAgICAgICAgaWYgKGVtcHR5U3BhY2UgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGB0cmFuc2xhdGUoLSR7ZC5yIC0gKGVtcHR5U3BhY2UgLyAyKX0sIDApYDtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgaWYgKGNoYXJ0LnNob3dUb29sVGlwKSB7XHJcbiAgICAgICAgICAgICAgICAvL0dldCB0aXAgZGF0YVxyXG4gICAgICAgICAgICAgICAgdmFyIHRpcERhdGEgPSBjaGFydC5zZXRUaXBEYXRhKGQuZGF0YSwgaSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9EcmF3IHRpcCBsaW5lXHJcbiAgICAgICAgICAgICAgICB0aXBEYXRhLmRhdGEuY29sb3IgPSBqdkNoYXJ0cy5nZXRDb2xvcnMoY29sb3JzLCB0aXBEYXRhLmluZGV4LCBkLmRhdGFbbGFiZWxLZXldKTtcclxuICAgICAgICAgICAgICAgIGNoYXJ0LnRpcC5nZW5lcmF0ZVNpbXBsZVRpcCh0aXBEYXRhLCBjaGFydC5kYXRhLmRhdGFUYWJsZSk7XHJcbiAgICAgICAgICAgICAgICBjaGFydC50aXAuZCA9IGQuZGF0YTtcclxuICAgICAgICAgICAgICAgIGNoYXJ0LnRpcC5pID0gaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLm9uKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICBpZiAoY2hhcnQuc2hvd1Rvb2xUaXApIHtcclxuICAgICAgICAgICAgICAgIGlmIChjaGFydC50aXAuZCA9PT0gZCAmJiBjaGFydC50aXAuaSA9PT0gaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0LnRpcC5zaG93VGlwKDApO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvL0dldCB0aXAgZGF0YVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0aXBEYXRhID0gY2hhcnQuc2V0VGlwRGF0YShkLmRhdGEsIGkpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vRHJhdyB0aXAgbGluZVxyXG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0LnRpcC5nZW5lcmF0ZVNpbXBsZVRpcCh0aXBEYXRhLCBjaGFydC5kYXRhLmRhdGFUYWJsZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChjaGFydC5zaG93VG9vbFRpcCkge1xyXG4gICAgICAgICAgICAgICAgY2hhcnQudGlwLmhpZGVUaXAoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIGJ1YmJsZS5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgIC50ZXh0KGQgPT4gZC5kYXRhW3ZhbHVlS2V5XSlcclxuICAgICAgICAuYXR0cignZmlsbCcsICd3aGl0ZScpXHJcbiAgICAgICAgLy9oaWRlIHRleHQgaWYgaXRzIHRvbyB3aWRlXHJcbiAgICAgICAgLmF0dHIoJ3N0eWxlJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY2xpZW50V2lkdGggPiBkLnIgKiAyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2Rpc3BsYXk6IG5vbmUnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9KVxyXG4gICAgICAgIC8vY2VudGVyIHRoZSB0ZXh0IG9uIHRoZSBidWJibGVcclxuICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgdmFyIGRpYW1ldGVyID0gZC5yICogMixcclxuICAgICAgICAgICAgICAgIHRleHRXaWR0aCA9IHRoaXMuY2xpZW50V2lkdGgsXHJcbiAgICAgICAgICAgICAgICBlbXB0eVNwYWNlID0gZGlhbWV0ZXIgLSB0ZXh0V2lkdGg7XHJcblxyXG4gICAgICAgICAgICBpZiAoZW1wdHlTcGFjZSA8IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYHRyYW5zbGF0ZSgtJHtkLnIgLSAoZW1wdHlTcGFjZSAvIDIpfSwgMTUpYDtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgaWYgKGNoYXJ0LnNob3dUb29sVGlwKSB7XHJcbiAgICAgICAgICAgICAgICAvL0dldCB0aXAgZGF0YVxyXG4gICAgICAgICAgICAgICAgdmFyIHRpcERhdGEgPSBjaGFydC5zZXRUaXBEYXRhKGQuZGF0YSwgaSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9EcmF3IHRpcCBsaW5lXHJcbiAgICAgICAgICAgICAgICB0aXBEYXRhLmRhdGEuY29sb3IgPSBqdkNoYXJ0cy5nZXRDb2xvcnMoY29sb3JzLCB0aXBEYXRhLmluZGV4LCBkLmRhdGFbbGFiZWxLZXldKTtcclxuICAgICAgICAgICAgICAgIGNoYXJ0LnRpcC5nZW5lcmF0ZVNpbXBsZVRpcCh0aXBEYXRhLCBjaGFydC5kYXRhLmRhdGFUYWJsZSk7XHJcbiAgICAgICAgICAgICAgICBjaGFydC50aXAuZCA9IGQuZGF0YTtcclxuICAgICAgICAgICAgICAgIGNoYXJ0LnRpcC5pID0gaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLm9uKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICBpZiAoY2hhcnQuc2hvd1Rvb2xUaXApIHtcclxuICAgICAgICAgICAgICAgIGlmIChjaGFydC50aXAuZCA9PT0gZCAmJiBjaGFydC50aXAuaSA9PT0gaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0LnRpcC5zaG93VGlwKDApO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvL0dldCB0aXAgZGF0YVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0aXBEYXRhID0gY2hhcnQuc2V0VGlwRGF0YShkLmRhdGEsIGkpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vRHJhdyB0aXAgbGluZVxyXG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0LnRpcC5nZW5lcmF0ZVNpbXBsZVRpcCh0aXBEYXRhLCBjaGFydC5kYXRhLmRhdGFUYWJsZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChjaGFydC5zaG93VG9vbFRpcCkge1xyXG4gICAgICAgICAgICAgICAgY2hhcnQudGlwLmhpZGVUaXAoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGp2Q2hhcnRzO1xyXG4iLCIndXNlIHN0cmljdCc7XHJcbnZhciBqdkNoYXJ0cyA9IHJlcXVpcmUoJy4uL2p2Q2hhcnRzLmpzJyk7XHJcblxyXG5qdkNoYXJ0cy5wcm90b3R5cGUuY2x1c3RlcmdyYW0gPSB7XHJcbiAgICBwYWludDogcGFpbnQsXHJcbiAgICBzZXREYXRhOiBzZXREYXRhLFxyXG4gICAgZ2V0RXZlbnREYXRhOiBudWxsXHJcbn07XHJcblxyXG5qdkNoYXJ0cy5wcm90b3R5cGUuZ2VuZXJhdGVDbHVzdGVyZ3JhbSA9IGdlbmVyYXRlQ2x1c3RlcmdyYW07XHJcblxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIENsdXN0ZXJncmFtIGZ1bmN0aW9ucyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG4vKipzZXRDbHVzdGVyZ3JhbURhdGFcclxuICogIGdldHMgaGVhdG1hcCBkYXRhIGFuZCBhZGRzIGl0IHRvIHRoZSBjaGFydCBvYmplY3RcclxuICpcclxuICogQHBhcmFtcyBkYXRhLCBkYXRhVGFibGUsIGNvbG9yc1xyXG4gKi9cclxuZnVuY3Rpb24gc2V0RGF0YSgpIHtcclxuICAgIHZhciBjaGFydCA9IHRoaXMsXHJcbiAgICAgICAgbGVmdFRyZWVEYXRhID0gY2hhcnQuZGF0YS5jaGFydERhdGFbMF0sXHJcbiAgICAgICAgcmlnaHRUcmVlRGF0YSA9IGNoYXJ0LmRhdGEuY2hhcnREYXRhWzFdO1xyXG5cclxuICAgIGNoYXJ0LmxlZnRMYWJlbHMgPSB7fTtcclxuICAgIGNoYXJ0LmxlZnRMYWJlbHMudmFsdWVzID0gW107XHJcbiAgICBmb3IgKGxldCBsZWZ0RWxlIG9mIGxlZnRUcmVlRGF0YS5jaGlsZHJlbikge1xyXG4gICAgICAgIGlmIChsZWZ0RWxlLm5hbWUpIHtcclxuICAgICAgICAgICAgY2hhcnQubGVmdExhYmVscy52YWx1ZXMucHVzaChsZWZ0RWxlLm5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjaGFydC5yaWdodExhYmVscyA9IHt9O1xyXG4gICAgY2hhcnQucmlnaHRMYWJlbHMudmFsdWVzID0gW107XHJcbiAgICBmb3IgKGxldCByaWdodEVsZSBvZiByaWdodFRyZWVEYXRhLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgaWYgKHJpZ2h0RWxlLm5hbWUpIHtcclxuICAgICAgICAgICAgY2hhcnQucmlnaHRMYWJlbHMudmFsdWVzLnB1c2gocmlnaHRFbGUubmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNoYXJ0LmxlZnRMZWF2ZXMgPSBnZXRMZWFmTm9kZXMoW2xlZnRUcmVlRGF0YV0pO1xyXG4gICAgY2hhcnQucmlnaHRMZWF2ZXMgPSBnZXRMZWFmTm9kZXMoW3JpZ2h0VHJlZURhdGFdKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0TGVhZk5vZGVzKG5vZGVzLCByZXN1bHQgPSBbXSkge1xyXG4gICAgbGV0IHJldHVybkRhdGEgPSByZXN1bHQ7XHJcbiAgICBmb3IgKGxldCBub2RlIG9mIG5vZGVzKSB7XHJcbiAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybkRhdGEucHVzaChub2RlLm5hbWUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybkRhdGEgPSBnZXRMZWFmTm9kZXMobm9kZS5jaGlsZHJlbiwgcmV0dXJuRGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJldHVybkRhdGE7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhaW50KCkge1xyXG4gICAgdmFyIGNoYXJ0ID0gdGhpcyxcclxuICAgICAgICBjdXN0b21NYXJnaW4gPSB7XHJcbiAgICAgICAgICAgIHRvcDogMjAsXHJcbiAgICAgICAgICAgIHJpZ2h0OiA0MCxcclxuICAgICAgICAgICAgbGVmdDogMCxcclxuICAgICAgICAgICAgYm90dG9tOiAyMFxyXG4gICAgICAgIH07XHJcbiAgICBjaGFydC5fdmFycy5jb2xvciA9IGNoYXJ0LmRhdGEuY29sb3I7XHJcbiAgICBjaGFydC5jdXJyZW50RGF0YSA9IGNoYXJ0LmRhdGE7Ly9NaWdodCBoYXZlIHRvIG1vdmUgaW50byBtZXRob2QgYmMgb2YgcmVmZXJlbmNlL3ZhbHVlIHJlbGF0aW9uc2hpcFxyXG5cclxuICAgIC8vR2VuZXJhdGUgU1ZHLWxlZ2VuZCBkYXRhIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBzaXplIG9mIHRoZSBib3R0b20gbWFyZ2luIChzZXQgdG8gbnVsbCBmb3Igbm8gbGVnZW5kKVxyXG4gICAgY2hhcnQuZ2VuZXJhdGVTVkcobnVsbCwgY3VzdG9tTWFyZ2luKTtcclxuICAgIC8vY2hhcnQuZ2VuZXJhdGVMZWdlbmQoY2hhcnQuY3VycmVudERhdGEubGVnZW5kRGF0YSwgJ2dlbmVyYXRlQ2x1c3RlcmdyYW0nKTtcclxuICAgIGNoYXJ0LmdlbmVyYXRlQ2x1c3RlcmdyYW0oKTtcclxufVxyXG5cclxuLyoqZ2VuZXJhdGVDbHVzdGVyZ3JhbVxyXG4gKlxyXG4gKiBwYWludHMgdGhlIENsdXN0ZXJncmFtIG9uIHRoZSBjaGFydFxyXG4gKiBAcGFyYW1zIENsdXN0ZXJncmFtRGF0YVxyXG4gKi9cclxuZnVuY3Rpb24gZ2VuZXJhdGVDbHVzdGVyZ3JhbSgpIHtcclxuICAgIHZhciBjaGFydCA9IHRoaXMsXHJcbiAgICAgICAgc3ZnID0gY2hhcnQuc3ZnLFxyXG4gICAgICAgIGNvbnRhaW5lciA9IGNoYXJ0LmNvbmZpZy5jb250YWluZXIsXHJcbiAgICAgICAgbGVmdFRyZWVEYXRhID0gY2hhcnQuZGF0YS5jaGFydERhdGFbMF0sXHJcbiAgICAgICAgcmlnaHRUcmVlRGF0YSA9IGNoYXJ0LmRhdGEuY2hhcnREYXRhWzFdLFxyXG4gICAgICAgIGdyaWREYXRhID0gY2hhcnQuZGF0YS5jaGFydERhdGFbMl0sXHJcbiAgICAgICAgc2l6ZVdpZHRoID0gY2hhcnQucmlnaHRMZWF2ZXMubGVuZ3RoICogMjAsXHJcbiAgICAgICAgc2l6ZUhlaWdodCA9IGNoYXJ0LmxlZnRMZWF2ZXMubGVuZ3RoICogMjAsXHJcbiAgICAgICAgdmlzLFxyXG4gICAgICAgIGxlZnRHLFxyXG4gICAgICAgIGJvdHRvbUcsXHJcbiAgICAgICAgaGVhdEcsXHJcbiAgICAgICAgbmV3V2lkdGgsXHJcbiAgICAgICAgbmV3SGVpZ2h0LFxyXG4gICAgICAgIGxlZnRDaGlsZENvdW50LFxyXG4gICAgICAgIHJpZ2h0Q2hpbGRDb3VudDtcclxuXHJcbiAgICBjaGFydC5kYXRhLnlBeGlzRGF0YSA9IFtdO1xyXG4gICAgY2hhcnQuZGF0YS54QXhpc0RhdGEgPSBbXTtcclxuXHJcbiAgICBpZiAoc2l6ZVdpZHRoIDwgY29udGFpbmVyLndpZHRoKSB7XHJcbiAgICAgICAgc2l6ZVdpZHRoID0gY29udGFpbmVyLndpZHRoO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzaXplSGVpZ2h0IDwgY29udGFpbmVyLmhlaWdodCkge1xyXG4gICAgICAgIHNpemVIZWlnaHQgPSBjb250YWluZXIuaGVpZ2h0O1xyXG4gICAgfVxyXG5cclxuICAgIC8vcmVtb3ZlIHN2ZyBlbGVtZW50c1xyXG4gICAgc3ZnLnNlbGVjdEFsbCgnKicpLnJlbW92ZSgpO1xyXG5cclxuICAgIHZpcyA9IHN2Zy5hcHBlbmQoJ2cnKS5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsIDApJykuYXR0cignY2xhc3MnLCAnaGVhdG1hcCcpO1xyXG4gICAgbGVmdEcgPSB2aXMuYXBwZW5kKCdnJykuYXR0cignaWQnLCAnbGVmdC10cmVlJyk7XHJcbiAgICBib3R0b21HID0gdmlzLmFwcGVuZCgnZycpLmF0dHIoJ2lkJywgJ2JvdHRvbS10cmVlJyk7XHJcbiAgICBoZWF0RyA9IHZpcy5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdjbHVzdGVyZ3JhbS1jb250YWluZXInKS5hdHRyKCdpZCcsICdoZWF0Jyk7XHJcblxyXG4gICAgZDMuc2VsZWN0KCdib2R5JykuYXBwZW5kKCdkaXYnKVxyXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICd0b29sdGlwJylcclxuICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAwKTtcclxuICAgIC8vY2FsYyBuZXcgd2lkdGggYW5kIGhlaWdodFxyXG4gICAgbmV3V2lkdGggPSBzaXplV2lkdGggLyAyO1xyXG4gICAgbmV3SGVpZ2h0ID0gc2l6ZUhlaWdodCAvIDI7XHJcblxyXG4gICAgbGVmdENoaWxkQ291bnQgPSBidWlsZFRyZWUobGVmdFRyZWVEYXRhLCBjaGFydC5kYXRhLnlBeGlzRGF0YSwgbGVmdEcsIG5ld0hlaWdodCwgbmV3V2lkdGgsICdsZWZ0Jyk7XHJcbiAgICByaWdodENoaWxkQ291bnQgPSBidWlsZFRyZWUocmlnaHRUcmVlRGF0YSwgY2hhcnQuZGF0YS54QXhpc0RhdGEsIGJvdHRvbUcsIG5ld0hlaWdodCwgbmV3V2lkdGgsICdyaWdodCcpO1xyXG4gICAgYnVpbGRIZWF0KGNoYXJ0LCBncmlkRGF0YSwgaGVhdEcsIG5ld0hlaWdodCwgbmV3V2lkdGgsIGxlZnRDaGlsZENvdW50LCByaWdodENoaWxkQ291bnQpO1xyXG5cclxuICAgIGNoYXJ0Lnpvb21lZCA9ICgpID0+IHN2Zy5hdHRyKCd0cmFuc2Zvcm0nLCBkMy5ldmVudC50cmFuc2Zvcm0pO1xyXG4gICAgY2hhcnQuY2hhcnREaXYuc2VsZWN0KCcuZWRpdGFibGUtc3ZnJykuY2FsbChkMy56b29tKClcclxuICAgICAgICAub24oJ3pvb20nLCBjaGFydC56b29tZWQpKTtcclxuXHJcbiAgICAvL2FsaWduIEcgdGFnc1xyXG4gICAgY2hhcnQuX3ZhcnMubGVmdFRyZWVXaWR0aCA9IGxlZnRHLm5vZGUoKS5nZXRCQm94KCkud2lkdGg7XHJcbiAgICBjaGFydC5fdmFycy50b3BUcmVlSGVpZ2h0ID0gYm90dG9tRy5ub2RlKCkuZ2V0QkJveCgpLmhlaWdodDtcclxuICAgIGxlZnRHLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIDAgKyAnLCcgKyAoY2hhcnQuX3ZhcnMudG9wVHJlZUhlaWdodCkgKyAnKScpO1xyXG4gICAgYm90dG9tRy5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyAoY2hhcnQuX3ZhcnMubGVmdFRyZWVXaWR0aCkgKyAnLCcgKyAwICsgJyknKTtcclxuICAgIGhlYXRHLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIGNoYXJ0Ll92YXJzLmxlZnRUcmVlV2lkdGggKyAnLCcgKyAoY2hhcnQuX3ZhcnMudG9wVHJlZUhlaWdodCkgKyAnKScpO1xyXG5cclxuICAgIGNoYXJ0LmNvbmZpZy5jb250YWluZXIuaGVpZ2h0ID0gaGVhdEcubm9kZSgpLmdldEJCb3goKS5oZWlnaHQ7XHJcbiAgICBjaGFydC5jb25maWcuY29udGFpbmVyLndpZHRoID0gaGVhdEcubm9kZSgpLmdldEJCb3goKS53aWR0aDtcclxufVxyXG5cclxuZnVuY3Rpb24gZmluZFBhdGgoY2hpbGQpIHtcclxuICAgIHZhciBzdHIgPSAnJztcclxuICAgIGxldCBjaGlsZE5vZGUgPSBjaGlsZDtcclxuICAgIHdoaWxlIChjaGlsZE5vZGUucGFyZW50KSB7XHJcbiAgICAgICAgc3RyICs9IGNoaWxkTm9kZS5kYXRhLm5hbWUgKyAnLic7XHJcbiAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLnBhcmVudDtcclxuICAgIH1cclxuICAgIHJldHVybiBzdHIuc2xpY2UoMCwgLTEpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBidWlsZFRyZWUoZGF0YSwgYXhpc0RhdGEsIGdFbGUsIG5ld0hlaWdodCwgbmV3V2lkdGgsIHNpZGVPZlRyZWUpIHtcclxuICAgIHZhciBtYWtlVHJlZSxcclxuICAgICAgICByb290LFxyXG4gICAgICAgIGNoaWxkQ291bnQgPSAwO1xyXG5cclxuICAgIG1ha2VUcmVlID0gZDMuY2x1c3RlcigpXHJcbiAgICAgICAgLnNpemUoc2lkZU9mVHJlZSA9PT0gJ2xlZnQnID8gW25ld0hlaWdodCwgbmV3V2lkdGhdIDogW25ld1dpZHRoLCBuZXdIZWlnaHRdKTtcclxuXHJcbiAgICByb290ID0gZDMuaGllcmFyY2h5KGRhdGEpO1xyXG4gICAgbWFrZVRyZWUocm9vdCk7XHJcblxyXG4gICAgZ0VsZS5zZWxlY3RBbGwoJy5jbHVzdGVyLWxpbmsnKVxyXG4gICAgICAgIC5kYXRhKHJvb3QuZGVzY2VuZGFudHMoKS5zbGljZSgxKSlcclxuICAgICAgICAuZW50ZXIoKS5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICdjbHVzdGVyLWxpbmsnKVxyXG4gICAgICAgIC5zdHlsZSgnZmlsbCcsICdub25lJylcclxuICAgICAgICAuc3R5bGUoJ3N0cm9rZScsICdibGFjaycpXHJcbiAgICAgICAgLmF0dHIoJ2QnLCBkID0+IHtcclxuICAgICAgICAgICAgaWYgKHNpZGVPZlRyZWUgPT09ICdsZWZ0Jykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdNJyArIGQueSAvIDggKyAnLCcgKyBkLnggKyAnVicgKyBkLnBhcmVudC54ICsgJ0gnICsgZC5wYXJlbnQueSAvIDg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuICdNJyArIGQueCArICcsJyArIGQueSAvIDggKyAnVicgKyBkLnBhcmVudC55IC8gOCArICdIJyArIGQucGFyZW50Lng7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgZ0VsZS5zZWxlY3RBbGwoJy5jbHVzdGVyLW5vZGUnKVxyXG4gICAgICAgIC5kYXRhKHJvb3QuZGVzY2VuZGFudHMoKSlcclxuICAgICAgICAuZW50ZXIoKS5hcHBlbmQoJ2cnKVxyXG4gICAgICAgIC5hdHRyKCdjbGFzcycsIGQgPT4gYGNsdXN0ZXItbm9kZSAkeyhkLmNoaWxkcmVuID8gJ2NsdXN0ZXItbm9kZS0taW50ZXJuYWwnIDogJ2NsdXN0ZXItbm9kZS0tbGVhZicpfWApXHJcbiAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGQgPT4ge1xyXG4gICAgICAgICAgICBpZiAoc2lkZU9mVHJlZSA9PT0gJ2xlZnQnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYHRyYW5zbGF0ZSgke2QueSAvIDh9LCAke2QueH0pYDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYHRyYW5zbGF0ZSgke2QueH0sICR7ZC55IC8gOH0pcm90YXRlKDE1KWA7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgaWYgKHNpZGVPZlRyZWUgPT09ICdsZWZ0Jykge1xyXG4gICAgICAgIGdFbGUuc2VsZWN0QWxsKCcuY2x1c3Rlci1ub2RlJykuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgLmF0dHIoJ2R5JywgMylcclxuICAgICAgICAgICAgLmF0dHIoJ3gnLCBkID0+IGQuY2hpbGRyZW4gPyAtOCA6IDApXHJcbiAgICAgICAgICAgIC5zdHlsZSgndGV4dC1hbmNob3InLCAnZW5kJylcclxuICAgICAgICAgICAgLnRleHQoZCA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWQuY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZENvdW50Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgYXhpc0RhdGEucHVzaChmaW5kUGF0aChkKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvL3JldHVybiBkLmRhdGEubmFtZTtcclxuICAgICAgICAgICAgICAgIGlmIChkLmRhdGEubmFtZSA9PT0gJ3Jvb3QnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGQuY2hpbGRyZW4gPyBkLmRhdGEubmFtZS5yZXBsYWNlKC9fL2csICcgJykgOiAnJztcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgZ0VsZS5zZWxlY3RBbGwoJy5jbHVzdGVyLW5vZGUnKS5hcHBlbmQoJ2xpbmUnKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsICdibGFjaycpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4MScsIGQgPT4gZC5jaGlsZHJlbiA/IDAgOiAwKVxyXG4gICAgICAgICAgICAuYXR0cigneDInLCBkID0+IGQuY2hpbGRyZW4gPyAwIDogMTUpO1xyXG4gICAgfSBlbHNlIGlmIChzaWRlT2ZUcmVlID09PSAncmlnaHQnKSB7XHJcbiAgICAgICAgZ0VsZS5zZWxlY3RBbGwoJy5jbHVzdGVyLW5vZGUnKS5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAuYXR0cignZHknLCA4KVxyXG4gICAgICAgICAgICAuc3R5bGUoJ3RleHQtYW5jaG9yJywgZCA9PiBkLmNoaWxkcmVuID8gJ2VuZCcgOiAnc3RhcnQnKVxyXG4gICAgICAgICAgICAuYXR0cigneScsIGQgPT4gZC5jaGlsZHJlbiA/IC04IDogOClcclxuICAgICAgICAgICAgLnRleHQoZCA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWQuY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZENvdW50Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgYXhpc0RhdGEucHVzaChmaW5kUGF0aChkKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZC5kYXRhLm5hbWUgPT09ICdyb290Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBkLmNoaWxkcmVuID8gZC5kYXRhLm5hbWUucmVwbGFjZSgvXy9nLCAnICcpIDogJyc7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNoaWxkQ291bnQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGJ1aWxkSGVhdChjaGFydCwgZ3JpZERhdGEsIGhlYXRHLCBuZXdIZWlnaHQsIG5ld1dpZHRoLCBsZWZ0Q2hpbGRDb3VudCwgcmlnaHRDaGlsZENvdW50KSB7XHJcbiAgICB2YXIgaGVhdFNjb3JlcyA9IFtdLFxyXG4gICAgICAgIGdyaWRIZWlnaHQsXHJcbiAgICAgICAgZ3JpZFdpZHRoLFxyXG4gICAgICAgIGNvbG9yO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JpZERhdGEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBsZXQgY2VsbCA9IGdyaWREYXRhW2ldO1xyXG4gICAgICAgIGhlYXRTY29yZXMucHVzaChjZWxsLnZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICAvL2hlYXQgdmFyaWFibGVzXHJcbiAgICBjb2xvciA9IGQzLnNjYWxlVGhyZXNob2xkKClcclxuICAgICAgICAuZG9tYWluKGhlYXRTY29yZXMpXHJcbiAgICAgICAgLnJhbmdlKFsnI2ZiZjJkMicsICcjZmVlN2EwJywgJyNmZmM2NjUnLCAnI2ZlYTc0MycsICcjZmQ4YzNjJywgJyNmYjRiMjknLCAnI2VhMjQxZScsICcjZDYwYjIwJywgJyNiMTAwMjYnLCAnIzYyMDAyMyddKTtcclxuXHJcbiAgICBncmlkSGVpZ2h0ID0gbmV3SGVpZ2h0IC8gbGVmdENoaWxkQ291bnQ7XHJcbiAgICBncmlkV2lkdGggPSBuZXdXaWR0aCAvIHJpZ2h0Q2hpbGRDb3VudDtcclxuXHJcbiAgICBjaGFydC5fdmFycy5jbHVzdGVyZ3JhbUdyaWRXaWR0aCA9IGdyaWRXaWR0aDtcclxuICAgIGNoYXJ0Ll92YXJzLmNsdXN0ZXJncmFtR3JpZEhlaWdodCA9IGdyaWRIZWlnaHQ7XHJcblxyXG4gICAgLy9ncmlkXHJcbiAgICBoZWF0Ry5zZWxlY3RBbGwoJy5oZWF0JylcclxuICAgICAgICAuZGF0YShncmlkRGF0YSlcclxuICAgICAgICAuZW50ZXIoKS5hcHBlbmQoJ3JlY3QnKVxyXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICdjbHVzdGVyLXJlY3QnKVxyXG4gICAgICAgIC5hdHRyKCd4JywgZCA9PiBkLnhfaW5kZXggKiBncmlkV2lkdGgpXHJcbiAgICAgICAgLmF0dHIoJ3knLCBkID0+IGQueV9pbmRleCAqIGdyaWRIZWlnaHQpXHJcbiAgICAgICAgLmF0dHIoJ3dpZHRoJywgKCkgPT4gZ3JpZFdpZHRoKVxyXG4gICAgICAgIC5hdHRyKCdoZWlnaHQnLCAoKSA9PiBncmlkSGVpZ2h0KVxyXG4gICAgICAgIC5hdHRyKCdzdHJva2UnLCAnI0U2RTZFNicpXHJcbiAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsICcxcHgnKVxyXG4gICAgICAgIC5zdHlsZSgnZmlsbCcsIGQgPT4gY29sb3IoZC52YWx1ZSkpXHJcbiAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICBpZiAoY2hhcnQuc2hvd1Rvb2xUaXApIHtcclxuICAgICAgICAgICAgICAgIGlmIChjaGFydC50aXAuZCA9PT0gZCAmJiBjaGFydC50aXAuaSA9PT0gaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0LnRpcC5zaG93VGlwKGQzLmV2ZW50KTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9HZXQgdGlwIGRhdGFcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdGlwRGF0YSA9IGNoYXJ0LnNldFRpcERhdGEoZCwgaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGlwRGF0YS5jb2xvciA9IGNvbG9yKGQudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vRHJhdyB0aXAgbGluZVxyXG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0LnRpcC5nZW5lcmF0ZVNpbXBsZVRpcCh0aXBEYXRhLCBjaGFydC5kYXRhLmRhdGFUYWJsZSwgZDMuZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBjaGFydC50aXAuaGlkZVRpcCgpO1xyXG4gICAgICAgIH0pO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGp2Q2hhcnRzO1xyXG5cclxuXHJcbiIsIid1c2Ugc3RyaWN0JztcclxudmFyIGp2Q2hhcnRzID0gcmVxdWlyZSgnLi4vanZDaGFydHMuanMnKTtcclxuXHJcbmp2Q2hhcnRzLnByb3RvdHlwZS5nYW50dCA9IHtcclxuICAgIHBhaW50OiBwYWludCxcclxuICAgIHNldERhdGE6IHNldERhdGEsXHJcbiAgICBnZXRFdmVudERhdGE6IGdldEV2ZW50RGF0YVxyXG59O1xyXG5cclxuanZDaGFydHMucHJvdG90eXBlLmdlbmVyYXRlR2FudHRCYXJzID0gZ2VuZXJhdGVHYW50dEJhcnM7XHJcbmp2Q2hhcnRzLnByb3RvdHlwZS5zZXRHYW50dExlZ2VuZERhdGEgPSBzZXRHYW50dExlZ2VuZERhdGE7XHJcbmp2Q2hhcnRzLnByb3RvdHlwZS5zZXRHYW50dEF4aXNEYXRhID0gc2V0R2FudHRBeGlzRGF0YTtcclxuXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogR2FudHQgZnVuY3Rpb25zICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcbiAgICAvKipcclxuICpcclxuICogQHBhcmFtIGRhdGFcclxuICogQHBhcmFtIGRhdGFUYWJsZVxyXG4gKiBAcGFyYW0gY29sb3JzXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXREYXRhKCkge1xyXG4gICAgdmFyIGNoYXJ0ID0gdGhpcztcclxuICAgIGNoYXJ0LmRhdGEubGVnZW5kRGF0YSA9IGNoYXJ0LnNldEdhbnR0TGVnZW5kRGF0YShjaGFydC5kYXRhKTtcclxuICAgIGNoYXJ0LmRhdGEueEF4aXNEYXRhID0gY2hhcnQuc2V0R2FudHRBeGlzRGF0YShjaGFydCwgJ3gnKTtcclxuICAgIGNoYXJ0LmRhdGEueUF4aXNEYXRhID0gY2hhcnQuc2V0R2FudHRBeGlzRGF0YShjaGFydCwgJ3knKTtcclxuICAgIC8vZGVmaW5lIGNvbG9yIG9iamVjdCBmb3IgY2hhcnREYXRhXHJcbiAgICBjaGFydC5kYXRhLmNvbG9yID0ganZDaGFydHMuc2V0Q2hhcnRDb2xvcnMoY2hhcnQuX3ZhcnMuY29sb3IsIGNoYXJ0LmRhdGEubGVnZW5kRGF0YSwgY2hhcnQuY29sb3JzKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0RXZlbnREYXRhKGV2ZW50KSB7XHJcbiAgICB2YXIgY2hhcnQgPSB0aGlzO1xyXG4gICAgdmFyIGVsZSA9IGV2ZW50LnRhcmdldC5jbGFzc0xpc3QudmFsdWUuc3BsaXQoJ2Jhci1jb2wtJylbMV07XHJcbiAgICBpZiAoZWxlKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgW2NoYXJ0LmN1cnJlbnREYXRhLmRhdGFUYWJsZS5ncm91cF06IFtlbGUucmVwbGFjZSgvXy9nLCAnICcpLnJlcGxhY2UoL19kb3RfL2csICcuJyldXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG5vZGU6IGV2ZW50LnRhcmdldFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge307XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldEdhbnR0TGVnZW5kRGF0YShkYXRhKSB7XHJcbiAgICB2YXIgbGVnZW5kQXJyYXkgPSBbXTtcclxuICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IE9iamVjdC5rZXlzKGRhdGEuZGF0YVRhYmxlKS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChkYXRhLmRhdGFUYWJsZS5oYXNPd25Qcm9wZXJ0eShbXCJzdGFydCBcIiArIGldKSkge1xyXG4gICAgICAgICAgICAvL2NoZWNrIHRvIG1ha2Ugc3VyZSBpdCBoYXMgYSBtYXRjaGluZyBlbmQgZGF0ZVxyXG4gICAgICAgICAgICBpZiAoZGF0YS5kYXRhVGFibGUuaGFzT3duUHJvcGVydHkoW1wiZW5kIFwiICsgaV0pKSB7XHJcbiAgICAgICAgICAgICAgICBsZWdlbmRBcnJheS5wdXNoKGRhdGEuZGF0YVRhYmxlW1wic3RhcnQgXCIgKyBpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxlZ2VuZEFycmF5O1xyXG59XHJcblxyXG5mdW5jdGlvbiBzZXRHYW50dEF4aXNEYXRhKGNoYXJ0LCBheGlzKSB7XHJcbiAgICB2YXIgYXhpc0RhdGEgPSBbXSxcclxuICAgICAgICBkYXRhID0gY2hhcnQuZGF0YSxcclxuICAgICAgICBjaGFydERhdGEgPSBkYXRhLmNoYXJ0RGF0YSxcclxuICAgICAgICBkYXRhVHlwZTtcclxuXHJcbiAgICBpZiAoYXhpcyA9PT0gJ3gnKSB7XHJcbiAgICAgICAgdmFyIGxhYmVsID0gZGF0YS5kYXRhVGFibGUuZ3JvdXA7XHJcbiAgICAgICAgZGF0YVR5cGUgPSAnREFURSc7XHJcblxyXG4gICAgICAgIHZhciBudW1CYXJzID0gZGF0YS5sZWdlbmREYXRhLmxlbmd0aDtcclxuICAgICAgICAvL0xvb3AgdGhyb3VnaCBkYXRhVGFibGUgYW5kIGFzc2lnbiBsYWJlbHMgYmFzZWQgb24gaG93IG1hbnkgZ3JvdXBzIHRoZXJlIGFyZVxyXG4gICAgICAgIHZhciB2YWx1ZUNvbnRhaW5lciA9IFtdO1xyXG4gICAgICAgIHZhbHVlQ29udGFpbmVyLnB1c2goZGF0YS5kYXRhVGFibGVbXCJzdGFydCAxXCJdKTtcclxuICAgICAgICB2YWx1ZUNvbnRhaW5lci5wdXNoKGRhdGEuZGF0YVRhYmxlW1wiZW5kIDFcIl0pO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbnVtQmFyczsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhbHVlQ29udGFpbmVyLnB1c2goZGF0YS5kYXRhVGFibGVbXCJzdGFydCBcIiArIChpICsgMSldKTtcclxuICAgICAgICAgICAgdmFsdWVDb250YWluZXIucHVzaChkYXRhLmRhdGFUYWJsZVtcImVuZCBcIiArIChpICsgMSldKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vR2V0IGFsbCB0aGUgc3RhcnQgYW5kIGVuZCBkYXRlcyBhbmQgYWRkIHRoZW0gdG8gYXhpcyBkYXRhXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZUNvbnRhaW5lci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgY2hhcnREYXRhLmxlbmd0aDsgaWkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoYXJ0RGF0YVtpaV1bdmFsdWVDb250YWluZXJbaV1dICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBheGlzRGF0YS5wdXNoKGNoYXJ0RGF0YVtpaV1bdmFsdWVDb250YWluZXJbaV1dKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9BZGQgYW55IGF4aXMgZm9ybWF0dGluZyB0byB0aGlzIG9iamVjdCwgbmVlZCB0byB1c2Ugd2hlbiBwYWludGluZ1xyXG4gICAgICAgIGNoYXJ0Ll92YXJzLnhBeGlzRm9ybWF0dGluZyA9IHt9O1xyXG5cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZGF0YVR5cGUgPSBcIlNUUklOR1wiO1xyXG4gICAgICAgIHZhciBsYWJlbCA9IGRhdGEuZGF0YVRhYmxlLmdyb3VwO1xyXG5cclxuICAgICAgICAvL0FkZCBhbnkgYXhpcyBmb3JtYXR0aW5nIHRvIHRoaXMgb2JqZWN0LCBuZWVkIHRvIHVzZSB3aGVuIHBhaW50aW5nXHJcbiAgICAgICAgY2hhcnQuX3ZhcnMueUF4aXNGb3JtYXR0aW5nID0ge307XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhcnREYXRhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGF4aXNEYXRhLnB1c2goY2hhcnREYXRhW2ldW2xhYmVsXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgJ2xhYmVsJzogbGFiZWwsXHJcbiAgICAgICAgJ3ZhbHVlcyc6IGF4aXNEYXRhLFxyXG4gICAgICAgICdkYXRhVHlwZSc6IGRhdGFUeXBlXHJcbiAgICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBwYWludCgpIHtcclxuICAgIHZhciBjaGFydCA9IHRoaXM7XHJcblxyXG4gICAgY2hhcnQuX3ZhcnMuY29sb3IgPSBjaGFydC5kYXRhLmNvbG9yO1xyXG5cclxuICAgIGNoYXJ0LmN1cnJlbnREYXRhID0gY2hhcnQuZGF0YTtcclxuXHJcbiAgICBjaGFydC5nZW5lcmF0ZVNWRyhjaGFydC5jdXJyZW50RGF0YS5sZWdlbmREYXRhKTtcclxuICAgIGNoYXJ0LmdlbmVyYXRlWEF4aXMoY2hhcnQuY3VycmVudERhdGEueEF4aXNEYXRhKTtcclxuICAgIGNoYXJ0LmdlbmVyYXRlWUF4aXMoY2hhcnQuY3VycmVudERhdGEueUF4aXNEYXRhKTtcclxuICAgIGNoYXJ0LmdlbmVyYXRlTGVnZW5kKGNoYXJ0LmN1cnJlbnREYXRhLmxlZ2VuZERhdGEsICdnZW5lcmF0ZUdhbnR0QmFycycpO1xyXG4gICAgY2hhcnQuZHJhd0dyaWRsaW5lcyhjaGFydC5jdXJyZW50RGF0YS54QXhpc0RhdGEpO1xyXG4gICAgY2hhcnQuZ2VuZXJhdGVHYW50dEJhcnMoY2hhcnQuY3VycmVudERhdGEpO1xyXG4gICAgaWYgKHR5cGVvZiBjaGFydC5jdXJyZW50RGF0YS54QXhpc1NjYWxlLnRpY2tzID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICBjaGFydC5mb3JtYXRYQXhpc0xhYmVscyhjaGFydC5jdXJyZW50RGF0YS54QXhpc1NjYWxlLnRpY2tzKCkubGVuZ3RoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY2hhcnQuZm9ybWF0WEF4aXNMYWJlbHMoY2hhcnQuY3VycmVudERhdGEueEF4aXNTY2FsZS5kb21haW4oKS5sZW5ndGgpO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZW5lcmF0ZUdhbnR0QmFycyhnYW50dERhdGEpIHtcclxuICAgIHZhciBjaGFydCA9IHRoaXMsXHJcbiAgICAgICAgc3ZnID0gY2hhcnQuc3ZnLFxyXG4gICAgICAgIGNvbG9ycyA9IGdhbnR0RGF0YS5jb2xvcixcclxuICAgICAgICBjb250YWluZXIgPSBjaGFydC5jb25maWcuY29udGFpbmVyLFxyXG4gICAgICAgIHlBeGlzRGF0YSA9IGdhbnR0RGF0YS55QXhpc0RhdGE7XHJcblxyXG4gICAgLy9SZW1vdmUgZXhpc3RpbmcgYmFycyBmcm9tIHBhZ2VcclxuICAgIHN2Zy5zZWxlY3RBbGwoXCJnLmdhbnR0LWNvbnRhaW5lclwiKS5yZW1vdmUoKTtcclxuICAgIHZhciBiYXJzID0gc3ZnLmFwcGVuZChcImdcIilcclxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiZ2FudHQtY29udGFpbmVyXCIpLFxyXG4gICAgICAgIGRhdGFIZWFkZXJzID0gY2hhcnQuX3ZhcnMubGVnZW5kSGVhZGVycyA/IGNoYXJ0Ll92YXJzLmxlZ2VuZEhlYWRlcnMgOiBnYW50dERhdGEubGVnZW5kRGF0YSxcclxuICAgICAgICBnYW50dERhdGFOZXcgPSBqdkNoYXJ0cy5nZXRUb2dnbGVkRGF0YShnYW50dERhdGEsIGRhdGFIZWFkZXJzKSxcclxuICAgICAgICB4ID0ganZDaGFydHMuZ2V0QXhpc1NjYWxlKCd4JywgZ2FudHREYXRhLnhBeGlzRGF0YSwgY29udGFpbmVyLCBjaGFydC5fdmFycyksXHJcbiAgICAgICAgeSA9IGp2Q2hhcnRzLmdldEF4aXNTY2FsZSgneScsIGdhbnR0RGF0YS55QXhpc0RhdGEsIGNvbnRhaW5lciwgY2hhcnQuX3ZhcnMpLFxyXG4gICAgICAgIHNhbXBsZURhdGEgPSBnYW50dERhdGFOZXc7XHJcblxyXG4gICAgY2hhcnQuX3ZhcnMucm90YXRlQXhpcyA9IHRydWU7XHJcblxyXG4gICAgdmFyIG51bUJhcnMgPSBnYW50dERhdGEubGVnZW5kRGF0YS5sZW5ndGg7XHJcbiAgICB2YXIgZ2FudHRCYXJzID0gW107XHJcbiAgICAvL2NyZWF0ZSBhcnJheSBvZiBzdGFydCBkYXRlcyBhbmQgZW5kIGRhdGVzIHRvIGl0ZXJhdGUgdGhyb3VnaFxyXG4gICAgdmFyIHN0YXJ0RGF0ZXMgPSBbXTtcclxuICAgIHZhciBlbmREYXRlcyA9IFtdO1xyXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gbnVtQmFyczsgaSsrKSB7XHJcbiAgICAgICAgc3RhcnREYXRlcy5wdXNoKGNoYXJ0LmN1cnJlbnREYXRhLmRhdGFUYWJsZVtcInN0YXJ0IFwiICsgaV0pO1xyXG4gICAgICAgIGVuZERhdGVzLnB1c2goY2hhcnQuY3VycmVudERhdGEuZGF0YVRhYmxlW1wiZW5kIFwiICsgaV0pO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgbnVtQmFyczsgaWkrKykge1xyXG4gICAgICAgIHZhciBleHRlcm5hbENvdW50ZXJGb3JKID0gLTE7XHJcbiAgICAgICAgZ2FudHRCYXJzW2lpXSA9IGJhcnMuc2VsZWN0QWxsKFwiLmdhbnR0LWJhclwiICsgaWkpXHJcbiAgICAgICAgICAgIC5kYXRhKHNhbXBsZURhdGEpXHJcbiAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgIC5hcHBlbmQoXCJyZWN0XCIpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIGZ1bmN0aW9uIChkLCBpLCBqKSB7XHJcbiAgICAgICAgICAgICAgICBleHRlcm5hbENvdW50ZXJGb3JKKys7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGFiZWwgPSBTdHJpbmcoc2FtcGxlRGF0YVtleHRlcm5hbENvdW50ZXJGb3JKXVtjaGFydC5jdXJyZW50RGF0YS5kYXRhVGFibGUuZ3JvdXBdKS5yZXBsYWNlKC9cXHMvZywgJ18nKS5yZXBsYWNlKC9cXC4vZywgJ19kb3RfJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdnYW50dC1iYXInICsgaWkgKyAnIGVkaXRhYmxlIGVkaXRhYmxlLWJhciBiYXItY29sLScgKyBsYWJlbCArICctaW5kZXgtJyArIGlpICsgJyBoaWdobGlnaHQtY2xhc3MtJyArIGxhYmVsICsgJyByZWN0ICc7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgMClcclxuICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgeS5iYW5kd2lkdGgoKSAvIG51bUJhcnMpXHJcbiAgICAgICAgICAgIC5hdHRyKFwieFwiLCBmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRbc3RhcnREYXRlc1tpaV1dKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHgobmV3IERhdGUoZFtzdGFydERhdGVzW2lpXV0pKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuYXR0cihcInlcIiwgZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB5KGRbeUF4aXNEYXRhLmxhYmVsXSkgKyAoeS5iYW5kd2lkdGgoKSAvIG51bUJhcnMgKiBpaSk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5hdHRyKFwicnhcIiwgMylcclxuICAgICAgICAgICAgLmF0dHIoXCJyeVwiLCAzKVxyXG4gICAgICAgICAgICAuYXR0cihcImZpbGxcIiwgZnVuY3Rpb24gKGQsIGksIGopIHtcclxuICAgICAgICAgICAgICAgIHZhciB0eXBlVmFsID0gY2hhcnQuY3VycmVudERhdGEuZGF0YVRhYmxlW1wiVHlwZVwiICsgKGlpICsgMSldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoYXJ0Ll92YXJzLmxlZ2VuZEhlYWRlcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSBqdkNoYXJ0cy5nZXRDb2xvcnMoY29sb3JzLCAwLCBjaGFydC5fdmFycy5sZWdlbmRIZWFkZXJzW2lpXSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2xvciA9IGp2Q2hhcnRzLmdldENvbG9ycyhjb2xvcnMsIDAsIGNoYXJ0LmN1cnJlbnREYXRhLmxlZ2VuZERhdGFbaWldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBjb2xvcjtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICBnYW50dEJhcnNbaWldLnRyYW5zaXRpb24oKVxyXG4gICAgICAgICAgICAuZHVyYXRpb24oNDAwKVxyXG4gICAgICAgICAgICAuZGVsYXkoMTAwKVxyXG4gICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIGZ1bmN0aW9uIChkLCBpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSB4KG5ldyBEYXRlKGRbZW5kRGF0ZXNbaWldXSkpIC0geChuZXcgRGF0ZShkW3N0YXJ0RGF0ZXNbaWldXSkpOy8vKHgoZC5TdGFydERhdGUpIC0geChkLkVuZERhdGUpKTtcclxuICAgICAgICAgICAgICAgIGlmICh3aWR0aCA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpZHRoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdmFyIGV4dGVybmFsQ291bnRlckZvckpKID0gLTE7XHJcbiAgICB2YXIgZGF0YVRvUGxvdCA9IGp2Q2hhcnRzLmdldFBsb3REYXRhKGdhbnR0RGF0YU5ldywgY2hhcnQpO1xyXG4gICAgdmFyIGV2ZW50R3JvdXBzID0gYmFycy5zZWxlY3RBbGwoXCIuZXZlbnQtcmVjdFwiKVxyXG4gICAgICAgIC5kYXRhKGRhdGFUb1Bsb3QpXHJcbiAgICAgICAgLmVudGVyKClcclxuICAgICAgICAuYXBwZW5kKCdyZWN0JylcclxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiZXZlbnQtcmVjdFwiKVxyXG4gICAgICAgIC5hdHRyKCdjbGFzcycsIGZ1bmN0aW9uIChkLCBpLCBqKSB7XHJcbiAgICAgICAgICAgIGV4dGVybmFsQ291bnRlckZvckpKKys7XHJcbiAgICAgICAgICAgIHZhciBsYWJlbCA9IFN0cmluZyhzYW1wbGVEYXRhW2V4dGVybmFsQ291bnRlckZvckpKXVtjaGFydC5jdXJyZW50RGF0YS5kYXRhVGFibGUuZ3JvdXBdKS5yZXBsYWNlKC9cXHMvZywgJ18nKS5yZXBsYWNlKC9cXC4vZywgJ19kb3RfJyk7XHJcbiAgICAgICAgICAgIHJldHVybiAnZXZlbnQtcmVjdCBiYXItY29sLScgKyBsYWJlbDtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5hdHRyKFwieFwiLCAwKVxyXG4gICAgICAgIC5hdHRyKFwieVwiLCBmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICByZXR1cm4gY29udGFpbmVyLmhlaWdodCAvIGdhbnR0RGF0YU5ldy5sZW5ndGggKiBpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCBjb250YWluZXIud2lkdGgpXHJcbiAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5lci5oZWlnaHQgLyBnYW50dERhdGFOZXcubGVuZ3RoO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmF0dHIoXCJmaWxsXCIsIFwidHJhbnNwYXJlbnRcIilcclxuICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwLDApXCIpO1xyXG4gICAgZXZlbnRHcm91cHNcclxuICAgICAgICAub24oXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24gKGQsIGksIGopIHsgLy8gVHJhbnNpdGlvbnMgaW4gRDMgZG9uJ3Qgc3VwcG9ydCB0aGUgJ29uJyBmdW5jdGlvbiBUaGV5IG9ubHkgZXhpc3Qgb24gc2VsZWN0aW9ucy4gU28gbmVlZCB0byBtb3ZlIHRoYXQgZXZlbnQgbGlzdGVuZXIgYWJvdmUgdHJhbnNpdGlvbiBhbmQgYWZ0ZXIgYXBwZW5kXHJcbiAgICAgICAgICAgIGlmIChjaGFydC5zaG93VG9vbFRpcCkge1xyXG4gICAgICAgICAgICAgICAgLy9HZXQgdGlwIGRhdGFcclxuICAgICAgICAgICAgICAgIHZhciB0aXBEYXRhID0gY2hhcnQuc2V0VGlwRGF0YShkLCBpKTtcclxuICAgICAgICAgICAgICAgIC8vRHJhdyB0aXBcclxuICAgICAgICAgICAgICAgIGNoYXJ0LnRpcC5nZW5lcmF0ZVNpbXBsZVRpcCh0aXBEYXRhLCBjaGFydC5kYXRhLmRhdGFUYWJsZSk7XHJcbiAgICAgICAgICAgICAgICBjaGFydC50aXAuZCA9IGQ7XHJcbiAgICAgICAgICAgICAgICBjaGFydC50aXAuaSA9IGk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSlcclxuICAgICAgICAub24oXCJtb3VzZW1vdmVcIiwgZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgaWYgKGNoYXJ0LnNob3dUb29sVGlwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hhcnQudGlwLmQgPT09IGQgJiYgY2hhcnQudGlwLmkgPT09IGkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGFydC50aXAuc2hvd1RpcChkMy5ldmVudCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vR2V0IHRpcCBkYXRhXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpcERhdGEgPSBjaGFydC5zZXRUaXBEYXRhKGQsIGkpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vRHJhdyB0aXAgbGluZVxyXG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0LnRpcC5nZW5lcmF0ZVNpbXBsZVRpcCh0aXBEYXRhLCBjaGFydC5kYXRhLmRhdGFUYWJsZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICAgIC5vbihcIm1vdXNlb3V0XCIsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIGlmIChjaGFydC5zaG93VG9vbFRpcCkge1xyXG4gICAgICAgICAgICAgICAgY2hhcnQudGlwLmhpZGVUaXAoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIHZhciBjdXJyZW50RGF0ZSA9IG5ldyBEYXRlKCk7XHJcbiAgICB2YXIgZGF0ZURhdGEgPSBbY3VycmVudERhdGVdO1xyXG4gICAgLy9EcmF3cyBhIGxpbmUgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IGRhdGVcclxuICAgIHN2Zy5zZWxlY3RBbGwoXCIuY3VycmVudERhdGVMaW5lXCIpXHJcbiAgICAgICAgLmRhdGEoZGF0ZURhdGEpXHJcbiAgICAgICAgLmVudGVyKClcclxuICAgICAgICAuYXBwZW5kKFwibGluZVwiKVxyXG4gICAgICAgIC5hdHRyKFwieDFcIiwgZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHgoZCk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuYXR0cihcIngyXCIsIGZ1bmN0aW9uIChkLCBpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB4KGQpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmF0dHIoXCJ5MVwiLCBmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICByZXR1cm4gXCIwcHhcIjtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5hdHRyKFwieTJcIiwgZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNoYXJ0LmNvbmZpZy5jb250YWluZXIuaGVpZ2h0O1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImN1cnJlbnREYXRlTGluZVwiKVxyXG4gICAgICAgIC5hdHRyKFwic3Ryb2tlXCIsIGNoYXJ0Ll92YXJzLmF4aXNDb2xvcilcclxuICAgICAgICAuYXR0cihcInN0cm9rZS13aWR0aFwiLCBjaGFydC5fdmFycy5TVFJPS0VfV0lEVEgpXHJcbiAgICAgICAgLmF0dHIoXCJzdHJva2UtZGFzaGFycmF5XCIsIChcIjMsIDNcIikpO1xyXG5cclxuXHJcbiAgICBzdmcuc2VsZWN0QWxsKFwiLmN1cnJlbnREYXRlTGFiZWxcIilcclxuICAgICAgICAuZGF0YShkYXRlRGF0YSlcclxuICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgIC5hcHBlbmQoXCJ0ZXh0XCIpXHJcbiAgICAgICAgLnRleHQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdG9kYXkgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICAgICAgICB2YXIgZGQgPSB0b2RheS5nZXREYXRlKCk7XHJcbiAgICAgICAgICAgIHZhciBtbSA9IHRvZGF5LmdldE1vbnRoKCkgKyAxOyAvL0phbnVhcnkgaXMgMCFcclxuXHJcbiAgICAgICAgICAgIHZhciB5eXl5ID0gdG9kYXkuZ2V0RnVsbFllYXIoKTtcclxuICAgICAgICAgICAgaWYgKGRkIDwgMTApIHtcclxuICAgICAgICAgICAgICAgIGRkID0gJzAnICsgZGRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobW0gPCAxMCkge1xyXG4gICAgICAgICAgICAgICAgbW0gPSAnMCcgKyBtbVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB0b2RheSA9IG1tICsgJy8nICsgZGQgKyAnLycgKyB5eXl5O1xyXG4gICAgICAgICAgICByZXR1cm4gdG9kYXk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuYXR0cihcInhcIiwgZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHgoZCk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuYXR0cihcInlcIiwgZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFwiLTEwcHhcIjtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5hdHRyKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIilcclxuICAgICAgICAuYXR0cignZmlsbCcsIGNoYXJ0Ll92YXJzLmZvbnRDb2xvcik7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ganZDaGFydHM7IiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIganZDaGFydHMgPSByZXF1aXJlKCcuLi9qdkNoYXJ0cy5qcycpO1xyXG5cclxuanZDaGFydHMucHJvdG90eXBlLmhlYXRtYXAgPSB7XHJcbiAgICBwYWludDogcGFpbnQsXHJcbiAgICBzZXREYXRhOiBzZXREYXRhLFxyXG4gICAgZ2V0RXZlbnREYXRhOiBnZXRFdmVudERhdGFcclxufTtcclxuXHJcbmp2Q2hhcnRzLnByb3RvdHlwZS5nZW5lcmF0ZUhlYXRNYXAgPSBnZW5lcmF0ZUhlYXRNYXA7XHJcblxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIEhlYXRNYXAgZnVuY3Rpb25zICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcbmZ1bmN0aW9uIHF1YW50aXplZChjaGFydCwgbWluLCBtYXgpIHtcclxuICAgIGxldCBidWNrZXRDb3VudCA9IGNoYXJ0Ll92YXJzLmJ1Y2tldHMsXHJcbiAgICAgICAgc2VjdGlvblZhbHVlID0gKG1heCAtIG1pbikgLyBidWNrZXRDb3VudCxcclxuICAgICAgICBxdWFudGl6ZWRBcnJheSA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWNrZXRDb3VudDsgaSsrKSB7XHJcbiAgICAgICAgcXVhbnRpemVkQXJyYXlbaV0gPSBtaW4gKyBpICogc2VjdGlvblZhbHVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHF1YW50aXplZEFycmF5O1xyXG59XHJcblxyXG4vKipzZXREYXRhXHJcbiAqICBnZXRzIGhlYXRtYXAgZGF0YSBhbmQgYWRkcyBpdCB0byB0aGUgY2hhcnQgb2JqZWN0XHJcbiAqXHJcbiAqIEBwYXJhbXMgZGF0YSwgZGF0YVRhYmxlLCBjb2xvcnNcclxuICovXHJcbmZ1bmN0aW9uIHNldERhdGEoKSB7XHJcbiAgICBsZXQgY2hhcnQgPSB0aGlzLFxyXG4gICAgICAgIGF4aXNOYW1lcyA9IHNldEhlYXRBeGlzTmFtZXMoY2hhcnQuZGF0YSk7XHJcbiAgICBjaGFydC5kYXRhLnhBeGlzRGF0YSA9IGF4aXNOYW1lcy54QXhpc0RhdGE7XHJcbiAgICBjaGFydC5kYXRhLnlBeGlzRGF0YSA9IGF4aXNOYW1lcy55QXhpc0RhdGE7XHJcbiAgICBjaGFydC5kYXRhLnByb2Nlc3NlZERhdGEgPSBzZXRQcm9jZXNzZWREYXRhKGNoYXJ0LCBjaGFydC5kYXRhLCBjaGFydC5kYXRhLnhBeGlzRGF0YS52YWx1ZXMsIGNoYXJ0LmRhdGEueUF4aXNEYXRhLnZhbHVlcyk7XHJcbiAgICAvL2RlZmluZSBjb2xvciBvYmplY3QgZm9yIGNoYXJ0RGF0YVxyXG4gICAgY2hhcnQuX3ZhcnMuY29sb3IgPSBqdkNoYXJ0cy5zZXRDaGFydENvbG9ycyhjaGFydC5fdmFycy5jb2xvciwgY2hhcnQuZGF0YS54QXhpc0RhdGEudmFsdWVzLCBjaGFydC5jb2xvcnMpO1xyXG4gICAgY2hhcnQuZGF0YS5oZWF0RGF0YSA9IHNldEhlYXRtYXBMZWdlbmREYXRhKGNoYXJ0LCBjaGFydC5kYXRhKTtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIGdldEV2ZW50RGF0YShldmVudCwgbW91c2UpIHtcclxuICAgIGxldCBjaGFydCA9IHRoaXMsXHJcbiAgICAgICAgLy9kZXRlcm1pbmUgaWYgdGhlIGNsaWNrIGV2ZW50IGhhcHBlbnMgaW5zaWRlIHRoZSBjb250YWluZXJcclxuICAgICAgICBicnVzaENvbnRhaW5lciA9IGNoYXJ0LmNoYXJ0RGl2LnNlbGVjdCgnLicgKyBjaGFydC5jb25maWcudHlwZSArICctY29udGFpbmVyJykubm9kZSgpLFxyXG4gICAgICAgIGNvbnRhaW5lckJveCA9IGJydXNoQ29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxyXG4gICAgICAgIHggPSBtb3VzZVswXSxcclxuICAgICAgICB5ID0gbW91c2VbMV0sXHJcbiAgICAgICAgaW5zaWRlQ29udGFpbmVyID0gZmFsc2U7XHJcblxyXG4gICAgaWYgKHggPCBjb250YWluZXJCb3gucmlnaHQgJiYgeSA8IGNvbnRhaW5lckJveC5ib3R0b20gJiYgeCA+IGNvbnRhaW5lckJveC5sZWZ0ICYmIHkgPiBjb250YWluZXJCb3gudG9wKSB7XHJcbiAgICAgICAgaW5zaWRlQ29udGFpbmVyID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmIChpbnNpZGVDb250YWluZXIgJiYgZXZlbnQudGFyZ2V0Ll9fZGF0YV9fKSB7XHJcbiAgICAgICAgbGV0IGRhdGEgPSBldmVudC50YXJnZXQuX19kYXRhX187XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgW2NoYXJ0LmN1cnJlbnREYXRhLmRhdGFUYWJsZS5oZWF0XTogW2RhdGEudmFsdWVdLFxyXG4gICAgICAgICAgICAgICAgW2NoYXJ0LmN1cnJlbnREYXRhLmRhdGFUYWJsZS54XTogW2RhdGEueEF4aXNOYW1lXSxcclxuICAgICAgICAgICAgICAgIFtjaGFydC5jdXJyZW50RGF0YS5kYXRhVGFibGUueV06IFtkYXRhLnlBeGlzTmFtZV1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbm9kZTogZXZlbnQudGFyZ2V0XHJcbiAgICAgICAgfTtcclxuICAgIH0gZWxzZSBpZiAoaW5zaWRlQ29udGFpbmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZGF0YToge31cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBkYXRhOiBmYWxzZVxyXG4gICAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gc2V0SGVhdG1hcExlZ2VuZERhdGEoY2hhcnQsIGRhdGEpIHtcclxuICAgIGxldCBoZWF0RGF0YTtcclxuXHJcbiAgICBjaGFydC5fdmFycy5jb2xvcnMgPSBvcmdhbml6ZUNvbG9ycyhjaGFydCk7XHJcbiAgICBkYXRhLmhlYXRTY29yZXMuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xyXG5cclxuICAgIGNoYXJ0LmRhdGEuY29sb3JTY2FsZSA9IGQzLnNjYWxlUXVhbnRpbGUoKVxyXG4gICAgICAgIC5kb21haW4oZGF0YS5oZWF0U2NvcmVzKVxyXG4gICAgICAgIC5yYW5nZShjaGFydC5fdmFycy5jb2xvcnMpO1xyXG5cclxuICAgIGlmIChjaGFydC5fdmFycy5xdWFudGlsZXMgPT09IHRydWUpIHtcclxuICAgICAgICBsZXQgdGVtcCA9IGNoYXJ0LmRhdGEuY29sb3JTY2FsZS5xdWFudGlsZXMoKTtcclxuICAgICAgICBpZiAodGVtcFswXSA9PT0gMCkge1xyXG4gICAgICAgICAgICBoZWF0RGF0YSA9IGNoYXJ0LmRhdGEuY29sb3JTY2FsZS5xdWFudGlsZXMoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBoZWF0RGF0YSA9IFswXS5jb25jYXQoY2hhcnQuZGF0YS5jb2xvclNjYWxlLnF1YW50aWxlcygpKTtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGhlYXREYXRhID0gcXVhbnRpemVkKGNoYXJ0LCBkYXRhLmhlYXRTY29yZXNbMF0sIGRhdGEuaGVhdFNjb3Jlc1tkYXRhLmhlYXRTY29yZXMubGVuZ3RoIC0gMV0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBoZWF0RGF0YTtcclxufVxyXG5cclxuZnVuY3Rpb24gb3JnYW5pemVDb2xvcnMoY2hhcnQpIHtcclxuICAgIGxldCBjb2xvclNlbGVjdGVkQnVja2V0ID0gW10sXHJcbiAgICAgICAgc1ZhbHVlID0gY2hhcnQuX3ZhcnMuYnVja2V0cyxcclxuICAgICAgICBuZXdDb2xvcnMgPSBbXSxcclxuICAgICAgICBidWNrZXRNYXBwZXIgPSBbMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTBdLFxyXG4gICAgICAgIGJ1Y2tldENvdW50ID0gYnVja2V0TWFwcGVyW3NWYWx1ZSAtIDFdLFxyXG4gICAgICAgIGNvbG9ycztcclxuXHJcbiAgICBmb3IgKGxldCBjIGluIGNoYXJ0Ll92YXJzLmNvbG9ycykge1xyXG4gICAgICAgIGlmIChjaGFydC5fdmFycy5jb2xvcnMuaGFzT3duUHJvcGVydHkoYykpIHtcclxuICAgICAgICAgICAgY29sb3JTZWxlY3RlZEJ1Y2tldC5wdXNoKGNoYXJ0Ll92YXJzLmNvbG9yc1tjXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVja2V0Q291bnQ7IGkrKykge1xyXG4gICAgICAgIGlmIChpID49IGJ1Y2tldENvdW50IC8gMikge1xyXG4gICAgICAgICAgICBuZXdDb2xvcnNbaV0gPSBjb2xvclNlbGVjdGVkQnVja2V0W01hdGgucm91bmQoKGkgKyAxKSAvIGJ1Y2tldENvdW50ICogMjApIC0gMV07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbmV3Q29sb3JzW2ldID0gY29sb3JTZWxlY3RlZEJ1Y2tldFtNYXRoLnJvdW5kKChpKSAvIGJ1Y2tldENvdW50ICogMjApXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29sb3JzID0gbmV3Q29sb3JzLnNsaWNlKDApO1xyXG4gICAgcmV0dXJuIGNvbG9ycztcclxufVxyXG5cclxuZnVuY3Rpb24gc2V0SGVhdEF4aXNOYW1lcyhkYXRhKSB7XHJcbiAgICB2YXIgY2hhcnREYXRhID0gZGF0YS5jaGFydERhdGEsXHJcbiAgICAgICAgeEF4aXNOYW1lID0gZGF0YS5kYXRhVGFibGUueCxcclxuICAgICAgICB5QXhpc05hbWUgPSBkYXRhLmRhdGFUYWJsZS55LFxyXG4gICAgICAgIHhBeGlzQXJyYXkgPSBbXSxcclxuICAgICAgICB5QXhpc0FycmF5ID0gW10sXHJcbiAgICAgICAgcmV0dXJuT2JqID0ge307XHJcblxyXG4gICAgZm9yIChsZXQga2V5IG9mIGRhdGEuZGF0YVRhYmxlS2V5cykge1xyXG4gICAgICAgIGlmIChrZXkubW9kZWwgPT09ICd4Jykge1xyXG4gICAgICAgICAgICByZXR1cm5PYmoueEF4aXNEYXRhID0ge307XHJcbiAgICAgICAgICAgIHJldHVybk9iai54QXhpc0RhdGEuZGF0YVR5cGUgPSBrZXkudHlwZTtcclxuICAgICAgICAgICAgcmV0dXJuT2JqLnhBeGlzRGF0YS5sYWJlbCA9IGRhdGEuZGF0YVRhYmxlLng7XHJcbiAgICAgICAgfSBlbHNlIGlmIChrZXkubW9kZWwgPT09ICd5Jykge1xyXG4gICAgICAgICAgICByZXR1cm5PYmoueUF4aXNEYXRhID0ge307XHJcbiAgICAgICAgICAgIHJldHVybk9iai55QXhpc0RhdGEuZGF0YVR5cGUgPSBrZXkudHlwZTtcclxuICAgICAgICAgICAgcmV0dXJuT2JqLnlBeGlzRGF0YS5sYWJlbCA9IGRhdGEuZGF0YVRhYmxlLnk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZvciAobGV0IGVsZSBvZiBjaGFydERhdGEpIHtcclxuICAgICAgICBpZiAoeEF4aXNBcnJheS5pbmRleE9mKGVsZVt4QXhpc05hbWVdKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgeEF4aXNBcnJheS5wdXNoKGVsZVt4QXhpc05hbWVdKTtcclxuICAgICAgICAgICAgLy9UT0RPIG1ha2UgaW50byAxIGZ1bmN0aW9uIGZvciBtaW4gbWF4Li4uIHdhc3RlIG9mIHNwYWNlXHJcbiAgICAgICAgICAgIGlmIChyZXR1cm5PYmoueEF4aXNEYXRhLmRhdGFUeXBlID09PSAnTlVNQkVSJykge1xyXG4gICAgICAgICAgICAgICAgLy9wdXNoIG1pbiBhbmQgbWF4IGluZm9cclxuICAgICAgICAgICAgICAgIGlmICghcmV0dXJuT2JqLnhBeGlzRGF0YS5taW4pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm5PYmoueEF4aXNEYXRhLm1pbiA9IGVsZVt4QXhpc05hbWVdO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlbGVbeEF4aXNOYW1lXSA8IHJldHVybk9iai54QXhpc0RhdGEubWluKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuT2JqLnhBeGlzRGF0YS5taW4gPSBlbGVbeEF4aXNOYW1lXTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIXJldHVybk9iai54QXhpc0RhdGEubWF4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuT2JqLnhBeGlzRGF0YS5tYXggPSBlbGVbeEF4aXNOYW1lXTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZWxlW3hBeGlzTmFtZV0gPCByZXR1cm5PYmoueEF4aXNEYXRhLm1heCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybk9iai54QXhpc0RhdGEubWF4ID0gZWxlW3hBeGlzTmFtZV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHlBeGlzQXJyYXkuaW5kZXhPZihlbGVbeUF4aXNOYW1lXSkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIHlBeGlzQXJyYXkucHVzaChlbGVbeUF4aXNOYW1lXSk7XHJcbiAgICAgICAgICAgIGlmIChyZXR1cm5PYmoueUF4aXNEYXRhLmRhdGFUeXBlID09PSAnTlVNQkVSJykge1xyXG4gICAgICAgICAgICAgICAgLy9wdXNoIG1pbiBhbmQgbWF4IGluZm9cclxuICAgICAgICAgICAgICAgIGlmICghcmV0dXJuT2JqLnlBeGlzRGF0YS5taW4pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm5PYmoueUF4aXNEYXRhLm1pbiA9IGVsZVt5QXhpc05hbWVdO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlbGVbeUF4aXNOYW1lXSA8IHJldHVybk9iai55QXhpc0RhdGEubWluKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuT2JqLnlBeGlzRGF0YS5taW4gPSBlbGVbeUF4aXNOYW1lXTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIXJldHVybk9iai55QXhpc0RhdGEubWF4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuT2JqLnlBeGlzRGF0YS5tYXggPSBlbGVbeUF4aXNOYW1lXTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZWxlW3lBeGlzTmFtZV0gPCByZXR1cm5PYmoueUF4aXNEYXRhLm1heCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybk9iai55QXhpc0RhdGEubWF4ID0gZWxlW3lBeGlzTmFtZV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm5PYmoueEF4aXNEYXRhLnZhbHVlcyA9IHhBeGlzQXJyYXk7XHJcbiAgICByZXR1cm5PYmoueUF4aXNEYXRhLnZhbHVlcyA9IHlBeGlzQXJyYXk7XHJcblxyXG4gICAgcmV0dXJuIHJldHVybk9iajtcclxufVxyXG5cclxuZnVuY3Rpb24gc2V0UHJvY2Vzc2VkRGF0YShjaGFydCwgZGF0YSwgeEF4aXNBcnJheSwgeUF4aXNBcnJheSkge1xyXG4gICAgdmFyIGNoYXJ0RGF0YSA9IGRhdGEuY2hhcnREYXRhLFxyXG4gICAgICAgIHhBeGlzTmFtZSA9IGRhdGEuZGF0YVRhYmxlLngsXHJcbiAgICAgICAgeUF4aXNOYW1lID0gZGF0YS5kYXRhVGFibGUueSxcclxuICAgICAgICBoZWF0ID0gZGF0YS5kYXRhVGFibGUuaGVhdCxcclxuICAgICAgICBkYXRhQXJyYXkgPSBbXSxcclxuICAgICAgICBrZXlzO1xyXG5cclxuICAgIGRhdGEuaGVhdFNjb3JlcyA9IFtdO1xyXG4gICAgLypBc3NpZ24gZWFjaCBuYW1lIGEgbnVtYmVyIGFuZCBwbGFjZSBtYXRyaXggY29vcmRpbmF0ZXMgaW5zaWRlIG9mIGRhdGFBcnJheSAqL1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFydERhdGEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBkYXRhQXJyYXkucHVzaCh7XHJcbiAgICAgICAgICAgIHZhbHVlOiBjaGFydERhdGFbaV1baGVhdF0sXHJcbiAgICAgICAgICAgIHhBeGlzTmFtZTogY2hhcnREYXRhW2ldW3hBeGlzTmFtZV0sXHJcbiAgICAgICAgICAgIHlBeGlzTmFtZTogY2hhcnREYXRhW2ldW3lBeGlzTmFtZV1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEuZGF0YVRhYmxlKTtcclxuICAgICAgICBmb3IgKGxldCBrZXkgb2Yga2V5cykge1xyXG4gICAgICAgICAgICBpZiAoa2V5LmluZGV4T2YoJ3Rvb2x0aXAnKSA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBkYXRhQXJyYXlbaV1ba2V5XSA9IGNoYXJ0RGF0YVtpXVtkYXRhLmRhdGFUYWJsZVtrZXldXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9UaGlzIGFycmF5IHN0b3JlcyB0aGUgdmFsdWVzIGFzIG51bWJlcnNcclxuICAgICAgICBkYXRhLmhlYXRTY29yZXMucHVzaChjaGFydERhdGFbaV1baGVhdF0pO1xyXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgeEF4aXNBcnJheS5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICBpZiAoeEF4aXNBcnJheVtqXSA9PT0gZGF0YUFycmF5W2ldLnhBeGlzTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgZGF0YUFycmF5W2ldLnhBeGlzID0gajtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgeUF4aXNBcnJheS5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICBpZiAoeUF4aXNBcnJheVtqXSA9PT0gZGF0YUFycmF5W2ldLnlBeGlzTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgZGF0YUFycmF5W2ldLnlBeGlzID0gajtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBkYXRhQXJyYXk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhaW50KCkge1xyXG4gICAgdmFyIGNoYXJ0ID0gdGhpcyxcclxuICAgICAgICBjdXN0b21NYXJnaW4gPSB7XHJcbiAgICAgICAgICAgIHRvcDogMCxcclxuICAgICAgICAgICAgcmlnaHQ6IDQwLFxyXG4gICAgICAgICAgICBsZWZ0OiAwLFxyXG4gICAgICAgICAgICBib3R0b206IDIwXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICBjaGFydC5fdmFycy5jb2xvciA9IGNoYXJ0LmRhdGEuY29sb3I7XHJcbiAgICBjaGFydC5jdXJyZW50RGF0YSA9IGNoYXJ0LmRhdGE7Ly9NaWdodCBoYXZlIHRvIG1vdmUgaW50byBtZXRob2QgYmMgb2YgcmVmZXJlbmNlL3ZhbHVlIHJlbGF0aW9uc2hpcFxyXG5cclxuICAgIC8vR2VuZXJhdGUgU1ZHLWxlZ2VuZCBkYXRhIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBzaXplIG9mIHRoZSBib3R0b20gbWFyZ2luIChzZXQgdG8gbnVsbCBmb3Igbm8gbGVnZW5kKVxyXG4gICAgY2hhcnQuZ2VuZXJhdGVTVkcobnVsbCwgY3VzdG9tTWFyZ2luKTtcclxuICAgIC8vY2hhcnQuZ2VuZXJhdGVMZWdlbmQoY2hhcnQuY3VycmVudERhdGEubGVnZW5kRGF0YSwgJ2dlbmVyYXRlSGVhdE1hcCcpO1xyXG4gICAgY2hhcnQuZ2VuZXJhdGVIZWF0TWFwKCk7XHJcbn1cclxuXHJcbi8qKmdlbmVyYXRlSGVhdE1hcFxyXG4gKlxyXG4gKiBwYWludHMgdGhlIEhlYXRNYXAgb24gdGhlIGNoYXJ0XHJcbiAqIEBwYXJhbXMgSGVhdE1hcERhdGFcclxuICovXHJcbmZ1bmN0aW9uIGdlbmVyYXRlSGVhdE1hcCgpIHtcclxuICAgIHZhciBjaGFydCA9IHRoaXMsXHJcbiAgICAgICAgc3ZnID0gY2hhcnQuc3ZnLFxyXG4gICAgICAgIGNvbG9ycyA9IGNoYXJ0Ll92YXJzLmNvbG9ycyxcclxuICAgICAgICBxdWFudGlsZXMgPSBjaGFydC5fdmFycy5xdWFudGlsZXMsXHJcbiAgICAgICAgZGF0YSA9IGNoYXJ0LmRhdGEucHJvY2Vzc2VkRGF0YSxcclxuICAgICAgICB0b2dnbGVMZWdlbmQgPSAhY2hhcnQuX3ZhcnMudG9nZ2xlTGVnZW5kLFxyXG4gICAgICAgIGhlYXRNYXBEYXRhID0gY2hhcnQuY3VycmVudERhdGEsXHJcbiAgICAgICAgZ3JpZFNpemUgPSBjaGFydC5fdmFycy5oZWF0R3JpZFNpemUsXHJcbiAgICAgICAgbGVnZW5kU3BhY2luZyA9IGNoYXJ0Ll92YXJzLmhlYXRMZWdlbmRTcGFjaW5nLFxyXG4gICAgICAgIHZpcyxcclxuICAgICAgICB5QXhpc1RpdGxlO1xyXG5cclxuICAgIGQzLnNlbGVjdCgnYm9keScpLmFwcGVuZCgnZGl2JylcclxuICAgICAgICAuYXR0cignY2xhc3MnLCAndG9vbHRpcCcpXHJcbiAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMCk7XHJcbiAgICB2aXMgPSBzdmcuYXBwZW5kKCdnJykuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLDApJykuYXR0cignY2xhc3MnLCAnaGVhdG1hcCcpO1xyXG5cclxuXHJcbiAgICB5QXhpc1RpdGxlID0gdmlzLnNlbGVjdEFsbCgnLmhlYXRtYXAnKVxyXG4gICAgICAgIC5kYXRhKFtoZWF0TWFwRGF0YS5kYXRhVGFibGUueV0pO1xyXG5cclxuICAgIHlBeGlzVGl0bGUuZW50ZXIoKS5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICdheGlzTGFiZWxzIGJvbGQnKVxyXG4gICAgICAgIC5hdHRyKCd4JywgLTIxKVxyXG4gICAgICAgIC5hdHRyKCd5JywgLTUpXHJcbiAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ2VuZCcpXHJcbiAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICgpID0+ICd0cmFuc2xhdGUoLScgKyAoY2hhcnQuX3ZhcnMuaGVhdG1hcFltYXJnaW4gKyAxMCkgKyAnLCcgKyAwICsgJylyb3RhdGUoLTkwKScpXHJcbiAgICAgICAgLnRleHQoZCA9PiBkKTtcclxuXHJcbiAgICB5QXhpc1RpdGxlLmV4aXQoKS5yZW1vdmUoKTtcclxuICAgIHZhciBmb3JtYXRUeXBlID0ganZDaGFydHMuanZGb3JtYXRWYWx1ZVR5cGUoY2hhcnQuY3VycmVudERhdGEueUF4aXNEYXRhLnZhbHVlcywgY2hhcnQuY3VycmVudERhdGEueUF4aXNEYXRhLmRhdGFUeXBlKTtcclxuXHJcbiAgICB2YXIgeUF4aXNTZWN0aW9uID0gdmlzLmFwcGVuZCgnc3ZnOmcnKVxyXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICd5QXhpc1NlY3Rpb24nKTtcclxuXHJcbiAgICB2YXIgeUF4aXMgPSB5QXhpc1NlY3Rpb24uc2VsZWN0QWxsKCcueEF4aXMnKVxyXG4gICAgICAgIC5kYXRhKGhlYXRNYXBEYXRhLnlBeGlzRGF0YS52YWx1ZXMpXHJcbiAgICAgICAgLmVudGVyKCkuYXBwZW5kKCdzdmc6ZycpO1xyXG5cclxuICAgIHlBeGlzLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgLnRleHQoZCA9PiB7XHJcbiAgICAgICAgICAgIHZhciBzdHIgPSBqdkNoYXJ0cy5qdkZvcm1hdFZhbHVlKGQsIGZvcm1hdFR5cGUpO1xyXG4gICAgICAgICAgICBpZiAoc3RyLmxlbmd0aCA+IDE1KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyLnN1YnN0cmluZygwLCAxNCkgKyAnLi4uJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmF0dHIoJ3gnLCAwKVxyXG4gICAgICAgIC5hdHRyKCd5JywgKGQsIGkpID0+IGkgKiBncmlkU2l6ZSlcclxuICAgICAgICAuc3R5bGUoJ3RleHQtYW5jaG9yJywgJ2VuZCcpXHJcbiAgICAgICAgLnN0eWxlKCdmb250LXNpemUnLCBjaGFydC5fdmFycy5mb250U2l6ZSlcclxuICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgtNiwnICsgZ3JpZFNpemUgLyAxLjUgKyAnKScpXHJcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3Jvd0xhYmVsIHBvaW50ZXInKVxyXG4gICAgICAgIC5vbignY2xpY2snLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAvL3JlbW92aW5nIHN0eWxpbmdcclxuICAgICAgICAgICAgZDMuc2VsZWN0QWxsKCcucm93TGFiZWwnKS5jbGFzc2VkKCd0ZXh0LWhpZ2hsaWdodCcsIGZhbHNlKTtcclxuICAgICAgICAgICAgZDMuc2VsZWN0QWxsKCcuY29sTGFiZWwnKS5jbGFzc2VkKCd0ZXh0LWhpZ2hsaWdodCcsIGZhbHNlKTtcclxuICAgICAgICAgICAgZDMuc2VsZWN0QWxsKCcuaGVhdCcpLmNsYXNzZWQoJ3JlY3QtaGlnaGxpZ2h0JywgZmFsc2UpO1xyXG4gICAgICAgICAgICBkMy5zZWxlY3RBbGwoJy5oZWF0JykuY2xhc3NlZCgncmVjdC1ib3JkZXInLCBmYWxzZSk7XHJcblxyXG4gICAgICAgICAgICBsZXQgcGFpbnRCb29sID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKGQgPT09IGNoYXJ0Ll92YXJzLnNlbGVjdGVkWCkge1xyXG4gICAgICAgICAgICAgICAgY2hhcnQuX3ZhcnMuc2VsZWN0ZWRYID0gJyc7XHJcbiAgICAgICAgICAgICAgICBwYWludEJvb2wgPSBmYWxzZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNoYXJ0Ll92YXJzLnNlbGVjdGVkWCA9IGQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vZmFkZSBhbGwgcmVjdHMgZXhjZXB0IGluIHRoaXMgcm93XHJcbiAgICAgICAgICAgIGQzLnNlbGVjdEFsbCgnLmhlYXQnKS5jbGFzc2VkKCdyZWN0LWhpZ2hsaWdodCcsIHIgPT4ge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFydC5jdXJyZW50RGF0YS55QXhpc0RhdGEudmFsdWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJ0LmN1cnJlbnREYXRhLnlBeGlzRGF0YS52YWx1ZXNbaV0gPT09IGQgJiYgZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoci55QXhpcyAhPT0gaSAmJiBwYWludEJvb2wpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICB5QXhpcy5hcHBlbmQoJ3RpdGxlJylcclxuICAgICAgICAudGV4dChkID0+IGQpO1xyXG5cclxuXHJcbiAgICB2YXIgeEF4aXNUaXRsZSA9IHZpcy5zZWxlY3RBbGwoJy54QXhpc1RpdGxlJylcclxuICAgICAgICAuZGF0YShbaGVhdE1hcERhdGEuZGF0YVRhYmxlLnhdKTtcclxuXHJcbiAgICB4QXhpc1RpdGxlLmVudGVyKCkuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAuYXR0cignY2xhc3MnLCAnYXhpc0xhYmVscyBib2xkJylcclxuICAgICAgICAuYXR0cigneCcsIDYpXHJcbiAgICAgICAgLmF0dHIoJ3knLCA5KVxyXG4gICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKDAsIC0ke2NoYXJ0Ll92YXJzLmhlYXRtYXBYbWFyZ2luIC0gMTB9KWApXHJcbiAgICAgICAgLnRleHQoZCA9PiBkKTtcclxuXHJcbiAgICB4QXhpc1RpdGxlLmV4aXQoKS5yZW1vdmUoKTtcclxuXHJcbiAgICB2YXIgeEF4aXNTZWN0aW9uID0gdmlzLmFwcGVuZCgnc3ZnOmcnKVxyXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICd4QXhpc1NlY3Rpb24nKTtcclxuXHJcbiAgICB2YXIgeEF4aXMgPSB4QXhpc1NlY3Rpb24uc2VsZWN0QWxsKCcueEF4aXMnKVxyXG4gICAgICAgIC5kYXRhKGhlYXRNYXBEYXRhLnhBeGlzRGF0YS52YWx1ZXMpXHJcbiAgICAgICAgLmVudGVyKCkuYXBwZW5kKCdzdmc6ZycpO1xyXG5cclxuICAgIGZvcm1hdFR5cGUgPSBqdkNoYXJ0cy5qdkZvcm1hdFZhbHVlVHlwZShjaGFydC5jdXJyZW50RGF0YS54QXhpc0RhdGEudmFsdWVzLCBjaGFydC5jdXJyZW50RGF0YS54QXhpc0RhdGEuZGF0YVR5cGUpO1xyXG5cclxuICAgIHhBeGlzLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgLnRleHQoZCA9PiB7XHJcbiAgICAgICAgICAgIHZhciBzdHIgPSBqdkNoYXJ0cy5qdkZvcm1hdFZhbHVlKGQsIGZvcm1hdFR5cGUpO1xyXG4gICAgICAgICAgICBpZiAoc3RyLmxlbmd0aCA+IDE1KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyLnN1YnN0cmluZygwLCAxNCkgKyAnLi4uJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLnN0eWxlKCd0ZXh0LWFuY2hvcicsICdzdGFydCcpXHJcbiAgICAgICAgLmF0dHIoJ3gnLCA2KVxyXG4gICAgICAgIC5hdHRyKCd5JywgNylcclxuICAgICAgICAuYXR0cignY2xhc3MnLCAnY29sTGFiZWwgcG9pbnRlcicpXHJcbiAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIChkLCBpKSA9PiBgdHJhbnNsYXRlKCR7aSAqIGdyaWRTaXplfSwgLTYpcm90YXRlKC00NSlgKVxyXG4gICAgICAgIC5hdHRyKCd0aXRsZScsIGQgPT4gZClcclxuICAgICAgICAuc3R5bGUoJ2ZvbnQtc2l6ZScsIGNoYXJ0Ll92YXJzLmZvbnRTaXplKVxyXG4gICAgICAgIC5vbignY2xpY2snLCBkID0+IHtcclxuICAgICAgICAgICAgLy9yZW1vdmluZyBzdHlsaW5nXHJcbiAgICAgICAgICAgIGQzLnNlbGVjdEFsbCgnLnJvd0xhYmVsJykuY2xhc3NlZCgndGV4dC1oaWdobGlnaHQnLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIGQzLnNlbGVjdEFsbCgnLmNvbExhYmVsJykuY2xhc3NlZCgndGV4dC1oaWdobGlnaHQnLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIGQzLnNlbGVjdEFsbCgnLmhlYXQnKS5jbGFzc2VkKCdyZWN0LWhpZ2hsaWdodCcsIGZhbHNlKTtcclxuICAgICAgICAgICAgZDMuc2VsZWN0QWxsKCcuaGVhdCcpLmNsYXNzZWQoJ3JlY3QtYm9yZGVyJywgZmFsc2UpO1xyXG5cclxuICAgICAgICAgICAgbGV0IHBhaW50Qm9vbCA9IHRydWU7XHJcbiAgICAgICAgICAgIGlmIChkID09PSBjaGFydC5fdmFycy5zZWxlY3RlZFgpIHtcclxuICAgICAgICAgICAgICAgIGNoYXJ0Ll92YXJzLnNlbGVjdGVkWCA9ICcnO1xyXG4gICAgICAgICAgICAgICAgcGFpbnRCb29sID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjaGFydC5fdmFycy5zZWxlY3RlZFggPSBkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vZmFkZSBhbGwgcmVjdHMgZXhjZXB0IGluIHRoaXMgY29sdW1uXHJcbiAgICAgICAgICAgIGQzLnNlbGVjdEFsbCgnLmhlYXQnKS5jbGFzc2VkKCdyZWN0LWhpZ2hsaWdodCcsIHIgPT4ge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFydC5jdXJyZW50RGF0YS54QXhpc0RhdGEudmFsdWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJ0LmN1cnJlbnREYXRhLnhBeGlzRGF0YS52YWx1ZXNbaV0gPT09IGQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIueEF4aXMgIT09IGkgJiYgcGFpbnRCb29sKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgeEF4aXMuYXBwZW5kKCd0aXRsZScpXHJcbiAgICAgICAgLnRleHQoZCA9PiBkKTtcclxuXHJcbiAgICB2YXIgd2lkdGggPSBoZWF0TWFwRGF0YS54QXhpc0RhdGEudmFsdWVzLmxlbmd0aCAqIGdyaWRTaXplO1xyXG4gICAgdmFyIGhlaWdodCA9IGhlYXRNYXBEYXRhLnlBeGlzRGF0YS52YWx1ZXMubGVuZ3RoICogZ3JpZFNpemU7XHJcbiAgICB2YXIgZm9ybWF0VmFsdWVUeXBlID0ganZDaGFydHMuanZGb3JtYXRWYWx1ZVR5cGUoY2hhcnQuZGF0YS5oZWF0RGF0YSk7XHJcblxyXG4gICAgLy92ZXJ0aWNhbCBsaW5lc1xyXG4gICAgdmFyIHZMaW5lID0gdmlzLmFwcGVuZCgnc3ZnOmcnKVxyXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICd2TGluZVNlY3Rpb24nKTtcclxuXHJcbiAgICB2TGluZS5zZWxlY3RBbGwoJy52TGluZVNlY3Rpb24nKVxyXG4gICAgICAgIC5kYXRhKGQzLnJhbmdlKGhlYXRNYXBEYXRhLnhBeGlzRGF0YS52YWx1ZXMubGVuZ3RoICsgMSkpXHJcbiAgICAgICAgLmVudGVyKCkuYXBwZW5kKCdsaW5lJylcclxuICAgICAgICAuYXR0cigneDEnLCBkID0+IGQgKiBncmlkU2l6ZSlcclxuICAgICAgICAuYXR0cigneDInLCBkID0+IGQgKiBncmlkU2l6ZSlcclxuICAgICAgICAuYXR0cigneTEnLCAwKVxyXG4gICAgICAgIC5hdHRyKCd5MicsIGhlaWdodClcclxuICAgICAgICAuc3R5bGUoJ3N0cm9rZScsIGNoYXJ0Ll92YXJzLmF4aXNDb2xvcik7XHJcblxyXG4gICAgLy9ob3Jpem9udGFsIGxpbmVzXHJcbiAgICB2YXIgaExpbmUgPSB2aXMuYXBwZW5kKCdzdmc6ZycpXHJcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2hlYXRtYXAtY29udGFpbmVyJyk7XHJcblxyXG4gICAgaExpbmUuc2VsZWN0QWxsKCcuaGVhdG1hcC1jb250YWluZXInKVxyXG4gICAgICAgIC5kYXRhKGQzLnJhbmdlKGhlYXRNYXBEYXRhLnlBeGlzRGF0YS52YWx1ZXMubGVuZ3RoICsgMSkpXHJcbiAgICAgICAgLmVudGVyKCkuYXBwZW5kKCdsaW5lJylcclxuICAgICAgICAuYXR0cigneDEnLCAwKVxyXG4gICAgICAgIC5hdHRyKCd4MicsIHdpZHRoKVxyXG4gICAgICAgIC5hdHRyKCd5MScsIGQgPT4gZCAqIGdyaWRTaXplKVxyXG4gICAgICAgIC5hdHRyKCd5MicsIGQgPT4gZCAqIGdyaWRTaXplKVxyXG4gICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgY2hhcnQuX3ZhcnMuYXhpc0NvbG9yKTtcclxuXHJcbiAgICB2YXIgaGVhdE1hcCA9IHZpcy5hcHBlbmQoJ3N2ZzpnJylcclxuICAgICAgICAuYXR0cignY2xhc3MnLCAnaGVhdFNlY3Rpb24nKTtcclxuXHJcbiAgICBoZWF0TWFwLnNlbGVjdEFsbCgnLmhlYXRTZWN0aW9uJylcclxuICAgICAgICAuZGF0YShkYXRhKVxyXG4gICAgICAgIC5lbnRlcigpLmFwcGVuZCgncmVjdCcpXHJcbiAgICAgICAgLmF0dHIoJ3gnLCBkID0+IGQueEF4aXMgKiBncmlkU2l6ZSlcclxuICAgICAgICAuYXR0cigneScsIGQgPT4gZC55QXhpcyAqIGdyaWRTaXplKVxyXG4gICAgICAgIC5hdHRyKCdyeCcsIDIpXHJcbiAgICAgICAgLmF0dHIoJ3J5JywgMilcclxuICAgICAgICAuYXR0cignY2xhc3MnLCAnaGVhdCcpXHJcbiAgICAgICAgLmF0dHIoJ3dpZHRoJywgZ3JpZFNpemUgLSAxKVxyXG4gICAgICAgIC5hdHRyKCdoZWlnaHQnLCBncmlkU2l6ZSAtIDEpXHJcbiAgICAgICAgLnN0eWxlKCdmaWxsJywgZCA9PiB7XHJcbiAgICAgICAgICAgIGlmIChxdWFudGlsZXMgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjaGFydC5fdmFycy5kb21haW5BcnJheS5sZW5ndGggPT09IDAgfHwgKGQudmFsdWUgPj0gY2hhcnQuX3ZhcnMuZG9tYWluQXJyYXlbMF0gJiYgZC52YWx1ZSA8PSBjaGFydC5fdmFycy5kb21haW5BcnJheVsxXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hhcnQuZGF0YS5jb2xvclNjYWxlKGQudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICd3aGl0ZSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNoYXJ0Ll92YXJzLmRvbWFpbkFycmF5Lmxlbmd0aCA9PT0gMCB8fCAoZC52YWx1ZSA+PSBjaGFydC5fdmFycy5kb21haW5BcnJheVswXSAmJiBkLnZhbHVlIDw9IGNoYXJ0Ll92YXJzLmRvbWFpbkFycmF5WzFdKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldFF1YW50aXplZENvbG9yKGNoYXJ0LmRhdGEuaGVhdERhdGEsIGQudmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAnd2hpdGUnO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICAvL0dldCB0aXAgZGF0YVxyXG4gICAgICAgICAgICB2YXIgdGlwRGF0YSA9IGNoYXJ0LnNldFRpcERhdGEoZCwgaSk7XHJcbiAgICAgICAgICAgIHRpcERhdGEuY29sb3IgPSBjaGFydC5kYXRhLmNvbG9yU2NhbGUoZC52YWx1ZSk7XHJcblxyXG4gICAgICAgICAgICAvL0RyYXcgdGlwXHJcbiAgICAgICAgICAgIGNoYXJ0LnRpcC5nZW5lcmF0ZVNpbXBsZVRpcCh0aXBEYXRhLCBjaGFydC5kYXRhLmRhdGFUYWJsZSk7XHJcbiAgICAgICAgICAgIGNoYXJ0LnRpcC5kID0gZDtcclxuICAgICAgICAgICAgY2hhcnQudGlwLmkgPSBpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLm9uKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICBpZiAoY2hhcnQuc2hvd1Rvb2xUaXApIHtcclxuICAgICAgICAgICAgICAgIGlmIChjaGFydC50aXAuZCA9PT0gZCAmJiBjaGFydC50aXAuaSA9PT0gaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0LnRpcC5zaG93VGlwKGQzLmV2ZW50KTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9HZXQgdGlwIGRhdGFcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGlwRGF0YSA9IGNoYXJ0LnNldFRpcERhdGEoZCwgaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9EcmF3IHRpcCBsaW5lXHJcbiAgICAgICAgICAgICAgICAgICAgY2hhcnQudGlwLmdlbmVyYXRlU2ltcGxlVGlwKHRpcERhdGEsIGNoYXJ0LmRhdGEuZGF0YVRhYmxlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY2hhcnQudGlwLmhpZGVUaXAoKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5vbignZGJsY2xpY2snLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICBjaGFydC5jbGlja2VkID0gIWNoYXJ0LmNsaWNrZWQ7XHJcbiAgICAgICAgICAgIGlmIChjaGFydC5jbGlja2VkKSB7XHJcbiAgICAgICAgICAgICAgICAvL2JvcmRlciBhcm91bmQgc2VsZWN0ZWQgcmVjdFxyXG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmNsYXNzZWQoJ3JlY3QtYm9yZGVyJywgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAvL0ZhZGUgcm93IGxhYmVsc1xyXG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0QWxsKCcucm93TGFiZWwnKS5jbGFzc2VkKCd0ZXh0LWhpZ2hsaWdodCcsIChyLCByaSkgPT4gcmkgIT0gZC55QXhpcyk7XHJcbiAgICAgICAgICAgICAgICAvL2ZhZGUgY29sdW1uIGxhYmVsc1xyXG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0QWxsKCcuY29sTGFiZWwnKS5jbGFzc2VkKCd0ZXh0LWhpZ2hsaWdodCcsIChyLCByaSkgPT4gcmkgIT0gZC54QXhpcyk7XHJcbiAgICAgICAgICAgICAgICAvL2ZhZGUgYWxsIHJlY3RzIGV4Y2VwdCBzZWxlY3RlZFxyXG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0QWxsKCcuaGVhdCcpLmNsYXNzZWQoJ3JlY3QtaGlnaGxpZ2h0JywgciA9PiByLnlBeGlzICE9IGQueUF4aXMgfHwgci54QXhpcyAhPSBkLnhBeGlzKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vcmVtb3Zpbmcgc3R5bGluZ1xyXG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0QWxsKCcucm93TGFiZWwnKS5jbGFzc2VkKCd0ZXh0LWhpZ2hsaWdodCcsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIGQzLnNlbGVjdEFsbCgnLmNvbExhYmVsJykuY2xhc3NlZCgndGV4dC1oaWdobGlnaHQnLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICBkMy5zZWxlY3RBbGwoJy5oZWF0JykuY2xhc3NlZCgncmVjdC1oaWdobGlnaHQnLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICBkMy5zZWxlY3RBbGwoJy5oZWF0JykuY2xhc3NlZCgncmVjdC1ib3JkZXInLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcblxyXG4gICAgY2hhcnQuY2hhcnREaXYuc2VsZWN0KCdzdmcuaGVhdExlZ2VuZCcpLnJlbW92ZSgpO1xyXG5cclxuICAgIGlmICh0b2dnbGVMZWdlbmQpIHtcclxuICAgICAgICB2YXIgbGVnZW5kQ29udGFpbmVyID0gY2hhcnQuY2hhcnREaXYuYXBwZW5kKCdzdmcnKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ3RvcCcsIGNoYXJ0LmNvbmZpZy5tYXJnaW4udG9wICsgJ3B4JylcclxuICAgICAgICAgICAgLnN0eWxlKCdiYWNrZ3JvdW5kJywgY2hhcnQuX3ZhcnMuYmFja2dyb3VuZENvbG9yKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnaGVhdExlZ2VuZCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIGNoYXJ0LmNvbmZpZy5oZWF0V2lkdGgpO1xyXG5cclxuICAgICAgICB2YXIgbGVnZW5kID0gbGVnZW5kQ29udGFpbmVyLnNlbGVjdEFsbCgnLmxlZ2VuZCcpXHJcbiAgICAgICAgICAgIC5kYXRhKGNoYXJ0LmRhdGEuaGVhdERhdGEpXHJcbiAgICAgICAgICAgIC5lbnRlcigpLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAoZCwgaSkgPT4gYHRyYW5zbGF0ZSgwLCAke2dyaWRTaXplICogaX0gKWApO1xyXG5cclxuICAgICAgICBsZWdlbmQuYXBwZW5kKCdyZWN0JylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2xlZ2VuZCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIGdyaWRTaXplKVxyXG4gICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgZ3JpZFNpemUpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIChkLCBpKSA9PiBjb2xvcnNbaV0pXHJcbiAgICAgICAgICAgIC5vbignY2xpY2snLCAoKSA9PiBkMy5zZWxlY3RBbGwoJy5oZWF0JykuY2xhc3NlZCgncmVjdC1oaWdobGlnaHQnLCBmYWxzZSkpXHJcbiAgICAgICAgICAgIC8vcmVtb3Zpbmcgc3R5bGluZ1xyXG4gICAgICAgICAgICAvL2ZhZGUgYWxsIHJlY3RzIGV4Y2VwdCBzZWxlY3RlZFxyXG4gICAgICAgICAgICAub24oJ2RibGNsaWNrJywgZCA9PiBkMy5zZWxlY3RBbGwoJy5oZWF0JykuY2xhc3NlZCgncmVjdC1oaWdobGlnaHQnLCByID0+IHIudmFsdWUgPCBkKSk7XHJcblxyXG4gICAgICAgIGxlZ2VuZC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbGVnZW5kVGV4dCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4JywgZ3JpZFNpemUgKyBsZWdlbmRTcGFjaW5nKVxyXG4gICAgICAgICAgICAuYXR0cigneScsIGdyaWRTaXplIC0gbGVnZW5kU3BhY2luZylcclxuICAgICAgICAgICAgLnRleHQoZCA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4oZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBqdkNoYXJ0cy5qdkZvcm1hdFZhbHVlKGQsIGZvcm1hdFZhbHVlVHlwZSk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIGNoYXJ0Ll92YXJzLmJsYWNrKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRRdWFudGl6ZWRDb2xvcihxdWFudGl6ZWRBcnJheSwgdmFsdWUpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHF1YW50aXplZEFycmF5Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA8IHF1YW50aXplZEFycmF5W2ldKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sb3JzW2kgLSAxXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29sb3JzW3F1YW50aXplZEFycmF5Lmxlbmd0aCAtIDFdO1xyXG4gICAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGp2Q2hhcnRzO1xyXG5cclxuXHJcbiIsIid1c2Ugc3RyaWN0JztcclxudmFyIGp2Q2hhcnRzID0gcmVxdWlyZSgnLi4vanZDaGFydHMuanMnKTtcclxuXHJcblxyXG5qdkNoYXJ0cy5wcm90b3R5cGUubGluZSA9IHtcclxuICAgIHBhaW50OiBwYWludCxcclxuICAgIHNldERhdGE6IHNldERhdGEsXHJcbiAgICBnZXRFdmVudERhdGE6IGdldEV2ZW50RGF0YVxyXG59O1xyXG5cclxuanZDaGFydHMucHJvdG90eXBlLmdlbmVyYXRlTGluZSA9IGdlbmVyYXRlTGluZTtcclxuanZDaGFydHMucHJvdG90eXBlLnNldExpbmVUaHJlc2hvbGREYXRhID0gc2V0TGluZVRocmVzaG9sZERhdGE7XHJcblxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIExpbmUgZnVuY3Rpb25zICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcbi8qKnNldExpbmVEYXRhXHJcbiAqICBnZXRzIGxpbmUgZGF0YSBhbmQgYWRkcyBpdCB0byB0aGUgY2hhcnQgb2JqZWN0XHJcbiAqXHJcbiAqIEBwYXJhbXMgZGF0YSwgZGF0YVRhYmxlLCBjb2xvcnNcclxuICovXHJcbmZ1bmN0aW9uIHNldERhdGEoKSB7XHJcbiAgICB2YXIgY2hhcnQgPSB0aGlzO1xyXG4gICAgLy9zb3J0IGNoYXJ0IGRhdGEgaWYgdGhlcmUgaXMgYSBzb3J0IHR5cGUgYW5kIGxhYmVsIGluIHRoZSBfdmFyc1xyXG4gICAgaWYgKGNoYXJ0Ll92YXJzLnNvcnRUeXBlKSB7XHJcbiAgICAgICAgaWYgKGNoYXJ0Ll92YXJzLnNvcnRMYWJlbCAmJiBjaGFydC5fdmFycy5zb3J0VHlwZSAhPT0gJ2RlZmF1bHQnKSB7XHJcbiAgICAgICAgICAgIGNoYXJ0Lm9yZ2FuaXplQ2hhcnREYXRhKGNoYXJ0Ll92YXJzLnNvcnRMYWJlbCwgY2hhcnQuX3ZhcnMuc29ydFR5cGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNoYXJ0LmRhdGEubGVnZW5kRGF0YSA9IHNldEJhckxpbmVMZWdlbmREYXRhKGNoYXJ0LmRhdGEpO1xyXG4gICAgY2hhcnQuZGF0YS54QXhpc0RhdGEgPSBjaGFydC5zZXRBeGlzRGF0YSgneCcsIGNoYXJ0LmRhdGEpO1xyXG4gICAgY2hhcnQuZGF0YS55QXhpc0RhdGEgPSBjaGFydC5zZXRBeGlzRGF0YSgneScsIGNoYXJ0LmRhdGEpO1xyXG5cclxuICAgIGlmIChjaGFydC5fdmFycy5zZXJpZXNGbGlwcGVkKSB7XHJcbiAgICAgICAgY2hhcnQuc2V0RmxpcHBlZFNlcmllcyhjaGFydC5kYXRhLmRhdGFUYWJsZUtleXMpO1xyXG4gICAgICAgIGNoYXJ0LmZsaXBwZWREYXRhLmNvbG9yID0ganZDaGFydHMuc2V0Q2hhcnRDb2xvcnMoY2hhcnQuX3ZhcnMuY29sb3IsIGNoYXJ0LmZsaXBwZWREYXRhLmxlZ2VuZERhdGEsIGNoYXJ0LmNvbG9ycyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGNoYXJ0LmRhdGEuZGF0YVRhYmxlLmhhc093blByb3BlcnR5KCdzZXJpZXMnKSkge1xyXG4gICAgICAgIGNoYXJ0LmRhdGEuY2hhcnREYXRhID0gc2V0U2VyaWVzRGF0YShjaGFydC5kYXRhLmNoYXJ0RGF0YSwgY2hhcnQuZGF0YS5kYXRhVGFibGUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vZGVmaW5lIGNvbG9yIG9iamVjdCBmb3IgY2hhcnREYXRhXHJcbiAgICBjaGFydC5kYXRhLmNvbG9yID0ganZDaGFydHMuc2V0Q2hhcnRDb2xvcnMoY2hhcnQuX3ZhcnMuY29sb3IsIGNoYXJ0LmRhdGEubGVnZW5kRGF0YSwgY2hhcnQuY29sb3JzKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0RXZlbnREYXRhKGV2ZW50KSB7XHJcbiAgICB2YXIgY2hhcnQgPSB0aGlzO1xyXG4gICAgaWYgKGV2ZW50LnRhcmdldC5jbGFzc0xpc3QudmFsdWUuc3BsaXQoJ2Jhci1jb2wtJylbMV0pIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICAgICAgICBbY2hhcnQuY3VycmVudERhdGEuZGF0YVRhYmxlLmxhYmVsXTogW2V2ZW50LnRhcmdldC5jbGFzc0xpc3QudmFsdWUuc3BsaXQoJ2Jhci1jb2wtJylbMV0ucmVwbGFjZSgvXy9nLCAnICcpLnJlcGxhY2UoL19kb3RfL2csICcuJyldXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG5vZGU6IGV2ZW50LnRhcmdldFxyXG4gICAgICAgIH07XHJcbiAgICB9IGVsc2UgaWYgKGV2ZW50LnRhcmdldC5jbGFzc0xpc3QudmFsdWUuaW5kZXhPZignbGluZS1jb250YWluZXInKSA+IC0xKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZGF0YToge31cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBkYXRhOiBmYWxzZVxyXG4gICAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBuYW1lIHNldFNlcmllc0RhdGFcclxuICogQGRlc2MgU2V0cyBjaGFydERhdGEgdG8gY29udGFpbiBhIHNlcmllcyBkYXRhIGlmIHRoZSBzZXJpZXMgZmllbGQgZXhpc3RzIGluIHZpc3VhbCBwYW5lbFxyXG4gKi9cclxuZnVuY3Rpb24gc2V0U2VyaWVzRGF0YShkYXRhLCBkYXRhVGFibGUpIHtcclxuICAgIHZhciBsYWJlbExpc3QgPSBbXSxcclxuICAgICAgICBhZGQsXHJcbiAgICAgICAgbmV3RGF0YSA9IFtdO1xyXG4gICAgLy9HZXQgdW5pcXVlIGxhYmVsIGxpc3RcclxuICAgIGZvciAobGV0IGRhdGFFbGUgb2YgZGF0YSkge1xyXG4gICAgICAgIGFkZCA9IHRydWU7XHJcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBsYWJlbExpc3QubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgaWYgKGRhdGFFbGVbZGF0YVRhYmxlLmxhYmVsXSA9PT0gbGFiZWxMaXN0W2pdKSB7XHJcbiAgICAgICAgICAgICAgICBhZGQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhZGQpIHtcclxuICAgICAgICAgICAgbGFiZWxMaXN0LnB1c2goZGF0YUVsZVtkYXRhVGFibGUubGFiZWxdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvL0l0ZXJhdGUgb3ZlciBsYWJlbCBsaXN0XHJcbiAgICB2YXIgbmV3RGF0YSA9IFtdO1xyXG4gICAgZm9yKGxldCBpID0gMDsgaSA8IGxhYmVsTGlzdC5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgdmFyIGRhdGFPYmogPSB7fTtcclxuICAgICAgICBkYXRhT2JqW2RhdGFUYWJsZS5sYWJlbF0gPSBsYWJlbExpc3RbaV07XHJcbiAgICAgICAgZm9yKGxldCBqID0gMDsgaiA8IGRhdGEubGVuZ3RoOyBqKyspe1xyXG4gICAgICAgICAgICBpZihkYXRhW2pdW2RhdGFUYWJsZS5sYWJlbF0gPT09IGxhYmVsTGlzdFtpXSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5ld0VudHJ5ID0gZGF0YVtqXVtkYXRhVGFibGUuc2VyaWVzXSArICcgJyArIGRhdGFUYWJsZVsndmFsdWUgMSddO1xyXG4gICAgICAgICAgICAgICAgZGF0YU9ialtuZXdFbnRyeV0gPSBkYXRhW2pdW2RhdGFUYWJsZVsndmFsdWUgMSddXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBuZXdEYXRhLnB1c2goZGF0YU9iaik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3RGF0YTtcclxufVxyXG5cclxuLyoqc2V0QmFyTGluZUxlZ2VuZERhdGFcclxuICogIGdldHMgbGVnZW5kIGluZm8gZnJvbSBjaGFydCBEYXRhXHJcbiAqXHJcbiAqIEBwYXJhbXMgZGF0YSwgdHlwZVxyXG4gKiBAcmV0dXJucyBbXSBvZiBsZWdlbmQgdGV4XHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRCYXJMaW5lTGVnZW5kRGF0YShkYXRhKSB7XHJcbiAgICB2YXIgbGVnZW5kQXJyYXkgPSBbXTtcclxuXHJcbiAgICBpZiAoZGF0YS5kYXRhVGFibGUuaGFzT3duUHJvcGVydHkoJ3NlcmllcycpKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmNoYXJ0RGF0YS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgYWRkVG9MZWdlbmQgPSB0cnVlO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxlZ2VuZEFycmF5Lmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSBkYXRhLmNoYXJ0RGF0YVtpXVtkYXRhLmRhdGFUYWJsZS5zZXJpZXNdICsgJyAnICsgZGF0YS5kYXRhVGFibGVbJ3ZhbHVlIDEnXTtcclxuICAgICAgICAgICAgICAgIGlmIChlbnRyeSA9PT0gbGVnZW5kQXJyYXlbal0pIHtcclxuICAgICAgICAgICAgICAgICAgICBhZGRUb0xlZ2VuZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChhZGRUb0xlZ2VuZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5ld0VudHJ5ID0gZGF0YS5jaGFydERhdGFbaV1bZGF0YS5kYXRhVGFibGUuc2VyaWVzXSArICcgJyArIGRhdGEuZGF0YVRhYmxlWyd2YWx1ZSAxJ107XHJcbiAgICAgICAgICAgICAgICBsZWdlbmRBcnJheS5wdXNoKG5ld0VudHJ5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGZvciAodmFyIGl0ZW0gaW4gZGF0YS5kYXRhVGFibGUpIHtcclxuICAgICAgICAgICAgaWYgKGRhdGEuZGF0YVRhYmxlLmhhc093blByb3BlcnR5KGl0ZW0pKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXRlbSAhPT0gJ2xhYmVsJyAmJiBpdGVtLmluZGV4T2YoJ3Rvb2x0aXAnKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZWdlbmRBcnJheS5wdXNoKGRhdGEuZGF0YVRhYmxlW2l0ZW1dKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgcmV0dXJuIGxlZ2VuZEFycmF5O1xyXG59XHJcbi8qKnBhaW50TGluZUNoYXJ0XHJcbiAqXHJcbiAqIFRoZSBpbml0aWFsIHN0YXJ0aW5nIHBvaW50IGZvciBsaW5lIGNoYXJ0LCBiZWdpbnMgdGhlIGRyYXdpbmcgcHJvY2Vzcy4gTXVzdCBhbHJlYWR5IGhhdmUgdGhlIGRhdGEgc3RvcmVkIGluIHRoZSBjaGFydFxyXG4gKiBvYmplY3RcclxuICovXHJcbmZ1bmN0aW9uIHBhaW50KCkge1xyXG4gICAgdmFyIGNoYXJ0ID0gdGhpcztcclxuICAgIC8vVXNlcyB0aGUgb3JpZ2luYWwgZGF0YSBhbmQgdGhlbiBtYW5pcHVsYXRlcyBpdCBiYXNlZCBvbiBhbnkgZXhpc3Rpbmcgb3B0aW9uc1xyXG4gICAgdmFyIGRhdGFPYmogPSBjaGFydC5nZXRCYXJEYXRhRnJvbU9wdGlvbnMoKTtcclxuXHJcbiAgICAvL2Fzc2lnbiBjdXJyZW50IGRhdGEgd2hpY2ggaXMgdXNlZCBieSBhbGwgYmFyIGNoYXJ0IG9wZXJhdGlvbnNcclxuICAgIGNoYXJ0LmN1cnJlbnREYXRhID0gZGF0YU9iajtcclxuXHJcbiAgICAvL2dlbmVyYXRlIHN2ZyBkeW5hbWljYWxseSBiYXNlZCBvbiBsZWdlbmQgZGF0YVxyXG4gICAgY2hhcnQuZ2VuZXJhdGVTVkcoZGF0YU9iai5sZWdlbmREYXRhKTtcclxuICAgIGNoYXJ0LmdlbmVyYXRlWEF4aXMoZGF0YU9iai54QXhpc0RhdGEpO1xyXG4gICAgY2hhcnQuZ2VuZXJhdGVZQXhpcyhkYXRhT2JqLnlBeGlzRGF0YSk7XHJcbiAgICBjaGFydC5nZW5lcmF0ZUxlZ2VuZChkYXRhT2JqLmxlZ2VuZERhdGEsICdnZW5lcmF0ZUxpbmUnKTtcclxuICAgIGlmIChjaGFydC5fdmFycy5yb3RhdGVBeGlzKSB7XHJcbiAgICAgICAgY2hhcnQuZm9ybWF0WEF4aXNMYWJlbHMoZGF0YU9iai54QXhpc1NjYWxlLnRpY2tzKCkubGVuZ3RoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY2hhcnQuZm9ybWF0WEF4aXNMYWJlbHMoZGF0YU9iai54QXhpc1NjYWxlLmRvbWFpbigpLmxlbmd0aCk7XHJcbiAgICB9XHJcblxyXG4gICAgY2hhcnQuZ2VuZXJhdGVMaW5lKGRhdGFPYmopO1xyXG59XHJcblxyXG4vKipnZW5lcmF0ZUxpbmVcclxuICpcclxuICogUGFpbnRzIHRoZSBsaW5lc1xyXG4gKiBAcGFyYW1zIGxpbmVEYXRhXHJcbiAqL1xyXG5mdW5jdGlvbiBnZW5lcmF0ZUxpbmUobGluZURhdGEpIHtcclxuICAgIHZhciBjaGFydCA9IHRoaXMsXHJcbiAgICAgICAgc3ZnID0gY2hhcnQuc3ZnO1xyXG5cclxuICAgIHN2Zy5zZWxlY3RBbGwoJ2cuJyArIGNoYXJ0LmNvbmZpZy50eXBlICsgJy1jb250YWluZXInKS5yZW1vdmUoKTtcclxuICAgIHZhciBsaW5lcyA9IHN2Zy5hcHBlbmQoJ2cnKVxyXG4gICAgICAgIC5hdHRyKCdjbGFzcycsIGNoYXJ0LmNvbmZpZy50eXBlICsgJy1jb250YWluZXInKVxyXG4gICAgICAgIC5zZWxlY3RBbGwoJ2cnKTtcclxuXHJcbiAgICB2YXIgZGF0YUhlYWRlcnMgPSBsaW5lRGF0YS5sZWdlbmREYXRhO1xyXG5cclxuICAgIGlmIChjaGFydC5fdmFycy5zZXJpZXNGbGlwcGVkICYmIGNoYXJ0Ll92YXJzLmZsaXBwZWRMZWdlbmRIZWFkZXJzKSB7XHJcbiAgICAgICAgZGF0YUhlYWRlcnMgPSBjaGFydC5fdmFycy5mbGlwcGVkTGVnZW5kSGVhZGVycztcclxuICAgIH0gZWxzZSBpZiAoY2hhcnQuX3ZhcnMubGVnZW5kSGVhZGVycykge1xyXG4gICAgICAgIGRhdGFIZWFkZXJzID0gY2hhcnQuX3ZhcnMubGVnZW5kSGVhZGVycztcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbGluZURhdGFOZXcgPSBqdkNoYXJ0cy5nZXRUb2dnbGVkRGF0YShsaW5lRGF0YSwgZGF0YUhlYWRlcnMpO1xyXG5cclxuICAgIC8vSWYgaXQncyBhbiBhcmVhIGNoYXJ0LCBhZGQgdGhlIGFyZWFcclxuICAgIGlmIChjaGFydC5jb25maWcudHlwZSA9PT0gJ2FyZWEnKSB7XHJcbiAgICAgICAgY2hhcnQuZmlsbEFyZWEobGluZURhdGFOZXcpO1xyXG4gICAgfVxyXG5cclxuICAgIGdlbmVyYXRlTGluZUdyb3VwcyhsaW5lcywgbGluZURhdGFOZXcsIGNoYXJ0KTtcclxuICAgIHZhciBldmVudEdyb3VwcyA9IGp2Q2hhcnRzLmdlbmVyYXRlRXZlbnRHcm91cHMobGluZXMsIGxpbmVEYXRhTmV3LCBjaGFydCk7XHJcblxyXG4gICAgZXZlbnRHcm91cHNcclxuICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uIChkLCBpLCBqKSB7IC8vVHJhbnNpdGlvbnMgaW4gRDMgZG9uJ3Qgc3VwcG9ydCB0aGUgJ29uJyBmdW5jdGlvbiBUaGV5IG9ubHkgZXhpc3Qgb24gc2VsZWN0aW9ucy4gU28gbmVlZCB0byBtb3ZlIHRoYXQgZXZlbnQgbGlzdGVuZXIgYWJvdmUgdHJhbnNpdGlvbiBhbmQgYWZ0ZXIgYXBwZW5kXHJcbiAgICAgICAgICAgIGlmIChjaGFydC5zaG93VG9vbFRpcCkge1xyXG4gICAgICAgICAgICAgICAgLy9HZXQgdGlwIGRhdGFcclxuICAgICAgICAgICAgICAgIHZhciB0aXBEYXRhID0gY2hhcnQuc2V0VGlwRGF0YShkLCBpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL0RyYXcgdGlwXHJcbiAgICAgICAgICAgICAgICBjaGFydC50aXAuZ2VuZXJhdGVTaW1wbGVUaXAodGlwRGF0YSwgY2hhcnQuZGF0YS5kYXRhVGFibGUpO1xyXG4gICAgICAgICAgICAgICAgY2hhcnQudGlwLmQgPSBkO1xyXG4gICAgICAgICAgICAgICAgY2hhcnQudGlwLmkgPSBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICAub24oJ21vdXNlbW92ZScsIGZ1bmN0aW9uIChkLCBpKSB7XHJcbiAgICAgICAgICAgIGlmIChjaGFydC5zaG93VG9vbFRpcCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoYXJ0LnRpcC5kID09PSBkICYmIGNoYXJ0LnRpcC5pID09PSBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhcnQudGlwLnNob3dUaXAoZDMuZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvL0dldCB0aXAgZGF0YVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0aXBEYXRhID0gY2hhcnQuc2V0VGlwRGF0YShkLCBpKTtcclxuICAgICAgICAgICAgICAgICAgICAvL0RyYXcgdGlwIGxpbmVcclxuICAgICAgICAgICAgICAgICAgICBjaGFydC50aXAuZ2VuZXJhdGVTaW1wbGVUaXAodGlwRGF0YSwgY2hhcnQuZGF0YS5kYXRhVGFibGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgY2hhcnQudGlwLmhpZGVUaXAoKTtcclxuICAgICAgICAgICAgc3ZnLnNlbGVjdEFsbCgnLnRpcC1saW5lJykucmVtb3ZlKCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgY2hhcnQuZGlzcGxheVZhbHVlcygpO1xyXG4gICAgY2hhcnQuZ2VuZXJhdGVDbGlwUGF0aCgpO1xyXG4gICAgY2hhcnQuZ2VuZXJhdGVMaW5lVGhyZXNob2xkKCk7XHJcblxyXG4gICAgcmV0dXJuIGxpbmVzO1xyXG59XHJcblxyXG4vKipnZW5lcmF0ZUxpbmVHcm91cHNcclxuICpcclxuICogUGFpbnRzIHRoZSBncm91cHMgb2YgdGhlIGxpbmVzXHJcbiAqIEBwYXJhbXMgY2hhcnRDb250YWluZXIsIGJhckRhdGEsIGNoYXJ0XHJcbiAqL1xyXG5mdW5jdGlvbiBnZW5lcmF0ZUxpbmVHcm91cHMobGluZUNvbnRhaW5lciwgbGluZURhdGEsIGNoYXJ0KSB7XHJcbiAgICB2YXIgY29udGFpbmVyID0gY2hhcnQuY29uZmlnLmNvbnRhaW5lcixcclxuICAgICAgICB4QXhpc0RhdGEgPSBjaGFydC5jdXJyZW50RGF0YS54QXhpc0RhdGEsXHJcbiAgICAgICAgeUF4aXNEYXRhID0gY2hhcnQuY3VycmVudERhdGEueUF4aXNEYXRhLFxyXG4gICAgICAgIGxlZ2VuZERhdGEgPSBjaGFydC5jdXJyZW50RGF0YS5sZWdlbmREYXRhLFxyXG4gICAgICAgIGNvbG9ycyA9IGNoYXJ0Ll92YXJzLmNvbG9yLFxyXG4gICAgICAgIGxpbmVzLFxyXG4gICAgICAgIGxpbmVMZW5ndGggPSBsaW5lRGF0YS5sZW5ndGgsXHJcbiAgICAgICAgbGVnZW5kTGVuZ3RoID0gbGVnZW5kRGF0YS5sZW5ndGg7XHJcblxyXG4gICAgLy9HZXQgUG9zaXRpb24gQ2FsY3VsYXRpb25zXHJcbiAgICB2YXIgeCA9IGp2Q2hhcnRzLmdldEF4aXNTY2FsZSgneCcsIHhBeGlzRGF0YSwgY29udGFpbmVyLCBjaGFydC5fdmFycywgJ25vLXBhZGRpbmcnKTtcclxuICAgIHZhciB5ID0ganZDaGFydHMuZ2V0QXhpc1NjYWxlKCd5JywgeUF4aXNEYXRhLCBjb250YWluZXIsIGNoYXJ0Ll92YXJzLCAnbm8tcGFkZGluZycpO1xyXG5cclxuICAgIHZhciB4VHJhbnNsYXRlLFxyXG4gICAgICAgIHlUcmFuc2xhdGU7XHJcblxyXG4gICAgaWYgKGNoYXJ0Ll92YXJzLnJvdGF0ZUF4aXMgPT09IHRydWUpIHtcclxuICAgICAgICB4VHJhbnNsYXRlID0gZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgaWYgKGQgPT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geCgnRU1QVFlfU1RSSU5HJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHgoZCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB5VHJhbnNsYXRlID0gZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgcmV0dXJuICh5KGxpbmVEYXRhW2ldW3lBeGlzRGF0YS5sYWJlbF0pKSArIChjb250YWluZXIuaGVpZ2h0IC8gKGxpbmVMZW5ndGgpIC8gMik7Ly8rIGNvbnRhaW5lci5oZWlnaHQgLyAobGluZUxlbmd0aCkgLyAyICAtIHkucGFkZGluZ0lubmVyKCkpO1xyXG4gICAgICAgIH07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHhUcmFuc2xhdGUgPSBmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICBpZiAobGluZURhdGFbaV1beEF4aXNEYXRhLmxhYmVsXSA9PT0gJycpIHtcclxuICAgICAgICAgICAgICAgIGxpbmVEYXRhW2ldW3hBeGlzRGF0YS5sYWJlbF0gPSAnRU1QVFlfU1RSSU5HJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gKHgobGluZURhdGFbaV1beEF4aXNEYXRhLmxhYmVsXSkpICsgKGNvbnRhaW5lci53aWR0aCAvIChsaW5lTGVuZ3RoKSAvIDIpOy8vKyBjb250YWluZXIud2lkdGggLyAobGluZUxlbmd0aCkgLyAyIC0geC5wYWRkaW5nSW5uZXIoKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB5VHJhbnNsYXRlID0gZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHkoZCk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvL0FwcGVuZCBsaW5lcyBhbmQgY2lyY2xlc1xyXG5cclxuICAgIHZhciB1bmlxdWVYQXhpc0RhdGEgPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhcnQuZGF0YS54QXhpc0RhdGEudmFsdWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIGFkZCA9IHRydWU7XHJcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB1bmlxdWVYQXhpc0RhdGEubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgaWYgKGNoYXJ0LmRhdGEueEF4aXNEYXRhLnZhbHVlc1tpXSA9PT0gdW5pcXVlWEF4aXNEYXRhW2pdKSB7XHJcbiAgICAgICAgICAgICAgICBhZGQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhZGQpIHtcclxuICAgICAgICAgICAgdW5pcXVlWEF4aXNEYXRhLnB1c2goY2hhcnQuZGF0YS54QXhpc0RhdGEudmFsdWVzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuXHJcbiAgICB2YXIgZGF0YSA9IHt9O1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lTGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGxlZ2VuZExlbmd0aDsgaysrKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2hhcnQuX3ZhcnMubGVnZW5kT3B0aW9ucyAhPT0gJ3VuZGVmaW5lZCcpIHsvL0FjY291bnRpbmcgZm9yIGxlZ2VuZCB0b2dnbGVzXHJcbiAgICAgICAgICAgICAgICBpZiAoY2hhcnQuX3ZhcnMubGVnZW5kT3B0aW9uc1trXS50b2dnbGUgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9Eb24ndCB3cml0ZSBhbnl0aGluZyB0byBkYXRhXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vV3JpdGUgc29tZXRoaW5nIHRvIGRhdGFcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWRhdGFbbGVnZW5kRGF0YVtrXV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtsZWdlbmREYXRhW2tdXSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBkYXRhW2xlZ2VuZERhdGFba11dLnB1c2gocGFyc2VGbG9hdChsaW5lRGF0YVtpXVtsZWdlbmREYXRhW2tdXSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Ugey8vSW5pdGlhbCBjcmVhdGlvbiBvZiB2aXN1YWxpemF0aW9uIHcvbyBsZWdlbmQgb3B0aW9uc1xyXG4gICAgICAgICAgICAgICAgaWYgKCFkYXRhW2xlZ2VuZERhdGFba11dKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtsZWdlbmREYXRhW2tdXSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGRhdGFbbGVnZW5kRGF0YVtrXV0ubGVuZ3RoIDwgbGluZUxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFbbGVnZW5kRGF0YVtrXV0ucHVzaChwYXJzZUZsb2F0KGxpbmVEYXRhW2ldW2xlZ2VuZERhdGFba11dKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY2hhcnQuc3ZnLnNlbGVjdEFsbCgnLmxpbmVzJykucmVtb3ZlKCk7XHJcbiAgICBjaGFydC5zdmcuc2VsZWN0QWxsKCcubGluZScpLnJlbW92ZSgpO1xyXG4gICAgY2hhcnQuc3ZnLnNlbGVjdEFsbCgnLmNpcmNsZScpLnJlbW92ZSgpO1xyXG4gICAgY2hhcnQuc3ZnLnNlbGVjdEFsbCgnI2xpbmUtZ3JhZGllbnQnKS5yZW1vdmUoKTtcclxuXHJcbiAgICBsaW5lcyA9IGNoYXJ0LnN2Zy5zZWxlY3RBbGwoJy4nICsgY2hhcnQuY29uZmlnLnR5cGUgKyAnLWNvbnRhaW5lcicpO1xyXG5cclxuICAgIC8vY3VydmVzIG9iamVjdFxyXG4gICAgdmFyIGN1cnZlcyA9IHtcclxuICAgICAgICAnTGluZWFyJzogZDMuY3VydmVMaW5lYXIsXHJcbiAgICAgICAgJ1N0ZXAnOiBkMy5jdXJ2ZVN0ZXAsXHJcbiAgICAgICAgJ1N0ZXAgQmVmb3JlJzogZDMuY3VydmVTdGVwQmVmb3JlLFxyXG4gICAgICAgICdTdGVwIEFmdGVyJzogZDMuY3VydmVTdGVwQWZ0ZXIsXHJcbiAgICAgICAgJ0Jhc2lzJzogZDMuY3VydmVCYXNpcyxcclxuICAgICAgICAnQ2FyZGluYWwnOiBkMy5jdXJ2ZUNhcmRpbmFsLFxyXG4gICAgICAgICdNb25vdG9uZSBYJzogZDMuY3VydmVNb25vdG9uZVgsXHJcbiAgICAgICAgJ0NhdG11bGwgUm9tJzogZDMuY3VydmVDYXRtdWxsUm9tXHJcbiAgICB9O1xyXG5cclxuICAgIHZhciB2YWx1ZWxpbmUgPSB7fTtcclxuICAgIHZhciBjaXJjbGVzID0ge307XHJcbiAgICB2YXIgaW5kZXggPSAwO1xyXG4gICAgdmFyIGxpbmVDb2xvcnMgPSBbXTtcclxuICAgIHZhciB0aHJlc2hvbGRpbmcgPSBmYWxzZTtcclxuICAgIGZvciAodmFyIGsgaW4gZGF0YSkge1xyXG4gICAgICAgIC8vQ3JlYXRlIHBhdGggZ2VuZXJhdG9yIGZvciBlYWNoIHNlcmllc1xyXG4gICAgICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KGspKSB7XHJcbiAgICAgICAgICAgIGlmIChkYXRhW2tdID09PSAnJykge1xyXG4gICAgICAgICAgICAgICAgZGF0YVtrXSA9ICdFTVBUWV9TVFJJTkcnO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YWx1ZWxpbmVba10gPSBkMy5saW5lKCkvL2xpbmUgZHJhd2luZyBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgLmN1cnZlKGN1cnZlc1tjaGFydC5fdmFycy5saW5lQ3VydmVUeXBlXSlcclxuICAgICAgICAgICAgICAgIC5kZWZpbmVkKGZ1bmN0aW9uKGQpe1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhaXNOYU4oZCk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLngoZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOYU4oZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geFRyYW5zbGF0ZShkLCBpKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAueShmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc05hTihkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB5VHJhbnNsYXRlKGQsIGkpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICAgICAgLy9BZGQgbGluZXMgdG8gdGhlIGNoYXJ0LmNvbmZpZy50eXBlICsgJy1jb250YWluZXInXHJcbiAgICAgICAgICAgIGxpbmVzXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdsaW5lICcgKyAoaykpXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdwYXRoJykvL2RyYXdzIHRoZSBsaW5lXHJcbiAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgZnVuY3Rpb24gKGQsIGksIGopIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29sb3JPYmogPSBqdkNoYXJ0cy5nZXRDb2xvcnMoY29sb3JzLCBpLCBrKTtcclxuICAgICAgICAgICAgICAgICAgICBsaW5lQ29sb3JzLnB1c2goY29sb3JPYmopO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2xvck9iajtcclxuICAgICAgICAgICAgICAgIH0pICAgLy9maWxscyB0aGUgYmFyIHdpdGggY29sb3JcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCAnMicpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZmlsbCcsICdub25lJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdkJywgZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVsaW5lW2tdKGRhdGFba10pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvL0NvbG9yIFRocmVzaG9sZGluZyBmb3IgZWFjaCB0aWVyXHJcbiAgICAgICAgICAgIGlmIChjaGFydC5fdmFycy50aHJlc2hvbGRzICE9ICdub25lJyAmJiBjaGFydC5fdmFycy5jb2xvckNoYXJ0ICE9IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hhcnQuX3ZhcnMuY29sb3JMaW5lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRocmVzaG9sZFBlcmNlbnRzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRocmVzaG9sZExlbmd0aCA9IE9iamVjdC5rZXlzKGNoYXJ0Ll92YXJzLnRocmVzaG9sZHMpLmxlbmd0aFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFydC5fdmFycy5yb3RhdGVBeGlzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB6ZXJvID0geyBwZXJjZW50OiAwLCBjb2xvcjogbGluZUNvbG9yc1tpbmRleF0gfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyZXNob2xkUGVyY2VudHMucHVzaCh6ZXJvKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHogPSAwOyB6IDwgdGhyZXNob2xkTGVuZ3RoOyB6KyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwQ2VudCA9ICgoY2hhcnQuX3ZhcnMudGhyZXNob2xkc1t6XS50aHJlc2hvbGQpICogMTAwKSAvICh4QXhpc0RhdGEubWF4IC0geEF4aXNEYXRhLm1pbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcCA9IHsgcGVyY2VudDogcENlbnQsIGNvbG9yOiBjaGFydC5fdmFycy50aHJlc2hvbGRzW3pdLnRocmVzaG9sZENvbG9yIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJlc2hvbGRQZXJjZW50cy5wdXNoKHRlbXApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHplcm8gPSB7IHBlcmNlbnQ6IDAsIGNvbG9yOiBsaW5lQ29sb3JzW2luZGV4XSB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJlc2hvbGRQZXJjZW50cy5wdXNoKHplcm8pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgeiA9IDA7IHogPCB0aHJlc2hvbGRMZW5ndGg7IHorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBDZW50ID0gKChjaGFydC5fdmFycy50aHJlc2hvbGRzW3pdLnRocmVzaG9sZCkgKiAxMDApIC8gKHlBeGlzRGF0YS5tYXggLSB5QXhpc0RhdGEubWluKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wID0geyBwZXJjZW50OiBwQ2VudCwgY29sb3I6IGNoYXJ0Ll92YXJzLnRocmVzaG9sZHNbel0udGhyZXNob2xkQ29sb3IgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocmVzaG9sZFBlcmNlbnRzLnB1c2godGVtcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGhyZXNob2xkRGF0YSA9IGNoYXJ0LnNldExpbmVUaHJlc2hvbGREYXRhKGNoYXJ0LCB0aHJlc2hvbGRQZXJjZW50cywgbGluZUNvbG9yc1tpbmRleF0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBsaW5lcy5zZWxlY3RBbGwoJ3BhdGgnKS5hdHRyKCdjbGFzcycsICdsaW5lLXRocmVzaG9sZCcpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhcnQuX3ZhcnMucm90YXRlQXhpcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFydC5zdmcuYXBwZW5kKCdsaW5lYXJHcmFkaWVudCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAnbGluZS1ncmFkaWVudCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignZ3JhZGllbnRVbml0cycsICd1c2VyU3BhY2VPblVzZScpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneDEnLCB4VHJhbnNsYXRlKHhBeGlzRGF0YS5taW4pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MicsIHhUcmFuc2xhdGUoeEF4aXNEYXRhLm1heCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneTInLCAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgnc3RvcCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZGF0YSh0aHJlc2hvbGREYXRhKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmVudGVyKCkuYXBwZW5kKCdzdG9wJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdvZmZzZXQnLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5vZmZzZXQ7IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignc3RvcC1jb2xvcicsIGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLmNvbG9yOyB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFydC5zdmcuYXBwZW5kKCdsaW5lYXJHcmFkaWVudCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAnbGluZS1ncmFkaWVudCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignZ3JhZGllbnRVbml0cycsICd1c2VyU3BhY2VPblVzZScpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneDEnLCAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgeVRyYW5zbGF0ZSh5QXhpc0RhdGEubWluKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MicsIDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneTInLCB5VHJhbnNsYXRlKHlBeGlzRGF0YS5tYXgpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgnc3RvcCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZGF0YSh0aHJlc2hvbGREYXRhKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmVudGVyKCkuYXBwZW5kKCdzdG9wJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdvZmZzZXQnLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5vZmZzZXQ7IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignc3RvcC1jb2xvcicsIGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLmNvbG9yOyB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aHJlc2hvbGRpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL0FkZCBjaXJjbGVzIGF0IGpvaW50cyBpbiB0aGUgbGluZXNcclxuICAgICAgICAgICAgY2lyY2xlc1trXSA9IGxpbmVzXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdjaXJjbGUgJyArIChrKSlcclxuICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoJ2NpcmNsZScpXHJcbiAgICAgICAgICAgICAgICAuZGF0YShkYXRhW2tdKVxyXG4gICAgICAgICAgICAgICAgLmVudGVyKClcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2NpcmNsZScpLy9DaXJjbGVzIGZvciB0aGUgam9pbnRzIGluIHRoZSBsaW5lXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCBmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnY2lyY2xlLScgKyBjaGFydC5jdXJyZW50RGF0YS5jaGFydERhdGFbaV1bY2hhcnQuY3VycmVudERhdGEuZGF0YVRhYmxlLmxhYmVsXSArICcgaGlnaGxpZ2h0LWNsYXNzLScgKyBpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjeCcsIGZ1bmN0aW9uIChkLCBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmFOKGQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geFRyYW5zbGF0ZShkLCBpKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY3knLCBmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc05hTihkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHlUcmFuc2xhdGUoZCwgaSk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCBmdW5jdGlvbiAoZCwgaSwgaikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc05hTihkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRocmVzaG9sZGluZyA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSBPYmplY3Qua2V5cyhjaGFydC5fdmFycy50aHJlc2hvbGRzKS5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhcnQuX3ZhcnMucm90YXRlQXhpcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeiA9IGxlbmd0aDsgeiA+IC0xOyB6LS0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGhyZXNob2xkID0gY2hhcnQuX3ZhcnMudGhyZXNob2xkc1t6XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZCA+PSB0aHJlc2hvbGQudGhyZXNob2xkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aHJlc2hvbGQudGhyZXNob2xkQ29sb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeiA9IGxlbmd0aDsgeiA+IC0xOyB6LS0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGhyZXNob2xkID0gY2hhcnQuX3ZhcnMudGhyZXNob2xkc1t6XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZCA+PSB0aHJlc2hvbGQudGhyZXNob2xkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aHJlc2hvbGQudGhyZXNob2xkQ29sb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ganZDaGFydHMuZ2V0Q29sb3JzKGNvbG9ycywgaSwgayk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ29wYWNpdHknLCBmdW5jdGlvbiAoZCwgaSwgaikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc05hTihkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3InLCAyLjUpO1xyXG5cclxuICAgICAgICAgICAgaW5kZXgrKztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy9SZXR1cm4gbGluZSBncm91cHNcclxuICAgIHJldHVybiBsaW5lcy5zZWxlY3RBbGwoJy5jaXJjbGUnKTtcclxufVxyXG5cclxuZnVuY3Rpb24gc2V0TGluZVRocmVzaG9sZERhdGEoY2hhcnQsIHRocmVzaG9sZHMpIHtcclxuICAgIHZhciBkYXRhID0gW107XHJcbiAgICB2YXIgdGhyZXNob2xkTGVuZ3RoID0gdGhyZXNob2xkcy5sZW5ndGg7XHJcbiAgICBmb3IgKHZhciBrID0gMDsgayA8IHRocmVzaG9sZExlbmd0aDsgaysrKSB7XHJcbiAgICAgICAgdmFyIGdyYWRpZW50T25lID0geyBvZmZzZXQ6IHRocmVzaG9sZHNba10ucGVyY2VudCArICclJywgY29sb3I6IHRocmVzaG9sZHNba10uY29sb3IgfTtcclxuICAgICAgICBkYXRhLnB1c2goZ3JhZGllbnRPbmUpO1xyXG5cclxuICAgICAgICBpZiAoayArIDEgPCB0aHJlc2hvbGRMZW5ndGgpIHtcclxuICAgICAgICAgICAgdmFyIGdyYWRpZW50VHdvID0geyBvZmZzZXQ6IHRocmVzaG9sZHNbayArIDFdLnBlcmNlbnQgKyAnJScsIGNvbG9yOiB0aHJlc2hvbGRzW2tdLmNvbG9yIH07XHJcbiAgICAgICAgICAgIGRhdGEucHVzaChncmFkaWVudFR3byk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoayA9PSB0aHJlc2hvbGRMZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgIHZhciBsYXN0ID0geyBvZmZzZXQ6ICcxMDAlJywgY29sb3I6IHRocmVzaG9sZHNba10uY29sb3IgfTtcclxuICAgICAgICAgICAgZGF0YS5wdXNoKGxhc3QpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZGF0YTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBqdkNoYXJ0cztcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIganZDaGFydHMgPSByZXF1aXJlKCcuLi9qdkNoYXJ0cy5qcycpO1xyXG5cclxuXHJcbmp2Q2hhcnRzLnByb3RvdHlwZS5jaXJjbGVwYWNrID0ge1xyXG4gICAgcGFpbnQ6IHBhaW50LFxyXG4gICAgc2V0RGF0YTogc2V0RGF0YSxcclxuICAgIGdldEV2ZW50RGF0YTogZ2V0RXZlbnREYXRhXHJcbn07XHJcblxyXG5qdkNoYXJ0cy5wcm90b3R5cGUuZ2VuZXJhdGVQYWNrID0gZ2VuZXJhdGVQYWNrO1xyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBQYWNrIGZ1bmN0aW9ucyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG4vKipzZXRQYWNrQ2hhcnREYXRhXHJcbiAqICBnZXRzIHBhY2sgZGF0YSBhbmQgYWRkcyBpdCB0byB0aGUgY2hhcnQgb2JqZWN0XHJcbiAqXHJcbiAqIEBwYXJhbXMgZGF0YSwgZGF0YVRhYmxlLCBjb2xvcnNcclxuICovXHJcbmZ1bmN0aW9uIHNldERhdGEoKSB7XHJcbiAgICB2YXIgY2hhcnQgPSB0aGlzO1xyXG4gICAgY2hhcnQuZGF0YS5sZWdlbmREYXRhID0gc2V0UGFja0xlZ2VuZERhdGEoY2hhcnQuZGF0YS5kYXRhVGFibGUpO1xyXG4gICAgaWYgKCFjaGFydC5kYXRhLmNoYXJ0RGF0YS5oYXNPd25Qcm9wZXJ0eSgnY2hpbGRyZW4nKSkge1xyXG4gICAgICAgIGNoYXJ0LmRhdGEuY2hhcnREYXRhID0ganZDaGFydHMuY29udmVydFRhYmxlVG9UcmVlKGNoYXJ0LmRhdGEuY2hhcnREYXRhLCBjaGFydC5kYXRhLmRhdGFUYWJsZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy9kZWZpbmUgY29sb3Igb2JqZWN0IGZvciBjaGFydERhdGFcclxuICAgIGNoYXJ0LmRhdGEuY29sb3IgPSBjaGFydC5jb2xvcnM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEV2ZW50RGF0YSgpIHtcclxuICAgIHJldHVybiB7fTtcclxufVxyXG5cclxuLyoqc2V0UGFja0xlZ2VuZERhdGFcclxuICogIGdldHMgbGVnZW5kIGluZm8gZnJvbSBjaGFydCBEYXRhXHJcbiAqXHJcbiAqIEBwYXJhbXMgZGF0YSwgdHlwZVxyXG4gKiBAcmV0dXJucyBbXSBvZiBsZWdlbmQgdGV4dFxyXG4gKi9cclxuZnVuY3Rpb24gc2V0UGFja0xlZ2VuZERhdGEoZGF0YVRhYmxlKSB7XHJcbiAgICB2YXIgbGVnZW5kQXJyYXkgPSBbXSxcclxuICAgICAgICBsYWJlbCA9ICcnO1xyXG4gICAgZm9yIChsZXQga2V5IGluIGRhdGFUYWJsZSkge1xyXG4gICAgICAgIGlmIChkYXRhVGFibGUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICAgICAgICBpZiAoa2V5ID09PSAndmFsdWUnKSB7XHJcbiAgICAgICAgICAgICAgICBsYWJlbCA9IGRhdGFUYWJsZVtrZXldO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGtleSAhPT0gJ3Rvb2x0aXAgMScpIHtcclxuICAgICAgICAgICAgICAgIGxlZ2VuZEFycmF5LnB1c2goZGF0YVRhYmxlW2tleV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbGVnZW5kQXJyYXkudW5zaGlmdChsYWJlbCk7XHJcbiAgICByZXR1cm4gbGVnZW5kQXJyYXk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhaW50KCkge1xyXG4gICAgdmFyIGNoYXJ0ID0gdGhpcyxcclxuICAgICAgICBwYWNrTWFyZ2lucyA9IHtcclxuICAgICAgICAgICAgdG9wOiAzMCxcclxuICAgICAgICAgICAgcmlnaHQ6IDIwLFxyXG4gICAgICAgICAgICBib3R0b206IDE1LFxyXG4gICAgICAgICAgICBsZWZ0OiAyMFxyXG4gICAgICAgIH07XHJcbiAgICBjaGFydC5fdmFycy5jb2xvciA9IGNoYXJ0LmRhdGEuY29sb3I7XHJcblxyXG4gICAgY2hhcnQuY3VycmVudERhdGEgPSBjaGFydC5kYXRhOy8vTWlnaHQgaGF2ZSB0byBtb3ZlIGludG8gbWV0aG9kIGJjIG9mIHJlZmVyZW5jZS92YWx1ZSByZWxhdGlvbnNoaXBcclxuXHJcbiAgICAvL0dlbmVyYXRlIFNWRy1sZWdlbmQgZGF0YSBpcyB1c2VkIHRvIGRldGVybWluZSB0aGUgc2l6ZSBvZiB0aGUgYm90dG9tIG1hcmdpbiAoc2V0IHRvIG51bGwgZm9yIG5vIGxlZ2VuZClcclxuICAgIGNoYXJ0LmdlbmVyYXRlU1ZHKG51bGwsIHBhY2tNYXJnaW5zKTtcclxuICAgIGNoYXJ0LmdlbmVyYXRlVmVydGljYWxMZWdlbmQoJ2dlbmVyYXRlUGFjaycpO1xyXG4gICAgY2hhcnQuZ2VuZXJhdGVQYWNrKGNoYXJ0LmN1cnJlbnREYXRhKTtcclxufVxyXG5cclxuLyoqZ2VuZXJhdGVQYWNrXHJcbiAqXHJcbiAqIHBhaW50cyB0aGUgcGFjayBvbiB0aGUgY2hhcnRcclxuICogQHBhcmFtcyBwYWNrRGF0YVxyXG4gKi9cclxuZnVuY3Rpb24gZ2VuZXJhdGVQYWNrKCkge1xyXG4gICAgdmFyIGNoYXJ0ID0gdGhpcyxcclxuICAgICAgICBzdmcgPSBjaGFydC5zdmcsXHJcbiAgICAgICAgY29udGFpbmVyID0gY2hhcnQuY29uZmlnLmNvbnRhaW5lcixcclxuICAgICAgICB3ID0gY29udGFpbmVyLndpZHRoLFxyXG4gICAgICAgIGggPSBjb250YWluZXIuaGVpZ2h0LFxyXG4gICAgICAgIHIgPSBNYXRoLm1pbihoIC8gMiwgdyAvIDMpLFxyXG4gICAgICAgIG1hcmdpbiA9IDIwLFxyXG4gICAgICAgIGRpYW1ldGVyID0gciAqIDIsXHJcbiAgICAgICAgY29sb3IsXHJcbiAgICAgICAgcm9vdCxcclxuICAgICAgICBwYWNrLFxyXG4gICAgICAgIHZpcyxcclxuICAgICAgICBjaXJjbGUsXHJcbiAgICAgICAgbm9kZSxcclxuICAgICAgICB2aWV3O1xyXG5cclxuICAgIGNoYXJ0LmNoaWxkcmVuID0gY2hhcnQuZGF0YS5jaGFydERhdGE7XHJcblxyXG4gICAgY29sb3IgPSBkMy5zY2FsZU9yZGluYWwoKVxyXG4gICAgICAgIC5yYW5nZShjaGFydC5kYXRhLmNvbG9yXHJcbiAgICAgICAgICAgIC5tYXAoYyA9PiB7XHJcbiAgICAgICAgICAgICAgICBjID0gZDMucmdiKGMpO1xyXG4gICAgICAgICAgICAgICAgYy5vcGFjaXR5ID0gMC44O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGM7XHJcbiAgICAgICAgICAgIH0pKTtcclxuXHJcbiAgICAvL2Fzc2lnbnMgdGhlIGRhdGEgdG8gYSBoaWVyYXJjaHkgdXNpbmcgcGFyZW50LWNoaWxkIHJlbGF0aW9uc2hpcHNcclxuICAgIHJvb3QgPSBkMy5oaWVyYXJjaHkoY2hhcnQuY2hpbGRyZW4sIGQgPT4gZC5jaGlsZHJlbik7XHJcblxyXG4gICAgcGFjayA9IGQzLnBhY2soKVxyXG4gICAgICAgIC5zaXplKFtjb250YWluZXIud2lkdGgsIGNvbnRhaW5lci5oZWlnaHRdKVxyXG4gICAgICAgIC5wYWRkaW5nKDIpO1xyXG5cclxuICAgIHBhY2socm9vdFxyXG4gICAgICAgIC5zdW0oZCA9PiBkLmhhc093blByb3BlcnR5KCdjaGlsZHJlbicpID8gMCA6IGQubmFtZSlcclxuICAgICAgICAuc29ydCgoYSwgYikgPT4gYi5oZWlnaHQgLSBhLmhlaWdodCB8fCBiLnZhbHVlIC0gYS52YWx1ZSkpXHJcbiAgICAgICAgLmRlc2NlbmRhbnRzKCk7XHJcblxyXG4gICAgc3ZnLnNlbGVjdEFsbCgnLnBhY2snKS5yZW1vdmUoKTtcclxuXHJcbiAgICB2aXMgPSBzdmcuYXBwZW5kKCdnJylcclxuICAgICAgICAuYXR0cignY2xhc3MnLCAncGFjaycpXHJcbiAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArICh3IC8gMikgKyAnLCcgKyByICsgJyknKTtcclxuXHJcbiAgICBjaXJjbGUgPSB2aXMuc2VsZWN0QWxsKCdjaXJjbGUnKVxyXG4gICAgICAgIC5kYXRhKHJvb3QuZGVzY2VuZGFudHMoKSlcclxuICAgICAgICAuZW50ZXIoKS5hcHBlbmQoJ2NpcmNsZScpXHJcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgZCA9PiBkLnBhcmVudCA/IGQuY2hpbGRyZW4gPyAnbm9kZScgOiAnbm9kZSBub2RlLS1sZWFmJyA6ICdub2RlIG5vZGUtLXJvb3QnKVxyXG4gICAgICAgIC5zdHlsZSgnZmlsbCcsIGQgPT4ge1xyXG4gICAgICAgICAgICBkLmNvbG9yID0gY29sb3IoZC5kZXB0aCk7XHJcbiAgICAgICAgICAgIHJldHVybiBkLmNoaWxkcmVuID8gY29sb3IoZC5kZXB0aCkgOiBudWxsO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLm9uKCdjbGljaycsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIGlmIChmb2N1cyAhPT0gZCkge1xyXG4gICAgICAgICAgICAgICAgem9vbShkKTtcclxuICAgICAgICAgICAgICAgIGQzLmV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uIChkLCBpKSB7XHJcbiAgICAgICAgICAgIC8vR2V0IHRpcCBkYXRhXHJcbiAgICAgICAgICAgIHZhciB0aXBEYXRhID0gY2hhcnQuc2V0VGlwRGF0YShkLCBpKTtcclxuICAgICAgICAgICAgLy9EcmF3IHRpcCBsaW5lXHJcbiAgICAgICAgICAgIGNoYXJ0LnRpcC5nZW5lcmF0ZVNpbXBsZVRpcCh0aXBEYXRhLCBjaGFydC5kYXRhLmRhdGFUYWJsZSk7XHJcbiAgICAgICAgICAgIGNoYXJ0LnRpcC5kID0gZDtcclxuICAgICAgICAgICAgY2hhcnQudGlwLmkgPSBpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLm9uKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICBpZiAoY2hhcnQuc2hvd1Rvb2xUaXApIHtcclxuICAgICAgICAgICAgICAgIGlmIChjaGFydC50aXAuZCA9PT0gZCAmJiBjaGFydC50aXAuaSA9PT0gaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0LnRpcC5zaG93VGlwKGQzLmV2ZW50KTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9HZXQgdGlwIGRhdGFcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGlwRGF0YSA9IGNoYXJ0LnNldFRpcERhdGEoZCwgaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9EcmF3IHRpcCBsaW5lXHJcbiAgICAgICAgICAgICAgICAgICAgY2hhcnQudGlwLmdlbmVyYXRlU2ltcGxlVGlwKHRpcERhdGEsIGNoYXJ0LmRhdGEuZGF0YVRhYmxlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY2hhcnQudGlwLmhpZGVUaXAoKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICBub2RlID0gc3ZnLnNlbGVjdEFsbCgnY2lyY2xlLHRleHQnKTtcclxuXHJcbiAgICBkMy5zZWxlY3QoJ2JvZHknKVxyXG4gICAgICAgIC5vbignY2xpY2snLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHpvb20ocm9vdCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgem9vbVRvKFtyb290LngsIHJvb3QueSwgcm9vdC5yICogMiArIG1hcmdpbl0pO1xyXG5cclxuICAgIGZ1bmN0aW9uIHpvb20oZCkge1xyXG4gICAgICAgIHZhciBmb2N1cyA9IGQ7XHJcbiAgICAgICAgZDMudHJhbnNpdGlvbigpXHJcbiAgICAgICAgICAgIC5kdXJhdGlvbihkMy5ldmVudC5hbHRLZXkgPyA3NTAwIDogNzUwKVxyXG4gICAgICAgICAgICAudHdlZW4oJ3pvb20nLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGkgPSBkMy5pbnRlcnBvbGF0ZVpvb20odmlldywgW2ZvY3VzLngsIGZvY3VzLnksIGZvY3VzLnIgKiAyICsgbWFyZ2luXSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHQpIHtcclxuICAgICAgICAgICAgICAgICAgICB6b29tVG8oaSh0KSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHpvb21Ubyh2KSB7XHJcbiAgICAgICAgdmFyIGsgPSBkaWFtZXRlciAvIHZbMl07XHJcblxyXG4gICAgICAgIC8vc2V0IGdsb2JhbCB6b29tXHJcbiAgICAgICAgdmlldyA9IHY7XHJcblxyXG4gICAgICAgIG5vZGUuYXR0cigndHJhbnNmb3JtJywgZCA9PiB7XHJcbiAgICAgICAgICAgIGlmIChkICYmIGQueCAmJiBkLnkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyAoZC54IC0gdlswXSkgKiBrICsgJywnICsgKGQueSAtIHZbMV0pICogayArICcpJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGNpcmNsZS5hdHRyKCdyJywgZCA9PiBkLnIgKiBrKTtcclxuICAgIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBqdkNoYXJ0cztcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIganZDaGFydHMgPSByZXF1aXJlKCcuLi9qdkNoYXJ0cy5qcycpO1xyXG5cclxuanZDaGFydHMucHJvdG90eXBlLnBpZSA9IHtcclxuICAgIHBhaW50OiBwYWludCxcclxuICAgIHNldERhdGE6IHNldERhdGEsXHJcbiAgICBnZXRFdmVudERhdGE6IGdldEV2ZW50RGF0YVxyXG59O1xyXG5cclxuanZDaGFydHMucHJvdG90eXBlLmdlbmVyYXRlUGllID0gZ2VuZXJhdGVQaWU7XHJcblxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIFBpZSBEYXRhIGZ1bmN0aW9ucyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG4vKipzZXRQaWVEYXRhXHJcbiAqICBnZXRzIHBpZSBkYXRhIGFuZCBhZGRzIGl0IHRvIHRoZSBjaGFydCBvYmplY3RcclxuICpcclxuICogQHBhcmFtcyBkYXRhLCBkYXRhVGFibGUsIGNvbG9yc1xyXG4gKi9cclxuZnVuY3Rpb24gc2V0RGF0YSgpIHtcclxuICAgIHZhciBjaGFydCA9IHRoaXM7XHJcblxyXG4gICAgLy9TZXQgZGF0YSBpZiBhICdidWNrZXQnIGlzIHNwZWNpZmllZC0tcGFpbnRzICMgc3BlY2lmaWVkLCBncm91cHMgcmVzdCBpbnRvIG90aGVyIGNhdGVnb3J5XHJcbiAgICBpZiAoY2hhcnQuX3ZhcnMuaGFzT3duUHJvcGVydHkoJ2J1Y2tldHMnKSAmJiBwYXJzZUludChjaGFydC5fdmFycy5idWNrZXRzLCAxMCkgIT09IDApIHtcclxuICAgICAgICAvL2J1Y2tldCB0aGUgZGF0YVxyXG4gICAgICAgIGxldCBkYXRhID0gY2hhcnQuZGF0YSxcclxuICAgICAgICAgICAgb3RoZXIgPSB7fSxcclxuICAgICAgICAgICAgY2F0ZWdvcml6ZWREYXRhID0gW10sIGk7XHJcblxyXG4gICAgICAgIGRhdGEuY2hhcnREYXRhLnNvcnQoKGEsIGIpID0+IGJbZGF0YS5kYXRhVGFibGUudmFsdWVdIC0gYVtkYXRhLmRhdGFUYWJsZS52YWx1ZV0pO1xyXG4gICAgICAgIG90aGVyW2RhdGEuZGF0YVRhYmxlLmxhYmVsXSA9ICdPdGhlcic7XHJcbiAgICAgICAgb3RoZXJbZGF0YS5kYXRhVGFibGUudmFsdWVdID0gMDtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGF0YS5jaGFydERhdGEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGkgPCBjaGFydC5fdmFycy5idWNrZXRzKSB7XHJcbiAgICAgICAgICAgICAgICBjYXRlZ29yaXplZERhdGEucHVzaChkYXRhLmNoYXJ0RGF0YVtpXSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvdGhlcltkYXRhLmRhdGFUYWJsZS52YWx1ZV0gKz0gZGF0YS5jaGFydERhdGFbaV1bZGF0YS5kYXRhVGFibGUudmFsdWVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGVnb3JpemVkRGF0YS5wdXNoKG90aGVyKTtcclxuICAgICAgICBkYXRhLmNoYXJ0RGF0YSA9IGNhdGVnb3JpemVkRGF0YTtcclxuICAgIH1cclxuICAgIC8vU2V0IGxlZ2VuZCBkYXRhIGFmdGVyIGRldGVybWluaW5nIGlmIHRoZSBkYXRhIGlzIGJ1Y2tldGVkXHJcbiAgICBjaGFydC5kYXRhLmxlZ2VuZERhdGEgPSBzZXRQaWVMZWdlbmREYXRhKGNoYXJ0LmRhdGEpO1xyXG4gICAgLy9kZWZpbmUgY29sb3Igb2JqZWN0IGZvciBjaGFydERhdGFcclxuICAgIGNoYXJ0LmRhdGEuY29sb3IgPSBqdkNoYXJ0cy5zZXRDaGFydENvbG9ycyhjaGFydC5fdmFycy5jb2xvciwgY2hhcnQuZGF0YS5sZWdlbmREYXRhLCBjaGFydC5jb2xvcnMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRFdmVudERhdGEoZXZlbnQpIHtcclxuICAgIHZhciBjaGFydCA9IHRoaXMsXHJcbiAgICAgICAgZWxlID0gZXZlbnQudGFyZ2V0LmNsYXNzTGlzdC52YWx1ZS5zcGxpdCgncGllLWRhdGEtJylbMV07XHJcbiAgICBpZiAoZWxlKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgW2NoYXJ0LmN1cnJlbnREYXRhLmRhdGFUYWJsZS5sYWJlbF06IFtlbGUucmVwbGFjZSgvXy9nLCAnICcpLnJlcGxhY2UoL19kb3RfL2csICcuJyldXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG5vZGU6IGV2ZW50LnRhcmdldFxyXG4gICAgICAgIH07XHJcbiAgICB9IGVsc2UgaWYgKGV2ZW50LnRhcmdldC5jbGFzc0xpc3QudmFsdWUuaW5kZXhPZigncGllLWNvbnRhaW5lcicpID4gLTEpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBkYXRhOiB7fVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGRhdGE6IGZhbHNlXHJcbiAgICB9O1xyXG59XHJcblxyXG4vKipzZXRQaWVMZWdlbmREYXRhXHJcbiAqICBnZXRzIGxlZ2VuZCBpbmZvIGZyb20gY2hhcnQgRGF0YVxyXG4gKlxyXG4gKiBAcGFyYW1zIGRhdGEsIHR5cGVcclxuICogQHJldHVybnMgW10gb2YgbGVnZW5kIHRleHRcclxuICovXHJcbmZ1bmN0aW9uIHNldFBpZUxlZ2VuZERhdGEoZGF0YSkge1xyXG4gICAgdmFyIGxlZ2VuZEFycmF5ID0gW107XHJcbiAgICBmb3IgKHZhciBpID0gZGF0YS5jaGFydERhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICBsZWdlbmRBcnJheS5wdXNoKChkYXRhLmNoYXJ0RGF0YVtpXVtkYXRhLmRhdGFUYWJsZS5sYWJlbF0pKTtcclxuICAgIH1cclxuICAgIHJldHVybiBsZWdlbmRBcnJheTtcclxufVxyXG5cclxuZnVuY3Rpb24gcGFpbnQoKSB7XHJcbiAgICB2YXIgY2hhcnQgPSB0aGlzLFxyXG4gICAgICAgIGN1c3RvbU1hcmdpbnMgPSB7XHJcbiAgICAgICAgICAgIHRvcDogNDAsXHJcbiAgICAgICAgICAgIHJpZ2h0OiAyMCxcclxuICAgICAgICAgICAgYm90dG9tOiAyMCxcclxuICAgICAgICAgICAgbGVmdDogMjBcclxuICAgICAgICB9O1xyXG5cclxuICAgIGNoYXJ0LmN1cnJlbnREYXRhID0gY2hhcnQuZGF0YTtcclxuICAgIGNoYXJ0Ll92YXJzLmNvbG9yID0gY2hhcnQuZGF0YS5jb2xvcjtcclxuICAgIGNoYXJ0LmxlZ2VuZERhdGEgPSBjaGFydC5kYXRhLmxlZ2VuZERhdGE7XHJcbiAgICBjaGFydC5nZW5lcmF0ZVNWRyhjaGFydC5kYXRhLmxlZ2VuZERhdGEsIGN1c3RvbU1hcmdpbnMpO1xyXG5cclxuICAgIC8vSWYgdGhlIGNvbnRhaW5lciBzaXplIGlzIHNtYWxsLCBkb24ndCBnZW5lcmF0ZSBhIGxlZ2VuZFxyXG4gICAgaWYgKGNoYXJ0LmNvbmZpZy5jb250YWluZXIud2lkdGggPiA1NTApIHtcclxuICAgICAgICBjaGFydC5nZW5lcmF0ZVZlcnRpY2FsTGVnZW5kKCdnZW5lcmF0ZVBpZScpO1xyXG4gICAgfVxyXG5cclxuICAgIGNoYXJ0LmdlbmVyYXRlUGllKGNoYXJ0LmN1cnJlbnREYXRhKTtcclxufVxyXG5cclxuLyoqZ2VuZXJhdGVQaWVcclxuICpcclxuICogY3JlYXRlcyBhbmQgZHJhd3MgYSBwaWUgY2hhcnQgb24gdGhlIHN2ZyBlbGVtZW50XHJcbiAqIEBwYXJhbXMgc3ZnLCBwaWVEYXRhLCBfdmFycywgY29udGFpbmVyXHJcbiAqIEByZXR1cm5zIHt7fX1cclxuICovXHJcbmZ1bmN0aW9uIGdlbmVyYXRlUGllKGN1cnJlbnREYXRhKSB7XHJcbiAgICB2YXIgY2hhcnQgPSB0aGlzLFxyXG4gICAgICAgIHN2ZyA9IGNoYXJ0LnN2ZyxcclxuICAgICAgICBwaWVEYXRhID0gY3VycmVudERhdGEuY2hhcnREYXRhLFxyXG4gICAgICAgIGNvbnRhaW5lciA9IGNoYXJ0LmNvbmZpZy5jb250YWluZXIsXHJcbiAgICAgICAgbGVnZW5kRGF0YSA9IGNoYXJ0LmN1cnJlbnREYXRhLmxlZ2VuZERhdGEsXHJcbiAgICAgICAgY29sb3JzID0gY2hhcnQuX3ZhcnMuY29sb3IsXHJcbiAgICAgICAgdyA9IGNvbnRhaW5lci53aWR0aCxcclxuICAgICAgICBoID0gY29udGFpbmVyLmhlaWdodCxcclxuICAgICAgICByID0gTWF0aC5taW4oaCAvIDIsIHcgLyAzKSxcclxuICAgICAgICBkYXRhID0gW10sXHJcbiAgICAgICAgdG90YWwgPSAwLFxyXG4gICAgICAgIHBpZURhdGFOZXcsXHJcbiAgICAgICAgbGVnZW5kRWxlbWVudFRvZ2dsZUFycmF5LFxyXG4gICAgICAgIHZpcyxcclxuICAgICAgICBwaWUsXHJcbiAgICAgICAgYXJjLFxyXG4gICAgICAgIGFyY3M7XHJcblxyXG4gICAgLy9kZWZpbmUgdmFyaWFibGVzIHRvIGNoYW5nZSBhdHRyJ3NcclxuICAgIHN2Zy5zZWxlY3QoJ2cucGllLWNvbnRhaW5lcicpLnJlbW92ZSgpO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGllRGF0YS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGxldCBvYmogPSB7fTtcclxuICAgICAgICBmb3IgKGxldCBqIGluIGNoYXJ0LmRhdGEuZGF0YVRhYmxlKSB7XHJcbiAgICAgICAgICAgIGlmIChjaGFydC5kYXRhLmRhdGFUYWJsZS5oYXNPd25Qcm9wZXJ0eShqKSkge1xyXG4gICAgICAgICAgICAgICAgb2JqW2pdID0gcGllRGF0YVtpXVtjaGFydC5kYXRhLmRhdGFUYWJsZVtqXV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZGF0YVtpXSA9IG9iajtcclxuICAgIH1cclxuXHJcbiAgICBwaWVEYXRhTmV3ID0gZGF0YTtcclxuXHJcbiAgICBpZiAoIWNoYXJ0Ll92YXJzLmxlZ2VuZEhlYWRlcnMpIHtcclxuICAgICAgICBjaGFydC5fdmFycy5sZWdlbmRIZWFkZXJzID0gbGVnZW5kRGF0YTtcclxuICAgIH1cclxuXHJcbiAgICBsZWdlbmRFbGVtZW50VG9nZ2xlQXJyYXkgPSBqdkNoYXJ0cy5nZXRMZWdlbmRFbGVtZW50VG9nZ2xlQXJyYXkoY2hhcnQuX3ZhcnMubGVnZW5kSGVhZGVycywgbGVnZW5kRGF0YSk7XHJcblxyXG4gICAgaWYgKGxlZ2VuZEVsZW1lbnRUb2dnbGVBcnJheSkge1xyXG4gICAgICAgIGZvciAobGV0IHNsaWNlIG9mIHBpZURhdGFOZXcpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgbGVnZW5kRWxlIG9mIGxlZ2VuZEVsZW1lbnRUb2dnbGVBcnJheSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGxlZ2VuZEVsZS5lbGVtZW50ID09PSBzbGljZS5sYWJlbCAmJiBsZWdlbmRFbGUudG9nZ2xlID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNsaWNlLnZhbHVlID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgZm9yIChsZXQgc2xpY2Ugb2YgcGllRGF0YU5ldykge1xyXG4gICAgICAgIHRvdGFsICs9IHBhcnNlRmxvYXQoc2xpY2UudmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIHZpcyA9IHN2Z1xyXG4gICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgIC5kYXRhKFtwaWVEYXRhTmV3XSlcclxuICAgICAgICAuYXR0cignY2xhc3MnLCAncGllLWNvbnRhaW5lcicpXHJcbiAgICAgICAgLmF0dHIoJ2hlaWdodCcsIDIwMClcclxuICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke3cgLyAyfSwgJHtyfSlgKTtcclxuXHJcbiAgICBwaWUgPSBkMy5waWUoKS52YWx1ZShkID0+IGQudmFsdWUpO1xyXG5cclxuICAgIC8vZGVjbGFyZSBhbiBhcmMgZ2VuZXJhdG9yIGZ1bmN0aW9uXHJcbiAgICBhcmMgPSBkMy5hcmMoKVxyXG4gICAgICAgIC5pbm5lclJhZGl1cygwKS8vTm9ybWFsIHBpZSBjaGFydCB3aGVuIHRoaXMgPSAwLCBjYW4gYmUgY2hhbmdlZCB0byBjcmVhdGUgZG9udXQgY2hhcnRcclxuICAgICAgICAub3V0ZXJSYWRpdXMocik7XHJcblxyXG4gICAgLy9zZWxlY3QgcGF0aHMsIHVzZSBhcmMgZ2VuZXJhdG9yIHRvIGRyYXdcclxuICAgIGFyY3MgPSB2aXNcclxuICAgICAgICAuc2VsZWN0QWxsKCdnLnNsaWNlJylcclxuICAgICAgICAuZGF0YShwaWUpXHJcbiAgICAgICAgLmVudGVyKCkuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnc2xpY2UnKTtcclxuXHJcbiAgICBhcmNzLmFwcGVuZCgncGF0aCcpXHJcbiAgICAgICAgLmF0dHIoJ2ZpbGwnLCAoZCwgaSkgPT4ganZDaGFydHMuZ2V0Q29sb3JzKGNvbG9ycywgaSwgZC5kYXRhLmxhYmVsKSlcclxuICAgICAgICAuYXR0cignZCcsIGQgPT4gYXJjKGQpKVxyXG4gICAgICAgIC5hdHRyKCdjbGFzcycsIChkLCBpKSA9PiBgZWRpdGFibGUgZWRpdGFibGUtcGllIHBpZS1zbGljZS0ke2l9IGhpZ2hsaWdodC1jbGFzcy0ke2l9IHBpZS1kYXRhLSR7ZC5kYXRhLmxhYmVsLnJlcGxhY2UoL1xccy9nLCAnXycpLnJlcGxhY2UoL1xcLi9nLCAnX2RvdF8nKX1gKVxyXG4gICAgICAgIC5hdHRyKCdzdHJva2UnLCBjaGFydC5fdmFycy5waWVCb3JkZXIpXHJcbiAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIGNoYXJ0Ll92YXJzLnBpZUJvcmRlcldpZHRoKVxyXG4gICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgaWYgKGNoYXJ0LnNob3dUb29sVGlwKSB7XHJcbiAgICAgICAgICAgICAgICAvL0dldCB0aXAgZGF0YVxyXG4gICAgICAgICAgICAgICAgdmFyIHRpcERhdGEgPSBjaGFydC5zZXRUaXBEYXRhKGQuZGF0YSwgaSk7XHJcbiAgICAgICAgICAgICAgICAvLyBEcmF3IHRpcCBsaW5lXHJcbiAgICAgICAgICAgICAgICBjaGFydC50aXAuZ2VuZXJhdGVTaW1wbGVUaXAodGlwRGF0YSwgY2hhcnQuZGF0YS5kYXRhVGFibGUpO1xyXG4gICAgICAgICAgICAgICAgY2hhcnQudGlwLmQgPSBkO1xyXG4gICAgICAgICAgICAgICAgY2hhcnQudGlwLmkgPSBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICAub24oJ21vdXNlbW92ZScsIGZ1bmN0aW9uIChkLCBpKSB7XHJcbiAgICAgICAgICAgIGlmIChjaGFydC5zaG93VG9vbFRpcCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoYXJ0LnRpcC5kID09PSBkICYmIGNoYXJ0LnRpcC5pID09PSBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhcnQudGlwLnNob3dUaXAoZDMuZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvL0dldCB0aXAgZGF0YVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0aXBEYXRhID0gY2hhcnQuc2V0VGlwRGF0YShkLCBpKTtcclxuICAgICAgICAgICAgICAgICAgICAvL0RyYXcgdGlwIGxpbmVcclxuICAgICAgICAgICAgICAgICAgICBjaGFydC50aXAuZ2VuZXJhdGVTaW1wbGVUaXAodGlwRGF0YSwgY2hhcnQuZGF0YS5kYXRhVGFibGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBjaGFydC50aXAuaGlkZVRpcCgpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIGFyY3MuYXBwZW5kKCdzdmc6dGV4dCcpXHJcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3NsaWNlTGFiZWwnKVxyXG4gICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAoZCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgY2VudHJvaWQgPSBhcmMuY2VudHJvaWQoZCk7XHJcbiAgICAgICAgICAgIGNlbnRyb2lkWzBdID0gY2VudHJvaWRbMF0gKiAxLjY7XHJcbiAgICAgICAgICAgIGNlbnRyb2lkWzFdID0gY2VudHJvaWRbMV0gKiAxLjY7XHJcbiAgICAgICAgICAgIHJldHVybiBgdHJhbnNsYXRlKCR7Y2VudHJvaWR9KWA7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuYXR0cignZHknLCAnLjM1ZW0nKVxyXG4gICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKVxyXG4gICAgICAgIC50ZXh0KChkLCBpKSA9PiB7XHJcbiAgICAgICAgICAgIHZhciBwZXJjZW50ID0gcGllRGF0YU5ld1tpXS52YWx1ZSAvIHRvdGFsICogMTAwO1xyXG4gICAgICAgICAgICBwZXJjZW50ID0gZDMuZm9ybWF0KCcuMWYnKShwZXJjZW50KTtcclxuICAgICAgICAgICAgaWYgKHBlcmNlbnQgPiAxKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGVyY2VudCArICclJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmF0dHIoJ2ZvbnQtc2l6ZScsIGNoYXJ0Ll92YXJzLmZvbnRTaXplKVxyXG4gICAgICAgIC5hdHRyKCdmaWxsJywgY2hhcnQuX3ZhcnMucGllVGV4dENvbG9yKVxyXG4gICAgICAgIC5hdHRyKCdwb2ludGVyLWV2ZW50cycsICdub25lJyk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ganZDaGFydHM7XHJcbiIsIid1c2Ugc3RyaWN0JztcclxudmFyIGp2Q2hhcnRzID0gcmVxdWlyZSgnLi4vanZDaGFydHMuanMnKTtcclxuXHJcbmp2Q2hhcnRzLnByb3RvdHlwZS5yYWRpYWwgPSB7XHJcbiAgICBwYWludDogcGFpbnQsXHJcbiAgICBzZXREYXRhOiBzZXREYXRhLFxyXG4gICAgZ2V0RXZlbnREYXRhOiBnZXRFdmVudERhdGFcclxufTtcclxuXHJcbmp2Q2hhcnRzLnByb3RvdHlwZS5nZW5lcmF0ZVJhZGlhbCA9IGdlbmVyYXRlUmFkaWFsO1xyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBSYWRpYWwgRGF0YSBmdW5jdGlvbnMgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG4vKipzZXRSYWRpYWxDaGFydERhdGFcclxuICogIGdldHMgYmFyIGRhdGEgYW5kIGFkZHMgaXQgdG8gdGhlIGNoYXJ0IG9iamVjdFxyXG4gKlxyXG4gKiBAcGFyYW1zIGRhdGEsIGRhdGFUYWJsZSwgY29sb3JzXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXREYXRhKCkge1xyXG4gICAgbGV0IGNoYXJ0ID0gdGhpcztcclxuICAgIGNoYXJ0LmRhdGEubGVnZW5kRGF0YSA9IHNldFJhZGlhbExlZ2VuZERhdGEoY2hhcnQuZGF0YSk7XHJcbiAgICAvL2RlZmluZSBjb2xvciBvYmplY3QgZm9yIGNoYXJ0RGF0YVxyXG4gICAgY2hhcnQuZGF0YS5jb2xvciA9IGp2Q2hhcnRzLnNldENoYXJ0Q29sb3JzKGNoYXJ0Ll92YXJzLmNvbG9yLCBjaGFydC5kYXRhLmxlZ2VuZERhdGEsIGNoYXJ0LmNvbG9ycyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhaW50KCkge1xyXG4gICAgbGV0IGNoYXJ0ID0gdGhpcyxcclxuICAgICAgICByYWRpYWxNYXJnaW5zID0ge1xyXG4gICAgICAgICAgICB0b3A6IDQwLFxyXG4gICAgICAgICAgICByaWdodDogMjAsXHJcbiAgICAgICAgICAgIGJvdHRvbTogMjAsXHJcbiAgICAgICAgICAgIGxlZnQ6IDIwXHJcbiAgICAgICAgfTtcclxuICAgIGNoYXJ0Ll92YXJzLmNvbG9yID0gY2hhcnQuZGF0YS5jb2xvcjtcclxuICAgIGNoYXJ0LmN1cnJlbnREYXRhID0gY2hhcnQuZGF0YTsvL01pZ2h0IGhhdmUgdG8gbW92ZSBpbnRvIG1ldGhvZCBiYyBvZiByZWZlcmVuY2UvdmFsdWUgcmVsYXRpb25zaGlwXHJcblxyXG4gICAgLy9HZW5lcmF0ZSBTVkctbGVnZW5kIGRhdGEgaXMgdXNlZCB0byBkZXRlcm1pbmUgdGhlIHNpemUgb2YgdGhlIGJvdHRvbSBtYXJnaW4gKHNldCB0byBudWxsIGZvciBubyBsZWdlbmQpXHJcbiAgICBjaGFydC5nZW5lcmF0ZVNWRyhudWxsLCByYWRpYWxNYXJnaW5zKTtcclxuICAgIGNoYXJ0LmdlbmVyYXRlVmVydGljYWxMZWdlbmQoJ2dlbmVyYXRlUmFkaWFsJyk7XHJcbiAgICBjaGFydC5nZW5lcmF0ZVJhZGlhbCgpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRFdmVudERhdGEoZXZlbnQpIHtcclxuICAgIGxldCBjaGFydCA9IHRoaXMsXHJcbiAgICAgICAgZWxlID0gZXZlbnQudGFyZ2V0LmNsYXNzTGlzdC52YWx1ZS5zcGxpdCgncmFkaWFsLWRhdGEtJylbMV07XHJcbiAgICBpZiAoZWxlKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgW2NoYXJ0LmN1cnJlbnREYXRhLmRhdGFUYWJsZS5sYWJlbF06IFtlbGUucmVwbGFjZSgvXy9nLCAnICcpLnJlcGxhY2UoL19kb3RfL2csICcuJyldXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG5vZGU6IGV2ZW50LnRhcmdldFxyXG4gICAgICAgIH07XHJcbiAgICB9IGVsc2UgaWYgKGV2ZW50LnRhcmdldC5jbGFzc0xpc3QudmFsdWUuaW5kZXhPZigncmFkaWFsLWNvbnRhaW5lcicpID4gLTEpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBkYXRhOiB7fVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGRhdGE6IGZhbHNlXHJcbiAgICB9O1xyXG59XHJcblxyXG4vKipzZXRSYWRpYWxMZWdlbmREYXRhXHJcbiAqICBnZXRzIGxlZ2VuZCBpbmZvIGZyb20gY2hhcnQgRGF0YVxyXG4gKlxyXG4gKiBAcGFyYW1zIGRhdGEsIHR5cGVcclxuICogQHJldHVybnMgW10gb2YgbGVnZW5kIHRleHRcclxuICovXHJcbmZ1bmN0aW9uIHNldFJhZGlhbExlZ2VuZERhdGEoZGF0YSkge1xyXG4gICAgdmFyIGxlZ2VuZEFycmF5ID0gW107XHJcbiAgICBmb3IgKGxldCBjaGFydEVsZSBvZiBkYXRhLmNoYXJ0RGF0YSkge1xyXG4gICAgICAgIGlmIChsZWdlbmRBcnJheS5pbmRleE9mKGNoYXJ0RWxlW2RhdGEuZGF0YVRhYmxlLmxhYmVsXSkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIGxlZ2VuZEFycmF5LnB1c2goKGNoYXJ0RWxlW2RhdGEuZGF0YVRhYmxlLmxhYmVsXSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBsZWdlbmRBcnJheTtcclxufVxyXG5cclxuLyoqZ2VuZXJhdGVSYWRpYWxcclxuICpcclxuICogcGFpbnRzIHRoZSByYWRpbCBiYXIgY2hhcnQgb24gdGhlIGNoYXJ0XHJcbiAqIEBwYXJhbXMgcmFkaWFsRGF0YVxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIGdlbmVyYXRlUmFkaWFsKCkge1xyXG4gICAgdmFyIGNoYXJ0ID0gdGhpcyxcclxuICAgICAgICBzdmcgPSBjaGFydC5zdmcsXHJcbiAgICAgICAgY29sb3JzID0gY2hhcnQuX3ZhcnMuY29sb3IsXHJcbiAgICAgICAgY29udGFpbmVyID0gY2hhcnQuY29uZmlnLmNvbnRhaW5lcixcclxuICAgICAgICBsZWdlbmREYXRhID0gY2hhcnQuZGF0YS5sZWdlbmREYXRhLFxyXG4gICAgICAgIHJhZGlhbERhdGEgPSBjaGFydC5kYXRhLmNoYXJ0RGF0YSxcclxuICAgICAgICB0aWNrTnVtYmVyID0gMyxcclxuICAgICAgICBiYXJIZWlnaHQgPSBjb250YWluZXIuaGVpZ2h0IC8gMiAtIDQwLFxyXG4gICAgICAgIHdpZHRoID0gY29udGFpbmVyLndpZHRoLFxyXG4gICAgICAgIGhlaWdodCA9IGNvbnRhaW5lci5oZWlnaHQsXHJcbiAgICAgICAgciA9IE1hdGgubWluKGhlaWdodCAvIDIsIHdpZHRoIC8gMyksXHJcbiAgICAgICAgZGF0YSA9IFtdLFxyXG4gICAgICAgIHJhZGlhbERhdGFOZXcsXHJcbiAgICAgICAgZGF0YUhlYWRlcnMsXHJcbiAgICAgICAgbGVnZW5kRWxlbWVudFRvZ2dsZUFycmF5ID0gW10sXHJcbiAgICAgICAgcmFkaWFsRGF0YUZpbHRlcmVkLFxyXG4gICAgICAgIG9iaixcclxuICAgICAgICB2aXMsXHJcbiAgICAgICAgZXh0ZW50LFxyXG4gICAgICAgIGZvcm1hdE51bWJlcixcclxuICAgICAgICBiYXJTY2FsZSxcclxuICAgICAgICBrZXlzLFxyXG4gICAgICAgIG51bUJhcnMsXHJcbiAgICAgICAgeCxcclxuICAgICAgICB4QXhpcyxcclxuICAgICAgICBhcmMsXHJcbiAgICAgICAgc2VnbWVudHMsXHJcbiAgICAgICAgYXhpc0dyb3VwO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSByYWRpYWxEYXRhLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgb2JqID0ge307XHJcbiAgICAgICAgZm9yIChsZXQgaiBpbiBjaGFydC5kYXRhLmRhdGFUYWJsZSkge1xyXG4gICAgICAgICAgICBvYmpbal0gPSByYWRpYWxEYXRhW2ldW2NoYXJ0LmRhdGEuZGF0YVRhYmxlW2pdXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGF0YVtpXSA9IG9iajtcclxuICAgIH1cclxuXHJcbiAgICByYWRpYWxEYXRhTmV3ID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShkYXRhKSk7Ly9jb3B5IG9mIHBpZSBkYXRhXHJcblxyXG5cclxuICAgIGlmICghY2hhcnQuX3ZhcnMubGVnZW5kSGVhZGVycykge1xyXG4gICAgICAgIGNoYXJ0Ll92YXJzLmxlZ2VuZEhlYWRlcnMgPSBsZWdlbmREYXRhO1xyXG4gICAgfVxyXG5cclxuICAgIGRhdGFIZWFkZXJzID0gY2hhcnQuX3ZhcnMubGVnZW5kSGVhZGVycztcclxuICAgIGxlZ2VuZEVsZW1lbnRUb2dnbGVBcnJheSA9IGp2Q2hhcnRzLmdldExlZ2VuZEVsZW1lbnRUb2dnbGVBcnJheShkYXRhSGVhZGVycywgbGVnZW5kRGF0YSk7XHJcbiAgICByYWRpYWxEYXRhRmlsdGVyZWQgPSBbXTtcclxuXHJcbiAgICBpZiAobGVnZW5kRWxlbWVudFRvZ2dsZUFycmF5KSB7XHJcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCByYWRpYWxEYXRhTmV3Lmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVnZW5kRWxlbWVudFRvZ2dsZUFycmF5Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobGVnZW5kRWxlbWVudFRvZ2dsZUFycmF5W2ldLmVsZW1lbnQgPT09IHJhZGlhbERhdGFOZXdbal0ubGFiZWwgJiYgbGVnZW5kRWxlbWVudFRvZ2dsZUFycmF5W2ldLnRvZ2dsZSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICByYWRpYWxEYXRhTmV3W2pdLnZhbHVlID0gLTE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCByYWRpYWxEYXRhTmV3Lmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgaWYgKHJhZGlhbERhdGFOZXdbal0udmFsdWUgIT09IC0xKSB7XHJcbiAgICAgICAgICAgIHJhZGlhbERhdGFGaWx0ZXJlZC5wdXNoKHJhZGlhbERhdGFOZXdbal0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvL1JlbW92ZSBleGlzdGluZyBiYXJzIGZyb20gcGFnZVxyXG4gICAgc3ZnLnNlbGVjdEFsbCgnZy5yYWRpYWwtY29udGFpbmVyJykucmVtb3ZlKCk7XHJcblxyXG5cclxuICAgIHZpcyA9IHN2Z1xyXG4gICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICdyYWRpYWwtY29udGFpbmVyJylcclxuICAgICAgICAuYXR0cignaGVpZ2h0JywgaGVpZ2h0KVxyXG4gICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCAke3dpZHRoIC8gMn0gLCAke3J9IClgKTtcclxuXHJcbiAgICBleHRlbnQgPSBkMy5leHRlbnQocmFkaWFsRGF0YUZpbHRlcmVkLCBkID0+IGQudmFsdWUpO1xyXG5cclxuICAgIC8vY29tbWFzIGFuZCAwIGRlY2ltYWxzXHJcbiAgICBmb3JtYXROdW1iZXIgPSBkMy5mb3JtYXQoJywuMGYnKTtcclxuICAgIGlmIChleHRlbnRbMV0gPj0gMTAwMDAwMCkge1xyXG4gICAgICAgIC8vbWlsbGlvbnNcclxuICAgICAgICBsZXQgcCA9IGQzLnByZWNpc2lvblByZWZpeCgxZTUsIDEuM2U2KTtcclxuICAgICAgICBmb3JtYXROdW1iZXIgPSBkMy5mb3JtYXRQcmVmaXgoJy4nICsgcCwgMS4zZTYpO1xyXG4gICAgfSBlbHNlIGlmIChleHRlbnRbMV0gPD0gMTAwKSB7XHJcbiAgICAgICAgLy8yIGRlY2ltYWxzXHJcbiAgICAgICAgZm9ybWF0TnVtYmVyID0gZDMuZm9ybWF0KCcsLjJmJyk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGlmIChleHRlbnRbMF0gIT09IDApIHtcclxuICAgICAgICBleHRlbnRbMF0gPSAwO1xyXG4gICAgfVxyXG4gICAgYmFyU2NhbGUgPSBkMy5zY2FsZUxpbmVhcigpXHJcbiAgICAgICAgLmRvbWFpbihleHRlbnQpXHJcbiAgICAgICAgLnJhbmdlKFswLCBiYXJIZWlnaHRdKTtcclxuXHJcbiAgICBrZXlzID0gcmFkaWFsRGF0YUZpbHRlcmVkLm1hcChkID0+IGQubGFiZWwpO1xyXG4gICAgbnVtQmFycyA9IGtleXMubGVuZ3RoO1xyXG5cclxuICAgIHggPSBkMy5zY2FsZUxpbmVhcigpXHJcbiAgICAgICAgLmRvbWFpbihleHRlbnQpXHJcbiAgICAgICAgLnJhbmdlKFswLCAtYmFySGVpZ2h0XSk7XHJcblxyXG4gICAgLy9jcmVhdGUgeEF4aXMgZHJhd2luZyBmdW5jdGlvblxyXG4gICAgeEF4aXMgPSBkMy5heGlzTGVmdCgpXHJcbiAgICAgICAgLnNjYWxlKHgpXHJcbiAgICAgICAgLnRpY2tzKHRpY2tOdW1iZXIpXHJcbiAgICAgICAgLnRpY2tGb3JtYXQoZm9ybWF0TnVtYmVyKTtcclxuXHJcbiAgICB2aXMuc2VsZWN0QWxsKCdjaXJjbGUnKVxyXG4gICAgICAgIC5kYXRhKHgudGlja3MoMykpXHJcbiAgICAgICAgLmVudGVyKCkuYXBwZW5kKCdjaXJjbGUnKVxyXG4gICAgICAgIC5hdHRyKCdyJywgZCA9PiBiYXJTY2FsZShkKSlcclxuICAgICAgICAuc3R5bGUoJ2ZpbGwnLCAnbm9uZScpXHJcbiAgICAgICAgLnN0eWxlKCdzdHJva2UnLCAnYmxhY2snKVxyXG4gICAgICAgIC5zdHlsZSgnc3Ryb2tlLWRhc2hhcnJheScsICcyLDInKVxyXG4gICAgICAgIC5zdHlsZSgnc3Ryb2tlLXdpZHRoJywgJy41cHgnKTtcclxuXHJcbiAgICBhcmMgPSBkMy5hcmMoKVxyXG4gICAgICAgIC5zdGFydEFuZ2xlKChkLCBpKSA9PiAoaSAqIDIgKiBNYXRoLlBJKSAvIG51bUJhcnMpXHJcbiAgICAgICAgLmVuZEFuZ2xlKChkLCBpKSA9PiAoKGkgKyAxKSAqIDIgKiBNYXRoLlBJKSAvIG51bUJhcnMpXHJcbiAgICAgICAgLmlubmVyUmFkaXVzKDApO1xyXG5cclxuICAgIHNlZ21lbnRzID0gdmlzLnNlbGVjdEFsbCgncGF0aCcpXHJcbiAgICAgICAgLmRhdGEocmFkaWFsRGF0YUZpbHRlcmVkKVxyXG4gICAgICAgIC5lbnRlcigpLmFwcGVuZCgnZycpXHJcbiAgICAgICAgLmFwcGVuZCgncGF0aCcpXHJcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgKGQpID0+ICdyYWRpYWwtZGF0YS0nICsgZC5sYWJlbC5yZXBsYWNlKC9cXHMvZywgJ18nKS5yZXBsYWNlKC9cXC4vZywgJ19kb3RfJykpXHJcbiAgICAgICAgLmVhY2goZCA9PiB7XHJcbiAgICAgICAgICAgIGQub3V0ZXJSYWRpdXMgPSAwO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLnN0eWxlKCdmaWxsJywgKGQsIGkpID0+IGp2Q2hhcnRzLmdldENvbG9ycyhjb2xvcnMsIGksIGQubGFiZWwpKVxyXG4gICAgICAgIC5hdHRyKCdkJywgYXJjKVxyXG4gICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgaWYgKGNoYXJ0LnNob3dUb29sVGlwKSB7XHJcbiAgICAgICAgICAgICAgICAvL0dldCB0aXAgZGF0YVxyXG4gICAgICAgICAgICAgICAgdmFyIHRpcERhdGEgPSBjaGFydC5zZXRUaXBEYXRhKGQsIGkpO1xyXG4gICAgICAgICAgICAgICAgLy9EcmF3IHRpcCBsaW5lXHJcbiAgICAgICAgICAgICAgICBjaGFydC50aXAuZ2VuZXJhdGVTaW1wbGVUaXAodGlwRGF0YSwgY2hhcnQuZGF0YS5kYXRhVGFibGUpO1xyXG4gICAgICAgICAgICAgICAgY2hhcnQudGlwLmQgPSBkO1xyXG4gICAgICAgICAgICAgICAgY2hhcnQudGlwLmkgPSBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICAub24oJ21vdXNlbW92ZScsIGZ1bmN0aW9uIChkLCBpKSB7XHJcbiAgICAgICAgICAgIGlmIChjaGFydC5zaG93VG9vbFRpcCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoYXJ0LnRpcC5kID09PSBkICYmIGNoYXJ0LnRpcC5pID09PSBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhcnQudGlwLnNob3dUaXAoZDMuZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvL0dldCB0aXAgZGF0YVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0aXBEYXRhID0gY2hhcnQuc2V0VGlwRGF0YShkLCBpKTtcclxuICAgICAgICAgICAgICAgICAgICAvL0RyYXcgdGlwIGxpbmVcclxuICAgICAgICAgICAgICAgICAgICBjaGFydC50aXAuZ2VuZXJhdGVTaW1wbGVUaXAodGlwRGF0YSwgY2hhcnQuZGF0YS5kYXRhVGFibGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgaWYgKGNoYXJ0LnNob3dUb29sVGlwKSB7XHJcbiAgICAgICAgICAgICAgICBjaGFydC50aXAuaGlkZVRpcCgpO1xyXG4gICAgICAgICAgICAgICAgc3ZnLnNlbGVjdEFsbCgnbGluZS50aXAtbGluZScpLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgc2VnbWVudHNcclxuICAgICAgICAudHJhbnNpdGlvbigpXHJcbiAgICAgICAgLmR1cmF0aW9uKDgwMClcclxuICAgICAgICAuZWFzZShkMy5lYXNlRWxhc3RpYylcclxuICAgICAgICAuZGVsYXkoKGQsIGkpID0+IDc1MCAtIDUwICogaSlcclxuICAgICAgICAuYXR0clR3ZWVuKCdkJywgKGQsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgIHZhciBpID0gZDMuaW50ZXJwb2xhdGUoZC5vdXRlclJhZGl1cywgYmFyU2NhbGUoK2QudmFsdWUpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHQgPT4ge1xyXG4gICAgICAgICAgICAgICAgZC5vdXRlclJhZGl1cyA9IGkodCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJjKGQsIGluZGV4KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICB2aXMuYXBwZW5kKCdjaXJjbGUnKVxyXG4gICAgICAgIC5hdHRyKCdyJywgYmFySGVpZ2h0KVxyXG4gICAgICAgIC5jbGFzc2VkKCdvdXRlcicsIHRydWUpXHJcbiAgICAgICAgLnN0eWxlKCdmaWxsJywgJ25vbmUnKVxyXG4gICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgJ2JsYWNrJylcclxuICAgICAgICAuc3R5bGUoJ3N0cm9rZS13aWR0aCcsICcxLjVweCcpO1xyXG5cclxuICAgIHZpcy5zZWxlY3RBbGwoJ2xpbmUnKVxyXG4gICAgICAgIC5kYXRhKGtleXMpXHJcbiAgICAgICAgLmVudGVyKCkuYXBwZW5kKCdnJylcclxuICAgICAgICAuYXR0cignY2xhc3MnLCAnbGFiZWwnKVxyXG4gICAgICAgIC5hcHBlbmQoJ2xpbmUnKVxyXG4gICAgICAgIC5hdHRyKCd5MicsIC1iYXJIZWlnaHQgLSAyMClcclxuICAgICAgICAuc3R5bGUoJ3N0cm9rZScsICdibGFjaycpXHJcbiAgICAgICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLCAnLjVweCcpXHJcbiAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIChkLCBpKSA9PiBgcm90YXRlKCAke2kgKiAzNjAgLyBudW1CYXJzfSApYCk7XHJcblxyXG4gICAgYXhpc0dyb3VwID0gdmlzLmFwcGVuZCgnZycpXHJcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3hBeGlzJylcclxuICAgICAgICAuc3R5bGUoJ3BvaW50ZXItZXZlbnRzJywgJ25vbmUnKVxyXG4gICAgICAgIC5jYWxsKHhBeGlzKTtcclxuXHJcbiAgICBheGlzR3JvdXAuc2VsZWN0QWxsKCd0ZXh0JylcclxuICAgICAgICAuYXR0cignZmlsbCcsICdibGFjaycpLy9DdXN0b21pemUgdGhlIGNvbG9yIG9mIGF4aXMgbGFiZWxzXHJcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3lBeGlzTGFiZWxzIGVkaXRhYmxlIGVkaXRhYmxlLXlBeGlzIGVkaXRhYmxlLXRleHQgZWRpdGFibGUtbnVtJylcclxuICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZCA9PiB7XHJcbiAgICAgICAgICAgIGlmIChkID09PSB4QXhpcy5zY2FsZSgpLnRpY2tzKHRpY2tOdW1iZXIpW3RpY2tOdW1iZXJdKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgwLCAxMCknO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKDAsMCknO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmF0dHIoJ2ZvbnQtc2l6ZScsIGNoYXJ0Ll92YXJzLmZvbnRTaXplKVxyXG4gICAgICAgIC5hcHBlbmQoJ3N2Zzp0aXRsZScpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGp2Q2hhcnRzO1xyXG4iLCIndXNlIHN0cmljdCc7XHJcbnZhciBqdkNoYXJ0cyA9IHJlcXVpcmUoJy4uL2p2Q2hhcnRzLmpzJyk7XHJcblxyXG5qdkNoYXJ0cy5wcm90b3R5cGUuc2Fua2V5ID0ge1xyXG4gICAgcGFpbnQ6IHBhaW50LFxyXG4gICAgc2V0RGF0YTogc2V0RGF0YSxcclxuICAgIGdldEV2ZW50RGF0YTogZ2V0RXZlbnREYXRhXHJcbn07XHJcblxyXG5qdkNoYXJ0cy5wcm90b3R5cGUuZ2VuZXJhdGVTYW5rZXkgPSBnZW5lcmF0ZVNhbmtleTtcclxuXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogU2Fua2V5IGZ1bmN0aW9ucyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcbi8qKlxyXG4gKlxyXG4gKiBAcGFyYW0gZGF0YVxyXG4gKiBAcGFyYW0gZGF0YVRhYmxlXHJcbiAqIEBwYXJhbSBjb2xvcnNcclxuICovXHJcbmZ1bmN0aW9uIHNldERhdGEoKSB7XHJcbiAgICB2YXIgY2hhcnQgPSB0aGlzO1xyXG4gICAgdmFyIHNhbmtleURhdGEgPSB7fSxcclxuICAgICAgICBkYXRhID0gY2hhcnQuZGF0YS5jaGFydERhdGEsXHJcbiAgICAgICAgZGF0YVRhYmxlID0gY2hhcnQuZGF0YS5kYXRhVGFibGU7XHJcblxyXG4gICAgc2Fua2V5RGF0YS5saW5rcyA9IFtdO1xyXG4gICAgc2Fua2V5RGF0YS5ub2RlcyA9IFtdO1xyXG5cclxuICAgIC8vSXRlcmF0ZSB0aHJvdWdoIHNvdXJjZXMgYW5kIHRhcmdldHMgdG8gbWFrZSBhIG5vZGUgbGlzdFxyXG4gICAgdmFyIG5vZGVMaXN0ID0gW107XHJcbiAgICB2YXIgbm9kZUdyb3VwID0gMTtcclxuICAgIGZvciAodmFyIGl0ZW0gaW4gZGF0YVRhYmxlKSB7XHJcbiAgICAgICAgdmFyIG5vZGVMaXN0Rm9yTGFiZWwgPSBbXTtcclxuICAgICAgICBpZiAoaXRlbSA9PT0gJ3ZhbHVlJykgeyBjb250aW51ZTsgfVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgcG90ZW50aWFsTm9kZSA9IGRhdGFbaV1bZGF0YVRhYmxlW2l0ZW1dXSArICctJyArIG5vZGVHcm91cDtcclxuICAgICAgICAgICAgdmFyIGFkZFRvTGlzdCA9IHRydWU7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbm9kZUxpc3RGb3JMYWJlbC5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHBvdGVudGlhbE5vZGUgPT09IG5vZGVMaXN0Rm9yTGFiZWxbal0pIHtcclxuICAgICAgICAgICAgICAgICAgICBhZGRUb0xpc3QgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYWRkVG9MaXN0KSB7XHJcbiAgICAgICAgICAgICAgICBub2RlTGlzdEZvckxhYmVsLnB1c2gocG90ZW50aWFsTm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbm9kZUdyb3VwKys7XHJcbiAgICAgICAgbm9kZUxpc3QgPSBub2RlTGlzdC5jb25jYXQobm9kZUxpc3RGb3JMYWJlbCk7XHJcbiAgICB9XHJcbiAgICAvL0NyZWF0ZSBub2RlcyBvYmplY3RcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZUxpc3QubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBzYW5rZXlEYXRhLm5vZGVzLnB1c2goe1xyXG4gICAgICAgICAgICAnbmFtZSc6IG5vZGVMaXN0W2ldXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy9TZWUgaG93IG1hbnkgc2V0cyBvZiBsaW5rcyB5b3UgbmVlZFxyXG4gICAgdmFyIGxpbmtHcm91cHMgPSAwO1xyXG5cclxuICAgIGZvciAobGV0IGl0ZW0gaW4gZGF0YVRhYmxlKSB7XHJcbiAgICAgICAgaWYgKGl0ZW0uaW5kZXhPZignbGFiZWwnKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgbGlua0dyb3VwcysrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBsZXQgc291cmNlLFxyXG4gICAgICAgIHRhcmdldCxcclxuICAgICAgICB2YWx1ZTtcclxuXHJcbiAgICBmb3IgKGxldCBrIGluIGRhdGFUYWJsZSkge1xyXG4gICAgICAgIGlmIChrLmluZGV4T2YoJ3ZhbHVlJykgPiAtMSkge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IGRhdGFUYWJsZVtrXTtcclxuICAgICAgICB9IGVsc2UgaWYgKCFzb3VyY2UpIHtcclxuICAgICAgICAgICAgc291cmNlID0gZGF0YVRhYmxlW2tdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRhcmdldCA9IGRhdGFUYWJsZVtrXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBsaW5rR3JvdXBzOyBpKyspIHtcclxuICAgICAgICB2YXIgbGlua0dyb3VwID0gW107XHJcbiAgICAgICAgbGlua0dyb3VwID0gZGF0YS5tYXAoZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICdzb3VyY2UnOiB4W3NvdXJjZV0gKyAnLScgKyBpLFxyXG4gICAgICAgICAgICAgICAgJ3RhcmdldCc6IHhbdGFyZ2V0XSArICctJyArIChpICsgMSksXHJcbiAgICAgICAgICAgICAgICAndmFsdWUnOiB4W3ZhbHVlXVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBzYW5rZXlEYXRhLmxpbmtzID0gc2Fua2V5RGF0YS5saW5rcy5jb25jYXQobGlua0dyb3VwKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbm9kZU1hcCA9IHt9O1xyXG4gICAgZm9yIChpID0gMDsgaSA8IHNhbmtleURhdGEubm9kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBzYW5rZXlEYXRhLm5vZGVzW2ldLm5vZGUgPSBpO1xyXG4gICAgICAgIG5vZGVNYXBbc2Fua2V5RGF0YS5ub2Rlc1tpXS5uYW1lXSA9IGk7XHJcbiAgICB9XHJcbiAgICBzYW5rZXlEYXRhLmxpbmtzID0gc2Fua2V5RGF0YS5saW5rcy5tYXAoZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzb3VyY2U6IG5vZGVNYXBbeC5zb3VyY2VdLFxyXG4gICAgICAgICAgICB0YXJnZXQ6IG5vZGVNYXBbeC50YXJnZXRdLFxyXG4gICAgICAgICAgICB2YWx1ZTogeC52YWx1ZVxyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxuXHJcbiAgICAvL0dyb3VwIGNvbW1vbiBzYW5rZXkgbGlua3MgdG9nZXRoZXIgYW5kIGFkZCB0aGUgdmFsdWVzXHJcbiAgICB2YXIgYWdncmVnYXRlU2Fua2V5TGlua3MgPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2Fua2V5RGF0YS5saW5rcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciBjdXJyZW50TGluayA9IHt9O1xyXG4gICAgICAgIGN1cnJlbnRMaW5rLnNvdXJjZSA9IHNhbmtleURhdGEubGlua3NbaV0uc291cmNlO1xyXG4gICAgICAgIGN1cnJlbnRMaW5rLnRhcmdldCA9IHNhbmtleURhdGEubGlua3NbaV0udGFyZ2V0O1xyXG4gICAgICAgIGN1cnJlbnRMaW5rLnZhbHVlID0gc2Fua2V5RGF0YS5saW5rc1tpXS52YWx1ZTtcclxuXHJcbiAgICAgICAgLy9NYWtlIHN1cmUgdGhhdCBvbmx5IHVuaXF1ZSBsaW5rcyBhcmUgcHVzaGVkIHRvIHRoZSBhZ2dyZWdhdGVkIGFycmF5XHJcbiAgICAgICAgbGV0IGFkZFRvQWdncmVnYXRlID0gdHJ1ZTtcclxuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGFnZ3JlZ2F0ZVNhbmtleUxpbmtzLmxlbmd0aDsgaysrKSB7XHJcbiAgICAgICAgICAgIGlmIChhZ2dyZWdhdGVTYW5rZXlMaW5rc1trXS5zb3VyY2UgPT09IGN1cnJlbnRMaW5rLnNvdXJjZSAmJiBhZ2dyZWdhdGVTYW5rZXlMaW5rc1trXS50YXJnZXQgPT09IGN1cnJlbnRMaW5rLnRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgYWRkVG9BZ2dyZWdhdGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWFkZFRvQWdncmVnYXRlKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9TdW0gdGhlIHZhbHVlIG9mIGlkZW50aWNhbCBsaW5rc1xyXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2Fua2V5RGF0YS5saW5rcy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICBpZiAoc2Fua2V5RGF0YS5saW5rc1tpXS5zb3VyY2UgPT09IHNhbmtleURhdGEubGlua3Nbal0uc291cmNlICYmIHNhbmtleURhdGEubGlua3NbaV0udGFyZ2V0ID09PSBzYW5rZXlEYXRhLmxpbmtzW2pdLnRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudExpbmsudmFsdWUgPSBjdXJyZW50TGluay52YWx1ZSArIHNhbmtleURhdGEubGlua3Nbal0udmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGFnZ3JlZ2F0ZVNhbmtleUxpbmtzLnB1c2goY3VycmVudExpbmspO1xyXG4gICAgfVxyXG5cclxuICAgIHNhbmtleURhdGEubGlua3MgPSBhZ2dyZWdhdGVTYW5rZXlMaW5rcztcclxuXHJcbiAgICBjaGFydC5kYXRhLmNoYXJ0RGF0YSA9IHNhbmtleURhdGE7XHJcbiAgICBjaGFydC5kYXRhLmNvbG9yID0gZDMuc2NhbGVPcmRpbmFsKGQzLnNjaGVtZUNhdGVnb3J5MjApO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwYWludCgpIHtcclxuICAgIHZhciBjaGFydCA9IHRoaXM7XHJcbiAgICB2YXIgZGF0YSA9IGNoYXJ0LmRhdGEuY2hhcnREYXRhO1xyXG5cclxuICAgIC8vZ2VuZXJhdGUgU1ZHXHJcbiAgICBjaGFydC5nZW5lcmF0ZVNWRyhudWxsKTtcclxuICAgIGNoYXJ0LmdlbmVyYXRlU2Fua2V5KGRhdGEpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRFdmVudERhdGEoKSB7XHJcbiAgICByZXR1cm4ge307XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSBzYW5rZXkgY2hhcnQgd2l0aCB0aGUgZ2l2ZW4gZGF0YVxyXG4gKiBAcGFyYW0gc2Fua2V5RGF0YVxyXG4gKi9cclxuZnVuY3Rpb24gZ2VuZXJhdGVTYW5rZXkoc2Fua2V5RGF0YSkge1xyXG4gICAgdmFyIGNoYXJ0ID0gdGhpcyxcclxuICAgICAgICBzdmcgPSBjaGFydC5zdmcsXHJcbiAgICAgICAgY29sb3IgPSBjaGFydC5fdmFycy5jb2xvcjtcclxuXHJcbiAgICB2YXIgd2lkdGggPSBjaGFydC5jb25maWcuY29udGFpbmVyLndpZHRoO1xyXG4gICAgdmFyIGhlaWdodCA9IGNoYXJ0LmNvbmZpZy5jb250YWluZXIuaGVpZ2h0O1xyXG5cclxuICAgIHZhciBmb3JtYXROdW1iZXIgPSBkMy5mb3JtYXQoJywuMGYnKSwgICAgLy96ZXJvIGRlY2ltYWwgcGxhY2VzXHJcbiAgICAgICAgZm9ybWF0ID0gZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGZvcm1hdE51bWJlcihkKSArICcgJyArICdXaWRnZXRzJzsgfSxcclxuICAgICAgICBjb2xvciA9IGQzLnNjYWxlT3JkaW5hbChkMy5zY2hlbWVDYXRlZ29yeTIwKTtcclxuXHJcbiAgICB2YXIgc2Fua2V5ID0gZDMuc2Fua2V5KClcclxuICAgICAgICAubm9kZVdpZHRoKDEwKVxyXG4gICAgICAgIC5ub2RlUGFkZGluZygxNSlcclxuICAgICAgICAuc2l6ZShbd2lkdGgsIGhlaWdodF0pO1xyXG5cclxuICAgIHZhciBwYXRoID0gc2Fua2V5LmxpbmsoKTtcclxuXHJcbiAgICAvLy8vQWRkaW5nIHpvb20gdjQgYmVoYXZpb3IgdG8gc2Fua2V5XHJcbiAgICBkMy5zZWxlY3RBbGwoJ3N2ZycpXHJcbiAgICAgICAgLmNhbGwoZDMuem9vbSgpXHJcbiAgICAgICAgICAgIC5zY2FsZUV4dGVudChbMC4xLCAxMF0pXHJcbiAgICAgICAgICAgIC5vbignem9vbScsIHpvb20pKTsvL3pvb20gZXZlbnQgbGlzdGVuZXJcclxuXHJcbiAgICBzYW5rZXlcclxuICAgICAgICAubm9kZXMoc2Fua2V5RGF0YS5ub2RlcylcclxuICAgICAgICAubGlua3Moc2Fua2V5RGF0YS5saW5rcylcclxuICAgICAgICAubGF5b3V0KDMyKTtcclxuXHJcbiAgICB2YXIgbGluayA9IHN2Zy5hcHBlbmQoJ2cnKS5zZWxlY3RBbGwoJy5zYW5rZXktbGluaycpXHJcbiAgICAgICAgLmRhdGEoc2Fua2V5RGF0YS5saW5rcylcclxuICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgIC5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQudmFsdWUgPiAwOyB9KVxyXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICdzYW5rZXktbGluaycpXHJcbiAgICAgICAgLmF0dHIoJ2QnLCBwYXRoKVxyXG4gICAgICAgIC5zdHlsZSgnc3Ryb2tlLXdpZHRoJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KDEsIGQuZHkpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGIuZHkgLSBhLmR5O1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICBpZiAoY2hhcnQuc2hvd1Rvb2xUaXApIHtcclxuICAgICAgICAgICAgICAgIHZhciB0aXBEYXRhID0gY2hhcnQuc2V0VGlwRGF0YShkLCBpKTtcclxuICAgICAgICAgICAgICAgIGNoYXJ0LnRpcC5nZW5lcmF0ZVNpbXBsZVRpcCh0aXBEYXRhLCBjaGFydC5kYXRhLmRhdGFUYWJsZSk7XHJcbiAgICAgICAgICAgICAgICBjaGFydC50aXAuZCA9IGQ7XHJcbiAgICAgICAgICAgICAgICBjaGFydC50aXAuaSA9IGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICAgIC5vbignbW91c2Vtb3ZlJywgZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgaWYgKGNoYXJ0LnNob3dUb29sVGlwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hhcnQudGlwLmQgPT09IGQgJiYgY2hhcnQudGlwLmkgPT09IGkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGFydC50aXAuc2hvd1RpcChkMy5ldmVudCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vR2V0IHRpcCBkYXRhXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpcERhdGEgPSBjaGFydC5zZXRUaXBEYXRhKGQsIGkpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vRHJhdyB0aXAgbGluZVxyXG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0LnRpcC5nZW5lcmF0ZVNpbXBsZVRpcCh0aXBEYXRhLCBjaGFydC5kYXRhLmRhdGFUYWJsZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICBpZiAoY2hhcnQuc2hvd1Rvb2xUaXApIHtcclxuICAgICAgICAgICAgICAgIGNoYXJ0LnRpcC5oaWRlVGlwKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICB2YXIgbm9kZSA9IHN2Zy5hcHBlbmQoJ2cnKS5zZWxlY3RBbGwoJy5ub2RlJylcclxuICAgICAgICAuZGF0YShzYW5rZXlEYXRhLm5vZGVzKVxyXG4gICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC52YWx1ZSA+IDA7IH0pXHJcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ25vZGUnKVxyXG4gICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgZC54ICsgJywgJyArIGQueSArICcpJztcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5jYWxsKGQzLmRyYWcoKVxyXG4gICAgICAgICAgICAuc3ViamVjdChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGQ7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5vbignc3RhcnQnLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgZDMuZXZlbnQuc291cmNlRXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQodGhpcyk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5vbignZHJhZycsIGRyYWdtb3ZlKSk7XHJcblxyXG4gICAgbm9kZS5hcHBlbmQoJ3JlY3QnKVxyXG4gICAgICAgIC5hdHRyKCdoZWlnaHQnLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAvL3JldHVybiBkLmR5O1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hYnMoZC5keSk7XHJcbiAgICAgICAgICAgIC8vcmV0dXJuIE1hdGgubWF4KGQuZHksIDIpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmF0dHIoJ3dpZHRoJywgc2Fua2V5Lm5vZGVXaWR0aCgpKVxyXG4gICAgICAgIC5zdHlsZSgnZmlsbCcsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkLmNvbG9yID0gY29sb3IoZC5uYW1lKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGQzLnJnYihkLmNvbG9yKS5kYXJrZXIoMik7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgbm9kZS5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgIC5hdHRyKCd4JywgLTYpXHJcbiAgICAgICAgLmF0dHIoJ3knLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZC5keSAvIDI7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuYXR0cignZHknLCAnLjM1ZW0nKVxyXG4gICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdlbmQnKVxyXG4gICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBudWxsKVxyXG4gICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBudWxsKVxyXG4gICAgICAgIC50ZXh0KGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIC8vUmVtb3ZlIHRoZSB0aGUgbm9kZUdyb3VwIHRhZyBhbmQgaHlwaGVuIGZyb20gdGhlIGVuZCBvZiB0aGUgbGFiZWxcclxuICAgICAgICAgICAgcmV0dXJuIGQubmFtZS5zbGljZSgwLCAtMik7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkLnggPCB3aWR0aCAvIDI7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuYXR0cigneCcsIDYgKyBzYW5rZXkubm9kZVdpZHRoKCkpXHJcbiAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ3N0YXJ0Jyk7XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhZ21vdmUoZCkge1xyXG4gICAgICAgIGQzLnNlbGVjdCh0aGlzKS5hdHRyKCd0cmFuc2Zvcm0nLFxyXG4gICAgICAgICAgICAndHJhbnNsYXRlKCcgKyAoXHJcbiAgICAgICAgICAgICAgICBkLnggPSBNYXRoLm1heCgwLCBNYXRoLm1pbih3aWR0aCAtIGQuZHgsIGQzLmV2ZW50LngpKVxyXG4gICAgICAgICAgICApICsgJywnICsgKFxyXG4gICAgICAgICAgICAgICAgZC55ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oaGVpZ2h0IC0gZC5keSwgZDMuZXZlbnQueSkpXHJcbiAgICAgICAgICAgICkgKyAnKScpO1xyXG4gICAgICAgIHNhbmtleS5yZWxheW91dCgpO1xyXG4gICAgICAgIGxpbmsuYXR0cignZCcsIHBhdGgpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHpvb20oKSB7IC8vSW1wbGVtZW50aW5nIHRoZSB2NCB6b29taW5nIGZlYXR1cmVcclxuICAgICAgICBzdmcuYXR0cigndHJhbnNmb3JtJywgZDMuZXZlbnQudHJhbnNmb3JtKTtcclxuICAgIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBqdkNoYXJ0cztcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIganZDaGFydHMgPSByZXF1aXJlKCcuLi9qdkNoYXJ0cy5qcycpO1xyXG5cclxuanZDaGFydHMucHJvdG90eXBlLnNjYXR0ZXJwbG90ID0ge1xyXG4gICAgcGFpbnQ6IHBhaW50LFxyXG4gICAgc2V0RGF0YTogc2V0RGF0YSxcclxuICAgIGdldEV2ZW50RGF0YTogZ2V0RXZlbnREYXRhXHJcbn07XHJcblxyXG5qdkNoYXJ0cy5wcm90b3R5cGUuZ2VuZXJhdGVTY2F0dGVyID0gZ2VuZXJhdGVTY2F0dGVyO1xyXG5qdkNoYXJ0cy5wcm90b3R5cGUuY3JlYXRlTGluZUd1aWRlID0gY3JlYXRlTGluZUd1aWRlO1xyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBTY2F0dGVyIGZ1bmN0aW9ucyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG4vKipzZXRTY2F0dGVyRGF0YVxyXG4gKiAgZ2V0cyBzY2F0dGVyIGRhdGEgYW5kIGFkZHMgaXQgdG8gdGhlIGNoYXJ0IG9iamVjdFxyXG4gKlxyXG4gKiBAcGFyYW1zIGRhdGEsIGRhdGFUYWJsZSwgY29sb3JzXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXREYXRhKCkge1xyXG4gICAgdmFyIGNoYXJ0ID0gdGhpcztcclxuICAgIGNoYXJ0LmRhdGEubGVnZW5kRGF0YSA9IHNldFNjYXR0ZXJMZWdlbmREYXRhKGNoYXJ0LmRhdGEpO1xyXG4gICAgY2hhcnQuZGF0YS54QXhpc0RhdGEgPSBzZXRTY2F0dGVyQXhpc0RhdGEoY2hhcnQuZGF0YSwgJ3gnLCBjaGFydC5fdmFycyk7XHJcbiAgICBjaGFydC5kYXRhLnlBeGlzRGF0YSA9IHNldFNjYXR0ZXJBeGlzRGF0YShjaGFydC5kYXRhLCAneScsIGNoYXJ0Ll92YXJzKTtcclxuICAgIGNoYXJ0LmRhdGEuekF4aXNEYXRhID0gY2hhcnQuZGF0YS5kYXRhVGFibGUuaGFzT3duUHJvcGVydHkoJ3onKSA/IHNldFNjYXR0ZXJBeGlzRGF0YShjaGFydC5kYXRhLCAneicsIGNoYXJ0Ll92YXJzKSA6IHt9O1xyXG4gICAgLy9kZWZpbmUgY29sb3Igb2JqZWN0IGZvciBjaGFydERhdGFcclxuICAgIGNoYXJ0LmRhdGEuY29sb3IgPSBqdkNoYXJ0cy5zZXRDaGFydENvbG9ycyhjaGFydC5fdmFycy5jb2xvciwgY2hhcnQuZGF0YS5sZWdlbmREYXRhLCBjaGFydC5jb2xvcnMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRFdmVudERhdGEoZXZlbnQsIG1vdXNlKSB7XHJcbiAgICB2YXIgY2hhcnQgPSB0aGlzLFxyXG4gICAgICAgIGVsZSA9IGV2ZW50LnRhcmdldC5fX2RhdGFfXztcclxuXHJcbiAgICAvL2RldGVybWluZSBpZiB0aGUgY2xpY2sgZXZlbnQgaGFwcGVucyBpbnNpZGUgdGhlIGNvbnRhaW5lclxyXG4gICAgbGV0IGJydXNoQ29udGFpbmVyID0gY2hhcnQuY2hhcnREaXYuc2VsZWN0KCcuJyArIGNoYXJ0LmNvbmZpZy50eXBlICsgJy1jb250YWluZXInKS5ub2RlKCksXHJcbiAgICAgICAgY29udGFpbmVyQm94ID0gYnJ1c2hDb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXHJcbiAgICAgICAgeCA9IG1vdXNlWzBdLFxyXG4gICAgICAgIHkgPSBtb3VzZVsxXSxcclxuICAgICAgICBpbnNpZGVDb250YWluZXIgPSBmYWxzZTtcclxuXHJcbiAgICBpZiAoeCA8IGNvbnRhaW5lckJveC5yaWdodCAmJiB5IDwgY29udGFpbmVyQm94LmJvdHRvbSAmJiB4ID4gY29udGFpbmVyQm94LmxlZnQgJiYgeSA+IGNvbnRhaW5lckJveC50b3ApIHtcclxuICAgICAgICBpbnNpZGVDb250YWluZXIgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpbnNpZGVDb250YWluZXIgJiYgZWxlKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgW2NoYXJ0LmN1cnJlbnREYXRhLmRhdGFUYWJsZS5sYWJlbF06IFtlbGVbY2hhcnQuY3VycmVudERhdGEuZGF0YVRhYmxlLmxhYmVsXS5yZXBsYWNlKC9fL2csICcgJykucmVwbGFjZSgvX2RvdF8vZywgJy4nKV1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbm9kZTogZXZlbnQudGFyZ2V0XHJcbiAgICAgICAgfTtcclxuICAgIH0gZWxzZSBpZiAoaW5zaWRlQ29udGFpbmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZGF0YToge31cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBkYXRhOiBmYWxzZVxyXG4gICAgfTtcclxufVxyXG5cclxuLyoqc2V0U2NhdHRlckxlZ2VuZERhdGFcclxuICogIGdldHMgbGVnZW5kIGluZm8gZnJvbSBjaGFydCBEYXRhXHJcbiAqXHJcbiAqIEBwYXJhbXMgZGF0YSwgdHlwZVxyXG4gKiBAcmV0dXJucyBbXSBvZiBsZWdlbmQgdGV4dFxyXG4gKi9cclxuZnVuY3Rpb24gc2V0U2NhdHRlckxlZ2VuZERhdGEoZGF0YSkge1xyXG4gICAgbGV0IGxlZ2VuZEFycmF5ID0gW107XHJcbiAgICBpZiAoZGF0YS5kYXRhVGFibGUuaGFzT3duUHJvcGVydHkoJ3NlcmllcycpKSB7XHJcbiAgICAgICAgbGV0IHNlcmllcyA9IGRhdGEuZGF0YVRhYmxlLnNlcmllcztcclxuICAgICAgICBmb3IgKGxldCBjaGFydEVsZSBvZiBkYXRhLmNoYXJ0RGF0YSkge1xyXG4gICAgICAgICAgICBpZiAobGVnZW5kQXJyYXkuaW5kZXhPZihjaGFydEVsZVtzZXJpZXNdKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIGxlZ2VuZEFycmF5LnB1c2goY2hhcnRFbGVbc2VyaWVzXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGxlZ2VuZEFycmF5Lmxlbmd0aCA9PT0gMCB8fCB0eXBlb2YgbGVnZW5kQXJyYXlbMF0gPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgbGVnZW5kQXJyYXkucHVzaChkYXRhLmRhdGFUYWJsZS5sYWJlbCk7XHJcbiAgICAgICAgZGF0YS5kYXRhVGFibGUuc2VyaWVzID0gZGF0YS5kYXRhVGFibGUubGFiZWw7XHJcbiAgICB9XHJcblxyXG4gICAgLy9vcmRlciBsZWdlbmQgZGF0YSBpbiBhbHBoYWJldGljYWwgb3JkZXJcclxuICAgIGxlZ2VuZEFycmF5LnNvcnQoKTtcclxuICAgIHJldHVybiBsZWdlbmRBcnJheTtcclxufVxyXG5cclxuLyoqc2V0U2NhdHRlckF4aXNEYXRhXHJcbiAqICBnZXRzIHogYXhpcyBkYXRhIGJhc2VkIG9uIHRoZSBjaGFydERhdGFcclxuICpcclxuICogQHBhcmFtcyBkYXRhLCBkYXRhVGFibGVcclxuICogQHJldHVybnMgb2JqZWN0IHdpdGggbGFiZWwgYW5kIHZhbHVlc1xyXG4gKi9cclxuZnVuY3Rpb24gc2V0U2NhdHRlckF4aXNEYXRhKGRhdGEsIGF4aXMsIF92YXJzKSB7XHJcbiAgICAvL2RlY2xhcmUgdmFyc1xyXG4gICAgdmFyIGF4aXNEYXRhID0gW10sXHJcbiAgICAgICAgY2hhcnREYXRhID0gZGF0YS5jaGFydERhdGEsXHJcbiAgICAgICAgc2NhdHRlckxhYmVsID0gZGF0YS5kYXRhVGFibGVbYXhpc10sXHJcbiAgICAgICAgbWluID0gc2NhdHRlckxhYmVsID8gY2hhcnREYXRhWzBdW3NjYXR0ZXJMYWJlbF0gOiAwLFxyXG4gICAgICAgIG1heCA9IHNjYXR0ZXJMYWJlbCA/IGNoYXJ0RGF0YVswXVtzY2F0dGVyTGFiZWxdIDogMDtcclxuXHJcbiAgICAvL2xvb3Agb3ZlciBkYXRhIHRvIGZpbmQgbWF4IGFuZCBtaW5cclxuICAgIC8vYWxzbyBkZXRlcm1pbmVzIHRoZSB5IGF4aXMgdG90YWwgaWYgdGhlIGRhdGEgaXMgc3RhY2tlZFxyXG4gICAgZm9yIChsZXQgY2hhcnRFbGUgb2YgY2hhcnREYXRhKSB7XHJcbiAgICAgICAgaWYgKGNoYXJ0RWxlLmhhc093blByb3BlcnR5KHNjYXR0ZXJMYWJlbCkpIHtcclxuICAgICAgICAgICAgbGV0IG51bSA9IGNoYXJ0RWxlW3NjYXR0ZXJMYWJlbF07XHJcbiAgICAgICAgICAgIGlmICghaXNOYU4obnVtKSkge1xyXG4gICAgICAgICAgICAgICAgbnVtID0gcGFyc2VGbG9hdChudW0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKG51bSA+IG1heCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1heCA9IG51bTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtIDwgbWluKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWluID0gbnVtO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGF4aXMgIT09ICd6Jykge1xyXG4gICAgICAgIG1pbiAqPSAwLjk7XHJcbiAgICAgICAgbWF4ICo9IDEuMTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoX3ZhcnMueU1pbiAmJiAhaXNOYU4oX3ZhcnMueU1pbikgJiYgYXhpcyA9PT0gJ3knKSB7XHJcbiAgICAgICAgbWluID0gX3ZhcnMueU1pbjtcclxuICAgIH1cclxuICAgIGlmIChfdmFycy55TWF4ICYmICFpc05hTihfdmFycy55TWF4KSAmJiBheGlzID09PSAneScpIHtcclxuICAgICAgICBtYXggPSBfdmFycy55TWF4O1xyXG4gICAgfVxyXG4gICAgaWYgKF92YXJzLnhNaW4gJiYgIWlzTmFOKF92YXJzLnhNaW4pICYmIGF4aXMgPT09ICd4Jykge1xyXG4gICAgICAgIG1pbiA9IF92YXJzLnhNaW47XHJcbiAgICB9XHJcbiAgICBpZiAoX3ZhcnMueE1heCAmJiAhaXNOYU4oX3ZhcnMueE1heCkgJiYgYXhpcyA9PT0gJ3gnKSB7XHJcbiAgICAgICAgbWF4ID0gX3ZhcnMueE1heDtcclxuICAgIH1cclxuXHJcbiAgICBheGlzRGF0YS5wdXNoKG1pbik7XHJcbiAgICBheGlzRGF0YS5wdXNoKG1heCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgICdsYWJlbCc6IHNjYXR0ZXJMYWJlbCxcclxuICAgICAgICAndmFsdWVzJzogYXhpc0RhdGEsXHJcbiAgICAgICAgJ2RhdGFUeXBlJzogJ05VTUJFUicsXHJcbiAgICAgICAgJ21pbic6IG1pbixcclxuICAgICAgICAnbWF4JzogbWF4XHJcbiAgICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBwYWludCgpIHtcclxuICAgIHZhciBjaGFydCA9IHRoaXMsXHJcbiAgICAgICAgZGF0YU9iaiA9IHt9O1xyXG5cclxuICAgIGRhdGFPYmouY2hhcnREYXRhID0gY2hhcnQuZGF0YS5jaGFydERhdGE7XHJcbiAgICBkYXRhT2JqLmxlZ2VuZERhdGEgPSBjaGFydC5kYXRhLmxlZ2VuZERhdGE7XHJcbiAgICBkYXRhT2JqLmRhdGFUYWJsZSA9IGNoYXJ0LmRhdGEuZGF0YVRhYmxlO1xyXG4gICAgY2hhcnQuX3ZhcnMuY29sb3IgPSBjaGFydC5kYXRhLmNvbG9yO1xyXG4gICAgZGF0YU9iai54QXhpc0RhdGEgPSBjaGFydC5kYXRhLnhBeGlzRGF0YTtcclxuICAgIGRhdGFPYmoueUF4aXNEYXRhID0gY2hhcnQuZGF0YS55QXhpc0RhdGE7XHJcbiAgICBkYXRhT2JqLnpBeGlzRGF0YSA9IGNoYXJ0LmRhdGEuekF4aXNEYXRhO1xyXG4gICAgY2hhcnQuY3VycmVudERhdGEgPSBkYXRhT2JqO1xyXG5cclxuXHJcbiAgICAvL2dlbmVyYXRlIHN2ZyBkeW5hbWljYWxseSBiYXNlZCBvbiBsZWdlbmQgZGF0YVxyXG4gICAgY2hhcnQuZ2VuZXJhdGVTVkcoZGF0YU9iai5sZWdlbmREYXRhKTtcclxuXHJcbiAgICAvL1RPRE8gcmVtb3ZlIHRoZXNlIGZyb20gZHJhdyBvYmplY3RcclxuICAgIGNoYXJ0LmdlbmVyYXRlWEF4aXMoY2hhcnQuY3VycmVudERhdGEueEF4aXNEYXRhKTtcclxuICAgIGNoYXJ0LmdlbmVyYXRlWUF4aXMoY2hhcnQuY3VycmVudERhdGEueUF4aXNEYXRhKTtcclxuICAgIGNoYXJ0LmdlbmVyYXRlTGVnZW5kKGNoYXJ0LmN1cnJlbnREYXRhLmxlZ2VuZERhdGEsICdnZW5lcmF0ZVNjYXR0ZXInKTtcclxuXHJcbiAgICBjaGFydC5nZW5lcmF0ZVNjYXR0ZXIoKTtcclxuXHJcbiAgICBpZiAoY2hhcnQuX3ZhcnMubGluZUd1aWRlKSB7XHJcbiAgICAgICAgY2hhcnQuY3JlYXRlTGluZUd1aWRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHR5cGVvZiBkYXRhT2JqLnhBeGlzU2NhbGUudGlja3MgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICBjaGFydC5mb3JtYXRYQXhpc0xhYmVscyhkYXRhT2JqLnhBeGlzU2NhbGUudGlja3MoKS5sZW5ndGgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBjaGFydC5mb3JtYXRYQXhpc0xhYmVscyhkYXRhT2JqLnhBeGlzU2NhbGUuZG9tYWluKCkubGVuZ3RoKTtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gY2FsY3VsYXRlTWVhbihkYXRhLCB0eXBlKSB7XHJcbiAgICByZXR1cm4gZDMubWVhbihkYXRhLCB2YWx1ZSA9PiArdmFsdWVbdHlwZV0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVMaW5lR3VpZGUoKSB7XHJcbiAgICB2YXIgY2hhcnQgPSB0aGlzLFxyXG4gICAgICAgIHN2ZyA9IGNoYXJ0LnN2ZyxcclxuICAgICAgICBjb250YWluZXIgPSBjaGFydC5jb25maWcuY29udGFpbmVyLFxyXG4gICAgICAgIGNoYXJ0RGF0YSA9IGNoYXJ0LmN1cnJlbnREYXRhLmNoYXJ0RGF0YSxcclxuICAgICAgICBkYXRhVGFibGUgPSBjaGFydC5jdXJyZW50RGF0YS5kYXRhVGFibGUsXHJcbiAgICAgICAgeEF4aXNEYXRhID0gY2hhcnQuY3VycmVudERhdGEueEF4aXNEYXRhLFxyXG4gICAgICAgIHlBeGlzRGF0YSA9IGNoYXJ0LmN1cnJlbnREYXRhLnlBeGlzRGF0YSxcclxuICAgICAgICB4TWVhbiA9IGNhbGN1bGF0ZU1lYW4oY2hhcnREYXRhLCBkYXRhVGFibGUueCksXHJcbiAgICAgICAgeU1lYW4gPSBjYWxjdWxhdGVNZWFuKGNoYXJ0RGF0YSwgZGF0YVRhYmxlLnkpLFxyXG4gICAgICAgIHhTY2FsZSA9IGp2Q2hhcnRzLmdldEF4aXNTY2FsZSgneCcsIHhBeGlzRGF0YSwgY29udGFpbmVyLCBjaGFydC5fdmFycyksXHJcbiAgICAgICAgeVNjYWxlID0ganZDaGFydHMuZ2V0QXhpc1NjYWxlKCd5JywgeUF4aXNEYXRhLCBjb250YWluZXIsIGNoYXJ0Ll92YXJzKSxcclxuICAgICAgICBsaW5lR3JvdXA7XHJcblxyXG4gICAgc3ZnLnNlbGVjdEFsbCgnZy5saW5lZ3VpZGUueCcpLnJlbW92ZSgpO1xyXG4gICAgc3ZnLnNlbGVjdEFsbCgnZy5saW5lZ3VpZGUueScpLnJlbW92ZSgpO1xyXG5cclxuICAgIGxpbmVHcm91cCA9IHN2Zy5hcHBlbmQoJ2cnKVxyXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICdsaW5lLWdyb3VwIHNjYXR0ZXJwbG90LWNvbnRhaW5lcicpO1xyXG5cclxuICAgIC8vY3JlYXRlIGNyb3NzaGFpciBiYXNlZCBvbiBtZWRpYW4geCAodXAvZG93bilcclxuICAgIGxpbmVHcm91cC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICdsaW5lZ3VpZGUgeCcpXHJcbiAgICAgICAgLmFwcGVuZCgnbGluZScpXHJcbiAgICAgICAgLnN0eWxlKCdzdHJva2UnLCAnZ3JheScpXHJcbiAgICAgICAgLnN0eWxlKCdzdHJva2UtZGFzaGFycmF5JywgKCczLCAzJykpXHJcbiAgICAgICAgLnN0eWxlKCdmaWxsJywgJ2JsYWNrJylcclxuICAgICAgICAuYXR0cigneDEnLCB4U2NhbGUoeE1lYW4pKVxyXG4gICAgICAgIC5hdHRyKCd5MScsIDApXHJcbiAgICAgICAgLmF0dHIoJ3gyJywgeFNjYWxlKHhNZWFuKSlcclxuICAgICAgICAuYXR0cigneTInLCBjb250YWluZXIuaGVpZ2h0KTtcclxuXHJcbiAgICAvL2NyZWF0ZSBjcm9zc2hhaXIgYmFzZWQgb24gbWVkaWFuIHkgKGxlZnQvcmlnaHQpXHJcbiAgICBsaW5lR3JvdXAuYXBwZW5kKCdnJylcclxuICAgICAgICAuYXR0cignY2xhc3MnLCAnbGluZWd1aWRlIHknKVxyXG4gICAgICAgIC5hcHBlbmQoJ2xpbmUnKVxyXG4gICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgJ2dyYXknKVxyXG4gICAgICAgIC5zdHlsZSgnc3Ryb2tlLWRhc2hhcnJheScsICgnMywgMycpKVxyXG4gICAgICAgIC5zdHlsZSgnZmlsbCcsICdibGFjaycpXHJcbiAgICAgICAgLmF0dHIoJ3gxJywgMClcclxuICAgICAgICAuYXR0cigneTEnLCB5U2NhbGUoeU1lYW4pKVxyXG4gICAgICAgIC5hdHRyKCd4MicsIGNvbnRhaW5lci53aWR0aClcclxuICAgICAgICAuYXR0cigneTInLCB5U2NhbGUoeU1lYW4pKTtcclxufVxyXG5cclxuLyoqZ2VuZXJhdGVTY2F0dGVyXHJcbiAqXHJcbiAqIGNyZWF0ZXMgYW5kIGRyYXdzIGEgc2NhdHRlciBwbG90IG9uIHRoZSBzdmcgZWxlbWVudFxyXG4gKiBAcGFyYW1zIHN2Zywgc2NhdHRlckRhdGEsIF92YXJzLCB4QXhpc0RhdGEsIHlBeGlzRGF0YSwgekF4aXNEYXRhLCBjb250YWluZXIsIGRhdGFUYWJsZSBsZWdlbmREYXRhXHJcbiAqIEByZXR1cm5zIHt7fX1cclxuICovXHJcbmZ1bmN0aW9uIGdlbmVyYXRlU2NhdHRlcigpIHtcclxuICAgIHZhciBjaGFydCA9IHRoaXMsXHJcbiAgICAgICAgc3ZnID0gY2hhcnQuc3ZnLFxyXG4gICAgICAgIGNvbnRhaW5lciA9IGNoYXJ0LmNvbmZpZy5jb250YWluZXIsXHJcbiAgICAgICAgc2NhdHRlckRhdGEgPSBjaGFydC5jdXJyZW50RGF0YS5jaGFydERhdGEsXHJcbiAgICAgICAgZGF0YVRhYmxlID0gY2hhcnQuY3VycmVudERhdGEuZGF0YVRhYmxlLFxyXG4gICAgICAgIHhBeGlzRGF0YSA9IGNoYXJ0LmN1cnJlbnREYXRhLnhBeGlzRGF0YSxcclxuICAgICAgICB5QXhpc0RhdGEgPSBjaGFydC5jdXJyZW50RGF0YS55QXhpc0RhdGEsXHJcbiAgICAgICAgekF4aXNEYXRhID0gY2hhcnQuY3VycmVudERhdGEuekF4aXNEYXRhLFxyXG4gICAgICAgIGxlZ2VuZERhdGEgPSBjaGFydC5jdXJyZW50RGF0YS5sZWdlbmREYXRhLFxyXG4gICAgICAgIGNvbG9ycyA9IGNoYXJ0Ll92YXJzLmNvbG9yLFxyXG4gICAgICAgIGxlZ2VuZEVsZW1lbnRUb2dnbGVBcnJheSxcclxuICAgICAgICBzY2F0dGVyRGF0YUZpbHRlcmVkID0gW10sXHJcbiAgICAgICAgeCxcclxuICAgICAgICB5LFxyXG4gICAgICAgIHo7XHJcblxyXG4gICAgaWYgKCFjaGFydC5fdmFycy5OT0RFX01JTl9TSVpFKSB7XHJcbiAgICAgICAgY2hhcnQuX3ZhcnMuTk9ERV9NSU5fU0laRSA9IDQuNTtcclxuICAgIH1cclxuICAgIGlmICghY2hhcnQuX3ZhcnMuTk9ERV9NQVhfU0laRSkge1xyXG4gICAgICAgIGNoYXJ0Ll92YXJzLk5PREVfTUFYX1NJWkUgPSAyNTtcclxuICAgIH1cclxuXHJcbiAgICAvL3NldCBjbGlwIHBhdGggcmVjdGFuZ2xlXHJcbiAgICBzdmcuYXBwZW5kKCdjbGlwUGF0aCcpXHJcbiAgICAgICAgLmF0dHIoJ2lkJywgJ3NjYXR0ZXItYXJlYScpXHJcbiAgICAgICAgLmFwcGVuZCgncmVjdCcpXHJcbiAgICAgICAgLmF0dHIoJ3gnLCAxKVxyXG4gICAgICAgIC5hdHRyKCd3aWR0aCcsIGNvbnRhaW5lci53aWR0aCAtIDEpXHJcbiAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGNvbnRhaW5lci5oZWlnaHQpXHJcbiAgICAgICAgLmF0dHIoJ2ZpbGwnLCBjaGFydC5fdmFycy5iYWNrZ3JvdW5kQ29sb3IpO1xyXG5cclxuICAgIHN2Zy5zZWxlY3RBbGwoJ2cuc2NhdHRlcnBsb3QtY29udGFpbmVyJykucmVtb3ZlKCk7XHJcbiAgICBzdmcuc2VsZWN0QWxsKCdnLnNjYXR0ZXJwbG90LWNvbnRhaW5lci5lZGl0YWJsZS1zY2F0dGVyJykucmVtb3ZlKCk7XHJcblxyXG4gICAgaWYgKCFjaGFydC5fdmFycy5sZWdlbmRIZWFkZXJzKSB7XHJcbiAgICAgICAgY2hhcnQuX3ZhcnMubGVnZW5kSGVhZGVycyA9IGxlZ2VuZERhdGE7XHJcbiAgICB9XHJcblxyXG4gICAgbGVnZW5kRWxlbWVudFRvZ2dsZUFycmF5ID0ganZDaGFydHMuZ2V0TGVnZW5kRWxlbWVudFRvZ2dsZUFycmF5KGNoYXJ0Ll92YXJzLmxlZ2VuZEhlYWRlcnMsIGxlZ2VuZERhdGEpO1xyXG5cclxuICAgIGlmIChsZWdlbmRFbGVtZW50VG9nZ2xlQXJyYXkpIHtcclxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNjYXR0ZXJEYXRhLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGxlZ2VuZEVsZSBvZiBsZWdlbmRFbGVtZW50VG9nZ2xlQXJyYXkpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NhdHRlckRhdGFbal1bZGF0YVRhYmxlLmxhYmVsXSA9PT0gJ3VuZGVmaW5lZCcgfHwgc2NhdHRlckRhdGFbal1bZGF0YVRhYmxlLmxhYmVsXSA9PT0gJycpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobGVnZW5kRWxlLnRvZ2dsZSAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2NhdHRlckRhdGFGaWx0ZXJlZC5wdXNoKHNjYXR0ZXJEYXRhW2pdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxlZ2VuZEVsZS5lbGVtZW50ICE9PSBzY2F0dGVyRGF0YVtqXVtkYXRhVGFibGUuc2VyaWVzXSB8fCBsZWdlbmRFbGUudG9nZ2xlICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNjYXR0ZXJEYXRhRmlsdGVyZWQucHVzaChzY2F0dGVyRGF0YVtqXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgeCA9IGp2Q2hhcnRzLmdldEF4aXNTY2FsZSgneCcsIHhBeGlzRGF0YSwgY29udGFpbmVyLCBjaGFydC5fdmFycyk7XHJcbiAgICB5ID0ganZDaGFydHMuZ2V0QXhpc1NjYWxlKCd5JywgeUF4aXNEYXRhLCBjb250YWluZXIsIGNoYXJ0Ll92YXJzKTtcclxuICAgIHo7XHJcblxyXG4gICAgaWYgKHpBeGlzRGF0YSAmJiB0eXBlb2YgekF4aXNEYXRhID09PSAnb2JqZWN0JyAmJiBPYmplY3Qua2V5cyh6QXhpc0RhdGEpLmxlbmd0aCA+IDApIHtcclxuICAgICAgICB6ID0ganZDaGFydHMuZ2V0WlNjYWxlKHpBeGlzRGF0YSwgY29udGFpbmVyLCBjaGFydC5fdmFycyk7XHJcbiAgICB9XHJcblxyXG4gICAgc3ZnLmFwcGVuZCgnZycpXHJcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3NjYXR0ZXJwbG90LWNpcmNsZXMnKVxyXG4gICAgICAgIC5zZWxlY3RBbGwoJ2cnKVxyXG4gICAgICAgIC5kYXRhKHNjYXR0ZXJEYXRhRmlsdGVyZWQpXHJcbiAgICAgICAgLmVudGVyKClcclxuICAgICAgICAuYXBwZW5kKCdjaXJjbGUnKVxyXG4gICAgICAgIC5hdHRyKCdjbGlwLXBhdGgnLCAndXJsKCNzY2F0dGVyLWFyZWEpJylcclxuICAgICAgICAuYXR0cignY2xhc3MnLCAoZCwgaSkgPT4gJ2VkaXRhYmxlIGVkaXRhYmxlLXNjYXR0ZXIgc2NhdHRlci1jaXJjbGUtJyArIGkgKyAnIGhpZ2hsaWdodC1jbGFzcycpXHJcbiAgICAgICAgLmF0dHIoJ2N4JywgKGQsIGkpID0+IHgoc2NhdHRlckRhdGFGaWx0ZXJlZFtpXVt4QXhpc0RhdGEubGFiZWxdKSlcclxuICAgICAgICAuYXR0cignY3knLCAoZCwgaSkgPT4geShzY2F0dGVyRGF0YUZpbHRlcmVkW2ldW3lBeGlzRGF0YS5sYWJlbF0pKVxyXG4gICAgICAgIC5hdHRyKCdvcGFjaXR5JywgMC44KVxyXG4gICAgICAgIC5hdHRyKCdyJywgKGQsIGkpID0+IHtcclxuICAgICAgICAgICAgaWYgKGRhdGFUYWJsZS5oYXNPd25Qcm9wZXJ0eSgneicpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hhcnQuX3ZhcnMudG9nZ2xlWiAmJiB6QXhpc0RhdGEgJiYgdHlwZW9mIHpBeGlzRGF0YSA9PT0gJ29iamVjdCcgJiYgT2JqZWN0LmtleXMoekF4aXNEYXRhKS5sZW5ndGggPiAwICYmIHNjYXR0ZXJEYXRhRmlsdGVyZWRbaV1bZGF0YVRhYmxlLnpdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHooc2NhdHRlckRhdGFGaWx0ZXJlZFtpXVtkYXRhVGFibGUuel0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjaGFydC5fdmFycy5OT0RFX01JTl9TSVpFO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoZCwgaSwgaikge1xyXG4gICAgICAgICAgICBpZiAoY2hhcnQuc2hvd1Rvb2xUaXApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdjbGlwLXBhdGgnLCAnJyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGlwRGF0YSA9IGNoYXJ0LnNldFRpcERhdGEoZCwgaSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9EcmF3IHRpcCBsaW5lXHJcbiAgICAgICAgICAgICAgICBjaGFydC50aXAuZ2VuZXJhdGVTaW1wbGVUaXAodGlwRGF0YSwgY2hhcnQuZGF0YS5kYXRhVGFibGUpO1xyXG4gICAgICAgICAgICAgICAgY2hhcnQudGlwLmQgPSBkO1xyXG4gICAgICAgICAgICAgICAgY2hhcnQudGlwLmkgPSBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICAub24oJ21vdXNlbW92ZScsIGZ1bmN0aW9uIChkLCBpKSB7XHJcbiAgICAgICAgICAgIGlmIChjaGFydC5zaG93VG9vbFRpcCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoYXJ0LnRpcC5kID09PSBkICYmIGNoYXJ0LnRpcC5pID09PSBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhcnQudGlwLnNob3dUaXAoZDMuZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvL0dldCB0aXAgZGF0YVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0aXBEYXRhID0gY2hhcnQuc2V0VGlwRGF0YShkLCBpKTtcclxuICAgICAgICAgICAgICAgICAgICAvL0RyYXcgdGlwIGxpbmVcclxuICAgICAgICAgICAgICAgICAgICBjaGFydC50aXAuZ2VuZXJhdGVTaW1wbGVUaXAodGlwRGF0YSwgY2hhcnQuZGF0YS5kYXRhVGFibGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoY2hhcnQuc2hvd1Rvb2xUaXApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdjbGlwLXBhdGgnLCAndXJsKCNzY2F0dGVyLWFyZWEpJyk7XHJcbiAgICAgICAgICAgICAgICBjaGFydC50aXAuaGlkZVRpcCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuYXR0cignZmlsbCcsIChkLCBpKSA9PiBqdkNoYXJ0cy5nZXRDb2xvcnMoY29sb3JzLCBpLCBzY2F0dGVyRGF0YUZpbHRlcmVkW2ldW2RhdGFUYWJsZS5zZXJpZXNdKSk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ganZDaGFydHM7XHJcbiIsIid1c2Ugc3RyaWN0JztcclxudmFyIGp2Q2hhcnRzID0gcmVxdWlyZSgnLi4vanZDaGFydHMuanMnKTtcclxuXHJcbmp2Q2hhcnRzLnByb3RvdHlwZS5zaW5nbGVheGlzID0ge1xyXG4gICAgcGFpbnQ6IHBhaW50LFxyXG4gICAgc2V0RGF0YTogc2V0RGF0YSxcclxuICAgIGdldEV2ZW50RGF0YTogZ2V0RXZlbnREYXRhXHJcbn07XHJcblxyXG5qdkNoYXJ0cy5wcm90b3R5cGUuZ2V0U2luZ2xlQXhpc0RhdGEgPSBnZXRTaW5nbGVBeGlzRGF0YTtcclxuanZDaGFydHMucHJvdG90eXBlLmdldFNpbmdsZUF4aXNaID0gZ2V0U2luZ2xlQXhpc1o7XHJcbmp2Q2hhcnRzLnByb3RvdHlwZS5nZW5lcmF0ZVBvaW50cyA9IGdlbmVyYXRlUG9pbnRzO1xyXG5cclxuZnVuY3Rpb24gaXNFbXB0eSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdmFsdWUgPT09IG51bGw7XHJcbn1cclxuXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogU2luZ2xlIEF4aXMgQ2x1c3RlciBmdW5jdGlvbnMgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuZnVuY3Rpb24gc2V0RGF0YSgpIHtcclxuICAgIHZhciBjaGFydCA9IHRoaXM7XHJcbiAgICBjaGFydC5jdXJyZW50RGF0YSA9IHsgY2hhcnREYXRhOiBjaGFydC5kYXRhLmNoYXJ0RGF0YSwgZGF0YVRhYmxlOiBjaGFydC5kYXRhLmRhdGFUYWJsZSB9O1xyXG5cclxuICAgIC8vU2V0IHRoZSBsZWdlbmQgRGF0YSB0byB0aGUgbGFiZWwgZnJvbSBkYXRhVGFibGUgS2V5c1xyXG4gICAgY2hhcnQuY3VycmVudERhdGEubGVnZW5kRGF0YSA9IFtjaGFydC5jdXJyZW50RGF0YS5kYXRhVGFibGUueF07XHJcbiAgICBjaGFydC5jdXJyZW50RGF0YS54QXhpc0RhdGEgPSBjaGFydC5nZXRTaW5nbGVBeGlzRGF0YShjaGFydC5jdXJyZW50RGF0YS5jaGFydERhdGEsIGNoYXJ0LmN1cnJlbnREYXRhLmRhdGFUYWJsZSk7XHJcblxyXG4gICAgaWYgKGNoYXJ0LmN1cnJlbnREYXRhLmRhdGFUYWJsZS5oYXNPd25Qcm9wZXJ0eSgnc2l6ZScpKSB7XHJcbiAgICAgICAgY2hhcnQuY3VycmVudERhdGEuekF4aXNEYXRhID0gY2hhcnQuZ2V0U2luZ2xlQXhpc1ooY2hhcnQuY3VycmVudERhdGEuY2hhcnREYXRhKTtcclxuICAgIH1cclxuXHJcbiAgICBjaGFydC5jdXJyZW50RGF0YS5jb2xvciA9ICdyZWQnOy8vY2hhcnQuc2V0Q2hhcnRDb2xvcnMgKGNoYXJ0Ll92YXJzLmNvbG9yLCBjaGFydC5kYXRhLmxlZ2VuZERhdGEsIGNvbG9ycyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEV2ZW50RGF0YShldmVudCkge1xyXG4gICAgdmFyIGNoYXJ0ID0gdGhpcztcclxuICAgIGlmIChldmVudC50YXJnZXQuY2xhc3NMaXN0LnZhbHVlLnNwbGl0KCdjZWxsLScpWzFdKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgW2NoYXJ0LmN1cnJlbnREYXRhLmRhdGFUYWJsZS5sYWJlbF06IFtldmVudC50YXJnZXQuY2xhc3NMaXN0LnZhbHVlLnNwbGl0KCdjZWxsLScpWzFdLnJlcGxhY2UoL18vZywgJyAnKS5yZXBsYWNlKC9fZG90Xy9nLCAnLicpXVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBub2RlOiBldmVudC50YXJnZXRcclxuICAgICAgICB9O1xyXG4gICAgfSBlbHNlIGlmIChldmVudC50YXJnZXQuY2xhc3NMaXN0LnZhbHVlLmluZGV4T2YoJ2VkaXRhYmxlLXN2ZycpID4gLTEpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBkYXRhOiB7fVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGRhdGE6IGZhbHNlXHJcbiAgICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBwYWludCgpIHtcclxuICAgIHZhciBjaGFydCA9IHRoaXMsXHJcbiAgICAgICAgc3BsaXREYXRhID0ge30sIC8vSWYgdGhlcmUgaXMgYSBzcGxpdCwgdGhlIGRhdGEgdGhhdCBoYXMgYmVlbiBzcGxpdFxyXG4gICAgICAgIG51bVZpenplcywgLy9JZiB0aGVyZSBpcyBhIHNwbGl0LCB0aGUgbnVtYmVyIG9mIHNpbmdsZSBheGlzIGNsdXN0ZXJzIHRoYXQgYXJlIGNyZWF0ZWRcclxuICAgICAgICBjdXN0b21TaXplID0ge30sIC8vSWYgdGhlcmUgaXMgYSBzcGxpdCwgdGhlIHN2ZyBuZWVkcyB0byBiZSBhIGN1c3RvbSBwcmVkZWZpbmVkIGhlaWdodFxyXG4gICAgICAgIG1hcmdpbiA9IHtcclxuICAgICAgICAgICAgdG9wOiA1MCxcclxuICAgICAgICAgICAgbGVmdDogMTAwLFxyXG4gICAgICAgICAgICByaWdodDogMTAwLFxyXG4gICAgICAgICAgICBib3R0b206IDUwXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAvL0lmIHRoZXJlIGlzIGEgc3BsaXQgb24gdGhlIHZpeiwgcnVuIHRocm91Z2ggdGhpcyBsb2dpY1xyXG4gICAgaWYgKGNoYXJ0LmRhdGEuZGF0YVRhYmxlLmZhY2V0KSB7XHJcbiAgICAgICAgbGV0IHNwbGl0RGF0YUtleXMgPSBbXSxcclxuICAgICAgICAgICAgc3BsaXRPcHRpb25OYW1lID0gY2hhcnQuZGF0YS5kYXRhVGFibGUuZmFjZXQucmVwbGFjZSgvXy9nLCAnICcpO1xyXG5cclxuICAgICAgICAvL0NoZWNrIHRvIHNlZSBob3cgbWFueSB2aXp6ZXMgbmVlZCB0byBiZSBjcmVhdGVkIGJlY2F1c2Ugb2YgdGhlIHNwbGl0XHJcbiAgICAgICAgZm9yIChsZXQgZWxlIG9mIGNoYXJ0LmN1cnJlbnREYXRhLmNoYXJ0RGF0YSkge1xyXG4gICAgICAgICAgICBsZXQgYWRkVG9LZXlzID0gdHJ1ZTtcclxuICAgICAgICAgICAgZm9yIChsZXQga2V5IG9mIHNwbGl0RGF0YUtleXMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlbGVbc3BsaXRPcHRpb25OYW1lXSA9PT0ga2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkVG9LZXlzID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGFkZFRvS2V5cykge1xyXG4gICAgICAgICAgICAgICAgc3BsaXREYXRhS2V5cy5wdXNoKGVsZVtzcGxpdE9wdGlvbk5hbWVdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9DcmVhdGUgT2JqZWN0IHdpdGgga2V5cyBhbmQgYXNzaWduIGVhY2ggZWxlbWVudCBvZiB0aGUgZGF0YSBhcnJheSB0byBjb3JyZXNwb25kaW5nIG9iamVjdFxyXG4gICAgICAgIGZvciAobGV0IGtleSBvZiBzcGxpdERhdGFLZXlzKSB7XHJcbiAgICAgICAgICAgIHNwbGl0RGF0YVtrZXldID0gW107Ly9Bc3NpZ24gZW1wdHkgYXJyYXkgdG8gZWFjaCBsb2NhdGlvblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9Bc3NpZ24gRGF0YSBlbGVtZW50cyB0byBhcHByb3ByaWF0ZSBwbGFjZSBpbiBzcGxpdERhdGEgb2JqZWN0XHJcbiAgICAgICAgZm9yIChsZXQgZWxlIG9mIGNoYXJ0LmN1cnJlbnREYXRhLmNoYXJ0RGF0YSkge1xyXG4gICAgICAgICAgICBzcGxpdERhdGFbZWxlW3NwbGl0T3B0aW9uTmFtZV1dLnB1c2goZWxlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG51bVZpenplcyA9IHNwbGl0RGF0YUtleXMubGVuZ3RoO1xyXG4gICAgICAgIGN1c3RvbVNpemUuaGVpZ2h0ID0gKG51bVZpenplcykgKiAzMDA7XHJcblxyXG4gICAgICAgIGNoYXJ0LmdlbmVyYXRlU1ZHKGNoYXJ0LmN1cnJlbnREYXRhLmxlZ2VuZERhdGEsIG1hcmdpbiwgY3VzdG9tU2l6ZSk7XHJcbiAgICAgICAgY2hhcnQuZ2VuZXJhdGVYQXhpcyhjaGFydC5jdXJyZW50RGF0YS54QXhpc0RhdGEpO1xyXG4gICAgICAgIGNoYXJ0LmRyYXdHcmlkbGluZXMoY2hhcnQuY3VycmVudERhdGEueEF4aXNEYXRhKTtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1WaXp6ZXM7IGkrKykge1xyXG4gICAgICAgICAgICBjaGFydC5nZW5lcmF0ZVBvaW50cyhzcGxpdERhdGFbc3BsaXREYXRhS2V5c1tpXV0sIGkpO1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7IC8vV2hlbiB0aGVyZSBpc24ndCBhIHNwbGl0LCB0aGUgYmFzZSBjYXNlXHJcbiAgICAgICAgY2hhcnQuZ2VuZXJhdGVTVkcoY2hhcnQuY3VycmVudERhdGEubGVnZW5kRGF0YSwgbWFyZ2luLCBjdXN0b21TaXplKTtcclxuICAgICAgICBjaGFydC5nZW5lcmF0ZVhBeGlzKGNoYXJ0LmN1cnJlbnREYXRhLnhBeGlzRGF0YSk7XHJcbiAgICAgICAgY2hhcnQuZHJhd0dyaWRsaW5lcyhjaGFydC5jdXJyZW50RGF0YS54QXhpc0RhdGEpO1xyXG4gICAgICAgIGNoYXJ0LmdlbmVyYXRlUG9pbnRzKGNoYXJ0LmN1cnJlbnREYXRhLmNoYXJ0RGF0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHR5cGVvZiBjaGFydC5jdXJyZW50RGF0YS54QXhpc1NjYWxlLnRpY2tzID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgY2hhcnQuZm9ybWF0WEF4aXNMYWJlbHMoY2hhcnQuY3VycmVudERhdGEueEF4aXNTY2FsZS50aWNrcygpLmxlbmd0aCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNoYXJ0LmZvcm1hdFhBeGlzTGFiZWxzKGNoYXJ0LmN1cnJlbnREYXRhLnhBeGlzU2NhbGUuZG9tYWluKCkubGVuZ3RoKTtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0U2luZ2xlQXhpc1ooZGF0YSkge1xyXG4gICAgdmFyIGNoYXJ0ID0gdGhpcyxcclxuICAgICAgICBzaXplID0gY2hhcnQuY3VycmVudERhdGEuZGF0YVRhYmxlLnNpemUsXHJcbiAgICAgICAgbWluID0gZGF0YVswXVtzaXplXSxcclxuICAgICAgICBtYXggPSBkYXRhWzBdW3NpemVdO1xyXG4gICAgLy9GaW5kIG1pbiBhbmQgbWF4IG9mIHRoZSBkYXRhXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBsZXQgbnVtID0gZGF0YVtpXVtzaXplXTtcclxuICAgICAgICBpZiAobnVtID4gbWF4KSB7XHJcbiAgICAgICAgICAgIG1heCA9IG51bTtcclxuICAgICAgICB9IGVsc2UgaWYgKG51bSA8IG1pbikge1xyXG4gICAgICAgICAgICBtaW4gPSBudW07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgJ21pbic6IG1pbixcclxuICAgICAgICAnbWF4JzogbWF4LFxyXG4gICAgICAgICdsYWJlbCc6IHNpemVcclxuICAgIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdlbmVyYXRlUG9pbnRzKGRhdGEsIHlMZXZlbCkge1xyXG4gICAgdmFyIGNoYXJ0ID0gdGhpcyxcclxuICAgICAgICBzdmcgPSBjaGFydC5zdmcsXHJcbiAgICAgICAgd2lkdGggPSBjaGFydC5jb25maWcuY29udGFpbmVyLndpZHRoLFxyXG4gICAgICAgIGhlaWdodCA9IGNoYXJ0LmNvbmZpZy5jb250YWluZXIuaGVpZ2h0LFxyXG4gICAgICAgIGRhdGFUYWJsZSA9IGNoYXJ0LmN1cnJlbnREYXRhLmRhdGFUYWJsZSxcclxuICAgICAgICB4QXhpc0RhdGEgPSBjaGFydC5jdXJyZW50RGF0YS54QXhpc0RhdGEsXHJcbiAgICAgICAgekF4aXNEYXRhID0gY2hhcnQuY3VycmVudERhdGEuekF4aXNEYXRhLFxyXG4gICAgICAgIGNvbnRhaW5lciA9IGNoYXJ0LmNvbmZpZy5jb250YWluZXIsXHJcbiAgICAgICAgcG9pbnRDb2xvciA9ICcjNjA5Y2RiJyxcclxuICAgICAgICBjb2xvcmVkUG9pbnQgPSAnI2U4OGExNycsXHJcbiAgICAgICAgeCA9IGp2Q2hhcnRzLmdldEF4aXNTY2FsZSgneCcsIHhBeGlzRGF0YSwgY2hhcnQuY29uZmlnLmNvbnRhaW5lciwgY2hhcnQuX3ZhcnMpLFxyXG4gICAgICAgIGN1cnJlbnRBeGlzSGVpZ2h0LFxyXG4gICAgICAgIHNpbXVsYXRpb24sXHJcbiAgICAgICAgY2VsbDtcclxuXHJcbiAgICBjb25zdCBTUExJVF9DTFVTVEVSX0hFSUdIVCA9IDMwMCxcclxuICAgICAgICBUUkFOU0xBVEVfU1BMSVRfQ0xVU1RFUiA9IDE1MDtcclxuXHJcbiAgICAvL0lmIHRoZXJlJ3MgYSBzcGxpdCwgYWNjb3VudCBmb3IgdGhlIG11bHRpcGxlIGF4ZXNcclxuICAgIGlmICghaXNFbXB0eSh5TGV2ZWwpKSB7XHJcbiAgICAgICAgY3VycmVudEF4aXNIZWlnaHQgPSAoeUxldmVsICogU1BMSVRfQ0xVU1RFUl9IRUlHSFQpICsgVFJBTlNMQVRFX1NQTElUX0NMVVNURVI7Ly9FYWNoIGhlaWdodCBpcyAxMDBweFxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBjdXJyZW50QXhpc0hlaWdodCA9IGhlaWdodCAvIDI7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFjaGFydC5fdmFycy5OT0RFX01JTl9TSVpFKSB7XHJcbiAgICAgICAgY2hhcnQuX3ZhcnMuTk9ERV9NSU5fU0laRSA9IDQuNTtcclxuICAgIH1cclxuICAgIGlmICghY2hhcnQuX3ZhcnMuTk9ERV9NQVhfU0laRSkge1xyXG4gICAgICAgIGNoYXJ0Ll92YXJzLk5PREVfTUFYX1NJWkUgPSAyNTtcclxuICAgIH1cclxuXHJcbiAgICBjaGFydC5jaGFydERpdi5zZWxlY3QoJy5jb250YWluZXInKS5hdHRyKCdjbGFzcycsICdzaW5nbGVheGlzLWNvbnRhaW5lcicpO1xyXG5cclxuICAgIC8vQWRkIGEgcGF0aCBsaW5lIHRocm91Z2ggdGhlIGhlaWdodCBvZiB0aGUgYXhpc1xyXG4gICAgaWYgKCFpc0VtcHR5KHlMZXZlbCkpIHtcclxuICAgICAgICBzdmcuYXBwZW5kKCdsaW5lJylcclxuICAgICAgICAgICAgLmF0dHIoJ3gxJywgMClcclxuICAgICAgICAgICAgLmF0dHIoJ3gyJywgY29udGFpbmVyLndpZHRoKVxyXG4gICAgICAgICAgICAuYXR0cigneTEnLCBjdXJyZW50QXhpc0hlaWdodClcclxuICAgICAgICAgICAgLmF0dHIoJ3kyJywgY3VycmVudEF4aXNIZWlnaHQpXHJcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCAnd2hpdGUnKVxyXG4gICAgICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgJzIwcHgnKVxyXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLCAnICsgVFJBTlNMQVRFX1NQTElUX0NMVVNURVIgKyAnKScpO1xyXG5cclxuICAgICAgICBzdmcuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgLmRhdHVtKGRhdGEpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4JywgMClcclxuICAgICAgICAgICAgLmF0dHIoJ3knLCBjdXJyZW50QXhpc0hlaWdodClcclxuICAgICAgICAgICAgLnRleHQoKGQpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChjaGFydC5kYXRhLmRhdGFUYWJsZS5mYWNldCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRbMF1bY2hhcnQuZGF0YS5kYXRhVGFibGUuZmFjZXQucmVwbGFjZSgvXy9nLCAnICcpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoLTg1LCAwKScpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBzaW11bGF0aW9uID0gZDMuZm9yY2VTaW11bGF0aW9uKGRhdGEpXHJcbiAgICAgICAgLmFscGhhRGVjYXkoMC4wNSlcclxuICAgICAgICAuZm9yY2UoJ3gnLCBkMy5mb3JjZVgoZCA9PiB4KGRbZGF0YVRhYmxlLnhdKSlcclxuICAgICAgICAgICAgLnN0cmVuZ3RoKDEpKVxyXG4gICAgICAgIC5mb3JjZSgneScsIGQzLmZvcmNlWShjdXJyZW50QXhpc0hlaWdodCkpXHJcbiAgICAgICAgLmZvcmNlKCdjb2xsaWRlJywgZDMuZm9yY2VDb2xsaWRlKGQgPT4ge1xyXG4gICAgICAgICAgICBsZXQgbm9ybSxcclxuICAgICAgICAgICAgICAgIHZhbCA9IGNoYXJ0Ll92YXJzLk5PREVfTUlOX1NJWkU7XHJcbiAgICAgICAgICAgIC8vU2V0IGNvbGxpc2lvbiByYWRpdXMgZXF1YWwgdG8gdGhlIHJhZGl1cyBvZiB0aGUgY2lyY2xlXHJcbiAgICAgICAgICAgIGlmIChkYXRhVGFibGUuaGFzT3duUHJvcGVydHkoJ3NpemUnKSkge1xyXG4gICAgICAgICAgICAgICAgbm9ybSA9IChkW2RhdGFUYWJsZS5zaXplXSAtIHpBeGlzRGF0YS5taW4pIC8gKHpBeGlzRGF0YS5tYXggLSB6QXhpc0RhdGEubWluKTtcclxuICAgICAgICAgICAgICAgIHZhbCA9IChjaGFydC5fdmFycy5OT0RFX01BWF9TSVpFIC0gY2hhcnQuX3ZhcnMuTk9ERV9NSU5fU0laRSkgKiBub3JtICsgY2hhcnQuX3ZhcnMuTk9ERV9NSU5fU0laRTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdmFsO1xyXG4gICAgICAgIH0pLnN0cmVuZ3RoKDEpKVxyXG4gICAgICAgIC5mb3JjZSgnY2hhcmdlJywgZDMuZm9yY2VNYW55Qm9keSgpLnN0cmVuZ3RoKC02KSlcclxuICAgICAgICAuc3RvcCgpO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTIwOyArK2kpIHNpbXVsYXRpb24udGljaygpO1xyXG5cclxuICAgIGNlbGwgPSBzdmcuYXBwZW5kKCdnJylcclxuICAgICAgICAuYXR0cignY2xhc3MnLCAnY2VsbHMnKVxyXG4gICAgICAgIC5zZWxlY3RBbGwoJ2cnKVxyXG4gICAgICAgIC5kYXRhKGQzLnZvcm9ub2koKVxyXG4gICAgICAgICAgICAuZXh0ZW50KFtbMCwgMF0sIFt3aWR0aCwgaGVpZ2h0XV0pXHJcbiAgICAgICAgICAgIC54KGQgPT4gZC54KVxyXG4gICAgICAgICAgICAueShkID0+IGQueSlcclxuICAgICAgICAgICAgLnBvbHlnb25zKGRhdGEpXHJcbiAgICAgICAgKVxyXG4gICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgLmFwcGVuZCgnZycpO1xyXG5cclxuICAgIGNlbGxcclxuICAgICAgICAuYXBwZW5kKCdjaXJjbGUnKVxyXG4gICAgICAgIC5hdHRyKCdjbGFzcycsIGQgPT4ge1xyXG4gICAgICAgICAgICAnY2VsbC0nICsgZC5kYXRhW2NoYXJ0LmN1cnJlbnREYXRhLmRhdGFUYWJsZS5sYWJlbF0ucmVwbGFjZSgvXFxzL2csICdfJykucmVwbGFjZSgvXFwuL2csICdfZG90XycpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmF0dHIoJ3InLCBkID0+IHtcclxuICAgICAgICAgICAgbGV0IHZhbCA9IGNoYXJ0Ll92YXJzLk5PREVfTUlOX1NJWkU7Ly9EZWZhdWx0IG5vZGUgc2l6ZSBvZiAxNVxyXG4gICAgICAgICAgICBpZiAoZGF0YVRhYmxlLmhhc093blByb3BlcnR5KCdzaXplJykgJiYgIWlzRW1wdHkoZCkgJiYgZC5oYXNPd25Qcm9wZXJ0eSgnZGF0YScpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbm9ybSA9IChkLmRhdGFbZGF0YVRhYmxlLnNpemVdIC0gekF4aXNEYXRhLm1pbikgLyAoekF4aXNEYXRhLm1heCAtIHpBeGlzRGF0YS5taW4pO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc05hTihub3JtKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IChjaGFydC5fdmFycy5OT0RFX01BWF9TSVpFIC0gY2hhcnQuX3ZhcnMuTk9ERV9NSU5fU0laRSkgKiBub3JtICsgY2hhcnQuX3ZhcnMuTk9ERV9NSU5fU0laRTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7Ly9JZiB0aGVyZSBpcyBvbmx5IDEgbm9kZSBvbiB0aGUgY2hhcnRcclxuICAgICAgICAgICAgICAgICAgICB2YWwgPSBjaGFydC5fdmFycy5OT0RFX01JTl9TSVpFO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzRW1wdHkoZCkpIHtcclxuICAgICAgICAgICAgICAgIHZhbCA9IDA7Ly9Eb24ndCBkaXNwbGF5IHVuZGVmaW5lZCBub2Rlc1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB2YWw7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuYXR0cignY3gnLCBkID0+IGlzRW1wdHkoZCkgPyAwIDogZC5kYXRhLngpXHJcbiAgICAgICAgLmF0dHIoJ2N5JywgZCA9PiBpc0VtcHR5KGQpID8gMCA6IGQuZGF0YS55KVxyXG4gICAgICAgIC5hdHRyKCdmaWxsJywgZCA9PiB7XHJcbiAgICAgICAgICAgIGlmICghaXNFbXB0eShkKSAmJiBkLmRhdGFbY2hhcnQuX3ZhcnMuY29sb3JEYXRhQ2F0ZWdvcnldID09PSBjaGFydC5fdmFycy5jb2xvckRhdGFJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbG9yZWRQb2ludDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcG9pbnRDb2xvcjtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5hdHRyKCdvcGFjaXR5JywgMC44KVxyXG4gICAgICAgIC5hdHRyKCdzdHJva2UnLCAnYmxhY2snKVxyXG4gICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCAxKVxyXG4gICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgaWYgKGNoYXJ0LnNob3dUb29sVGlwKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGlwRGF0YSA9IGNoYXJ0LnNldFRpcERhdGEoZCwgaSk7XHJcbiAgICAgICAgICAgICAgICBjaGFydC50aXAuZ2VuZXJhdGVTaW1wbGVUaXAodGlwRGF0YSwgZGF0YVRhYmxlKTtcclxuICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgY2hhcnQuX3ZhcnMuc2luZ2xlQXhpc0ZpbGxIb3ZlckNvbG9yKTtcclxuICAgICAgICAgICAgICAgIGNoYXJ0LnRpcC5kID0gZDtcclxuICAgICAgICAgICAgICAgIGNoYXJ0LnRpcC5pID0gaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLm9uKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICBpZiAoY2hhcnQuc2hvd1Rvb2xUaXApIHtcclxuICAgICAgICAgICAgICAgIGlmIChjaGFydC50aXAuZCA9PT0gZCAmJiBjaGFydC50aXAuaSA9PT0gaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0LnRpcC5zaG93VGlwKGQzLmV2ZW50KTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9HZXQgdGlwIGRhdGFcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGlwRGF0YSA9IGNoYXJ0LnNldFRpcERhdGEoZCwgaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9EcmF3IHRpcCBsaW5lXHJcbiAgICAgICAgICAgICAgICAgICAgY2hhcnQudGlwLmdlbmVyYXRlU2ltcGxlVGlwKHRpcERhdGEsIGNoYXJ0LmRhdGEuZGF0YVRhYmxlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKGNoYXJ0LnNob3dUb29sVGlwKSB7XHJcbiAgICAgICAgICAgICAgICBjaGFydC50aXAuaGlkZVRpcCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCBkID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzRW1wdHkoZCkgJiYgZC5kYXRhW2NoYXJ0Ll92YXJzLmNvbG9yRGF0YUNhdGVnb3J5XSA9PT0gY2hhcnQuX3ZhcnMuY29sb3JEYXRhSW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbG9yZWRQb2ludDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvaW50Q29sb3I7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0U2luZ2xlQXhpc0RhdGEoZGF0YSwgZGF0YVRhYmxlKSB7XHJcbiAgICB2YXIgY2hhcnQgPSB0aGlzLFxyXG4gICAgICAgIGxhYmVsLFxyXG4gICAgICAgIGRhdGFUeXBlLFxyXG4gICAgICAgIG1pbixcclxuICAgICAgICBtYXgsXHJcbiAgICAgICAgdmFsdWVzID0gW107XHJcblxyXG4gICAgaWYgKGRhdGFUYWJsZSkge1xyXG4gICAgICAgIGlmIChkYXRhVGFibGUuaGFzT3duUHJvcGVydHkoJ3gnKSkge1xyXG4gICAgICAgICAgICBsYWJlbCA9IGRhdGFUYWJsZS54O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBkYXRhVHlwZSA9ICdOVU1CRVInO1xyXG5cclxuICAgIGZvciAobGV0IGVsZSBvZiBkYXRhKSB7XHJcbiAgICAgICAgdmFsdWVzLnB1c2goZWxlW2RhdGFUYWJsZS54XSk7XHJcbiAgICB9XHJcblxyXG4gICAgbWluID0gTWF0aC5taW4uYXBwbHkobnVsbCwgdmFsdWVzKTtcclxuICAgIG1heCA9IE1hdGgubWF4LmFwcGx5KG51bGwsIHZhbHVlcyk7XHJcblxyXG4gICAgLy9BZGQgYSAxMCUgYnVmZmVyIHRvIGJvdGggc2lkZXNcclxuICAgIG1pbiA9IE1hdGguZmxvb3IobWluIC0gKChtYXggLSBtaW4pICogMC4xMCkpO1xyXG4gICAgbWF4ID0gTWF0aC5jZWlsKG1heCArICgobWF4IC0gbWluKSAqIDAuMTApKTtcclxuXHJcbiAgICAvL0ZvciBheGlzIG1pbi9tYXggd2lkZ2V0XHJcbiAgICBpZiAoY2hhcnQuX3ZhcnMuaGFzT3duUHJvcGVydHkoJ3hNaW4nKSAmJiBjaGFydC5fdmFycy54TWluICE9PSAnbm9uZScpIHtcclxuICAgICAgICBtaW4gPSBjaGFydC5vcHRpb25zLnhNaW47XHJcbiAgICB9XHJcbiAgICBpZiAoY2hhcnQuX3ZhcnMuaGFzT3duUHJvcGVydHkoJ3hNYXgnKSAmJiBjaGFydC5fdmFycy54TWF4ICE9PSAnbm9uZScpIHtcclxuICAgICAgICBtYXggPSBjaGFydC5fdmFycy54TWF4O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgJ2xhYmVsJzogbGFiZWwsXHJcbiAgICAgICAgJ3ZhbHVlcyc6IHZhbHVlcyxcclxuICAgICAgICAnZGF0YVR5cGUnOiBkYXRhVHlwZSxcclxuICAgICAgICAnbWluJzogbWluLFxyXG4gICAgICAgICdtYXgnOiBtYXhcclxuICAgIH07XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ganZDaGFydHM7XHJcbiIsIid1c2Ugc3RyaWN0JztcclxudmFyIGp2Q2hhcnRzID0gcmVxdWlyZSgnLi4vanZDaGFydHMuanMnKTtcclxuXHJcbmp2Q2hhcnRzLnByb3RvdHlwZS5zdW5idXJzdCA9IHtcclxuICAgIHBhaW50OiBwYWludCxcclxuICAgIHNldERhdGE6IHNldERhdGEsXHJcbiAgICBnZXRFdmVudERhdGE6IGdldEV2ZW50RGF0YVxyXG59O1xyXG5cclxuanZDaGFydHMucHJvdG90eXBlLmdlbmVyYXRlU3VuYnVyc3QgPSBnZW5lcmF0ZVN1bmJ1cnN0O1xyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBTdW5idXJzdCBmdW5jdGlvbnMgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuLyoqc2V0U3VuYnVyc3RDaGFydERhdGFcclxuICogIGdldHMgc3VuYnVyc3QgZGF0YSBhbmQgYWRkcyBpdCB0byB0aGUgY2hhcnQgb2JqZWN0XHJcbiAqXHJcbiAqIEBwYXJhbXMgZGF0YSwgZGF0YVRhYmxlLCBjb2xvcnNcclxuICovXHJcbmZ1bmN0aW9uIHNldERhdGEoKSB7XHJcbiAgICB2YXIgY2hhcnQgPSB0aGlzO1xyXG4gICAgaWYgKCFjaGFydC5kYXRhLmNoYXJ0RGF0YS5oYXNPd25Qcm9wZXJ0eSgnY2hpbGRyZW4nKSkge1xyXG4gICAgICAgIGNoYXJ0LmRhdGEuY2hhcnREYXRhID0ganZDaGFydHMuY29udmVydFRhYmxlVG9UcmVlKGNoYXJ0LmRhdGEuY2hhcnREYXRhLCBjaGFydC5kYXRhLmRhdGFUYWJsZSwgdHJ1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgY2hhcnQuZGF0YS5jb2xvciA9IGNoYXJ0LmNvbG9ycztcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0RXZlbnREYXRhKCkge1xyXG4gICAgcmV0dXJuIHt9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBwYWludCgpIHtcclxuICAgIHZhciBjaGFydCA9IHRoaXMsXHJcbiAgICAgICAgc3VuYnVyc3RNYXJnaW5zID0ge1xyXG4gICAgICAgICAgICB0b3A6IDE1LFxyXG4gICAgICAgICAgICByaWdodDogMTUsXHJcbiAgICAgICAgICAgIGJvdHRvbTogMTUsXHJcbiAgICAgICAgICAgIGxlZnQ6IDE1XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICBjaGFydC5fdmFycy5jb2xvciA9IGNoYXJ0LmRhdGEuY29sb3I7XHJcbiAgICBjaGFydC5jdXJyZW50RGF0YSA9IGNoYXJ0LmRhdGE7XHJcblxyXG4gICAgLy9HZW5lcmF0ZSBTVkctbGVnZW5kIGRhdGEgaXMgdXNlZCB0byBkZXRlcm1pbmUgdGhlIHNpemUgb2YgdGhlIGJvdHRvbSBtYXJnaW4gKHNldCB0byBudWxsIGZvciBubyBsZWdlbmQpXHJcbiAgICBjaGFydC5nZW5lcmF0ZVNWRyhudWxsLCBzdW5idXJzdE1hcmdpbnMpO1xyXG4gICAgLy9jaGFydC5nZW5lcmF0ZUxlZ2VuZChjaGFydC5jdXJyZW50RGF0YS5sZWdlbmREYXRhLCAnZ2VuZXJhdGVTdW5idXJzdCcpO1xyXG4gICAgY2hhcnQuZ2VuZXJhdGVTdW5idXJzdCgpO1xyXG59XHJcblxyXG4vKipnZW5lcmF0ZVN1bmJ1cnN0XHJcbiAqXHJcbiAqIHBhaW50cyB0aGUgc3VuYnVyc3Qgb24gdGhlIGNoYXJ0XHJcbiAqIEBwYXJhbXMgc3VuYnVyc3REYXRhXHJcbiAqL1xyXG5mdW5jdGlvbiBnZW5lcmF0ZVN1bmJ1cnN0KCkge1xyXG4gICAgdmFyIGNoYXJ0ID0gdGhpcyxcclxuICAgICAgICBzdmcgPSBjaGFydC5zdmcsXHJcbiAgICAgICAgdmlzLFxyXG4gICAgICAgIHRleHQsXHJcbiAgICAgICAgY29udGFpbmVyID0gY2hhcnQuY29uZmlnLmNvbnRhaW5lcixcclxuICAgICAgICB3aWR0aCA9IGNvbnRhaW5lci53aWR0aCxcclxuICAgICAgICBoZWlnaHQgPSBjb250YWluZXIuaGVpZ2h0LFxyXG4gICAgICAgIHJhZGl1cyA9IChNYXRoLm1pbih3aWR0aCwgaGVpZ2h0KSAvIDIpIC0gMTAsXHJcbiAgICAgICAgeCA9IGQzLnNjYWxlTGluZWFyKClcclxuICAgICAgICAgICAgLnJhbmdlKFswLCAyICogTWF0aC5QSV0pLFxyXG4gICAgICAgIHkgPSBkMy5zY2FsZVNxcnQoKVxyXG4gICAgICAgICAgICAucmFuZ2UoWzAsIHJhZGl1c10pLFxyXG4gICAgICAgIGNvbG9yID0gZDMuc2NhbGVPcmRpbmFsKClcclxuICAgICAgICAgICAgLnJhbmdlKGNoYXJ0LmRhdGEuY29sb3JcclxuICAgICAgICAgICAgICAgIC5tYXAoYyA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgYyA9IGQzLnJnYihjKTtcclxuICAgICAgICAgICAgICAgICAgICBjLm9wYWNpdHkgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjO1xyXG4gICAgICAgICAgICAgICAgfSkpLFxyXG4gICAgICAgIHBhcnRpdGlvbiA9IGQzLnBhcnRpdGlvbigpLFxyXG4gICAgICAgIGFyYyA9IGQzLmFyYygpXHJcbiAgICAgICAgICAgIC5zdGFydEFuZ2xlKGQgPT4gTWF0aC5tYXgoMCwgTWF0aC5taW4oMiAqIE1hdGguUEksIHgoZC54MCkpKSlcclxuICAgICAgICAgICAgLmVuZEFuZ2xlKGQgPT4gTWF0aC5tYXgoMCwgTWF0aC5taW4oMiAqIE1hdGguUEksIHgoZC54MSkpKSlcclxuICAgICAgICAgICAgLmlubmVyUmFkaXVzKGQgPT4gTWF0aC5tYXgoMCwgeShkLnkwKSkpXHJcbiAgICAgICAgICAgIC5vdXRlclJhZGl1cyhkID0+IE1hdGgubWF4KDAsIHkoZC55MSkpKSxcclxuXHJcbiAgICAgICAgLy9hc3NpZ25zIHRoZSBkYXRhIHRvIGEgaGllcmFyY2h5IHVzaW5nIHBhcmVudC1jaGlsZCByZWxhdGlvbnNoaXBzXHJcbiAgICAgICAgcm9vdCA9IGQzLmhpZXJhcmNoeShjaGFydC5jdXJyZW50RGF0YS5jaGFydERhdGEsIGQgPT4gZC5jaGlsZHJlbik7XHJcblxyXG4gICAgcm9vdC5zdW0oZCA9PiBkLnZhbHVlKTtcclxuXHJcbiAgICB2aXMgPSBzdmcuYXBwZW5kKCdnJylcclxuICAgICAgICAuYXR0cignY2xhc3MnLCAnc3VuYnVyc3QnKVxyXG4gICAgICAgIC5hdHRyKCd3aWR0aCcsIHdpZHRoKVxyXG4gICAgICAgIC5hdHRyKCdoZWlnaHQnLCBoZWlnaHQpXHJcbiAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIHdpZHRoIC8gMiArICcsJyArIChoZWlnaHQgLyAyKSArICcpJyk7XHJcblxyXG5cclxuICAgIHZpcy5zZWxlY3RBbGwoJ3BhdGgnKVxyXG4gICAgICAgIC5kYXRhKHBhcnRpdGlvbihyb290KS5kZXNjZW5kYW50cygpKVxyXG4gICAgICAgIC5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ25vZGUnKTtcclxuXHJcbiAgICB2aXMuc2VsZWN0QWxsKCcubm9kZScpXHJcbiAgICAgICAgLmFwcGVuZCgncGF0aCcpXHJcbiAgICAgICAgLmF0dHIoJ2QnLCBhcmMpXHJcbiAgICAgICAgLnN0eWxlKCdmaWxsJywgZCA9PiB7XHJcbiAgICAgICAgICAgIGlmIChkLmRhdGEubmFtZSA9PT0gJ3Jvb3QnKSB7XHJcbiAgICAgICAgICAgICAgICBkLmNvbG9yID0gY2hhcnQuX3ZhcnMuYmFja2dyb3VuZENvbG9yO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoYXJ0Ll92YXJzLmJhY2tncm91bmRDb2xvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkLmNvbG9yID0gY29sb3IoZC5kYXRhLm5hbWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gY29sb3IoZC5kYXRhLm5hbWUpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICBpZiAoY2hhcnQuc2hvd1Rvb2xUaXApIHtcclxuICAgICAgICAgICAgICAgIHZhciB0aXBEYXRhID0gY2hhcnQuc2V0VGlwRGF0YShkLCBpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL0RyYXcgdGlwIGxpbmVcclxuICAgICAgICAgICAgICAgIGNoYXJ0LnRpcC5nZW5lcmF0ZVNpbXBsZVRpcCh0aXBEYXRhLCBjaGFydC5kYXRhLmRhdGFUYWJsZSk7XHJcbiAgICAgICAgICAgICAgICBjaGFydC50aXAuZCA9IGQ7XHJcbiAgICAgICAgICAgICAgICBjaGFydC50aXAuaSA9IGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICAgIC5vbignbW91c2Vtb3ZlJywgZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgaWYgKGNoYXJ0LnNob3dUb29sVGlwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hhcnQudGlwLmQgPT09IGQgJiYgY2hhcnQudGlwLmkgPT09IGkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGFydC50aXAuc2hvd1RpcChkMy5ldmVudCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vR2V0IHRpcCBkYXRhXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpcERhdGEgPSBjaGFydC5zZXRUaXBEYXRhKGQsIGkpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vRHJhdyB0aXAgbGluZVxyXG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0LnRpcC5nZW5lcmF0ZVNpbXBsZVRpcCh0aXBEYXRhLCBjaGFydC5kYXRhLmRhdGFUYWJsZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICAgIC5vbignY2xpY2snLCBjbGljaylcclxuICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBjaGFydC50aXAuaGlkZVRpcCgpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIGlmIChjaGFydC5fdmFycy5kaXNwbGF5VmFsdWVzKSB7XHJcbiAgICAgICAgdGV4dCA9IHZpcy5zZWxlY3RBbGwoJy5ub2RlJylcclxuICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBkID0+IGByb3RhdGUoJHtjb21wdXRlVGV4dFJvdGF0aW9uKGQpfSlgKVxyXG4gICAgICAgICAgICAuYXR0cigneCcsIGQgPT4geShkLnkwKSlcclxuICAgICAgICAgICAgLmF0dHIoJ2R4JywgJzYnKSAvL21hcmdpblxyXG4gICAgICAgICAgICAuYXR0cignZHknLCAnLjM1ZW0nKSAvL3ZlcnRpY2FsLWFsaWduXHJcbiAgICAgICAgICAgIC50ZXh0KGQgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKE51bWJlcihkLmRhdGEudmFsdWUpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkLmRhdGEubmFtZSA9PT0gJ3Jvb3QnID8gJycgOiBkLmRhdGEubmFtZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIGNsaWNrKGQpIHtcclxuICAgICAgICAvL2ZhZGUgb3V0IGFsbCB0ZXh0IGVsZW1lbnRzXHJcbiAgICAgICAgaWYgKGNoYXJ0Ll92YXJzLmRpc3BsYXlWYWx1ZXMpIHtcclxuICAgICAgICAgICAgdGV4dC50cmFuc2l0aW9uKCkuYXR0cignb3BhY2l0eScsIDApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmlzLnRyYW5zaXRpb24oKVxyXG4gICAgICAgICAgICAuZHVyYXRpb24oNzUwKVxyXG4gICAgICAgICAgICAudHdlZW4oJ3NjYWxlJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdmFyIHhkID0gZDMuaW50ZXJwb2xhdGUoeC5kb21haW4oKSwgW2QueDAsIGQueDFdKSxcclxuICAgICAgICAgICAgICAgICAgICB5ZCA9IGQzLmludGVycG9sYXRlKHkuZG9tYWluKCksIFtkLnkwLCAxXSksXHJcbiAgICAgICAgICAgICAgICAgICAgeXIgPSBkMy5pbnRlcnBvbGF0ZSh5LnJhbmdlKCksIFtkLnkwID8gMjAgOiAwLCByYWRpdXNdKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdCA9PiB7IHguZG9tYWluKHhkKHQpKTsgeS5kb21haW4oeWQodCkpLnJhbmdlKHlyKHQpKTsgfTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLnNlbGVjdEFsbCgncGF0aCcpXHJcbiAgICAgICAgICAgIC5hdHRyVHdlZW4oJ2QnLCBlbGUgPT4gKCkgPT4gYXJjKGVsZSkpXHJcbiAgICAgICAgICAgIC5vbignZW5kJywgZnVuY3Rpb24gKGUsIGkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjaGFydC5fdmFycy5kaXNwbGF5VmFsdWVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9jaGVjayBpZiB0aGUgYW5pbWF0ZWQgZWxlbWVudCdzIGRhdGEgZSBsaWVzIHdpdGhpbiB0aGUgdmlzaWJsZSBhbmdsZSBzcGFuIGdpdmVuIGluIGRcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZS54MCA+IGQueDAgJiYgZS54MCA8IGQueDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9nZXQgYSBzZWxlY3Rpb24gb2YgdGhlIGFzc29jaWF0ZWQgdGV4dCBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmNUZXh0ID0gZDMuc2VsZWN0KHRoaXMucGFyZW50Tm9kZSkuc2VsZWN0KCd0ZXh0Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZmFkZSBpbiB0aGUgdGV4dCBlbGVtZW50IGFuZCByZWNhbGN1bGF0ZSBwb3NpdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJjVGV4dC50cmFuc2l0aW9uKCkuZHVyYXRpb24oNzUwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ29wYWNpdHknLCAxKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3Zpc2libGUnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICgpID0+IGByb3RhdGUoJHtjb21wdXRlVGV4dFJvdGF0aW9uKGUpfSlgKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBlbGUgPT4geShlbGUueTApKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRleHQoZWxlID0+IGVsZS5kYXRhLm5hbWUgPT09ICdyb290JyA/ICcnIDogZWxlLmRhdGEubmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjb21wdXRlVGV4dFJvdGF0aW9uKGQpIHtcclxuICAgICAgICByZXR1cm4gKHgoKGQueDAgKyBkLngxKSAvIDIpIC0gTWF0aC5QSSAvIDIpIC8gTWF0aC5QSSAqIDE4MDtcclxuICAgIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBqdkNoYXJ0cztcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIganZDaGFydHMgPSByZXF1aXJlKCcuLi9qdkNoYXJ0cy5qcycpO1xyXG5cclxuanZDaGFydHMucHJvdG90eXBlLnRyZWVtYXAgPSB7XHJcbiAgICBwYWludDogcGFpbnQsXHJcbiAgICBzZXREYXRhOiBzZXREYXRhLFxyXG4gICAgZ2V0RXZlbnREYXRhOiBnZXRFdmVudERhdGFcclxufTtcclxuXHJcbmp2Q2hhcnRzLnByb3RvdHlwZS5nZW5lcmF0ZVRyZWVNYXAgPSBnZW5lcmF0ZVRyZWVNYXA7XHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogVHJlZU1hcCBmdW5jdGlvbnMgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuLyoqc2V0VHJlZU1hcERhdGFcclxuICogIGdldHMgdHJlZW1hcCBkYXRhIGFuZCBhZGRzIGl0IHRvIHRoZSBjaGFydCBvYmplY3RcclxuICpcclxuICogQHBhcmFtcyBkYXRhLCBkYXRhVGFibGUsIGNvbG9yc1xyXG4gKi9cclxuZnVuY3Rpb24gc2V0RGF0YSgpIHtcclxuICAgIHZhciBjaGFydCA9IHRoaXM7XHJcbiAgICBpZiAoIWNoYXJ0LmRhdGEuY2hhcnREYXRhLmhhc093blByb3BlcnR5KCdjaGlsZHJlbicpKSB7XHJcbiAgICAgICAgY2hhcnQuZGF0YS5jaGFydERhdGEgPSBqdkNoYXJ0cy5jb252ZXJ0VGFibGVUb1RyZWVtYXAoY2hhcnQuZGF0YS5jaGFydERhdGEsIGNoYXJ0LmRhdGEuZGF0YVRhYmxlKTtcclxuICAgIH1cclxuICAgIGNoYXJ0LmRhdGEubGVnZW5kRGF0YSA9IHNldFRyZWVNYXBMZWdlbmREYXRhKGNoYXJ0LmRhdGEpO1xyXG4gICAgLy9kZWZpbmUgY29sb3Igb2JqZWN0IGZvciBjaGFydERhdGFcclxuICAgIGNoYXJ0LmRhdGEuY29sb3IgPSBqdkNoYXJ0cy5zZXRDaGFydENvbG9ycyhjaGFydC5fdmFycy5jb2xvciwgY2hhcnQuZGF0YS5sZWdlbmREYXRhLCBjaGFydC5jb2xvcnMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRFdmVudERhdGEoKSB7XHJcbiAgICByZXR1cm4ge307XHJcbn1cclxuXHJcbi8qKnNldFRyZWVNYXBMZWdlbmREYXRhXHJcbiAqICBnZXRzIGxlZ2VuZCBpbmZvIGZyb20gY2hhcnQgRGF0YVxyXG4gKlxyXG4gKiBAcGFyYW1zIGRhdGEsIHR5cGVcclxuICogQHJldHVybnMgW10gb2YgbGVnZW5kIHRleHRcclxuICovXHJcbmZ1bmN0aW9uIHNldFRyZWVNYXBMZWdlbmREYXRhKGRhdGEpIHtcclxuICAgIHZhciBsZWdlbmRBcnJheSA9IFtdLFxyXG4gICAgICAgIHNlcmllcyA9IGRhdGEuZGF0YVRhYmxlLnNlcmllcztcclxuICAgIGZvciAobGV0IGNoaWxkRWxlIG9mIGRhdGEuY2hhcnREYXRhLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgaWYgKGxlZ2VuZEFycmF5LmluZGV4T2YoY2hpbGRFbGVbc2VyaWVzXSkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIGxlZ2VuZEFycmF5LnB1c2goKGNoaWxkRWxlW3Nlcmllc10pKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbGVnZW5kQXJyYXk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhaW50KCkge1xyXG4gICAgdmFyIGNoYXJ0ID0gdGhpcyxcclxuICAgICAgICB0cmVlTWFwTWFyZ2lucyA9IHtcclxuICAgICAgICAgICAgdG9wOiA0NSxcclxuICAgICAgICAgICAgcmlnaHQ6IDUwLFxyXG4gICAgICAgICAgICBsZWZ0OiA1MCxcclxuICAgICAgICAgICAgYm90dG9tOiAxMzBcclxuICAgICAgICB9O1xyXG4gICAgY2hhcnQuX3ZhcnMuY29sb3IgPSBjaGFydC5kYXRhLmNvbG9yO1xyXG4gICAgY2hhcnQuY3VycmVudERhdGEgPSBjaGFydC5kYXRhO1xyXG5cclxuICAgIC8vR2VuZXJhdGUgU1ZHLWxlZ2VuZCBkYXRhIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBzaXplIG9mIHRoZSBib3R0b20gbWFyZ2luIChzZXQgdG8gbnVsbCBmb3Igbm8gbGVnZW5kKVxyXG4gICAgY2hhcnQuZ2VuZXJhdGVTVkcobnVsbCwgdHJlZU1hcE1hcmdpbnMpO1xyXG4gICAgY2hhcnQuZ2VuZXJhdGVMZWdlbmQoY2hhcnQuY3VycmVudERhdGEubGVnZW5kRGF0YSwgJ2dlbmVyYXRlVHJlZU1hcCcpO1xyXG4gICAgY2hhcnQuZ2VuZXJhdGVUcmVlTWFwKGNoYXJ0LmN1cnJlbnREYXRhKTtcclxufVxyXG5cclxuLyoqZ2VuZXJhdGVUcmVlTWFwXHJcbiAqXHJcbiAqIHBhaW50cyB0aGUgdHJlZW1hcCBvbiB0aGUgY2hhcnRcclxuICogQHBhcmFtcyB0cmVlTWFwRGF0YVxyXG4gKi9cclxuZnVuY3Rpb24gZ2VuZXJhdGVUcmVlTWFwKHRyZWVNYXBEYXRhKSB7XHJcbiAgICB2YXIgY2hhcnQgPSB0aGlzLFxyXG4gICAgICAgIHN2ZyA9IGNoYXJ0LnN2ZyxcclxuICAgICAgICBjb2xvcnMgPSB0cmVlTWFwRGF0YS5jb2xvcixcclxuICAgICAgICBjb250YWluZXIgPSBjaGFydC5jb25maWcuY29udGFpbmVyLFxyXG4gICAgICAgIHJlbGF0aW9uTWFwID0gY2hhcnQuZGF0YS5kYXRhVGFibGUsXHJcbiAgICAgICAgZGF0YSA9IGNoYXJ0LmN1cnJlbnREYXRhLmNoYXJ0RGF0YSxcclxuICAgICAgICBkYXRhSGVhZGVycyxcclxuICAgICAgICBsZWdlbmRFbGVtZW50VG9nZ2xlQXJyYXksXHJcbiAgICAgICAgdHJlZU1hcERhdGFGaWx0ZXJlZCxcclxuICAgICAgICByb290LFxyXG4gICAgICAgIHRyZWVtYXBGdW5jLFxyXG4gICAgICAgIG5vZGUsXHJcbiAgICAgICAgdGV4dE5vZGU7XHJcblxyXG4gICAgaWYgKCFjaGFydC5fdmFycy5sZWdlbmRIZWFkZXJzKSB7XHJcbiAgICAgICAgY2hhcnQuX3ZhcnMubGVnZW5kSGVhZGVycyA9IGNoYXJ0LmN1cnJlbnREYXRhLmxlZ2VuZERhdGE7XHJcbiAgICB9XHJcblxyXG4gICAgZGF0YUhlYWRlcnMgPSBjaGFydC5fdmFycy5sZWdlbmRIZWFkZXJzO1xyXG4gICAgbGVnZW5kRWxlbWVudFRvZ2dsZUFycmF5ID0ganZDaGFydHMuZ2V0TGVnZW5kRWxlbWVudFRvZ2dsZUFycmF5KGRhdGFIZWFkZXJzLCBjaGFydC5kYXRhLmxlZ2VuZERhdGEpO1xyXG5cclxuICAgIGlmIChsZWdlbmRFbGVtZW50VG9nZ2xlQXJyYXkpIHtcclxuICAgICAgICBmb3IgKGxldCBjaGlsZEVsZSBvZiBkYXRhLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGxlZ2VuZEVsZSBvZiBsZWdlbmRFbGVtZW50VG9nZ2xlQXJyYXkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChsZWdlbmRFbGUuZWxlbWVudCA9PT0gY2hpbGRFbGVbcmVsYXRpb25NYXAuc2VyaWVzXSAmJiBsZWdlbmRFbGUudG9nZ2xlID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkRWxlLnNob3cgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0cmVlTWFwRGF0YUZpbHRlcmVkID0ge1xyXG4gICAgICAgIFBhcmVudDogJ1RvcCBMZXZlbCcsXHJcbiAgICAgICAgY2hpbGRyZW46IFtdXHJcbiAgICB9O1xyXG5cclxuICAgIGZvciAobGV0IGNoaWxkRWxlIG9mIGRhdGEuY2hpbGRyZW4pIHtcclxuICAgICAgICBpZiAoY2hpbGRFbGUuc2hvdyAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgdHJlZU1hcERhdGFGaWx0ZXJlZC5jaGlsZHJlbi5wdXNoKGNoaWxkRWxlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy9hc3NpZ25zIHRoZSBkYXRhIHRvIGEgaGllcmFyY2h5IHVzaW5nIHBhcmVudC1jaGlsZCByZWxhdGlvbnNoaXBzXHJcbiAgICByb290ID0gZDMuaGllcmFyY2h5KHRyZWVNYXBEYXRhRmlsdGVyZWQsIGQgPT4gZC5jaGlsZHJlbik7XHJcblxyXG4gICAgdHJlZW1hcEZ1bmMgPSBkMy50cmVlbWFwKClcclxuICAgICAgICAuc2l6ZShbY29udGFpbmVyLndpZHRoLCBjb250YWluZXIuaGVpZ2h0XSlcclxuICAgICAgICAucGFkZGluZygyKTtcclxuXHJcbiAgICB0cmVlbWFwRnVuYyhyb290XHJcbiAgICAgICAgLnN1bShkID0+IGRbcmVsYXRpb25NYXAuc2l6ZV0pXHJcbiAgICAgICAgLnNvcnQoKGEsIGIpID0+IGIuaGVpZ2h0IC0gYS5oZWlnaHQgfHwgYi52YWx1ZSAtIGEudmFsdWUpKVxyXG4gICAgICAgIC5kZXNjZW5kYW50cygpO1xyXG5cclxuICAgIC8vUmVtb3ZlIGV4aXN0aW5nIGJhcnMgZnJvbSBwYWdlXHJcbiAgICBzdmcuc2VsZWN0QWxsKCdnLnRyZWVtYXAnKS5yZW1vdmUoKTtcclxuICAgIHN2Zy5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICd0cmVlbWFwJyk7XHJcblxyXG4gICAgbm9kZSA9IHN2Zy5zZWxlY3QoJy50cmVlbWFwJylcclxuICAgICAgICAuc2VsZWN0QWxsKCdnJylcclxuICAgICAgICAuZGF0YShyb290LmxlYXZlcygpKVxyXG4gICAgICAgIC5lbnRlcigpLmFwcGVuZCgnZycpXHJcbiAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwwKScpO1xyXG5cclxuICAgIG5vZGUuYXBwZW5kKCdyZWN0JylcclxuICAgICAgICAuYXR0cigneCcsIGQgPT4gZC54MCArICdweCcpXHJcbiAgICAgICAgLmF0dHIoJ3knLCBkID0+IGQueTAgKyAncHgnKVxyXG4gICAgICAgIC5hdHRyKCd3aWR0aCcsIGQgPT4gZC54MSAtIGQueDAgKyAncHgnKVxyXG4gICAgICAgIC5hdHRyKCdoZWlnaHQnLCBkID0+IGQueTEgLSBkLnkwICsgJ3B4JylcclxuICAgICAgICAuYXR0cignZmlsbCcsIChkLCBpKSA9PiBqdkNoYXJ0cy5nZXRDb2xvcnMoY29sb3JzLCBpLCBkLmRhdGFbcmVsYXRpb25NYXAuc2VyaWVzXSkpXHJcbiAgICAgICAgLmF0dHIoJ2ZpbGwtb3BhY2l0eScsIDAuOClcclxuICAgICAgICAuYXR0cignc3Ryb2tlJywgY2hhcnQuX3ZhcnMud2hpdGUpXHJcbiAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIGNoYXJ0Ll92YXJzLnN0cm9rZVdpZHRoKVxyXG4gICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgLy9HZXQgdGlwIGRhdGFcclxuICAgICAgICAgICAgbGV0IHRpcERhdGEgPSBjaGFydC5zZXRUaXBEYXRhKGQuZGF0YSwgaSk7XHJcbiAgICAgICAgICAgIC8vRHJhdyB0aXAgbGluZVxyXG4gICAgICAgICAgICBjaGFydC50aXAuZ2VuZXJhdGVTaW1wbGVUaXAodGlwRGF0YSwgY2hhcnQuZGF0YS5kYXRhVGFibGUpO1xyXG4gICAgICAgICAgICBjaGFydC50aXAuZCA9IGQ7XHJcbiAgICAgICAgICAgIGNoYXJ0LnRpcC5pID0gaTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5vbignbW91c2Vtb3ZlJywgZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgaWYgKGNoYXJ0LnNob3dUb29sVGlwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hhcnQudGlwLmQgPT09IGQgJiYgY2hhcnQudGlwLmkgPT09IGkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGFydC50aXAuc2hvd1RpcChkMy5ldmVudCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vR2V0IHRpcCBkYXRhXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRpcERhdGEgPSBjaGFydC5zZXRUaXBEYXRhKGQsIGkpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vRHJhdyB0aXAgbGluZVxyXG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0LnRpcC5nZW5lcmF0ZVNpbXBsZVRpcCh0aXBEYXRhLCBjaGFydC5kYXRhLmRhdGFUYWJsZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGNoYXJ0LnRpcC5oaWRlVGlwKCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgbm9kZS5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgIC5hdHRyKCd4JywgZCA9PiBkLngwICsgJ3B4JylcclxuICAgICAgICAuYXR0cigneScsIGQgPT4gZC55MCArICdweCcpXHJcbiAgICAgICAgLmF0dHIoJ3dpZHRoJywgZCA9PiBkLngxIC0gZC54MCArICdweCcpXHJcbiAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGQgPT4gZC55MSAtIGQueTAgKyAncHgnKVxyXG4gICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDMsIDE4KScpXHJcbiAgICAgICAgLnRleHQoZCA9PiB7XHJcbiAgICAgICAgICAgIGlmIChkLmR5ICE9PSAwICYmICFkLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZC5kYXRhW3JlbGF0aW9uTWFwLmxhYmVsXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAvKkRvbid0IGRpc3BsYXkgdGV4dCBpZiB0ZXh0IGlzIHdpZGVyIHRoYW4gcmVjdCAqL1xyXG4gICAgdGV4dE5vZGUgPSBub2RlLnNlbGVjdEFsbCgndGV4dCcpO1xyXG4gICAgdGV4dE5vZGUuYXR0cignc3R5bGUnLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgIGxldCBiYm94ID0gdGhpcy5nZXRCQm94KCk7XHJcbiAgICAgICAgaWYgKGJib3gud2lkdGggPj0gKGQueDEgLSBkLngwKSAtIDUgfHwgYmJveC5oZWlnaHQgPj0gKGQueTEgLSBkLnkwKSAtIDUpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdkaXNwbGF5Om5vbmUnO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gJyc7XHJcbiAgICB9KTtcclxufVxyXG5tb2R1bGUuZXhwb3J0cyA9IGp2Q2hhcnRzO1xyXG4iLCIndXNlIHN0cmljdCc7XHJcbnZhciBqdkNoYXJ0cyA9IHJlcXVpcmUoJy4uL2p2Q2hhcnRzLmpzJyk7XHJcblxyXG5qdkNoYXJ0cy5wcm90b3R5cGUuY2xvdWQgPSB7XHJcbiAgICBwYWludDogcGFpbnQsXHJcbiAgICBzZXREYXRhOiBzZXREYXRhLFxyXG4gICAgZ2V0RXZlbnREYXRhOiBnZXRFdmVudERhdGFcclxufTtcclxuXHJcbmp2Q2hhcnRzLnByb3RvdHlwZS5nZW5lcmF0ZUNsb3VkID0gZ2VuZXJhdGVDbG91ZDtcclxuXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogQ2xvdWQgZnVuY3Rpb25zICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcbi8qKnNldENsb3VkRGF0YVxyXG4gKiAgZ2V0cyBjbG91ZCBkYXRhIGFuZCBhZGRzIGl0IHRvIHRoZSBjaGFydCBvYmplY3RcclxuICpcclxuICogQHBhcmFtcyBkYXRhLCBkYXRhVGFibGUsIGNvbG9yc1xyXG4gKi9cclxuZnVuY3Rpb24gc2V0RGF0YSgpIHtcclxuICAgIHZhciBjaGFydCA9IHRoaXM7XHJcbiAgICAvL2RlZmluZSBjb2xvciBvYmplY3QgZm9yIGNoYXJ0RGF0YVxyXG4gICAgY2hhcnQuZGF0YS5jb2xvciA9IGNoYXJ0LmNvbG9ycztcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0RXZlbnREYXRhKCkge1xyXG4gICAgcmV0dXJuIHt9O1xyXG59XHJcblxyXG4vKipzZXRDbG91ZExlZ2VuZERhdGFcclxuICogIGdldHMgbGVnZW5kIGluZm8gZnJvbSBjaGFydCBEYXRhXHJcbiAqXHJcbiAqIEBwYXJhbXMgZGF0YSwgdHlwZVxyXG4gKiBAcmV0dXJucyBbXSBvZiBsZWdlbmQgdGV4dFxyXG4gKi9cclxuZnVuY3Rpb24gc2V0Q2xvdWRMZWdlbmREYXRhKGRhdGEpIHtcclxuICAgIHZhciBsZWdlbmRBcnJheSA9IFtdO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmNoYXJ0RGF0YS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChsZWdlbmRBcnJheS5pbmRleE9mKGRhdGEuY2hhcnREYXRhLmNoaWxkcmVuW2ldW2RhdGEuZGF0YVRhYmxlLnNlcmllc10pID09IC0xKSB7XHJcbiAgICAgICAgICAgIGxlZ2VuZEFycmF5LnB1c2goKGRhdGEuY2hhcnREYXRhLmNoaWxkcmVuW2ldW2RhdGEuZGF0YVRhYmxlLnNlcmllc10pKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbGVnZW5kQXJyYXk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhaW50KCkge1xyXG4gICAgdmFyIGNoYXJ0ID0gdGhpcztcclxuICAgIGlmICghY2hhcnQuc21hbGxlckZvbnRSZXBhaW50KSB7XHJcbiAgICAgICAgY2hhcnQuX3ZhcnMuZm9udFNpemVNYXggPSA4MDtcclxuICAgICAgICBjaGFydC5jdXJyZW50RGF0YSA9IGNoYXJ0LmRhdGE7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNoYXJ0LmN1cnJlbnREYXRhID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShjaGFydC5kYXRhKSk7XHJcbiAgICB9XHJcblxyXG4gICAgY2hhcnQuX3ZhcnMuY29sb3IgPSBjaGFydC5kYXRhLmNvbG9yO1xyXG5cclxuICAgIHZhciBjbG91ZE1hcmdpbnMgPSB7XHJcbiAgICAgICAgdG9wOiAxNSxcclxuICAgICAgICByaWdodDogMTUsXHJcbiAgICAgICAgbGVmdDogMTUsXHJcbiAgICAgICAgYm90dG9tOiAxNVxyXG4gICAgfTtcclxuXHJcbiAgICAvL0dlbmVyYXRlIFNWRy1sZWdlbmQgZGF0YSBpcyB1c2VkIHRvIGRldGVybWluZSB0aGUgc2l6ZSBvZiB0aGUgYm90dG9tIG1hcmdpbiAoc2V0IHRvIG51bGwgZm9yIG5vIGxlZ2VuZClcclxuICAgIGNoYXJ0LmdlbmVyYXRlU1ZHKG51bGwsIGNsb3VkTWFyZ2lucyk7XHJcbiAgICAvLyBjaGFydC5nZW5lcmF0ZUxlZ2VuZChjaGFydC5jdXJyZW50RGF0YS5sZWdlbmREYXRhLCAnZ2VuZXJhdGVDbG91ZCcpO1xyXG4gICAgY2hhcnQuZ2VuZXJhdGVDbG91ZChjaGFydC5jdXJyZW50RGF0YSk7XHJcbn07XHJcblxyXG4vKiogZ2VuZXJhdGVDbG91ZFxyXG4gKlxyXG4gKiBwYWludHMgdGhlIGNsb3VkICBvbiB0aGUgY2hhcnRcclxuICogQHBhcmFtcyBjbG91ZCBEYXRhXHJcbiAqL1xyXG5mdW5jdGlvbiBnZW5lcmF0ZUNsb3VkKGNsb3VkRGF0YSkge1xyXG4gICAgdmFyIGNoYXJ0ID0gdGhpcyxcclxuICAgICAgICBzdmcgPSBjaGFydC5zdmcsXHJcbiAgICAgICAgY29udGFpbmVyID0gY2hhcnQuY29uZmlnLmNvbnRhaW5lcixcclxuICAgICAgICBhbGxGaWx0ZXJMaXN0ID0gW10sXHJcbiAgICAgICAgcmVsYXRpb25NYXAgPSBjaGFydC5kYXRhLmRhdGFUYWJsZSxcclxuICAgICAgICB3aWR0aCA9IGNvbnRhaW5lci53aWR0aCxcclxuICAgICAgICBoZWlnaHQgPSBjb250YWluZXIuaGVpZ2h0LFxyXG4gICAgICAgIG1hcmdpbiA9IGNoYXJ0LmNvbmZpZy5tYXJnaW4sXHJcbiAgICAgICAgbWluLFxyXG4gICAgICAgIG1heDtcclxuXHJcbiAgICB2YXIgY2F0ZWdvcmllcyA9IGQzLmtleXMoZDMubmVzdCgpLmtleShmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgIGlmICghbWluICYmICFtYXgpIHtcclxuICAgICAgICAgICAgbWluID0gZFtyZWxhdGlvbk1hcC52YWx1ZV07XHJcbiAgICAgICAgICAgIG1heCA9IGRbcmVsYXRpb25NYXAudmFsdWVdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChkW3JlbGF0aW9uTWFwLnZhbHVlXSA+IG1heCkge1xyXG4gICAgICAgICAgICAgICAgbWF4ID0gZFtyZWxhdGlvbk1hcC52YWx1ZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRbcmVsYXRpb25NYXAudmFsdWVdIDwgbWluKSB7XHJcbiAgICAgICAgICAgICAgICBtaW4gPSBkW3JlbGF0aW9uTWFwLnZhbHVlXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGRbcmVsYXRpb25NYXAudmFsdWVdO1xyXG4gICAgfSkubWFwKGNsb3VkRGF0YS5jaGFydERhdGEpKTtcclxuXHJcbiAgICBpZiAoIWNoYXJ0Ll92YXJzLmZvbnRTaXplTWF4KSB7XHJcbiAgICAgICAgY2hhcnQuX3ZhcnMuZm9udFNpemVNYXggPSA4MDtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgY29sb3IgPSBkMy5zY2FsZU9yZGluYWwoKVxyXG4gICAgICAgIC5yYW5nZShjaGFydC5kYXRhLmNvbG9yXHJcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGMpIHsgYyA9IGQzLnJnYihjKTsgYy5vcGFjaXR5ID0gMC44OyByZXR1cm4gYzsgfSkpO1xyXG5cclxuICAgIHZhciBmb250U2l6ZSA9IGQzLnNjYWxlUG93KCkuZXhwb25lbnQoNSkuZG9tYWluKFswLCAxXSkucmFuZ2UoWzEwLCBjaGFydC5fdmFycy5mb250U2l6ZU1heF0pO1xyXG4gICAgY2hhcnQuc21hbGxlckZvbnRSZXBhaW50ID0gZmFsc2U7XHJcbiAgICB2YXIgbGF5b3V0ID0gZDMubGF5b3V0LmNsb3VkKClcclxuICAgICAgICAudGltZUludGVydmFsKDEwKVxyXG4gICAgICAgIC5zaXplKFt3aWR0aCwgaGVpZ2h0XSlcclxuICAgICAgICAud29yZHMoY2xvdWREYXRhLmNoYXJ0RGF0YSlcclxuICAgICAgICAucm90YXRlKGZ1bmN0aW9uIChkKSB7IHJldHVybiAwOyB9KVxyXG4gICAgICAgIC5mb250KCdSb2JvdG8nKVxyXG4gICAgICAgIC5mb250U2l6ZShmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZm9udFNpemUobWF4IC0gbWluICE9PSAwID8gKGRbcmVsYXRpb25NYXAudmFsdWVdIC0gbWluKSAvIChtYXggLSBtaW4pIDogMCk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAucmVwYWludFdpdGhTbWFsbGVyRm9udChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKGNoYXJ0Ll92YXJzLmZvbnRTaXplTWF4ID4gMTApIHtcclxuICAgICAgICAgICAgICAgIGNoYXJ0Ll92YXJzLmZvbnRTaXplTWF4IC09IDU7XHJcbiAgICAgICAgICAgICAgICBjaGFydC5zbWFsbGVyRm9udFJlcGFpbnQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgcGFpbnQoY2hhcnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICAudGV4dChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZFtyZWxhdGlvbk1hcC5sYWJlbF07IH0pXHJcbiAgICAgICAgLnNwaXJhbChcImFyY2hpbWVkZWFuXCIpXHJcbiAgICAgICAgLm9uKFwiZW5kXCIsIGRyYXcpXHJcbiAgICAgICAgLnN0YXJ0KCk7XHJcblxyXG4gICAgdmFyIHdvcmRjbG91ZCA9IHN2Zy5hcHBlbmQoXCJnXCIpXHJcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3dvcmRjbG91ZCcpXHJcbiAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCB3aWR0aCArIG1hcmdpbi5sZWZ0ICsgbWFyZ2luLnJpZ2h0KVxyXG4gICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGhlaWdodCArIG1hcmdpbi50b3AgKyBtYXJnaW4uYm90dG9tKVxyXG4gICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgd2lkdGggLyAyICsgXCIsXCIgKyBoZWlnaHQgLyAyICsgXCIpXCIpO1xyXG5cclxuICAgIGZ1bmN0aW9uIGRyYXcod29yZHMpIHtcclxuICAgICAgICBpZiAoY2hhcnQuc21hbGxlckZvbnRSZXBhaW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgd29yZGNsb3VkLnNlbGVjdEFsbChcInRleHRcIilcclxuICAgICAgICAgICAgLmRhdGEoY2xvdWREYXRhLmNoYXJ0RGF0YSlcclxuICAgICAgICAgICAgLmVudGVyKCkuYXBwZW5kKFwidGV4dFwiKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnd29yZCcpXHJcbiAgICAgICAgICAgIC5zdHlsZShcImZvbnQtc2l6ZVwiLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGQuc2l6ZSArIFwicHhcIjtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLnN0eWxlKFwiZm9udC1mYW1pbHlcIiwgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkLmZvbnQ7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb2xvcihkW3JlbGF0aW9uTWFwLnZhbHVlXSk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5hdHRyKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIilcclxuICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQudGV4dDsgfSlcclxuICAgICAgICAgICAgLm9uKFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uIChkLCBpKSB7XHJcbiAgICAgICAgICAgICAgICAvL0dldCB0aXAgZGF0YVxyXG4gICAgICAgICAgICAgICAgdmFyIHRpcERhdGEgPSBjaGFydC5zZXRUaXBEYXRhKGQsIGkpO1xyXG4gICAgICAgICAgICAgICAgdGlwRGF0YS5jb2xvciA9IGNvbG9yKGRbcmVsYXRpb25NYXAudmFsdWVdKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL0RyYXcgdGlwXHJcbiAgICAgICAgICAgICAgICBjaGFydC50aXAuZ2VuZXJhdGVTaW1wbGVUaXAodGlwRGF0YSwgY2hhcnQuZGF0YS5kYXRhVGFibGUpO1xyXG4gICAgICAgICAgICAgICAgY2hhcnQudGlwLmQgPSBkO1xyXG4gICAgICAgICAgICAgICAgY2hhcnQudGlwLmkgPSBpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAub24oJ21vdXNlbW92ZScsIGZ1bmN0aW9uIChkLCBpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hhcnQuc2hvd1Rvb2xUaXApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhcnQudGlwLmQgPT09IGQgJiYgY2hhcnQudGlwLmkgPT09IGkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhcnQudGlwLnNob3dUaXAoZDMuZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vR2V0IHRpcCBkYXRhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aXBEYXRhID0gY2hhcnQuc2V0VGlwRGF0YShkLCBpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9EcmF3IHRpcCBsaW5lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJ0LnRpcC5nZW5lcmF0ZVNpbXBsZVRpcCh0aXBEYXRhLCBjaGFydC5kYXRhLmRhdGFUYWJsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAub24oXCJtb3VzZW91dFwiLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgY2hhcnQudGlwLmhpZGVUaXAoKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLnRyYW5zaXRpb24oKS5kdXJhdGlvbihcIjEwMDBcIilcclxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIFwidHJhbnNsYXRlKFwiICsgW2QueCwgZC55XSArIFwiKXJvdGF0ZShcIiArIGQucm90YXRlICsgXCIpXCI7IH0pO1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ganZDaGFydHM7XHJcbiJdfQ==
