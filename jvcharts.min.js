(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";

var html = "<!--Top title bar of edit popup-->\n<div class='title'>\n    <div class=\"jv-inline\">\n        <b>Edit Options<div id=\"edit-option-element\" class=\"jv-inline\" style=\"visibility: hidden;\"></div>:</b>\n    </div>\n\n    <div id='exitEditMode' class='jv-pull-right jv-pointer'>\n        <i class='fa fa-times'></i>\n    </div>\n</div>\n\n<!--Line dividing top bar with form options below-->\n<hr style='margin:3px 0 3px 0;'/>\n\n<!--Form Options-->\n<div id=\"form'+chart.config.name+'\">\n\n    <!--Number formatting options-->\n    <div class=\"jv-full-width editable-num-format\" style=\"display: none;\">\n        <div class=\"jv-edit-mode-input\">Number Format:\n            <select id=\"editable-num-format\">\n                <option value=\"\">--Select Option--</option>\n                <option value=\"currency\">Currency</option>\n                <option value=\"fixedCurrency\">Fixed Point Currency</option>\n                <option value=\"percent\">Percent</option>\n                <option value=\"millions\">Millions</option>\n                <option value=\"commas\">Commas</option>\n                <option value=\"none\">None</option>\n            </select>\n        </div>\n        <br/>\n    </div>\n\n    <!--Text formatting options-->\n    <div class=\"editable-text-size-buttons jv-center topBarOption increasefont jv-pointer\" style=\"display: none;\">\n        <button id='decreaseFontSize' title='Decrease the font size' class='topbar-button font jv-button jv-pointer'><i class='fa fa-font'></i><i class='fa fa-long-arrow-down'></i></button>\n        <button id='increaseFontSize' title='Increase the font size' class='topbar-button font jv-button jv-pointer'><i class='fa fa-font'></i><i class='fa fa-long-arrow-up'></i></button>\n    </div>\n\n\n    <div class=\"jv-full-width editable-text-color\" style=\"display: none;\">\n        <div class=\"jv-edit-mode-input\">Text Color:\n            <input type=\"color\" id=\"editable-text-color\" value=\"#000000\">\n        </div>\n        <br/>\n    </div>\n\n    <div class=\"jv-full-width editable-text-size\" style=\"display: none;\">\n        <div class=\"jv-edit-mode-input\">Text Size:\n            <input type=\"number\" id=\"editable-text-size\" min=\"0\" max=\"30\" value=\"12\" step=\"0.5\">\n        </div>\n        <br/>\n    </div>\n\n    <div class=\"jv-full-width editable-content\" style=\"display: none;\">\n        <div class=\"jv-edit-mode-input\">Text:\n            <input type=\"text\" id=\"editable-content\" placeholder=\"Enter text here\">\n        </div>\n        <br/>\n    </div>\n\n    <!--bar chart formatting-->\n    <div class=\"jv-full-width editable-bar\" style=\"display: none;\">\n        <div class=\"jv-edit-mode-input\">Bar Color:\n            <input type=\"color\" id=\"editable-bar\" value=\"#aaaaaa\">\n        </div>\n        <br/>\n    </div>\n\n    <!--pie chart formatting-->\n    <div class=\"jv-full-width editable-pie\" style=\"display: none;\">\n        <div class=\"jv-edit-mode-input\">Pie Slice Color:\n            <input type=\"color\" id=\"editable-pie\" value=\"#aaaaaa\">\n        </div>\n        <br/>\n    </div>\n\n    <!--scatter plot formatting-->\n    <div class=\"jv-full-width editable-scatter\" style=\"display: none;\">\n        <div class=\"jv-edit-mode-input\">Scatter Circle Color:\n            <input type=\"color\" id=\"editable-scatter\" value=\"#aaaaaa\">\n        </div>\n        <br/>\n    </div>\n\n    <!--bubble chart formatting-->\n    <div class=\"jv-full-width editable-bubble\" style=\"display: none;\">\n        <div class=\"jv-edit-mode-input\">Bubble Color:\n            <input type=\"color\" id=\"editable-bubble\" value=\"#aaaaaa\">\n        </div>\n        <br/>\n    </div>\n\n    <!--box and whisker plot formatting-->\n    <div class=\"jv-full-width editable-box\" style=\"display: none;\">\n        <div class=\"jv-edit-mode-input\">Box Color:\n            <input type=\"color\" id=\"editable-box\" value=\"#aaaaaa\">\n        </div>\n        <br/>\n    </div>\n\n    <!--Submit button-->\n    <div class=\"editable-default-and-apply\">\n        <button id=\"submitEditModeDefault\" class=\"jv-button jv-pull-left\">Default</button>\n        <button id=\"submitEditMode\" class=\"jv-button jv-button-green jv-pull-right\">Apply</button>\n    </div>\n</div>";

module.exports = html;

},{}],2:[function(require,module,exports){
'use strict';
//add all required files

require('./jvVars.js');
require('./jvEvents.js');
require('./jvTip.js');
require('./jvBrush.js');
require('./jvComment.js');
require('./jvEdit.js');
require('./visuals/jvBar.js');
require('./visuals/jvPie.js');
require('./visuals/jvLine.js');
require('./visuals/jvScatter.js');
require('./visuals/jvArea.js');
require('./visuals/jvGantt.js');
require('./visuals/jvHeatmap.js');
require('./visuals/jvPack.js');
require('./visuals/jvRadial.js');
require('./visuals/jvSankey.js');
require('./visuals/jvSingleAxis.js');
require('./visuals/jvSunburst.js');
require('./visuals/jvTreemap.js');
require('./visuals/jvWordCloud.js');
require('./visuals/jvBoxWhisker.js');
require('./visuals/jvBubble.js');
require('./visuals/jvClustergram.js');

//attach jv charts objects to the window
var jvCharts = require('./jvCharts.js');
var jvBrush = require('./jvBrush.js');
var jvComment = require('./jvComment.js');
var jvEdit = require('./jvEdit.js');
var jvSelect = require('./jvSelect');
// var jvDoodle = require('./jvDoodle.js');

//Comment out to remove from window object - if you are not using jvCharts as a minified file
window.jvCharts = jvCharts;
window.jvBrush = jvBrush;
window.jvComment = jvComment;
window.jvEdit = jvEdit;
window.jvSelect = jvSelect;

//add polyfill for Object.assign() if unsupported
if (typeof Object.assign !== 'function') {
    Object.assign = function (target) {
        //.length of function is 2
        'use strict';

        if (target == null) {
            //TypeError if undefined or null
            throw new TypeError('Cannot convert undefined or null to object');
        }
        var to = Object(target);
        for (var index = 1; index < arguments.length; index++) {
            var nextSource = arguments[index];

            if (nextSource != null) {
                //Skip over if undefined or null
                for (var nextKey in nextSource) {
                    //Avoid bugs when hasOwnProperty is shadowed
                    if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
                        to[nextKey] = nextSource[nextKey];
                    }
                }
            }
        }
        return to;
    };
}

},{"./jvBrush.js":3,"./jvCharts.js":4,"./jvComment.js":5,"./jvEdit.js":6,"./jvEvents.js":7,"./jvSelect":8,"./jvTip.js":9,"./jvVars.js":10,"./visuals/jvArea.js":11,"./visuals/jvBar.js":12,"./visuals/jvBoxWhisker.js":13,"./visuals/jvBubble.js":14,"./visuals/jvClustergram.js":15,"./visuals/jvGantt.js":16,"./visuals/jvHeatmap.js":17,"./visuals/jvLine.js":18,"./visuals/jvPack.js":19,"./visuals/jvPie.js":20,"./visuals/jvRadial.js":21,"./visuals/jvSankey.js":22,"./visuals/jvScatter.js":23,"./visuals/jvSingleAxis.js":24,"./visuals/jvSunburst.js":25,"./visuals/jvTreemap.js":26,"./visuals/jvWordCloud.js":27}],3:[function(require,module,exports){
'use strict';
/***  jvBrush ***/
'use-strict';

/**jv Brush Flow
*
*  1. create new jvBrush object with a config object containing the specific jvChart and an onBrushCallback
*  2. jvBrush exposes startBrush and removeBrush functions
*  3. if startBrush is called with a d3.event, brush will assume that a force click event should be fired at the location of the d3.event
*  4. if a d3.event is not given to startBrush(), a brush lisener will be added to the visual to listen for the user to brush
*  5. After the user finishs brushing an area of the chart, brushEnd() is calle.
*  6. brushEnd() will create a data object for the brushed area in the format:
*      {'label1': ['value1','value2']}
*      Example
*      {'Movie_Genre': ['Drama','Documentary','Action']}
*  7. brushEnd will then call the onBrushCallback function with the above data object
*  8. brushEnd will finally call the removeBrush() function
*/

/**
* @name jvBrush
* @desc Constructor for JV Brush - creates brush mode for a jv visualization and executes a callback for the visual to be filtered
* @param {object} configObj - constructor object containing the jvChart and other options
* @return {undefined} - no return
*/

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var jvBrush = function () {
    function jvBrush(configObj) {
        _classCallCheck(this, jvBrush);

        var brushObj = this;
        brushObj.chartDiv = configObj.jvChart.chartDiv;
        brushObj.jvChart = configObj.jvChart;
        brushObj.onBrushCallback = configObj.onBrushCallback;
    }

    /**
    * @name removeBrush
    * @desc removes the brush area from the visual
    * @return {undefined} - no return
    */


    _createClass(jvBrush, [{
        key: 'removeBrush',
        value: function removeBrush() {
            var brushObj = this;
            brushObj.jvChart.chartDiv.selectAll('.brusharea').remove();
        }

        /**
        * @name startBrush
        * @desc removes the brush area from the visual
        * @param {object} event - optional event to start brush immediately with a new mousedown
        * @return {undefined} - no return
        */

    }, {
        key: 'startBrush',
        value: function startBrush() {
            var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

            var brushObj = this,
                height = brushObj.jvChart.config.container.height,
                width = brushObj.jvChart.config.container.width,
                svg = brushObj.jvChart.svg;

            if (brushObj.jvChart.config.type === 'singleaxis') {
                brushObj.brushType = 'x';
                svg.append('g').attr('class', 'brusharea').style('height', height + 'px').style('width', width + 'px').call(d3.brushX().extent([[0, 0], [width, height]]).on('end', brushEnd.bind(brushObj)));
            } else if (brushObj.jvChart.config.type === 'clustergram') {
                brushObj.brushType = 'xy';
                svg.append('g').attr('class', 'brusharea').attr('transform', 'translate(' + brushObj.jvChart._vars.leftTreeWidth + ', ' + brushObj.jvChart._vars.topTreeHeight + ')').style('height', height + 'px').style('width', width + 'px').call(d3.brush().extent([[0, 0], [width, height]]).on('end', brushEnd.bind(brushObj)));
            } else {
                brushObj.brushType = 'xy';
                svg.append('g').attr('class', 'brusharea').style('height', height + 'px').style('width', width + 'px').call(d3.brush().extent([[0, 0], [width, height]]).on('end', brushEnd.bind(brushObj)));
            }

            if (event) {
                //dispatch mousedown to start a brush at the event coordinates
                var brushElement = svg.select('.brusharea').node(),
                    newEvent = new Event('mousedown');
                newEvent.pageX = event.pageX;
                newEvent.clientX = event.clientX;
                newEvent.pageY = event.pageY;
                newEvent.clientY = event.clientY;
                newEvent.view = event.view;
                brushElement.__data__ = { type: 'overlay' };
                brushElement.dispatchEvent(newEvent);
            }
        }
    }]);

    return jvBrush;
}();

/**
* @name brushEnd
* @desc called at the end of the user brushing which calls the onBrush callback
* @return {undefined} - no return
*/


function brushEnd() {
    var brushObj = this,
        xScale = brushObj.jvChart.currentData.xAxisScale,
        yScale = brushObj.jvChart.currentData.yAxisScale,
        filteredXAxisLabels = [],
        filteredYAxisLabels = [],
        shouldReset = false,
        e = d3.event.selection,
        returnObj,
        filteredLabels = [],
        filteredConcepts = {},
        index,
        filterCol,
        filteredLabelsX,
        filteredLabelsY,
        cleanDataFlag = true;

    if (e) {
        if (brushObj.brushType === 'xy') {
            if (xScale && typeof xScale.invert !== 'function') {
                //means that the scale is ordinal and not linear
                returnObj = calculateBrushAreaOrdinal(e[0][0], e[1][0], xScale);
                filteredXAxisLabels = returnObj.filteredAxisLabels;
                shouldReset = returnObj.shouldReset;
            } else if (xScale) {
                //calculate labels for linear scale
                returnObj = calculateBrushAreaLinear(e[0][0], e[1][0], xScale, brushObj.jvChart.currentData, brushObj.jvChart.config.type, 'x');
                filteredXAxisLabels = returnObj.filteredAxisLabels;
                shouldReset = returnObj.shouldReset;
            }

            if (yScale && typeof yScale.invert !== 'function') {
                //means that the scale is oridnal and not linear
                returnObj = calculateBrushAreaOrdinal(e[0][1], e[1][1], yScale);
                filteredYAxisLabels = returnObj.filteredAxisLabels;
                if (returnObj.shouldReset) {
                    shouldReset = true;
                }
            } else if (yScale) {
                //calculate labels for linear scale
                returnObj = calculateBrushAreaLinear(e[0][1], e[1][1], yScale, brushObj.jvChart.currentData, brushObj.jvChart.config.type, 'y');
                filteredYAxisLabels = returnObj.filteredAxisLabels;
                if (returnObj.shouldReset) {
                    shouldReset = true;
                }
            } else if (brushObj.jvChart.config.type === 'heatmap') {
                returnObj = calculateHeatmapBrush(e, brushObj.jvChart.currentData, brushObj.jvChart);
                filteredLabelsX = returnObj.filteredXAxisLabels;
                filteredLabelsY = returnObj.filteredYAxisLabels;
                if (returnObj.shouldReset) {
                    shouldReset = true;
                }
            } else if (brushObj.jvChart.config.type === 'clustergram') {
                returnObj = calculateClustergramBrush(e, brushObj.jvChart.currentData, brushObj.jvChart);
                filteredLabelsX = returnObj.filteredXAxisLabels;
                filteredLabelsY = returnObj.filteredYAxisLabels;
                if (returnObj.shouldReset) {
                    shouldReset = true;
                }
            }
        } else if (brushObj.brushType === 'x') {
            returnObj = calculateBrushAreaLinear(e[0], e[1], xScale, brushObj.jvChart.currentData, brushObj.jvChart.config.type, 'x');
            filteredXAxisLabels = returnObj.filteredAxisLabels;
            if (returnObj.shouldReset) {
                shouldReset = true;
            }
        }
    } else {
        shouldReset = true;
    }

    if (filteredXAxisLabels.length > 0 && filteredYAxisLabels.length > 0) {
        //merge axisLabels
        for (var j = 0; j < filteredXAxisLabels.length; j++) {
            index = filteredYAxisLabels.indexOf(filteredXAxisLabels[j]);
            if (index > -1) {
                filteredLabels.push(filteredXAxisLabels[j]);
            }
        }
    } else if (filteredXAxisLabels.length > 0) {
        filteredLabels = filteredXAxisLabels;
    } else if (filteredYAxisLabels.length > 0) {
        filteredLabels = filteredYAxisLabels;
    }

    if (shouldReset) {
        filteredLabels = [];
    }

    if (brushObj.jvChart.config.type === 'heatmap') {
        var filterColX = brushObj.jvChart.currentData.dataTable.x,
            filterColY = brushObj.jvChart.currentData.dataTable.y;
        if (!shouldReset) {
            if (filteredLabelsX.length > 0) {
                filteredConcepts[filterColX] = filteredLabelsX;
            }
            if (filteredLabelsY.length > 0) {
                filteredConcepts[filterColY] = filteredLabelsY;
            }
        } else {
            filteredConcepts[filterColX] = [];
            filteredConcepts[filterColY] = [];
        }
    } else if (brushObj.jvChart.config.type === 'clustergram') {
        if (!shouldReset) {
            var xLength = Object.keys(filteredLabelsX).length,
                yLength = Object.keys(filteredLabelsY).length;

            for (var i = 0; i < xLength; i++) {
                var _filterColX = brushObj.jvChart.currentData.dataTable['x_category ' + (xLength - i)];
                filteredConcepts[_filterColX] = filteredLabelsX[i];
            }
            for (var _i = 0; _i < yLength; _i++) {
                var _filterColY = brushObj.jvChart.currentData.dataTable['y_category ' + (yLength - _i)];
                filteredConcepts[_filterColY] = filteredLabelsY[_i];
            }
        }
        cleanDataFlag = false;
    } else {
        if (brushObj.jvChart.config.type === 'gantt') {
            filterCol = brushObj.jvChart.currentData.dataTable.group;
        } else {
            filterCol = brushObj.jvChart.currentData.dataTable.label;
        }
        filteredConcepts[filterCol] = filteredLabels;
    }

    //calls back to update data with brushed data
    brushObj.onBrushCallback({
        data: filteredConcepts,
        reset: shouldReset,
        clean: cleanDataFlag
    });
    brushObj.removeBrush();
}

/**
* @name calculateBrushAreaOrdinal
* @desc calculates the ordinal values that are in the brushed area
* @param {number} mousePosMin - lower bound mouse position
* @param {number} mousePosMax - upper bound mouse position
* @param {object} scale - d3 axis scale
* @return {Object} - object of filtered values
*/
function calculateBrushAreaOrdinal(mousePosMin, mousePosMax, scale) {
    var domain = scale.domain(),
        padding = scale.padding(),
        step = scale.step(),
        minIndex = void 0,
        maxIndex = void 0,
        paddingDistance = padding * step / 2,
        filteredAxisLabels = void 0;

    //determine min index
    if (mousePosMin % step > step - paddingDistance) {
        //don't include on min side
        minIndex = Math.floor(mousePosMin / step) + 1;
    } else {
        //include on min side
        minIndex = Math.floor(mousePosMin / step);
    }

    //determine max index
    if (mousePosMax % step < paddingDistance) {
        //don't include on max side
        maxIndex = Math.floor(mousePosMax / step) - 1;
    } else {
        //include on max side
        maxIndex = Math.floor(mousePosMax / step);
        if (maxIndex === domain.length) {
            maxIndex -= 1;
        }
    }
    filteredAxisLabels = domain.slice(minIndex, maxIndex + 1);
    return { filteredAxisLabels: filteredAxisLabels, shouldReset: filteredAxisLabels.length === 0 };
}

/**
* @name calculateBrushAreaLinear
* @desc calculates the linear values that are in the brushed area
* @param {number} mousePosMin - lower bound mouse position
* @param {number} mousePosMax - upper bound mouse position
* @param {object} scale - d3 axis scale
* @param {object} data - chartData
* @param {string} type - visual type
* @param {string} axis - x / y / z
* @return {Object} - object of filtered values
*/
function calculateBrushAreaLinear(mousePosMin, mousePosMax, scale, data, type, axis) {
    var filteredAxisLabels = [],
        min = void 0,
        max = void 0,
        axisLabel = void 0;

    //switch min and max if scale is y due to svg drawing (y axis increases up the screen while mousePos decreases)
    if (axis === 'y') {
        max = scale.invert(mousePosMin);
        min = scale.invert(mousePosMax);
    } else {
        min = scale.invert(mousePosMin);
        max = scale.invert(mousePosMax);
    }

    if (type === 'bar') {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = data.legendData[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                axisLabel = _step.value;
                var _iteratorNormalCompletion2 = true;
                var _didIteratorError2 = false;
                var _iteratorError2 = undefined;

                try {
                    for (var _iterator2 = data.chartData[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                        var dataElement = _step2.value;

                        if (dataElement[axisLabel] >= min) {
                            filteredAxisLabels.push(dataElement[data.dataTable.label]);
                        }
                    }
                } catch (err) {
                    _didIteratorError2 = true;
                    _iteratorError2 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion2 && _iterator2.return) {
                            _iterator2.return();
                        }
                    } finally {
                        if (_didIteratorError2) {
                            throw _iteratorError2;
                        }
                    }
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                    _iterator.return();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
    } else if (type === 'gantt') {
        max = new Date(max);
        min = new Date(min);
        for (var i = 0; i < data.legendData.length; i++) {
            var count = i + 1,
                startDate = void 0,
                endDate = void 0;
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
                for (var _iterator3 = data.chartData[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                    var _dataElement = _step3.value;

                    startDate = new Date(_dataElement[data.dataTable['start ' + count]]);
                    endDate = new Date(_dataElement[data.dataTable['end ' + count]]);
                    if (startDate <= max && startDate >= min || endDate <= max && endDate >= min || startDate <= min && endDate >= max) {
                        filteredAxisLabels.push(_dataElement[data.dataTable.group]);
                    }
                }
            } catch (err) {
                _didIteratorError3 = true;
                _iteratorError3 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion3 && _iterator3.return) {
                        _iterator3.return();
                    }
                } finally {
                    if (_didIteratorError3) {
                        throw _iteratorError3;
                    }
                }
            }
        }
    } else if (type === 'line' || type === 'area' || type === 'singleaxis') {
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
            for (var _iterator4 = data.legendData[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                axisLabel = _step4.value;
                var _iteratorNormalCompletion5 = true;
                var _didIteratorError5 = false;
                var _iteratorError5 = undefined;

                try {
                    for (var _iterator5 = data.chartData[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                        var _dataElement2 = _step5.value;

                        if (_dataElement2[axisLabel] <= max && _dataElement2[axisLabel] >= min) {
                            filteredAxisLabels.push(_dataElement2[data.dataTable.label]);
                        }
                    }
                } catch (err) {
                    _didIteratorError5 = true;
                    _iteratorError5 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion5 && _iterator5.return) {
                            _iterator5.return();
                        }
                    } finally {
                        if (_didIteratorError5) {
                            throw _iteratorError5;
                        }
                    }
                }
            }
        } catch (err) {
            _didIteratorError4 = true;
            _iteratorError4 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion4 && _iterator4.return) {
                    _iterator4.return();
                }
            } finally {
                if (_didIteratorError4) {
                    throw _iteratorError4;
                }
            }
        }
    } else if (type === 'scatterplot') {
        axisLabel = data.dataTable[axis];
        var _iteratorNormalCompletion6 = true;
        var _didIteratorError6 = false;
        var _iteratorError6 = undefined;

        try {
            for (var _iterator6 = data.chartData[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
                var _dataElement3 = _step6.value;

                if (_dataElement3[axisLabel] <= max && _dataElement3[axisLabel] >= min) {
                    filteredAxisLabels.push(_dataElement3[data.dataTable.label]);
                }
            }
        } catch (err) {
            _didIteratorError6 = true;
            _iteratorError6 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion6 && _iterator6.return) {
                    _iterator6.return();
                }
            } finally {
                if (_didIteratorError6) {
                    throw _iteratorError6;
                }
            }
        }
    } else if (type === 'boxwhisker') {
        axisLabel = data.dataTable.value;

        var _iteratorNormalCompletion7 = true;
        var _didIteratorError7 = false;
        var _iteratorError7 = undefined;

        try {
            for (var _iterator7 = data.chartData[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
                var _dataElement4 = _step7.value;

                if (_dataElement4[axisLabel] <= max && _dataElement4[axisLabel] >= min) {
                    filteredAxisLabels.push(_dataElement4[data.dataTable.label]);
                }
            }
        } catch (err) {
            _didIteratorError7 = true;
            _iteratorError7 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion7 && _iterator7.return) {
                    _iterator7.return();
                }
            } finally {
                if (_didIteratorError7) {
                    throw _iteratorError7;
                }
            }
        }
    } else if (type === 'heatmap') {
        axisLabel = data.dataTable[axis];
        var _iteratorNormalCompletion8 = true;
        var _didIteratorError8 = false;
        var _iteratorError8 = undefined;

        try {
            for (var _iterator8 = data.chartData[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
                var _dataElement5 = _step8.value;

                if (_dataElement5[axisLabel] <= max && _dataElement5[axisLabel] >= min) {
                    filteredAxisLabels.push(_dataElement5[data.dataTable.label]);
                }
            }
        } catch (err) {
            _didIteratorError8 = true;
            _iteratorError8 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion8 && _iterator8.return) {
                    _iterator8.return();
                }
            } finally {
                if (_didIteratorError8) {
                    throw _iteratorError8;
                }
            }
        }
    }
    return { filteredAxisLabels: filteredAxisLabels, shouldReset: filteredAxisLabels.length === 0 };
}

/**
* @name calculateHeatmapBrush
* @desc calculates values inside of brushed area of a heatmap
* @param {array} e - mouse extent for location of brushed area
* @param {array} data - chart data
* @param {array} chart - jvChart
* @return {object} - filtered data
*/
function calculateHeatmapBrush(e, data, chart) {
    var mouseXmin = e[0][0],
        mouseYmin = e[0][1],
        mouseXmax = e[1][0],
        mouseYmax = e[1][1],
        filteredXAxisLabels = [],
        filteredYAxisLabels = [],
        reset = true,
        xBucketMax = Math.floor(mouseXmax / chart._vars.heatGridSize) + 1,
        yBucketMax = Math.floor(mouseYmax / chart._vars.heatGridSize) + 1,
        xBucketMin = Math.floor(mouseXmin / chart._vars.heatGridSize),
        yBucketMin = Math.floor(mouseYmin / chart._vars.heatGridSize);

    for (var i = 0; i < xBucketMax; i++) {
        if (i >= xBucketMin) {
            filteredXAxisLabels.push(data.xAxisData.values[i]);
            reset = false;
        }
    }
    for (var _i2 = 0; _i2 < yBucketMax; _i2++) {
        if (_i2 >= yBucketMin) {
            filteredYAxisLabels.push(data.yAxisData.values[_i2]);
            reset = false;
        }
    }

    return { filteredXAxisLabels: filteredXAxisLabels, filteredYAxisLabels: filteredYAxisLabels, shouldReset: reset };
}

/**
* @name calculateClustergramBrush
* @desc calculates values inside of brushed area of a clustergram
* @param {array} e - mouse extent for location of brushed area
* @param {array} data - chart data
* @param {array} chart - jvChart
* @return {object} - filtered data
*/
function calculateClustergramBrush(e, data, chart) {
    var mouseXmin = e[0][0],
        mouseYmin = e[0][1],
        mouseXmax = e[1][0],
        mouseYmax = e[1][1],
        filteredXAxisLabels = [],
        filteredYAxisLabels = [],
        reset = true,
        xBucketMax = Math.floor(mouseXmax / chart._vars.clustergramGridWidth) + 1,
        yBucketMax = Math.floor(mouseYmax / chart._vars.clustergramGridHeight) + 1,
        xBucketMin = Math.floor(mouseXmin / chart._vars.clustergramGridWidth),
        yBucketMin = Math.floor(mouseYmin / chart._vars.clustergramGridHeight),
        xLevels = {},
        yLevels = {};

    for (var i = 0; i < xBucketMax; i++) {
        if (i >= xBucketMin) {
            filteredXAxisLabels.push(data.xAxisData[i]);
            reset = false;
        }
    }
    for (var _i3 = 0; _i3 < yBucketMax; _i3++) {
        if (_i3 >= yBucketMin) {
            filteredYAxisLabels.push(data.yAxisData[_i3]);
            reset = false;
        }
    }

    //X Axis
    //Dynamically create arrays for each level of the hierarchy
    if (filteredXAxisLabels[0]) {
        var parentCountX = (filteredXAxisLabels[0].match(/\./g) || []).length;
        for (var _i4 = 0; _i4 < parentCountX + 1; _i4++) {
            xLevels[_i4] = [];
        }

        //Populate the hierarchy arrays with the labels of that respective hierarchy
        for (var _i5 = 0; _i5 < filteredXAxisLabels.length; _i5++) {
            if (filteredXAxisLabels[_i5]) {
                var xFields = filteredXAxisLabels[_i5].split('.');
                for (var k = 0; k < xFields.length; k++) {
                    if (xLevels[k].indexOf(xFields[k]) === -1) {
                        xLevels[k].push(xFields[k]);
                    }
                }
            }
        }
    }

    //Y Axis
    //Dynamically create arrays for each level of the hierarchy
    if (filteredYAxisLabels[0]) {
        var parentCountY = (filteredYAxisLabels[0].match(/\./g) || []).length;
        for (var _i6 = 0; _i6 < parentCountY + 1; _i6++) {
            yLevels[_i6] = [];
        }

        //Populate the hierarchy arrays with the labels of that respective hierarchy
        for (var _i7 = 0; _i7 < filteredYAxisLabels.length; _i7++) {
            if (filteredYAxisLabels[_i7]) {
                var yFields = filteredYAxisLabels[_i7].split('.');
                for (var _k = 0; _k < yFields.length; _k++) {
                    if (yLevels[_k].indexOf(yFields[_k]) === -1) {
                        yLevels[_k].push(yFields[_k]);
                    }
                }
            }
        }
    }

    return { filteredXAxisLabels: xLevels, filteredYAxisLabels: yLevels, shouldReset: reset };
}

module.exports = jvBrush;

},{}],4:[function(require,module,exports){
'use strict';
/***  jvCharts ***/

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var jvTip = require('./jvTip.js');

/**Create a jvCharts object
 * @constructor
 * @param {Object} configObj - Configuration object passed into jvCharts constructor
 * @param {string} configObj.type - The type of chart
 * @param {string} configObj.name - The name of the chart
 * @param {Object} configObj.container - The container of the chart
 * @param {Object} configObj.userOptions - UI options for the chart
 * @param {Object} configObj.tipConfig - Configuration object for jvTooltip
 * @param {Object} configObj.chartDiv - A div wrapper for the chart and other jv features
 */

var jvCharts = function () {
    function jvCharts(configObj) {
        _classCallCheck(this, jvCharts);

        var chart = this;
        configObj.type = configObj.type.toLowerCase();
        chart.chartDiv = configObj.chartDiv;
        configObj.options = jvCharts.cleanToolData(configObj.options, configObj.editOptions);
        chart._vars = chart.getDefaultOptions(configObj.options);
        chart.mode = configObj.mode || 'default-mode';

        //remove pieces from config that have been copied somewhere else
        delete configObj.chartDiv;
        delete configObj.options;
        delete configObj.mode;

        chart.config = configObj;

        //Start painting the jv Chart
        chart.createTooltip();
        chart.setData();
        chart.paint(chart._vars.transitionTime);
    }

    _createClass(jvCharts, [{
        key: 'createTooltip',
        value: function createTooltip() {
            var chart = this;
            chart.tip = new jvTip({
                config: chart.config.tipConfig,
                chartDiv: chart.chartDiv
            });
        }
    }, {
        key: 'setData',
        value: function setData() {
            var chart = this;
            if (chart.config.setData) {
                chart.data = chart.config.setData;
                //refer to main data as chartData to keep naming separate and understandable
                chart.data.chartData = chart.config.setData.data;
                delete chart.data.data;
                if (chart.data.dataTableKeys) {
                    chart.cleanDataTableKeys();
                }

                if (chart.data.headers) {
                    chart.setAlignAndKeys();
                }

                chart.colors = chart.config.setData.colors;
                chart[chart.config.type].setData.call(chart);
            }
        }

        /**
        * @name updateDataTableAlign
        * @param {array} currentKeys - array of objects to describe how to build the visual
        * @return {object} dataTableAlign - key:value mapping of current alignment
        */

    }, {
        key: 'setAlignAndKeys',
        value: function setAlignAndKeys() {
            var chart = this,
                dataTableAlign = {},
                i,
                len,
                keyMapping = {},
                keys = chart.data.headers;

            //iterate over current keys to create new object with key:value mapping instead of key:array mapping
            for (i = 0, len = keys.length; i < len; i++) {
                if (!keyMapping.hasOwnProperty(keys[i].model)) {
                    keyMapping[keys[i].model] = 0;
                    dataTableAlign[keys[i].model] = keys[i].name;
                } else {
                    dataTableAlign[keys[i].model + ' ' + i] = keys[i].name;
                }
            }
            chart.data.dataTableKeys = chart.data.headers;
            chart.data.dataTable = dataTableAlign;
        }
    }, {
        key: 'cleanDataTableKeys',
        value: function cleanDataTableKeys() {
            var chart = this,
                newKeys = [];
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = chart.data.dataTableKeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var key = _step.value;

                    newKeys.push({
                        name: key.varKey || key.alias || key.name,
                        model: key.vizType || key.model,
                        type: key.type
                    });
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }

            chart.data.dataTableKeys = newKeys;
        }
    }, {
        key: 'checkDimensions',
        value: function checkDimensions() {
            var chart = this,
                dimensions = chart.chartDiv.node().getBoundingClientRect();
            if (dimensions.height > 50 && dimensions.width > 120) {
                return true;
            }
            console.log('Chart container is too small to paint');
            return false;
        }
    }, {
        key: 'paint',
        value: function paint(annimation) {
            var chart = this;
            if (chart.checkDimensions()) {
                if (chart.data && _typeof(chart[chart.config.type]) === 'object' && typeof chart[chart.config.type].paint === 'function') {
                    chart[chart.config.type].paint.call(chart, annimation);
                    chart.initializeModes();

                    if (chart._vars.highlight) {
                        /*******************************/
                        //TODO fix this when Jon is back
                        var tempHighlight = {},
                            convertedData = [];
                        for (var col in chart._vars.highlight.data) {
                            for (var i = 0; i < chart._vars.highlight.data[col].length; i++) {
                                convertedData.push(chart._vars.highlight.data[col][i].replace(/_/g, ' '));
                            }
                            tempHighlight[col.replace(/_/g, ' ')] = convertedData;
                        }

                        chart._vars.highlight.data = tempHighlight;
                        /*******************************/

                        chart[chart.config.type].highlightFromEventData.call(chart, chart._vars.highlight);
                    }
                } else {
                    console.log('no paint function for: ' + chart.config.type);
                }
            }
        }
    }, {
        key: 'setAxisData',
        value: function setAxisData(axis, data, keys) {
            var chart = this,
                axisData = [],
                chartData = data.chartData,
                label = '',
                maxStack = 0,
                dataTableKeys = data.dataTableKeys,
                dataType = void 0;

            if (!dataTableKeys) {
                dataTableKeys = keys;
            }

            //Step 1: find out what the label is for the axis
            if (axis === 'x') {
                if (data.dataTable) {
                    if (data.dataTable.hasOwnProperty('label')) {
                        label = data.dataTable.label;
                    } else {
                        console.error("Label doesn't exist in dataTable");
                    }
                } else {
                    console.log('DataTable does not exist');
                }

                dataType = 'STRING';

                //Replace underscores with spaces
                label = label.replace(/_/g, ' ');

                //loop through data to populate axisData
                var _iteratorNormalCompletion2 = true;
                var _didIteratorError2 = false;
                var _iteratorError2 = undefined;

                try {
                    for (var _iterator2 = chartData[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                        var chartEle = _step2.value;

                        if (chartEle[label] === null) {
                            axisData.push('NULL_VALUE');
                        } else if (chartEle[label] === '') {
                            axisData.push('EMPTY_STRING');
                        } else if (chartEle[label] || chartEle[label] === 0) {
                            axisData.push(chartEle[label]);
                        }
                    }
                } catch (err) {
                    _didIteratorError2 = true;
                    _iteratorError2 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion2 && _iterator2.return) {
                            _iterator2.return();
                        }
                    } finally {
                        if (_didIteratorError2) {
                            throw _iteratorError2;
                        }
                    }
                }
            } else {
                if (dataTableKeys === undefined) {
                    console.error('dataTableKeys do not exist');
                }
                //Find the max value for Y Data
                var count = 0;

                var _iteratorNormalCompletion3 = true;
                var _didIteratorError3 = false;
                var _iteratorError3 = undefined;

                try {
                    for (var _iterator3 = dataTableKeys[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                        var key = _step3.value;

                        if (key.model !== 'label' && key.model !== 'tooltip' && key.model !== 'series') {
                            label = key.name;
                            count++;
                        }
                    }
                } catch (err) {
                    _didIteratorError3 = true;
                    _iteratorError3 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion3 && _iterator3.return) {
                            _iterator3.return();
                        }
                    } finally {
                        if (_didIteratorError3) {
                            throw _iteratorError3;
                        }
                    }
                }

                dataType = jvCharts.getDataTypeFromKeys(label, dataTableKeys, 'NUMBER');

                //Add all values that are on yaxis to axis data
                var _iteratorNormalCompletion4 = true;
                var _didIteratorError4 = false;
                var _iteratorError4 = undefined;

                try {
                    for (var _iterator4 = chartData[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                        var _chartEle = _step4.value;

                        var stack = 0; //Keeps track of the maximum size of stacked data so that axis can be scaled to fit max size
                        for (var k in data.dataTable) {
                            if (_chartEle.hasOwnProperty(data.dataTable[k]) && k !== 'label' && k.indexOf('tooltip') === -1 && k !== 'series') {
                                stack += _chartEle[data.dataTable[k]];
                                axisData.push(_chartEle[data.dataTable[k]]);
                            }
                        }
                        if (stack > maxStack) {
                            maxStack = stack;
                        }
                    }

                    //If there are multiple values on the yAxis, don't specify a label
                } catch (err) {
                    _didIteratorError4 = true;
                    _iteratorError4 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion4 && _iterator4.return) {
                            _iterator4.return();
                        }
                    } finally {
                        if (_didIteratorError4) {
                            throw _iteratorError4;
                        }
                    }
                }

                if (count > 1) {
                    label = '';
                }
                label = label.replace(/_/g, ' ');
            }

            //Find the min and max of numeric data for building axes and add it to the returned object
            if (dataType === 'NUMBER') {
                var max = void 0,
                    min = void 0,
                    temp = void 0,
                    tempMin = void 0,
                    tempMax = void 0;
                if (chart._vars.stackToggle) {
                    max = maxStack;
                } else {
                    max = Math.max.apply(null, axisData);
                }

                min = Math.min.apply(null, axisData);
                min = Math.min(0, min);

                //Check if there's an axis min/max set
                if (axis === 'x') {
                    if (chart._vars.xMin != null && chart._vars.xMin !== 'none') {
                        min = chart._vars.xMin;
                    }
                    if (chart._vars.xMax != null && chart._vars.xMax !== 'none') {
                        max = chart._vars.xMax;
                    }
                } else if (axis === 'y') {
                    if (chart._vars.yMin != null && chart._vars.yMin !== 'none') {
                        min = chart._vars.yMin;
                    }
                    if (chart._vars.yMax != null && chart._vars.yMax !== 'none') {
                        max = chart._vars.yMax;
                    }
                }

                if (dataType === 'NUMBER' && axisData.length === 1) {
                    if (axisData[0] >= 0) {
                        axisData.unshift(0);
                    } else {
                        axisData.push(0);
                    }
                }

                tempMin = parseInt(min, 10);
                tempMax = parseInt(max, 10);
                //Make sure that axis min and max don't get flipped
                if (tempMin > tempMax) {
                    temp = min;
                    min = max;
                    max = temp;
                }

                return {
                    'label': label,
                    'values': axisData,
                    'dataType': dataType,
                    'min': min,
                    'max': max
                };
            }

            return {
                'label': label,
                'values': axisData,
                'dataType': dataType
            };
        }

        /**setFlippedSeries
         *  flips series and returns flipped data
         *
         * @params chartData, dataTable, dataLabel
         * @returns Object of data and table for flipped series
         */

    }, {
        key: 'setFlippedSeries',
        value: function setFlippedSeries(dataTableKeys) {
            var chart = this,
                chartData = chart.data.chartData,
                dataTable = chart.data.dataTable,
                dataLabel = chart.data.xAxisData.label,
                flippedData = [],
                flippedDataTable = {},
                valueCount = 1,
                filteredDataTableArray = [];

            for (var k in dataTable) {
                if (dataTable.hasOwnProperty(k)) {
                    var flippedObject = {};
                    if (dataTable[k] !== dataLabel) {
                        flippedObject[dataLabel] = dataTable[k];
                        var _iteratorNormalCompletion5 = true;
                        var _didIteratorError5 = false;
                        var _iteratorError5 = undefined;

                        try {
                            for (var _iterator5 = chartData[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                                var chartEle = _step5.value;

                                flippedObject[chartEle[dataLabel]] = chartEle[dataTable[k]];
                                if (filteredDataTableArray.indexOf(chartEle[dataLabel]) === -1) {
                                    flippedDataTable['value ' + valueCount] = chartEle[dataLabel];
                                    valueCount++;
                                    filteredDataTableArray.push(chartEle[dataLabel]);
                                }
                            }
                        } catch (err) {
                            _didIteratorError5 = true;
                            _iteratorError5 = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion5 && _iterator5.return) {
                                    _iterator5.return();
                                }
                            } finally {
                                if (_didIteratorError5) {
                                    throw _iteratorError5;
                                }
                            }
                        }

                        flippedData.push(flippedObject);
                    }
                }
            }
            flippedDataTable.label = dataLabel;
            chart.flippedData = { chartData: flippedData, dataTable: flippedDataTable };

            if (chart.config.type === 'bar' || chart.config.type === 'line' || chart.config.type === 'area') {
                chart.flippedData.xAxisData = chart.setAxisData('x', chart.flippedData, dataTableKeys);
                chart.flippedData.yAxisData = chart.setAxisData('y', chart.flippedData, dataTableKeys);
                chart.flippedData.legendData = jvCharts.setBarLineLegendData(chart.flippedData);
            } else {
                console.log('Add additional chart type to set flipped series');
            }
        }

        /**organizeChartData
         *  reorders all data based on the sortLabel and sortType
         *  -Only for chartData, does not work with flipped data
         *
         * @params sortLabel , sortType
         * @returns [] sorted data
         */

    }, {
        key: 'organizeChartData',
        value: function organizeChartData(sortParam, sortType) {
            var chart = this,
                organizedData = void 0,
                dataType = void 0,
                dataTableKeys = chart.data.dataTableKeys,
                sortLabel = sortParam;

            //If sortLabel doesn't exist, sort on the x axis label by default
            if (sortLabel === 'none') {
                var _iteratorNormalCompletion6 = true;
                var _didIteratorError6 = false;
                var _iteratorError6 = undefined;

                try {
                    for (var _iterator6 = dataTableKeys[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
                        var key = _step6.value;

                        if (key.model === 'label') {
                            sortLabel = key.name;
                            break;
                        }
                    }
                } catch (err) {
                    _didIteratorError6 = true;
                    _iteratorError6 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion6 && _iterator6.return) {
                            _iterator6.return();
                        }
                    } finally {
                        if (_didIteratorError6) {
                            throw _iteratorError6;
                        }
                    }
                }
            }

            //Remove underscores from sortLabel
            if (sortLabel) {
                sortLabel = sortLabel.replace(/_/g, ' ');
            }

            if (!chart.data.chartData[0][sortLabel]) {
                //Check if the sort label is a calculatedBy field
                var isValidSortLabel = false;
                var _iteratorNormalCompletion7 = true;
                var _didIteratorError7 = false;
                var _iteratorError7 = undefined;

                try {
                    for (var _iterator7 = dataTableKeys[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
                        var _key = _step7.value;

                        if (_key.operation.hasOwnProperty('calculatedBy') && _key.operation.calculatedBy[0] === sortLabel) {
                            sortLabel = _key.name.replace(/_/g, ' ');
                            isValidSortLabel = true;
                            break;
                        }
                    }
                    //If it's not a valid sort label, return and don't sort the data
                } catch (err) {
                    _didIteratorError7 = true;
                    _iteratorError7 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion7 && _iterator7.return) {
                            _iterator7.return();
                        }
                    } finally {
                        if (_didIteratorError7) {
                            throw _iteratorError7;
                        }
                    }
                }

                if (!isValidSortLabel) {
                    console.error('Not a valid sort');
                    //throw new Error('Not a valid sort');
                }
            }

            //Check the data type to determine which logic to flow through
            var _iteratorNormalCompletion8 = true;
            var _didIteratorError8 = false;
            var _iteratorError8 = undefined;

            try {
                for (var _iterator8 = dataTableKeys[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
                    var _key2 = _step8.value;

                    //Loop through dataTableKeys to find sortLabel
                    if (_key2.name.replace(/_/g, ' ') === sortLabel) {
                        dataType = _key2.type;
                        break;
                    }
                }

                //Date sorting
            } catch (err) {
                _didIteratorError8 = true;
                _iteratorError8 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion8 && _iterator8.return) {
                        _iterator8.return();
                    }
                } finally {
                    if (_didIteratorError8) {
                        throw _iteratorError8;
                    }
                }
            }

            if (dataType != null && dataType === 'DATE') {
                organizedData = chart.data.chartData.sort(function (a, b) {
                    return new Date(a[sortLabel]) - new Date(b[sortLabel]);
                });
            } else if (dataType != null && dataType === 'NUMBER') {
                organizedData = chart.data.chartData.sort(function (a, b) {
                    if (!isNaN(a[sortLabel]) && !isNaN(b[sortLabel])) {
                        return a[sortLabel] - b[sortLabel];
                    }
                });
            } else {
                organizedData = chart.data.chartData.sort(function (a, b) {
                    if (!isNaN(a[sortLabel]) && !isNaN(b[sortLabel])) {
                        if (parseFloat(a[sortLabel]) < parseFloat(b[sortLabel])) {
                            //sort string ascending
                            return -1;
                        }
                        if (parseFloat(a[sortLabel]) > parseFloat(b[sortLabel])) {
                            return 1;
                        }
                        return 0;
                    }
                    if (a[sortLabel].toLowerCase() < b[sortLabel].toLowerCase()) {
                        //sort string ascending
                        return -1;
                    }
                    if (a[sortLabel].toLowerCase() > b[sortLabel].toLowerCase()) {
                        return 1;
                    }
                    return 0;
                });
            }

            switch (sortType) {
                case 'sortAscending':
                case 'ascending':
                    chart.data.chartData = organizedData;
                    break;
                case 'sortDescending':
                case 'descending':
                    chart.data.chartData = organizedData.reverse();
                    break;
                default:
                    chart.data.chartData = organizedData;
            }
        }

        /**setTipData
         *
         * creates data object to display in tooltip
         * @params
         * @returns {{}}
         */

    }, {
        key: 'setTipData',
        value: function setTipData(d, i) {
            var chart = this,
                data = chart.currentData.chartData,

            //Get Color from chartData and add to object
            color = chart._vars.color,
                title = d[chart.data.dataTable.label],
                dataTable = {};

            if (chart.config.type === 'treemap') {
                for (var item in d) {
                    if (item !== chart.data.dataTable.label && item !== 'Parent') {
                        dataTable[item] = d[item];
                    }
                }
            } else if (chart.config.type === 'bar' || chart.config.type === 'line' || chart.config.type === 'area') {
                title = data[i][chart.data.dataTable.label];
                for (var _item in data[i]) {
                    if (_item !== chart.data.dataTable.label) {
                        dataTable[_item] = data[i][_item];
                    } else {
                        continue;
                    }
                }
            } else if (chart.config.type === 'gantt') {
                //Calculate length of dates
                for (var _item2 in data[i]) {
                    if (data[i].hasOwnProperty(_item2) && _item2 !== chart.data.dataTable.group) {
                        dataTable[_item2] = data[i][_item2];
                    }
                }

                var start = void 0,
                    end = void 0,
                    difference = void 0,

                //Calculting duration of date ranges to add to tooltip
                numPairs = Math.floor(Object.keys(chart.data.dataTable).length / 2);

                for (var j = 1; j <= numPairs; j++) {
                    start = new Date(data[i][chart.data.dataTable['start ' + j]]);
                    end = new Date(data[i][chart.data.dataTable['end ' + j]]);
                    difference = end.getTime() - start.getTime();
                    dataTable['Duration ' + j] = Math.ceil(difference / (1000 * 60 * 60 * 24)) + ' days';
                }

                title = data[i][chart.data.dataTable.group];
            } else if (chart.config.type === 'pie' || chart.config.type === 'radial') {
                title = d.label;
                for (var _item3 in d) {
                    if (_item3 !== 'label') {
                        dataTable[_item3] = d[_item3];
                    } else {
                        continue;
                    }
                }
                delete dataTable.outerRadius;
            } else if (chart.config.type === 'circlepack' || chart.config.type === 'sunburst') {
                title = d.data.name;
                dataTable[chart.data.dataTable.value] = d.value;
            } else if (chart.config.type === 'cloud') {
                title = d[chart.data.dataTable.label];
                dataTable[chart.data.dataTable.value] = d[chart.data.dataTable.value];
                if (typeof d[chart.data.dataTable['tooltip 1']] !== 'undefined') {
                    dataTable[chart.data.dataTable['tooltip 1']] = d[chart.data.dataTable['tooltip 1']];
                }
            } else if (chart.config.type === 'heatmap') {
                title = d.yAxisName + ' to ' + d.xAxisName;
                if (d.hasOwnProperty('value')) {
                    dataTable.value = d.value;
                }
                for (var tooltip in d) {
                    if (tooltip.indexOf('tooltip') > -1) {
                        dataTable[chart.data.dataTable[tooltip]] = d[tooltip];
                    }
                }
            } else if (chart.config.type === 'clustergram') {
                //title = d.y_path.replace(/\./g, '→') + '</br>' + d.x_path.replace(/\./g, '→');
                //Build strings for tooltip
                var yTemp = d.y_path.split('.'),
                    yTempString = '',
                    xTemp = d.x_path.split('.'),
                    xTempString = '';

                for (var k = 0; k < yTemp.length; k++) {
                    if (chart.data.dataTable['y_category ' + (k + 1)]) {
                        yTempString += yTemp[k] += ' (' + chart.data.dataTable['y_category ' + (k + 1)] + ')';
                    } else {
                        yTempString += yTemp[k] += ' (' + chart.data.dataTable.y_category + ')';
                    }

                    if (k !== yTemp.length - 1) {
                        yTempString += ' → ';
                    }
                }
                for (var _k = 0; _k < xTemp.length; _k++) {
                    if (chart.data.dataTable['x_category ' + (_k + 1)]) {
                        xTempString += xTemp[_k] += ' (' + chart.data.dataTable['x_category ' + (_k + 1)] + ')';
                    } else {
                        xTempString += xTemp[_k] += ' (' + chart.data.dataTable.x_category + ')';
                    }

                    if (_k !== xTemp.length - 1) {
                        xTempString += ' → ';
                    }
                }

                title = 'Y > ' + yTempString + '<br>' + 'X > ' + xTempString;
                if (d.hasOwnProperty('value')) {
                    dataTable.value = d.value;
                }
                for (var _tooltip in d) {
                    if (_tooltip.indexOf('tooltip') > -1) {
                        dataTable[chart.data.dataTable[_tooltip]] = d[_tooltip];
                    }
                }
            } else if (chart.config.type === 'sankey') {
                title = d.source.name.slice(0, -2) + ' to ' + d.target.name.slice(0, -2);

                if (d.hasOwnProperty('value')) {
                    dataTable.value = d.value;
                }
            } else if (chart.config.type === 'singleaxis') {
                title = d.data[chart.data.dataTable.label];

                for (var _item4 in chart.data.dataTable) {
                    if (_item4 !== 'label') {
                        dataTable[chart.data.dataTable[_item4]] = d.data[chart.data.dataTable[_item4]];
                    }
                }
            } else {
                for (var _item5 in d) {
                    if (_item5 !== chart.data.dataTable.label) {
                        dataTable[_item5] = d[_item5];
                    } else {
                        continue;
                    }
                }
            }

            return { 'data': d, 'tipData': dataTable, 'index': i, 'title': title, 'color': color, 'viz': chart.config.type };
        }

        /************************************************ Draw functions ******************************************************/

        /**generateSVG
         *creates an SVG element on the panel
         *
         * @params container, margin, name
         *
         */

    }, {
        key: 'generateSVG',
        value: function generateSVG(legendData, customMarginParam, customSizeParam) {
            var chart = this,
                margin = {},
                container = {},
                dimensions = chart.chartDiv.node().getBoundingClientRect(),
                customMargins = customMarginParam,
                customSize = customSizeParam,
                textWidth = void 0;

            if (chart._vars.customMargins) {
                customMargins = chart._vars.customMargins;
            }

            //set margins
            if (!customMargins) {
                //declare margins if they arent passed in
                margin = {
                    top: 55,
                    right: 50,
                    left: 100,
                    bottom: 70
                };
                if (legendData != null) {
                    if (legendData.length <= 3) {
                        margin.bottom = 70;
                    } else if (legendData.length <= 6) {
                        margin.bottom = 85;
                    } else {
                        margin.bottom = 130;
                    }
                }
            } else {
                margin = customMargins;
            }

            //reduce margins if legend is toggled off
            //TODO make this better
            if (chart._vars.toggleLegend === false) {
                if (chart.config.type === 'pie' || chart.config.type === 'radial' || chart.config.type === 'circlepack' || chart.config.type === 'heatmap') {
                    margin.left = 40;
                } else if (chart.config.type === 'treemap' || chart.config.type === 'bar' || chart.config.type === 'gantt' || chart.config.type === 'scatter' || chart.config.type === 'line') {
                    margin.bottom = 40;
                }
            }

            if (chart.config.type === 'clustergram') {
                textWidth = jvCharts.getMaxWidthForAxisData('y', chart.leftLabels, chart._vars, dimensions, margin, chart.chartDiv, chart.config.type);
                margin.left = Math.ceil(textWidth);
                if (margin.left < 30) {
                    margin.left = 30;
                }

                textWidth = jvCharts.getMaxWidthForAxisData('y', chart.rightLabels, chart._vars, dimensions, margin, chart.chartDiv, chart.config.type);
                margin.top = Math.ceil(textWidth);
                if (margin.top < 30) {
                    margin.top = 30;
                }
            }

            //set yAxis margins
            if (chart.currentData && chart.currentData.yAxisData) {
                textWidth = jvCharts.getMaxWidthForAxisData('y', chart.currentData.yAxisData, chart._vars, dimensions, margin, chart.chartDiv, chart.config.type);
                if (textWidth > 100 && chart.config.type === 'heatmap') {
                    textWidth = 100;
                }
                chart._vars.heatmapYmargin = textWidth;
                margin.left = Math.ceil(textWidth) + 30;
            }

            //set xAxis top margins
            if (chart.config.type === 'heatmap' && chart.currentData && chart.currentData.xAxisData) {
                textWidth = jvCharts.getMaxWidthForAxisData('x', chart.currentData.xAxisData, chart._vars, dimensions, margin, chart.chartDiv, chart.config.type);
                //subtract space for tilt
                textWidth = Math.ceil(textWidth);
                if (textWidth > 100) {
                    textWidth = 100;
                }
                //specific to heatmap
                //if (chart.config.type === 'heatmap') {
                if (textWidth > 100) {
                    textWidth = 100;
                } else if (textWidth < 80) {
                    textWidth = 80;
                }
                //}
                chart._vars.heatmapXmargin = textWidth;
                margin.top = textWidth;
                customSize = {};
                //set container
                customSize.width = chart.currentData.xAxisData.values.length * 20;
                customSize.height = chart.currentData.yAxisData.values.length * 20;

                if (chart._vars.toggleLegend) {
                    var dummyObj = {};
                    dummyObj.values = chart.data.heatData;
                    dummyObj.values.sort(function (a, b) {
                        return a - b;
                    });
                    dummyObj.label = '';
                    dummyObj.min = dummyObj.values[0];
                    dummyObj.max = dummyObj.values[dummyObj.values.length - 1];

                    textWidth = jvCharts.getMaxWidthForAxisData('y', dummyObj, chart._vars, dimensions, margin, chart.chartDiv, chart.config.type);
                    chart.config.heatWidth = Math.ceil(textWidth) + 30;
                    margin.left = margin.left + chart.config.heatWidth;
                }

                if (customSize.width + margin.left + margin.right < dimensions.width) {
                    margin.right = parseInt(dimensions.width, 10) - margin.left - customSize.width - 20;
                }
                if (customSize.height + margin.top + margin.bottom < dimensions.height) {
                    margin.bottom = parseInt(dimensions.height, 10) - margin.top - customSize.height - 10;
                }
                customSize.width += margin.right + margin.left;
                customSize.height += margin.top + margin.bottom;
            }

            //set container attributes
            //Set svg size based on calculation margins or custom size if specified
            if (customSize && customSize.hasOwnProperty('height')) {
                container.height = customSize.height - margin.top - margin.bottom;
            } else {
                container.height = parseInt(dimensions.height, 10) - margin.top - margin.bottom;
                if (container.height <= 50) {
                    margin.top = 10;
                    margin.bottom = 10;
                    container.height = parseInt(dimensions.height, 10) - margin.top - margin.bottom;
                    chart._vars.xLabelFontSize = 0;
                }
            }

            if (customSize && customSize.hasOwnProperty('width')) {
                container.width = customSize.width - margin.left - margin.right;
            } else {
                container.width = parseInt(dimensions.width, 10) - margin.left - margin.right;
            }

            //add margin and container to chart config object
            chart.config.margin = margin;
            chart.config.container = container;

            //remove old svg if it exists
            chart.svg = chart.chartDiv.select('svg').remove();

            //svg layer
            if (chart.config.type === 'heatmap' || chart.config.type === 'singleaxis') {
                chart.svg = chart.chartDiv.append('svg').attr('class', 'editable-svg').attr('width', container.width + margin.left + margin.right).attr('height', container.height + margin.top + margin.bottom).append('g').attr('class', 'container').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
            } else if (chart.config.type === 'clustergram') {
                var sizeWidth = chart.rightLeaves.length * 20;
                if (sizeWidth < container.width) {
                    sizeWidth = container.width;
                }

                var sizeHeight = chart.leftLeaves.length * 20;
                if (sizeHeight < container.height) {
                    sizeHeight = container.height;
                }

                chart.svg = chart.chartDiv.append('svg').attr('class', 'editable-svg').attr('width', sizeWidth + margin.left + margin.right).attr('height', sizeHeight + margin.top + margin.bottom).append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
            } else {
                chart.svg = chart.chartDiv.append('svg').attr('class', 'editable-svg').attr('width', container.width + margin.left + margin.right).attr('height', container.height + margin.top + margin.bottom).append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
            }

            //TODO move to edit mode
            if (chart._vars.backgroundColor !== 'none') {
                chart.colorBackground(chart._vars.backgroundColor);
            }
        }

        /**generateXAxis
         * creates x axis on the svg
         *
         * @params xAxisData
         */

    }, {
        key: 'generateXAxis',
        value: function generateXAxis(xAxisData, ticks) {
            //declare variables
            var chart = this,
                xAxis = void 0,

            //Need to getXAxisScale each time so that axis updates on resize
            xAxisScale = jvCharts.getAxisScale('x', xAxisData, chart.config.container, chart._vars),
                containerHeight = chart.config.container.height,
                containerWidth = chart.config.container.width,
                xAxisClass = 'xAxisLabels editable editable-xAxis editable-text',
                tickSize = 0,
                axisHeight = containerHeight,
                xContent = void 0,
                xAxisGroup = void 0,
                formatValueType = void 0;

            //assign css class for edit mode
            //if the axis is numbers add editable-num
            if (xAxisData.dataType === 'NUMBER') {
                xAxisClass += ' editable-num';
            }

            //remove previous xAxis container if its there
            chart.svg.selectAll('.xAxisContainer').remove();

            //Save the axis scale to chart object
            chart.currentData.xAxisScale = xAxisScale;

            if (chart.currentData.xAxisData.dataType === 'NUMBER') {
                tickSize = 5;
            }

            //create xAxis drawing function
            if (chart.config.type === 'singleaxis') {
                xAxis = d3.axisTop(xAxisScale).tickSize(tickSize);
            } else {
                xAxis = d3.axisBottom(xAxisScale).tickSize(tickSize);
            }

            if (ticks) {
                xAxis.ticks(ticks);
            }

            if (chart.config.type === 'singleaxis') {
                //For any axes that are on top of the data
                axisHeight = 0;
            }

            xContent = chart.svg.append('g').attr('class', 'xAxisContainer').attr('transform', 'translate(0,' + axisHeight + ')');

            xAxisGroup = xContent.append('g').attr('class', 'xAxis').call(xAxis);

            formatValueType = jvCharts.jvFormatValueType(xAxisData.values);

            //Styling the axis
            xAxisGroup.select('path').attr('stroke', chart._vars.axisColor).attr('stroke-width', chart._vars.strokeWidth);

            //Styling for ticks
            xAxisGroup.selectAll('line').attr('stroke', chart._vars.axisColor).attr('stroke-width', chart._vars.stroke);

            //Styling the labels for each piece of data
            xAxisGroup.selectAll('text').attr('fill', chart._vars.fontColor) //Customize the color of axis labels
            .attr('class', xAxisClass).style('text-anchor', 'middle').attr('font-size', chart._vars.fontSize).attr('transform', 'translate(0, 3)').text(function (d) {
                if (xAxisData.dataType === 'NUMBER' || chart._vars.rotateAxis) {
                    return jvCharts.jvFormatValue(d, formatValueType);
                }
                return d;
            });

            //Styling the label for the entire axis
            xContent.append('g').attr('class', 'xLabel').append('text').attr('class', 'xLabel editable editable-text editable-content').attr('text-anchor', 'middle').attr('font-size', chart._vars.fontSize).text(function () {
                if (xAxisData.dataType === 'DATE') {
                    return '';
                }
                return xAxisData.label;
            }).attr('transform', 'translate(' + containerWidth / 2 + ', 33)');
        }

        /**FormatXAxisLabels
         *
         * If x-axis labels are too long/overlapping, they will be hidden/shortened
         */

    }, {
        key: 'formatXAxisLabels',
        value: function formatXAxisLabels(dataLength, recursion) {
            var chart = this,
                showAxisLabels = true,
                xAxisLength = chart.config.container.width,
                textWidth = [],
                formatValueType = null,
                dataType = chart.currentData.xAxisData.dataType,
                axisValues = chart.currentData.xAxisData.values;

            if (dataType === 'NUMBER') {
                formatValueType = jvCharts.jvFormatValueType(axisValues);
            }

            //create dummy text to determine computed text length for the axis labels
            //necessary to do this because axis labels getBBox() is returning 0 since they do not seem to be drawn yet
            chart.svg.append('g').selectAll('.dummyText').data(axisValues).enter().append('text').attr('font-family', 'sans-serif').attr('font-size', chart._vars.fontSize).text(function (d) {
                var returnVal = d;
                if (dataType === 'NUMBER') {
                    returnVal = jvCharts.jvFormatValue(d, formatValueType);
                }
                return returnVal;
            }).each(function () {
                //adding 10px buffer
                var thisWidth = this.getComputedTextLength() + 10;
                textWidth.push(thisWidth);
                this.remove(); //remove them just after displaying them
            });

            var _iteratorNormalCompletion9 = true;
            var _didIteratorError9 = false;
            var _iteratorError9 = undefined;

            try {
                for (var _iterator9 = textWidth[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
                    var textEle = _step9.value;

                    if (textEle > xAxisLength / dataLength) {
                        showAxisLabels = false;
                    }
                }
            } catch (err) {
                _didIteratorError9 = true;
                _iteratorError9 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion9 && _iterator9.return) {
                        _iterator9.return();
                    }
                } finally {
                    if (_didIteratorError9) {
                        throw _iteratorError9;
                    }
                }
            }

            if (showAxisLabels) {
                if (recursion) {
                    chart.generateXAxis(chart.currentData.xAxisData, dataLength);
                }
                chart.svg.selectAll('.xAxisLabels').style('display', 'block');
            } else if (dataLength > 1 && chart.currentData.xAxisData.dataType === 'NUMBER') {
                //recursively keep decreasing to figure out ticks length to repaint the xAxis if its numeric
                chart.formatXAxisLabels(dataLength - 1, true);
            } else {
                chart.svg.selectAll('.xAxis').selectAll('text').style('display', 'none');
            }
        }

        /**generateYAxis
         * creates y axis on the svg
         *
         * @params generateYAxis
         */

    }, {
        key: 'generateYAxis',
        value: function generateYAxis(yAxisData) {
            var chart = this,
                yAxisScale = jvCharts.getAxisScale('y', yAxisData, chart.config.container, chart._vars),
                yAxisClass = 'yAxisLabels editable editable-yAxis editable-text',
                maxYAxisLabelWidth = void 0,
                numberOfTicks = Math.floor(chart.config.container.height / 14),
                yAxis = void 0,
                yContent = void 0,
                yAxisGroup = void 0,
                forceFormatTypeTo = null,
                ylabel = '';

            //assign css class for edit mode
            //if the axis is numbers add editable-num
            if (yAxisData.dataType === 'NUMBER') {
                yAxisClass += ' editable-num';
            }

            //Save y axis scale to chart object
            chart.currentData.yAxisScale = yAxisScale;

            //remove previous svg elements
            chart.svg.selectAll('.yAxisContainer').remove();
            chart.svg.selectAll('text.yLabel').remove();

            if (numberOfTicks > 10) {
                if (numberOfTicks < 20) {
                    numberOfTicks = 10;
                } else if (numberOfTicks < 30) {
                    numberOfTicks /= 2;
                } else {
                    numberOfTicks = 15;
                }
            }

            //If all y-axis values are the same, only show a tick for that value. If value is 1, don't show any decimal places
            if (yAxisData.values.length > 0 && !!yAxisData.values.reduce(function (a, b) {
                return a === b ? a : NaN;
            })) {
                numberOfTicks = 1;
                if (yAxisData.values[0] === 1) {
                    forceFormatTypeTo = 'nodecimals';
                }
            }
            yAxis = d3.axisLeft().ticks(numberOfTicks) //Link to D3.svg.axis options: https://github.com/mbostock/d3/wiki/SVG-Axes
            .scale(yAxisScale) //Sets the scale to use in the axis
            .tickSize(5) //Sets the thickness of the axis line
            .tickPadding(5);

            //Hide Axis values if necessary
            if (yAxisData.hideValues) {
                yAxis.tickFormat('');
            }
            if (chart._vars.displayYAxisLabel) {
                ylabel = yAxisData.label;
            }

            yContent = chart.svg.append('g').attr('class', 'yAxisContainer');

            yContent.append('g').attr('class', 'yLabel').append('text').attr('class', 'yLabel editable editable-text editable-content').attr('text-anchor', 'start').attr('font-size', chart._vars.fontSize).attr('x', 0).attr('y', 0).attr('transform', 'translate(' + (-chart.config.margin.left + 10) + ', -10)').text(ylabel).attr('fill-opacity', 1);

            yAxisGroup = yContent.append('g').attr('class', 'yAxis');

            yAxisGroup.call(yAxis);

            //Styling for Axis
            yAxisGroup.select('path').attr('stroke', chart._vars.axisColor).attr('stroke-width', chart._vars.strokeWidth);

            maxYAxisLabelWidth = 0;

            if (yAxisData.hideValues) {
                //Styling for ticks
                yAxisGroup.selectAll('line').attr('stroke-width', 0);
            } else {
                var formatValueType = jvCharts.jvFormatValueType(yAxisData.values);
                //Styling for ticks
                yAxisGroup.selectAll('line').attr('stroke', chart._vars.axisColor).attr('stroke-width', chart._vars.stroke);
                //Styling for data labels on axis
                yAxisGroup.selectAll('text').attr('fill', chart._vars.fontColor) //Customize the color of axis labels
                .attr('class', yAxisClass).attr('transform', 'rotate(0)') //Add logic to rotate axis based on size of title
                .attr('font-size', chart._vars.fontSize).append('svg:title');

                yAxisGroup.selectAll('text').text(function (d) {
                    if (chart._vars.rotateAxis) {
                        return d;
                    }
                    var maxLength = 13,
                        current = '';
                    if (d.length > maxLength) {
                        current = d.substring(0, maxLength) + '...';
                    } else {
                        current = d;
                    }

                    if (forceFormatTypeTo !== null) {
                        formatValueType = forceFormatTypeTo;
                    }
                    return jvCharts.jvFormatValue(current, formatValueType);
                }).each(function (d, i, j) {
                    if (j[0].getBBox().width > maxYAxisLabelWidth) {
                        maxYAxisLabelWidth = j[0].getBBox().width;
                    }
                });
                if (maxYAxisLabelWidth > 0) {
                    chart._vars.yLabelWidth = Math.ceil(maxYAxisLabelWidth) + 20;
                }
            }
        }
        /************************************************ Legend functions ******************************************************/

    }, {
        key: 'generateLegend',
        value: function generateLegend(legendData, drawFunc) {
            var chart = this,
                svg = chart.svg,
                legendElements = void 0;

            if (!chart._vars.toggleLegend) {
                return;
            }
            svg.selectAll('.legend').remove();

            legendElements = jvCharts.generateLegendElements(chart, legendData, drawFunc);

            //Returns the legend rectangles that are toggled on/off
            if (drawFunc) {
                jvCharts.attachClickEventsToLegend(chart, legendElements, drawFunc, legendData);
            }

            if (chart._vars.thresholds !== 'none' && chart._vars.thesholdLegend === true) {
                if (chart.config.type === 'bar' || chart.config.type === 'area' || chart.config.type === 'line') {
                    if (chart.config.container.height > 300 && chart.config.container.width > 300) {
                        jvCharts.generateThresholdLegend(chart);
                    }
                }
            }
        }

        /**generateVerticalLegend
         *
         * creates and draws a vertical legend on the svg element
         * @params svg, legendData, options, container, chartData, xAxisData, yAxisData, chartType
         * @returns {{}}
         */

    }, {
        key: 'generateVerticalLegend',
        value: function generateVerticalLegend(paintFunc) {
            var chart = this,
                svg = chart.svg,
                legendData = chart.currentData.legendData,
                legendElements = void 0;

            if (!chart._vars.toggleLegend) {
                return;
            }

            svg.selectAll('.legend').remove();
            legendElements = jvCharts.generateVerticalLegendElements(chart, legendData, paintFunc);

            //Returns the legend rectangles that are toggled on/off
            if (paintFunc !== 'generatePack') {
                jvCharts.attachClickEventsToLegend(chart, legendElements, paintFunc, legendData);
            }
        }

        /**
         *
         * Generates a clip path that contains the contents of the chart area to the view of the chart area container
         * i.e - don't want bars going below the x axis
         */

    }, {
        key: 'generateClipPath',
        value: function generateClipPath() {
            var chart = this,
                svg = chart.svg,
                type = chart.config.type,
                containerName = '.' + type + '-container';

            svg.append('clipPath').attr('id', 'clip').append('rect').attr('x', 0).attr('y', 0).attr('width', chart.config.container.width).attr('height', chart.config.container.height);

            //Break this out into logic for all other vizzes that have overflow issues
            svg.select(containerName).attr('clip-path', 'url(#clip)');
        }
    }, {
        key: 'setThreshold',
        value: function setThreshold(data) {
            var chart = this,
                thresholds = chart._vars.thresholds,
                length = thresholds ? Object.keys(thresholds).length : 0;

            if (thresholds !== 'none') {
                for (var i = length - 1; i >= 0; i--) {
                    var threshold = thresholds[i];
                    //console.log(typeof data == "date");
                    if (data >= Number(threshold.threshold)) {
                        return 'rect-' + i;
                    }
                }
            }
            return '';
        }
    }, {
        key: 'generateLineThreshold',
        value: function generateLineThreshold() {
            var chart = this,
                svg = chart.svg,
                width = chart.config.container.width,
                height = chart.config.container.height,
                thresholds = chart._vars.thresholds,
                length = Object.keys(chart._vars.thresholds).length,
                x = chart.currentData.xAxisScale,
                y = chart.currentData.yAxisScale;

            if (thresholds !== 'none') {
                for (var i = 0; i < length; i++) {
                    var threshold = thresholds[i];
                    if (chart._vars.rotateAxis) {
                        svg.append('line').style('stroke', threshold.thresholdColor).attr('x1', x(threshold.threshold)).attr('y1', 0).attr('x2', x(threshold.threshold)).attr('y2', height).attr('stroke-dasharray', '3, 3');
                    } else {
                        svg.append('line').style('stroke', threshold.thresholdColor).attr('x1', 0).attr('y1', y(threshold.threshold)).attr('x2', width).attr('y2', y(threshold.threshold)).attr('stroke-dasharray', '3, 3');
                    }
                }
            }
        }
    }, {
        key: 'colorBackground',
        value: function colorBackground(color) {
            var chart = this;
            chart._vars.backgroundColor = color;
            chart.chartDiv.style('background-color', '' + color);
        }

        /**displayValues
         *
         * toggles data values that are displayed on the specific type of chart on the svg
         * @params svg, barData, options, xAxisData, yAxisData, container
         * @returns {{}}
         */

    }, {
        key: 'displayValues',
        value: function displayValues() {
            var chart = this,
                svg = chart.svg,
                container = chart.config.container,
                chartData = chart.data.chartData,
                xAxisData = chart.currentData.xAxisData,
                yAxisData = chart.currentData.yAxisData,
                legendOptions = chart._vars.legendOptions,
                cleanedChartData = JSON.parse(JSON.stringify(chartData)),
                data = [],
                //Only stores values
            posCalc,
                x,
                y,
                displayValuesGroup;

            //If series is flipped, use flipped data; initialize with the full data set
            if (chart._vars.seriesFlipped) {
                chartData = chart.flippedData.chartData;
                legendOptions = chart._vars.flippedLegendOptions;
            }

            if (chart._vars.displayValues === true) {
                svg.selectAll('.displayValueContainer').remove();
                if (legendOptions) {
                    //Checking which legend elements are toggled on resize
                    var _iteratorNormalCompletion10 = true;
                    var _didIteratorError10 = false;
                    var _iteratorError10 = undefined;

                    try {
                        for (var _iterator10 = cleanedChartData[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
                            var chartEle = _step10.value;
                            var _iteratorNormalCompletion11 = true;
                            var _didIteratorError11 = false;
                            var _iteratorError11 = undefined;

                            try {
                                for (var _iterator11 = legendOptions[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
                                    var legendEle = _step11.value;

                                    if (legendEle.toggle === false) {
                                        delete chartEle[legendEle.element];
                                    }
                                }
                            } catch (err) {
                                _didIteratorError11 = true;
                                _iteratorError11 = err;
                            } finally {
                                try {
                                    if (!_iteratorNormalCompletion11 && _iterator11.return) {
                                        _iterator11.return();
                                    }
                                } finally {
                                    if (_didIteratorError11) {
                                        throw _iteratorError11;
                                    }
                                }
                            }
                        }
                    } catch (err) {
                        _didIteratorError10 = true;
                        _iteratorError10 = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion10 && _iterator10.return) {
                                _iterator10.return();
                            }
                        } finally {
                            if (_didIteratorError10) {
                                throw _iteratorError10;
                            }
                        }
                    }
                }

                var _iteratorNormalCompletion12 = true;
                var _didIteratorError12 = false;
                var _iteratorError12 = undefined;

                try {
                    for (var _iterator12 = cleanedChartData[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
                        var _chartEle2 = _step12.value;

                        var val = jvCharts.getDisplayValuesElement(_chartEle2, chart.currentData.dataTable, chart.config.type);
                        data.push(val);
                    }
                } catch (err) {
                    _didIteratorError12 = true;
                    _iteratorError12 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion12 && _iterator12.return) {
                            _iterator12.return();
                        }
                    } finally {
                        if (_didIteratorError12) {
                            throw _iteratorError12;
                        }
                    }
                }

                posCalc = jvCharts.getPosCalculations(cleanedChartData, chart._vars, xAxisData, yAxisData, container, chart);
                x = jvCharts.getAxisScale('x', xAxisData, container, chart._vars);
                y = jvCharts.getAxisScale('y', yAxisData, container, chart._vars);

                if (chart._vars.rotateAxis) {
                    //Add a container for display values over each bar group
                    displayValuesGroup = svg.append('g').attr('class', 'displayValuesGroup').selectAll('g').data(data).enter().append('g').attr('class', 'displayValuesGroup').attr('transform', function (d, i) {
                        var translate = y.paddingOuter() * y.step() + y.step() * i;
                        return 'translate(0,' + translate + ')';
                    });

                    displayValuesGroup.selectAll('text').data(function (d) {
                        return d;
                    }).enter().append('text').attr('class', 'displayValue').attr('x', function (d, i, j) {
                        //sets the x position of the bar)
                        return posCalc.width(d, i, j) + posCalc.x(d, i, j);
                    }).attr('y', function (d, i, j) {
                        //sets the y position of the bar
                        return posCalc.y(d, i, j) + posCalc.height(d, i, j) / 2;
                    }).attr('dy', '.35em').attr('text-anchor', 'start').attr('fill', chart._vars.fontColor).text(function (d) {
                        var returnText = Math.round(d * 100) / 100; //round to 2 decimals
                        return jvCharts.jvFormatValue(returnText);
                    }).attr('font-size', chart._vars.fontSize);
                } else {
                    //Add a display values container over each bar group
                    displayValuesGroup = svg.append('g').attr('class', 'displayValuesGroup').selectAll('g').data(data).enter().append('g').attr('class', 'displayValuesGroup').attr('transform', function (d, i) {
                        var translate = x.paddingOuter() * x.step() + x.step() * i;
                        return 'translate(' + translate + ',0)';
                    });
                    displayValuesGroup.selectAll('text').data(function (d) {
                        return d;
                    }).enter().append('text').attr('class', 'displayValue').attr('x', function (d, i, j) {
                        //sets the x position of the bar)
                        return Math.round(posCalc.x(d, i, j) + posCalc.width(d, i, j) / 2);
                    }).attr('y', function (d, i, j) {
                        //sets the y position of the bar
                        return Math.round(posCalc.y(d, i, j)) - 3; //+ posCalc.height(d, i, j) - 5);
                    }).attr('text-anchor', 'middle').attr('fill', chart._vars.fontColor).text(function (d, i, j) {
                        if (chart._vars.stackToggle && chart._vars.displayValuesStackAsPercent) {
                            var total = 0;
                            for (var index = 0; index < j.length; index++) {
                                total += j[index].__data__;
                            }
                            return jvCharts.jvFormatValue(d / total, 'percent');
                        }

                        return jvCharts.jvFormatValue(d);
                    }).attr('font-size', chart._vars.fontSize);

                    if (chart._vars.stackToggle && chart._vars.displayValuesStackTotal) {
                        var stackCounter = 0;
                        svg.append('g').attr('class', 'displayStackTotal').selectAll('g').data(data).enter().append('g').attr('transform', function (d, i) {
                            var translate = x.paddingOuter() * x.step() + x.step() * i;
                            return 'translate(' + translate + ',0)';
                        }).selectAll('text').data(function (d) {
                            return d;
                        }).enter().append('text').attr('x', function (d, i, j) {
                            //sets the x position of the bar)
                            return Math.round(posCalc.x(d, i, j) + posCalc.width(d, i, j) / 2);
                        }).attr('y', function (d, i, j) {
                            //sets the y position of the bar
                            return Math.round(posCalc.y(d, i, j)) - 18; //+ posCalc.height(d, i, j) - 5);
                        }).attr('text-anchor', 'middle').attr('fill', chart._vars.fontColor).text(function (d, i, j) {
                            var yLength = chart.currentData.yAxisData.values.length,
                                xLength = chart.currentData.xAxisData.values.length,
                                indexMax = yLength / xLength,
                                stack = 0;
                            if (i + 1 === indexMax) {
                                for (var k = 0; j < indexMax; k++) {
                                    stack += chart.currentData.yAxisData.values[indexMax * stackCounter + k];
                                }
                                stackCounter++;
                                return jvCharts.jvFormatValue(stack);
                            }
                            return '';
                        }).attr('font-size', chart._vars.fontSize);
                    }
                }
            } else {
                svg.selectAll('.displayValueContainer').remove();
            }
        }
    }, {
        key: 'drawGridlines',
        value: function drawGridlines(axisData) {
            var chart = this,
                scaleData = void 0;

            chart.svg.selectAll('g.gridLines').remove();
            chart.svg.append('g').attr('class', 'gridLines');

            //Determine if gridlines are horizontal or vertical based on rotateAxis
            if (chart._vars.rotateAxis === true || chart.config.type === 'gantt' || chart.config.type === 'singleaxis') {
                var gridLineHeight = chart.config.container.height,
                    xAxisScale = jvCharts.getAxisScale('x', axisData, chart.config.container, chart._vars);

                if (axisData.dataType === 'STRING') {
                    scaleData = axisData.values;
                } else if (axisData.dataType === 'NUMBER' || axisData.dataType === 'DATE') {
                    scaleData = xAxisScale.ticks(10);
                }

                chart.svg.select('.gridLines').selectAll('.horizontalGrid').data(scaleData).enter().append('line').attr('class', 'horizontalGrid').attr('x1', function (d, i) {
                    return i > 0 ? xAxisScale(d) : 0;
                }).attr('x2', function (d, i) {
                    return i > 0 ? xAxisScale(d) : 0;
                }).attr('y1', 0).attr('y2', function (d, i) {
                    return i > 0 ? gridLineHeight : 0;
                }).attr('fill', 'none').attr('shape-rendering', 'crispEdges').attr('stroke', chart._vars.axisColor).attr('stroke-width', chart._vars.gridLineStrokeWidth);
            } else {
                var gridLineWidth = chart.config.container.width,
                    yAxisScale = jvCharts.getAxisScale('y', axisData, chart.config.container, chart._vars);

                if (axisData.dataType === 'STRING') {
                    scaleData = axisData.values;
                } else if (axisData.dataType === 'NUMBER' || axisData.dataType === 'DATE') {
                    scaleData = yAxisScale.ticks(10);
                }

                chart.svg.select('.gridLines').selectAll('.horizontalGrid').data(scaleData).enter().append('line').attr('class', 'horizontalGrid').attr('x1', 0).attr('x2', function (d, i) {
                    return i > 0 ? gridLineWidth : 0;
                }).attr('y1', function (d, i) {
                    return i > 0 ? yAxisScale(d) : 0;
                }).attr('y2', function (d, i) {
                    return i > 0 ? yAxisScale(d) : 0;
                }).attr('fill', 'none').attr('shape-rendering', 'crispEdges').attr('stroke', chart._vars.axisColor).attr('stroke-width', chart._vars.gridLineStrokeWidth);
            }
        }

        /**getBarDataFromOptions
        * ^^ not just a bar function, line and area also use it
        *
        * Assigns the correct chart data to current data using the chart.options
        */

    }, {
        key: 'getBarDataFromOptions',
        value: function getBarDataFromOptions() {
            var chart = this,
                dataObj = {},
                data = chart.data;

            //set flipped data if necessary
            if (chart._vars.seriesFlipped) {
                data = chart.flippedData;
            }

            dataObj.chartData = data.chartData;
            dataObj.legendData = data.legendData;
            dataObj.dataTable = data.dataTable;
            chart._vars.color = data.color;
            if (chart._vars.rotateAxis === true) {
                dataObj.xAxisData = data.yAxisData;
                dataObj.yAxisData = data.xAxisData;
            } else {
                dataObj.xAxisData = data.xAxisData;
                dataObj.yAxisData = data.yAxisData;
            }

            return dataObj;
        }

        /************************************************ Utility functions ******************************************************/

        /**highlightItems
         *
         * highlights items on the svg element
         * @params items, svg
         * @returns {{}}
         */

    }, {
        key: 'highlightItem',
        value: function highlightItem(items, tag, highlightIndex, highlightUri) {
            var chart = this,
                svg = chart.svg;

            //TODO remove if statements
            if (highlightIndex >= 0) {
                if (chart.config.type === 'pie') {
                    //set all circles stroke width to 0
                    svg.select('.pie-container').selectAll(tag).attr('stroke', chart._vars.pieBorder).attr('stroke-width', 1);
                    //highlight necessary pie slices
                    svg.select('.pie-container').selectAll(tag).filter('.highlight-class-' + highlightIndex).attr('stroke', chart._vars.highlightBorderColor).attr('stroke-width', chart._vars.highlightBorderWidth);
                }
                if (chart.config.type === 'scatterplot') {
                    //set all circles stroke width to 0
                    svg.select('.scatter-container').selectAll(tag).attr('stroke-width', 0);
                    //highlight necessary scatter dots
                    svg.select('.scatter-container').selectAll(tag).filter('.scatter-circle-' + highlightIndex).attr('stroke', chart._vars.highlightBorderColor).attr('stroke-width', chart._vars.highlightBorderWidth);
                }
            } else if (highlightUri) {
                if (chart.config.type === 'bar') {
                    //set all bars stroke width to 0
                    svg.select('.bar-container').selectAll(tag).attr('stroke', 0).attr('stroke-width', 0);
                    //highlight necessary bars
                    svg.select('.bar-container').selectAll('.highlight-class-' + highlightUri).attr('stroke', chart._vars.highlightBorderColor).attr('stroke-width', chart._vars.highlightBorderWidth);
                }
                if (chart.config.type === 'line' || chart.config.type === 'area') {
                    //set all circles stroke width to 0
                    svg.select('.line-container').selectAll(tag).attr('stroke', 0).attr('stroke-width', 0);
                    //highlight necessary cirlces
                    svg.select('.line-container').selectAll(tag).filter('.highlight-class-' + highlightUri).attr('stroke', chart._vars.highlightBorderColor).attr('stroke-width', chart._vars.highlightBorderWidth);
                }
            } else {
                console.log('need to pass highlight index to highlight item');
            }
        }

        /**
        *@desc Removes highlights that were applied with related insights
        *
        */

    }, {
        key: 'removeHighlight',
        value: function removeHighlight() {
            var chart = this,
                svg = chart.svg;
            if (chart.config.type === 'pie') {
                //set all circles stroke width to 0
                svg.select('.pie-container').selectAll('path').attr('stroke', chart._vars.pieBorder).attr('stroke-width', 0);
            }
            if (chart.config.type === 'scatterplot') {
                svg.select('.scatter-container').selectAll('circle').attr('stroke-width', 0);
            }
            if (chart.config.type === 'bar') {
                svg.select('.bar-container').selectAll('rect').attr('stroke', 0).attr('stroke-width', 0);
            }
            if (chart.config.type === 'line' || chart.config.type === 'area') {
                svg.select('.line-container').selectAll('circle').attr('stroke', 0).attr('stroke-width', 0);
            }
        }
    }], [{
        key: 'getViewForValue',
        value: function getViewForValue(input) {
            var viewString = input.replace(/\s/g, '_').replace(/\./g, '_dot_');
            return viewString;
        }
    }, {
        key: 'getRawForValue',
        value: function getRawForValue(input) {
            var rawString = input.replace(/_/g, ' ').replace(/_dot_/g, '.');
            return rawString;
        }
    }, {
        key: 'jvFormatValue',
        value: function jvFormatValue(val, formatType) {
            if (!isNaN(val)) {
                var formatNumber = d3.format('.0f');

                if (formatType === 'billions') {
                    return formatNumber(val / 1e9) + 'B';
                } else if (formatType === 'millions') {
                    return formatNumber(val / 1e6) + 'M';
                } else if (formatType === 'thousands') {
                    return formatNumber(val / 1e3) + 'K';
                } else if (formatType === 'decimals') {
                    formatNumber = d3.format('.2f');
                    return formatNumber(val);
                } else if (formatType === 'nodecimals') {
                    return formatNumber(val);
                } else if (formatType === 'percent') {
                    var p = Math.max(0, d3.precisionFixed(0.05) - 2),
                        expression = d3.format('.' + p + '%');
                    return expression(val);
                } else if (formatType === '') {
                    return val;
                }

                if (val === 0) {
                    return 0;
                }

                if (Math.abs(val) >= 1000000000) {
                    //Billions
                    return formatNumber(val / 1e9) + 'B';
                } else if (Math.abs(val) >= 1000000) {
                    //Millions
                    return formatNumber(val / 1e6) + 'M';
                } else if (Math.abs(val) >= 1000) {
                    //Thousands
                    return formatNumber(val / 1e3) + 'K';
                } else if (Math.abs(val) <= 10) {
                    //2 decimals
                    formatNumber = d3.format('.2f');
                }
                return formatNumber(val);
            }
            return val;
        }

        /**
         * @param the set of values that you want to format uniformly
         * @return '' the level of formatting for the group of data
         * Problem with jvFormatValue function is that if you pass in values 10, 20... 90, 100, 1120, 120
         * you will get the formats 10.00, 20.00 .... 100, 110, 120 when you want 10, 20, ... 100, 110
         * --Format the value based off of the highest number in the group
         */

    }, {
        key: 'jvFormatValueType',
        value: function jvFormatValueType(valueArray, dataType) {
            if (valueArray != null && dataType !== 'STRING') {
                var max = Math.max.apply(null, valueArray),

                //After getting the max, check the min
                min = Math.min.apply(null, valueArray),
                    range = max - min,
                    incrememnt = Math.abs(Math.round(range / 10)); //10 being the number of axis labels to show

                if (Math.abs(incrememnt) >= 1000000000) {
                    return 'billions';
                } else if (Math.abs(incrememnt) >= 1000000) {
                    return 'millions';
                } else if (Math.abs(incrememnt) >= 1000) {
                    return 'thousands';
                } else if (Math.abs(incrememnt) <= 10) {
                    return 'decimals';
                } else if (Math.abs(incrememnt) >= 10) {
                    return 'nodecimals';
                }
            }
            return '';
        }

        /**getFormatExpression
         *
         * @desc returns the d3 format expression for a given option
         * @params option
         * @returns string expression
         */

    }, {
        key: 'getFormatExpression',
        value: function getFormatExpression(option) {
            var expression = '',
                p = void 0;
            if (option === 'currency') {
                expression = d3.format('$,');
            }
            if (option === 'fixedCurrency') {
                expression = d3.format('($.2f');
            }
            if (option === 'percent') {
                p = Math.max(0, d3.precisionFixed(0.05) - 2);
                expression = d3.format('.' + p + '%');
            }
            if (option === 'millions') {
                p = d3.precisionPrefix(1e5, 1.3e6);
                expression = d3.formatPrefix('.' + p, 1.3e6);
            }
            if (option === 'commas') {
                expression = d3.format(',.0f');
            }
            if (option === 'none' || option === '') {
                expression = d3.format('');
            }
            if (option === 'displayValues') {
                expression = d3.format(',.2f');
            }

            return expression;
        }

        /**getToggledData
         *
         * Gets the headers of the data to be drawn and filters the data based on that
         * @params chartData, dataHeaders
         */

    }, {
        key: 'getToggledData',
        value: function getToggledData(data, dataHeaders) {
            var legendToggleArray = this.getLegendElementToggleArray(dataHeaders, data.legendData),
                newData = JSON.parse(JSON.stringify(data.chartData));
            if (legendToggleArray) {
                for (var i = 0; i < data.chartData.length; i++) {
                    var _iteratorNormalCompletion13 = true;
                    var _didIteratorError13 = false;
                    var _iteratorError13 = undefined;

                    try {
                        for (var _iterator13 = legendToggleArray[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
                            var toggleKey = _step13.value;

                            if (toggleKey.toggle === false) {
                                delete newData[i][toggleKey.element];
                            }
                        }
                    } catch (err) {
                        _didIteratorError13 = true;
                        _iteratorError13 = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion13 && _iterator13.return) {
                                _iterator13.return();
                            }
                        } finally {
                            if (_didIteratorError13) {
                                throw _iteratorError13;
                            }
                        }
                    }
                }
            }
            return newData;
        }

        /**
         * @name getLegendElementToggleArray
         * @desc Gets an array of legend elements with true/false tags for if toggled
         * @param {any} selectedHeaders - headers selected by user
         * @param {any} allHeaders - all available headers in the visual
         * @returns {array} - array of legend elements
         */

    }, {
        key: 'getLegendElementToggleArray',
        value: function getLegendElementToggleArray(selectedHeaders, allHeaders) {
            var legendToggleArray = [];
            var _iteratorNormalCompletion14 = true;
            var _didIteratorError14 = false;
            var _iteratorError14 = undefined;

            try {
                for (var _iterator14 = allHeaders[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {
                    var header = _step14.value;

                    legendToggleArray.push({ element: header });
                }
            } catch (err) {
                _didIteratorError14 = true;
                _iteratorError14 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion14 && _iterator14.return) {
                        _iterator14.return();
                    }
                } finally {
                    if (_didIteratorError14) {
                        throw _iteratorError14;
                    }
                }
            }

            var _iteratorNormalCompletion15 = true;
            var _didIteratorError15 = false;
            var _iteratorError15 = undefined;

            try {
                for (var _iterator15 = legendToggleArray[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {
                    var toggleKey = _step15.value;
                    var _iteratorNormalCompletion16 = true;
                    var _didIteratorError16 = false;
                    var _iteratorError16 = undefined;

                    try {
                        for (var _iterator16 = selectedHeaders[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {
                            var _header = _step16.value;

                            if (toggleKey.element === _header) {
                                toggleKey.toggle = true;
                                continue;
                            }
                        }
                    } catch (err) {
                        _didIteratorError16 = true;
                        _iteratorError16 = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion16 && _iterator16.return) {
                                _iterator16.return();
                            }
                        } finally {
                            if (_didIteratorError16) {
                                throw _iteratorError16;
                            }
                        }
                    }

                    if (toggleKey.toggle !== true) {
                        toggleKey.toggle = false;
                    }
                }
            } catch (err) {
                _didIteratorError15 = true;
                _iteratorError15 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion15 && _iterator15.return) {
                        _iterator15.return();
                    }
                } finally {
                    if (_didIteratorError15) {
                        throw _iteratorError15;
                    }
                }
            }

            return legendToggleArray;
        }

        /**
         * generateLegendElements
         *
         * @param {any} chart - chart object
         * @param {any} legendData -legend data for visual
         * @param {any} drawFunc - redraw function for visual
         * @returns {object} - legend rectangles
         */

    }, {
        key: 'generateLegendElements',
        value: function generateLegendElements(chart, legendData, drawFunc) {
            var _this = this;

            var svg = chart.svg,
                container = chart.config.container,
                legend = void 0,
                legendRow = 0,
                legendColumn = 0,
                legendDataLength = legendData.length,
                legendElementToggleArray = void 0,
                legendRectangles = void 0,
                legendText = void 0;

            if (!chart._vars.legendIndex) {
                chart._vars.legendIndex = 0;
            }

            if (!chart._vars.legendIndexMax) {
                chart._vars.legendIndexMax = Math.floor(legendDataLength / chart._vars.legendMax - 0.01);
            }

            //if legend headers don't exist, set them equal to legend data
            if (!chart._vars.legendHeaders && !chart._vars.seriesFlipped) {
                chart._vars.legendHeaders = JSON.parse(JSON.stringify(legendData));
            } else if (!chart._vars.flippedLegendHeaders && chart._vars.seriesFlipped) {
                chart._vars.flippedLegendHeaders = JSON.parse(JSON.stringify(legendData));
            }
            //Set legend element toggle array based on if series is flipped
            if (!chart._vars.seriesFlipped) {
                legendElementToggleArray = this.getLegendElementToggleArray(chart._vars.legendHeaders, legendData);
            } else {
                legendElementToggleArray = this.getLegendElementToggleArray(chart._vars.flippedLegendHeaders, legendData);
            }

            legend = svg.append('g').attr('class', 'legend');

            //Adding colored rectangles to the legend
            legendRectangles = legend.selectAll('rect').data(legendData).enter().append('rect').attr('class', 'legendRect').attr('x', function (d, i) {
                var legendPos = void 0;
                if (i % (chart._vars.legendMax / 3) === 0 && i > 0) {
                    legendColumn = 0;
                }
                legendPos = 200 * legendColumn;
                legendColumn++;
                return legendPos;
            }).attr('y', function (d, i) {
                if (i % (chart._vars.legendMax / 3) === 0 && i > 0) {
                    legendRow++;
                }
                if (i % chart._vars.legendMax === 0 && i > 0) {
                    legendRow = 0;
                }
                return container.height + 10 + 15 * (legendRow + 1) - 5; //Increment row when column limit is reached
            }).attr('width', chart._vars.gridSize).attr('height', chart._vars.gridSize).attr('fill', function (d, i) {
                return _this.getColors(chart._vars.color, i, legendData[i]);
            }).attr('display', function (d, i) {
                if (i >= chart._vars.legendIndex * chart._vars.legendMax && i <= chart._vars.legendIndex * chart._vars.legendMax + (chart._vars.legendMax - 1)) {
                    return 'all';
                }
                return 'none';
            }).attr('opacity', function (d, i) {
                if (!legendElementToggleArray) {
                    return '1';
                }
                if (legendElementToggleArray[i].toggle === true) {
                    return '1';
                }
                return '0.2';
            });

            legendRow = 0;
            legendColumn = 0;

            //Adding text labels for each rectangle in legend
            legendText = legend.selectAll('text').data(legendData).enter().append('text').attr('class', function (d, i) {
                return 'legendText editable editable-text editable-content editable-legend-' + i;
            }).attr('x', function (d, i) {
                if (i % (chart._vars.legendMax / 3) === 0 && i > 0) {
                    legendColumn = 0;
                }
                var legendPos = 200 * legendColumn;
                legendColumn++;
                return legendPos + 17;
            }).attr('y', function (d, i) {
                if (i % (chart._vars.legendMax / 3) === 0 && i > 0) {
                    legendRow++;
                }
                if (i % chart._vars.legendMax === 0 && i > 0) {
                    legendRow = 0;
                }
                return container.height + 10 + 15 * (legendRow + 1); //Increment row when column limit is reached
            }).attr('text-anchor', 'start').attr('dy', '0.35em') //Vertically align with node
            .attr('fill', chart._vars.fontColor).attr('font-size', chart._vars.fontSize).attr('display', function (d, i) {
                if (i >= chart._vars.legendIndex * chart._vars.legendMax && i <= chart._vars.legendIndex * chart._vars.legendMax + (chart._vars.legendMax - 1)) {
                    return 'all';
                }
                return 'none';
            }).text(function (d, i) {
                var elementName = legendData[i];
                if (chart.config.type === 'gantt') {
                    elementName = legendData[i].slice(0, -5); //Removing last 5 characters of legend label---i.e plannedSTART -> planned
                }
                if (elementName.length > 20) {
                    return elementName.substring(0, 19) + '...';
                }
                return elementName;
            });

            //Adding info box to legend elements when hovering over
            legendText.data(legendData).append('svg:title').text(function (d) {
                return d;
            });

            //Only create carousel if the number of elements exceeds one legend "page"
            if (chart._vars.legendIndexMax > 0) {
                this.createCarousel(chart, legendData, drawFunc);
            }
            //Centers the legend in the panel
            if (legend) {
                var legendWidth = legend.node().getBBox().width;
                legend.attr('transform', 'translate(' + (container.width - legendWidth) / 2 + ', 30)');
            }

            return legendRectangles;
        }

        /**updateDataFromLegend
         *
         * Returns a list of data headers that should be displayed in viz
         * based off what is toggled on/off in legend
         * @params legendData
         */

    }, {
        key: 'updateDataFromLegend',
        value: function updateDataFromLegend(legendData) {
            var data = [],
                legendElement = legendData[0];
            var _iteratorNormalCompletion17 = true;
            var _didIteratorError17 = false;
            var _iteratorError17 = undefined;

            try {
                for (var _iterator17 = legendElement[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {
                    var ele = _step17.value;

                    if (ele.attributes.opacity.value !== '0.2') {
                        //If not white, add it to the updated data array
                        data.push(ele.__data__);
                    }
                }
            } catch (err) {
                _didIteratorError17 = true;
                _iteratorError17 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion17 && _iterator17.return) {
                        _iterator17.return();
                    }
                } finally {
                    if (_didIteratorError17) {
                        throw _iteratorError17;
                    }
                }
            }

            return data;
        }

        /**createCarousel
         *
         * Draws the horizontal legend carousel
         * @params chart, legendData, drawFunc
         */

    }, {
        key: 'createCarousel',
        value: function createCarousel(chart, legendData, drawFunc) {
            var _this2 = this;

            var svg = chart.svg,
                container = chart.config.container,
                legendPolygon = void 0;

            //Adding carousel to legend
            svg.selectAll('.legend-carousel').remove();
            svg.selectAll('#legend-text-index').remove();

            legendPolygon = svg.append('g').attr('class', 'legend-carousel');

            //Creates left navigation arrow for carousel
            legendPolygon.append('polygon').attr('id', 'leftChevron').attr('class', 'pointer-cursor').style('fill', chart._vars.legendArrowColor).attr('transform', 'translate(0,0)').attr('points', '0,7.5, 15,0, 15,15').on('click', function () {
                if (chart._vars.legendIndex >= 1) {
                    chart._vars.legendIndex--;
                }
                svg.selectAll('.legend').remove();
                var legendElements = _this2.generateLegendElements(chart, legendData, drawFunc);
                _this2.attachClickEventsToLegend(chart, legendElements, drawFunc, legendData);
            }).attr({
                display: function display() {
                    if (chart._vars.legendIndex === 0) {
                        return 'none';
                    }
                    return 'all';
                }
            });

            //Creates page number for carousel navigation
            legendPolygon.append('text').attr('id', 'legend-text-index').attr('x', 35).attr('y', 12.5).style('text-anchor', 'start').style('font-size', chart._vars.fontSize).text(function () {
                return chart._vars.legendIndex + 1 + ' / ' + (chart._vars.legendIndexMax + 1);
            }).attr({
                display: function display() {
                    if (chart._vars.legendIndexMax === 0) {
                        return 'none';
                    }
                    return 'all';
                }
            });

            //Creates right navigation arrow for carousel
            legendPolygon.append('polygon').attr('id', 'rightChevron').attr('class', 'pointer-cursor').style('fill', chart._vars.legendArrowColor).attr('transform', 'translate(85,0)').attr('points', '15,7.5, 0,0, 0,15').on('click', function () {
                if (chart._vars.legendIndex < chart._vars.legendIndexMax) {
                    chart._vars.legendIndex++;
                }
                svg.selectAll('.legend').remove();
                var legendElements = _this2.generateLegendElements(chart, legendData, drawFunc);
                _this2.attachClickEventsToLegend(chart, legendElements, drawFunc, legendData);
            }).attr({
                display: function display() {
                    if (chart._vars.legendIndex === chart._vars.legendIndexMax) {
                        return 'none';
                    }
                    return 'all';
                }
            });

            //Centers the legend polygons in the panel
            if (legendPolygon) {
                var legendPolygonWidth = legendPolygon.node().getBBox().width;
                legendPolygon.attr('transform', 'translate(' + (container.width - legendPolygonWidth) / 2 + ',' + (container.height + 105) + ')');
            }
        }

        /**getPlotData
         *
         * Returns only data values to be plotted; input is the data object
         * @params objectData, chart
         */

    }, {
        key: 'getPlotData',
        value: function getPlotData(objectData, chart) {
            var data = [],
                objDataNew = JSON.parse(JSON.stringify(objectData)); //Copy of barData
            var _iteratorNormalCompletion18 = true;
            var _didIteratorError18 = false;
            var _iteratorError18 = undefined;

            try {
                for (var _iterator18 = objDataNew[Symbol.iterator](), _step18; !(_iteratorNormalCompletion18 = (_step18 = _iterator18.next()).done); _iteratorNormalCompletion18 = true) {
                    var objEle = _step18.value;

                    var group = [];
                    var _iteratorNormalCompletion19 = true;
                    var _didIteratorError19 = false;
                    var _iteratorError19 = undefined;

                    try {
                        for (var _iterator19 = chart.currentData.legendData[Symbol.iterator](), _step19; !(_iteratorNormalCompletion19 = (_step19 = _iterator19.next()).done); _iteratorNormalCompletion19 = true) {
                            var legendEle = _step19.value;

                            if (typeof objEle[legendEle] !== 'undefined') {
                                group.push(objEle[legendEle]);
                            }
                        }
                    } catch (err) {
                        _didIteratorError19 = true;
                        _iteratorError19 = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion19 && _iterator19.return) {
                                _iterator19.return();
                            }
                        } finally {
                            if (_didIteratorError19) {
                                throw _iteratorError19;
                            }
                        }
                    }

                    data.push(group);
                }
            } catch (err) {
                _didIteratorError18 = true;
                _iteratorError18 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion18 && _iterator18.return) {
                        _iterator18.return();
                    }
                } finally {
                    if (_didIteratorError18) {
                        throw _iteratorError18;
                    }
                }
            }

            return data;
        }

        /**getPosCalculations
         *Holds the logic for positioning all bars on a bar chart (depends on toolData)
         *
         * @params svg, chartData, options, xAxisData, yAxisData, container
         * @returns {{}}
         */

    }, {
        key: 'getPosCalculations',
        value: function getPosCalculations(chartData, _vars, xAxisData, yAxisData, container, chart) {
            var x = jvCharts.getAxisScale('x', xAxisData, container, _vars),
                y = jvCharts.getAxisScale('y', yAxisData, container, _vars),
                scaleFactor = 1,
                data = [],
                size = 0,
                positionFunctions = {};

            for (var item in chart.currentData.dataTable) {
                if (item !== 'label' && item.indexOf('tooltip') === -1) {
                    size++;
                }
            }

            var _iteratorNormalCompletion20 = true;
            var _didIteratorError20 = false;
            var _iteratorError20 = undefined;

            try {
                for (var _iterator20 = chartData[Symbol.iterator](), _step20; !(_iteratorNormalCompletion20 = (_step20 = _iterator20.next()).done); _iteratorNormalCompletion20 = true) {
                    var chartEle = _step20.value;

                    var val = [];
                    for (var key in chartEle) {
                        if (chartEle.hasOwnProperty(key)) {
                            val.push(chartEle[key]);
                        }
                    }
                    data.push(val.slice(1, chartEle.length));
                }
            } catch (err) {
                _didIteratorError20 = true;
                _iteratorError20 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion20 && _iterator20.return) {
                        _iterator20.return();
                    }
                } finally {
                    if (_didIteratorError20) {
                        throw _iteratorError20;
                    }
                }
            }

            if (_vars.rotateAxis === true && _vars.stackToggle === true) {
                positionFunctions.startx = function () {
                    return 0;
                };
                positionFunctions.starty = function () {
                    return 0;
                };
                positionFunctions.startwidth = function () {
                    return 0;
                };
                positionFunctions.startheight = function () {
                    return y.bandwidth() * 0.95;
                };
                positionFunctions.x = function (d, i, j) {
                    var increment = 0; //Move the x up by the values that come before it
                    for (var k = i - 1; k >= 0; k--) {
                        if (!isNaN(j[k].__data__)) {
                            increment += j[k].__data__;
                        }
                    }
                    return x(increment) === 0 ? 1 : x(increment);
                };
                positionFunctions.y = function () {
                    return 0;
                };
                positionFunctions.width = function (d) {
                    return Math.abs(x(0) - x(d));
                };
                positionFunctions.height = function () {
                    return y.bandwidth() * 0.95;
                };
            } else if (_vars.rotateAxis === true && _vars.stackToggle === false) {
                positionFunctions.startx = function () {
                    return 0;
                };
                positionFunctions.starty = function (d, i) {
                    return y.bandwidth() / size * i;
                };
                positionFunctions.startwidth = function () {
                    return 0;
                };
                positionFunctions.startheight = function () {
                    return y.bandwidth() / size * 0.95 * scaleFactor;
                };
                positionFunctions.x = function (d) {
                    return x(0) - x(d) > 0 ? x(d) : x(0);
                };
                positionFunctions.y = function (d, i) {
                    return y.bandwidth() / size * i;
                };
                positionFunctions.width = function (d) {
                    return Math.abs(x(0) - x(d));
                };
                positionFunctions.height = function () {
                    return y.bandwidth() / size * 0.95 * scaleFactor;
                };
            } else if (_vars.rotateAxis === false && _vars.stackToggle === true) {
                positionFunctions.startx = function () {
                    return 0;
                };
                positionFunctions.starty = function () {
                    return container.height;
                };
                positionFunctions.startwidth = function () {
                    return x.bandwidth() * 0.95 * scaleFactor;
                };
                positionFunctions.startheight = function () {
                    return 0;
                };
                positionFunctions.x = function () {
                    return 0;
                };
                positionFunctions.y = function (d, i, j) {
                    var increment = 0; //Move the y up by the values that come before it
                    for (var k = i - 1; k >= 0; k--) {
                        if (!isNaN(j[k].__data__)) {
                            increment += j[k].__data__;
                        }
                    }
                    return y(parseFloat(d) + increment);
                };
                positionFunctions.width = function () {
                    return x.bandwidth() * 0.95 * scaleFactor;
                };
                positionFunctions.height = function (d) {
                    return container.height - y(d);
                };
            } else if (_vars.rotateAxis === false && _vars.stackToggle === false) {
                positionFunctions.startx = function (d, i) {
                    return x.bandwidth() / size * i;
                };
                positionFunctions.starty = function () {
                    return container.height;
                };
                positionFunctions.startwidth = function () {
                    return x.bandwidth() / size * 0.95;
                };
                positionFunctions.startheight = function () {
                    return 0;
                };
                positionFunctions.x = function (d, i) {
                    return x.bandwidth() / size * i;
                };
                positionFunctions.y = function (d) {
                    return y(0) - y(d) > 0 ? y(d) : y(0);
                };
                positionFunctions.width = function () {
                    return x.bandwidth() / size * 0.95;
                };
                positionFunctions.height = function (d) {
                    return Math.abs(y(0) - y(d));
                };
            }
            return positionFunctions;
        }

        /**getColors
         *
         * gets the colors to apply to the specific chart
         * @params colorObj, index, label
         * @returns {{}}
         */

    }, {
        key: 'getColors',
        value: function getColors(colorObj, paramIndex, label) {
            var index = paramIndex,
                cleanedColors = void 0;

            //logic to return the color if the colorObj passed in
            //is an object with the label being the key
            if (typeof label !== 'undefined' && colorObj.hasOwnProperty(label) && colorObj[label]) {
                return colorObj[label];
            }

            if (!Array.isArray(colorObj)) {
                cleanedColors = [];
                for (var k in colorObj) {
                    if (colorObj.hasOwnProperty(k)) {
                        if (colorObj[k]) {
                            cleanedColors.push(colorObj[k]);
                        }
                    }
                }
            } else {
                cleanedColors = colorObj;
            }

            //logic to return a repeating set of colors assuming that
            //the user changed data (ex: flip series on bar chart)
            if (!cleanedColors[index]) {
                while (index > cleanedColors.length - 1) {
                    index = index - cleanedColors.length;
                }
            }
            return cleanedColors[index];
        }
    }, {
        key: 'getAxisScale',
        value: function getAxisScale(whichAxis, axisData, container, _vars, paddingType) {
            var leftPadding = 0.4,
                rightPadding = 0.2,
                axisScale = void 0,
                axis = void 0,
                minDate = void 0,
                maxDate = void 0;

            if (paddingType === 'no-padding') {
                leftPadding = 0;
                rightPadding = 0;
            }

            whichAxis === 'x' ? axis = container.width : axis = container.height;

            if (axisData.dataType === 'DATE') {
                for (var i = 0; i < axisData.values.length; i++) {
                    axisData.values[i] = new Date(axisData.values[i]);
                }

                maxDate = Math.max.apply(null, axisData.values);
                minDate = Math.min.apply(null, axisData.values);

                axisScale = d3.scaleTime().domain([new Date(minDate), new Date(maxDate)]).rangeRound([0, axis]);
            } else if (axisData.dataType === 'STRING') {
                axisScale = d3.scaleBand().domain(axisData.values).range([0, axis]).paddingInner(leftPadding).paddingOuter(rightPadding);
            } else if (axisData.dataType === 'NUMBER') {
                var domain = void 0;
                if (_vars.xReversed || _vars.yReversed) {
                    if (_vars.xReversed && whichAxis === 'x' || whichAxis === 'y' && !_vars.yReversed) {
                        domain = [axisData.max, axisData.min];
                    }
                    if (_vars.yReversed && whichAxis === 'y' || whichAxis === 'x' && !_vars.xReversed) {
                        domain = [axisData.min, axisData.max];
                    }
                } else {
                    whichAxis === 'x' ? domain = [axisData.min, axisData.max] : domain = [axisData.max, axisData.min];
                }

                if (_vars.hasOwnProperty('axisType') && _vars.axisType === 'Logarithmic') {
                    domain[1] = 0.1;
                    axisScale = d3.scaleLog().base(10).domain(domain).rangeRound([0, axis]);
                } else {
                    axisScale = d3.scaleLinear().domain(domain).rangeRound([0, axis]);
                }
            } else {
                console.error('Axis is not a valid data type');
                //throw new Error('Axis is not a valid data type');
            }
            return axisScale;
        }

        /************************************************ Data functions ******************************************************/

        /**
         * @function
         * @param {string} label - The field that is checked for type
         * @param {Object} dataTableKeys - Object that contains the data type for each column of data
         */

    }, {
        key: 'getDataTypeFromKeys',
        value: function getDataTypeFromKeys(label, dataTableKeys) {
            var defaultType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'STRING';

            var type = defaultType;

            var _iteratorNormalCompletion21 = true;
            var _didIteratorError21 = false;
            var _iteratorError21 = undefined;

            try {
                for (var _iterator21 = dataTableKeys[Symbol.iterator](), _step21; !(_iteratorNormalCompletion21 = (_step21 = _iterator21.next()).done); _iteratorNormalCompletion21 = true) {
                    var key = _step21.value;

                    //Replace underscores with spaces
                    if (key.name.replace(/_/g, ' ') === label.replace(/_/g, ' ')) {
                        if (key.hasOwnProperty('type')) {
                            type = (key.type + '').toUpperCase();
                            if (type === 'STRING') {
                                type = 'STRING';
                            } else if (type === 'DATE') {
                                type = 'DATE';
                            } else if (type === 'NUMBER') {
                                type = 'NUMBER';
                            } else {
                                type = 'NUMBER';
                            }
                            break;
                        }
                    }
                }
            } catch (err) {
                _didIteratorError21 = true;
                _iteratorError21 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion21 && _iterator21.return) {
                        _iterator21.return();
                    }
                } finally {
                    if (_didIteratorError21) {
                        throw _iteratorError21;
                    }
                }
            }

            return type;
        }

        /**setBarLineLegendData
         *  gets legend info from chart Data
         *
         * @params data, type
         * @returns [] of legend text
         */

    }, {
        key: 'setBarLineLegendData',
        value: function setBarLineLegendData(data) {
            var legendArray = [];
            for (var item in data.dataTable) {
                if (data.dataTable.hasOwnProperty(item)) {
                    if (item !== 'label') {
                        legendArray.push(data.dataTable[item]);
                    }
                }
            }
            return legendArray;
        }

        /**setChartColors
         *  cleans incoming colors for consistency
         *
         * @params colorArray, legendData
         * @returns object with colors
         */

    }, {
        key: 'setChartColors',
        value: function setChartColors(toolData, legendData, defaultColorArray) {
            //function handles 3 color inputs
            //toolData as an array in toolData
            //toolData as an object
            //toolData as 'none'
            //any other case will result in using defaultColorArray

            var colors = {},
                usedColors = [],
                unaccountedLegendElements = [],
                toolDataAsArray = void 0;

            //toolData is array
            if (Array.isArray(toolData)) {
                if (toolData.length > 0) {
                    colors = this.createColorsWithDefault(legendData, toolData);
                } else {
                    colors = this.createColorsWithDefault(legendData, defaultColorArray);
                }
            } else if (toolData === Object(toolData)) {
                var _iteratorNormalCompletion22 = true;
                var _didIteratorError22 = false;
                var _iteratorError22 = undefined;

                try {
                    for (var _iterator22 = legendData[Symbol.iterator](), _step22; !(_iteratorNormalCompletion22 = (_step22 = _iterator22.next()).done); _iteratorNormalCompletion22 = true) {
                        var legendEle = _step22.value;

                        if (toolData.hasOwnProperty(legendEle)) {
                            usedColors.push(toolData[legendEle]);
                        } else {
                            unaccountedLegendElements.push(legendEle);
                        }
                    }
                    //check if object has desired keys
                } catch (err) {
                    _didIteratorError22 = true;
                    _iteratorError22 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion22 && _iterator22.return) {
                            _iterator22.return();
                        }
                    } finally {
                        if (_didIteratorError22) {
                            throw _iteratorError22;
                        }
                    }
                }

                if (usedColors.length === legendData.length) {
                    colors = toolData;
                } else if (usedColors.length > 0) {
                    toolDataAsArray = Object.values(toolData);
                    if (toolDataAsArray.length > legendData.length) {
                        colors = this.createColorsWithDefault(legendData, toolDataAsArray);
                    } else {
                        colors = this.createColorsWithDefault(legendData, defaultColorArray);
                    }
                } else {
                    toolDataAsArray = Object.values(toolData);
                    if (toolDataAsArray.length > legendData.length) {
                        colors = this.createColorsWithDefault(legendData, toolDataAsArray);
                    } else {
                        colors = this.createColorsWithDefault(legendData, defaultColorArray);
                    }
                }
            } else {
                colors = this.createColorsWithDefault(legendData, defaultColorArray);
            }

            return colors;
        }
    }, {
        key: 'createColorsWithDefault',
        value: function createColorsWithDefault(legendData, colors) {
            var mappedColors = {},
                count = 0;
            var _iteratorNormalCompletion23 = true;
            var _didIteratorError23 = false;
            var _iteratorError23 = undefined;

            try {
                for (var _iterator23 = legendData[Symbol.iterator](), _step23; !(_iteratorNormalCompletion23 = (_step23 = _iterator23.next()).done); _iteratorNormalCompletion23 = true) {
                    var legendEle = _step23.value;

                    if (count > colors.length - 1) {
                        count = 0;
                    }
                    mappedColors[legendEle] = colors[count];
                    count++;
                }
            } catch (err) {
                _didIteratorError23 = true;
                _iteratorError23 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion23 && _iterator23.return) {
                        _iterator23.return();
                    }
                } finally {
                    if (_didIteratorError23) {
                        throw _iteratorError23;
                    }
                }
            }

            return mappedColors;
        }

        /**cleanToolData
         *  cleans incoming toolData for consistency
         *
         * @param toolData
         * @returns object with tooldata
         */

    }, {
        key: 'cleanToolData',
        value: function cleanToolData() {
            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            var editOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            var data = options || {};

            if (!data.hasOwnProperty('rotateAxis')) {
                data.rotateAxis = false;
            }
            if (data.hasOwnProperty('stackToggle')) {
                if (data.stackToggle === 'stack-data' || data.stackToggle === true) {
                    data.stackToggle = true;
                } else {
                    data.stackToggle = false;
                }
            } else {
                data.stackToggle = false;
            }
            if (data.hasOwnProperty('colors')) {
                data.color = data.colors;
            }
            if (!data.hasOwnProperty('thresholds')) {
                data.thresholds = [];
            }

            //These are used in setting dynamic margins on the y Axis in jvCharts
            if (editOptions && editOptions.hasOwnProperty('yAxis') && editOptions.yAxis.hasOwnProperty('editable-text-size')) {
                data.yLabelFontSize = editOptions.yAxis['editable-text-size'];
                data.yLabelFormat = editOptions.yAxis['editable-num-format'];
            }
            return data;
        }
    }, {
        key: 'getMaxWidthForAxisData',
        value: function getMaxWidthForAxisData(axis, axisData, _vars, dimensions, margin, chartDiv) {
            var maxAxisText = '',
                formatType = void 0,
                dummySVG = void 0,
                axisDummy = void 0,
                width = void 0;
            //Dynamic left margin for charts with y axis
            if (_vars.rotateAxis) {
                //get length of longest text label and make the axis based off that
                var maxString = '',
                    height = parseInt(dimensions.height, 10) - margin.top - margin.bottom;

                //check if labels should be shown
                if (height !== 0 && height / axisData.values.length < parseInt(_vars.fontSize, 10)) {
                    axisData.hideValues = true;
                } else {
                    var _iteratorNormalCompletion24 = true;
                    var _didIteratorError24 = false;
                    var _iteratorError24 = undefined;

                    try {
                        for (var _iterator24 = axisData.values[Symbol.iterator](), _step24; !(_iteratorNormalCompletion24 = (_step24 = _iterator24.next()).done); _iteratorNormalCompletion24 = true) {
                            var axisValue = _step24.value;

                            var currentStr = axisValue.toString();
                            if (currentStr.length > maxString.length) {
                                maxString = currentStr;
                            }
                        }
                    } catch (err) {
                        _didIteratorError24 = true;
                        _iteratorError24 = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion24 && _iterator24.return) {
                                _iterator24.return();
                            }
                        } finally {
                            if (_didIteratorError24) {
                                throw _iteratorError24;
                            }
                        }
                    }

                    maxAxisText = maxString;
                }
            } else if (!!_vars.yLabelFormat || !!_vars.xLabelFormat) {
                var labelFormat = _vars.yLabelFormat,
                    expression = void 0;
                if (axis === 'x') {
                    labelFormat = _vars.xLabelFormat;
                }

                formatType = this.jvFormatValueType(axisData.values);
                expression = this.getFormatExpression(labelFormat);

                if (expression !== '') {
                    maxAxisText = expression(axisData.max);
                } else {
                    maxAxisText = this.jvFormatValue(axisData.max);
                }
            } else {
                formatType = this.jvFormatValueType(axisData.values);
                if (!axisData.hasOwnProperty('max')) {
                    var maxLength = 0;
                    var _iteratorNormalCompletion25 = true;
                    var _didIteratorError25 = false;
                    var _iteratorError25 = undefined;

                    try {
                        for (var _iterator25 = axisData.values[Symbol.iterator](), _step25; !(_iteratorNormalCompletion25 = (_step25 = _iterator25.next()).done); _iteratorNormalCompletion25 = true) {
                            var _axisValue = _step25.value;

                            if (_axisValue && _axisValue.length > maxLength) {
                                maxLength = _axisValue.length;
                                maxAxisText = _axisValue;
                            }
                        }
                    } catch (err) {
                        _didIteratorError25 = true;
                        _iteratorError25 = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion25 && _iterator25.return) {
                                _iterator25.return();
                            }
                        } finally {
                            if (_didIteratorError25) {
                                throw _iteratorError25;
                            }
                        }
                    }
                } else {
                    maxAxisText = this.jvFormatValue(axisData.max, formatType);
                }
            }

            //if (type === 'heatmap') {
            ////also need to check width of label
            //if (maxAxisText.length < axisData.label.length + 5) {
            ////need added space
            //if (axis === 'x') {
            //maxAxisText = axisData.label;
            //} else {
            //maxAxisText = axisData.label + 'Extra';
            //}
            //}
            //}

            //Create dummy svg to place max sized text element on
            dummySVG = chartDiv.append('svg').attr('class', 'dummy-svg');

            //Create dummy text element
            axisDummy = dummySVG.append('text').attr('font-size', function () {
                if (axis === 'y' && _vars.yLabelFontSize !== 'none') {
                    return _vars.yLabelFontSize;
                }
                if (axis === 'x' && _vars.xLabelFontSize !== 'none') {
                    return _vars.xLabelFontSize;
                }
                return _vars.fontSize;
            }).attr('x', 0).attr('y', 0).text(maxAxisText);

            //Calculate the width of the dummy text
            width = axisDummy.node().getBBox().width;
            //Remove the svg and text element
            chartDiv.select('.dummy-svg').remove();
            return width;
        }
    }, {
        key: 'getDisplayValuesElement',
        value: function getDisplayValuesElement(object, dataTableAlign, type) {
            var valuesArray = [];

            if (type === 'bar' || type === 'pie' || type === 'line' || type === 'area') {
                for (var key in dataTableAlign) {
                    if (dataTableAlign.hasOwnProperty(key)) {
                        if (key.indexOf('value') > -1) {
                            valuesArray.push(object[dataTableAlign[key]]);
                        }
                    }
                }
            } else {
                for (var _key3 in object) {
                    if (object.hasOwnProperty(_key3)) {
                        valuesArray.push(object[_key3]);
                    }
                }
            }
            return valuesArray;
        }

        /**getZScale
         *
         * gets the scale for the z axis
         * @params zAxisData, container, padding
         * @returns {{}}
         */

    }, {
        key: 'getZScale',
        value: function getZScale(zAxisData, container, _vars) {
            var zAxisScale = d3.scaleLinear().domain([d3.min(zAxisData.values), d3.max(zAxisData.values)]).rangeRound([_vars.NODE_MIN_SIZE, _vars.NODE_MAX_SIZE]).nice();
            return zAxisScale;
        }

        /**generateEventGroups
         *
         *
         * @params chartContainer, barData, chart
         */

    }, {
        key: 'generateEventGroups',
        value: function generateEventGroups(chartContainer, barData, chart) {
            var container = chart.config.container,
                dataToPlot = jvCharts.getPlotData(barData, chart),
                eventGroups = void 0;

            //Invisible rectangles on screen that represent bar groups. Used to show/hide tool tips on hover
            eventGroups = chartContainer.data(dataToPlot).enter().append('rect').attr('class', 'event-rect')
            //sets the x position of the bar
            .attr('x', function (d, i) {
                return chart._vars.rotateAxis ? 0 : container.width / barData.length * i;
            })
            //sets the y position of the bar
            .attr('y', function (d, i) {
                return chart._vars.rotateAxis ? container.height / barData.length * i : 0;
            })
            //sets the width position of the bar
            .attr('width', function () {
                return chart._vars.rotateAxis ? container.width : container.width / barData.length;
            })
            //sets the height position of the bar
            .attr('height', function () {
                return chart._vars.rotateAxis ? container.height / barData.length : container.height;
            }).attr('fill', 'transparent').attr('class', function (d, i) {
                return 'event-rect editable-bar bar-col-' + String(barData[i][chart.currentData.dataTable.label]).replace(/\s/g, '_').replace(/:/g, '_colon_').replace(/\./g, '_dot_');
            });

            return eventGroups;
        }
    }, {
        key: 'generateThresholdLegend',
        value: function generateThresholdLegend(chart) {
            var svg = chart.svg,
                colorLegendData = [],
                gLegend = void 0,
                legend = void 0;
            if (chart._vars.thresholds !== 'none') {
                for (var j = 0; j < Object.keys(chart._vars.thresholds).length; j++) {
                    colorLegendData.push(chart._vars.thresholds[j].thresholdName);
                }
            }

            gLegend = svg.append('g').attr('class', 'thresholdLegendContainer');

            legend = gLegend.selectAll('.thresholdLegend').data(colorLegendData).enter().append('g').attr('class', 'thresholdLegend').attr('transform', function (d, i) {
                var height = 19,
                    offset = 19 * colorLegendData.length / 2,
                    horz = -2 * 12,
                    vert = i * height - offset;
                return 'translate(' + horz + ',' + vert + ')';
            });

            legend.append('rect').attr('width', 12).attr('height', 12).style('fill', function (d, i) {
                return chart._vars.thresholds[i].thresholdColor;
            });

            legend.append('text').attr('x', 24).attr('y', 8).attr('font-size', '.75em').text(function (d) {
                return d;
            });

            //Centers the legend in the panel
            if (gLegend) {
                var legendWidth = gLegend.node().getBBox().width;
                gLegend.attr('transform', 'translate(' + (chart.config.container.width - legendWidth) + ',' + 10 * colorLegendData.length + ')');
            }
        }
    }, {
        key: 'attachClickEventsToLegend',
        value: function attachClickEventsToLegend(chart, legendElements, drawFunc) {
            //Adding the click event to legend rectangles for toggling on/off
            legendElements.on('click', function () {
                var selectedRect = d3.select(this),
                    dataHeaders = void 0;

                if (selectedRect._groups[0][0].attributes.opacity.value !== '0.2') {
                    selectedRect.attr('opacity', '0.2');
                } else {
                    selectedRect.attr('opacity', '1');
                }

                //Gets the headers of the data to be drawn
                dataHeaders = this.updateDataFromLegend(legendElements._groups);
                //Sets the legendData to the updated headers
                if (chart._vars.seriesFlipped) {
                    chart._vars.flippedLegendHeaders = dataHeaders;
                } else {
                    chart._vars.legendHeaders = dataHeaders;
                }

                //Plots the data
                chart._vars.transitionTime = 800; //Keep transition for toggling legend elements
                if (chart._vars.seriesFlipped) {
                    chart[drawFunc](chart.flippedData);
                } else {
                    chart[drawFunc](chart.data);
                }
                if (chart.applyEditMode) {
                    chart.applyEditMode();
                }
            });
        }

        /**generateVerticalLegendElements
         *
         * Creates the legend elements--rectangles and labels
         * @params chart, legendData, drawFunc
         */

    }, {
        key: 'generateVerticalLegendElements',
        value: function generateVerticalLegendElements(chart, legendData, drawFunc) {
            var _this3 = this;

            var svg = chart.svg,
                legend = void 0,
                legendDataLength = legendData.length,
                legendElementToggleArray = void 0,
                legendRectangles = void 0,
                legendText = void 0;

            chart._vars.gridSize = 20;

            if (!chart._vars.legendIndex) {
                chart._vars.legendIndex = 0;
            }

            if (!chart._vars.legendIndexMax) {
                chart._vars.legendIndexMax = Math.floor(legendDataLength / chart._vars.legendMax - 0.01);
            }

            //Check to see if legend element toggle array needs to be set
            if (chart._vars.legendIndexMax >= 0) {
                if (!chart._vars.legendHeaders) {
                    chart._vars.legendHeaders = JSON.parse(JSON.stringify(legendData));
                }

                legendElementToggleArray = this.getLegendElementToggleArray(chart._vars.legendHeaders, legendData);
            }

            legend = svg.append('g').attr('class', 'legend').attr('transform', 'translate(' + 18 + ',' + 20 + ')');

            //Adding colored rectangles to the legend
            legendRectangles = legend.selectAll('rect').data(legendData).enter().append('rect').attr('class', 'legendRect').attr('x', '3').attr('y', function (d, i) {
                return chart._vars.gridSize * (i % chart._vars.legendMax) * 1.1;
            }).attr('width', chart._vars.gridSize).attr('height', chart._vars.gridSize).attr('fill', function (d, i) {
                if (!legendElementToggleArray && !chart._vars.seriesFlipped || chart._vars.seriesFlipped && !legendElementToggleArray) {
                    return _this3.getColors(chart._vars.color, i, legendData[i]);
                }
                if (!chart._vars.seriesFlipped && legendElementToggleArray[i].toggle === true || chart._vars.seriesFlipped && legendElementToggleArray[i].toggle === true) {
                    return _this3.getColors(chart._vars.color, i, legendData[i]);
                }
                return chart._vars.emptyLegendSquare;
            }).attr('display', function (d, i) {
                if (i >= chart._vars.legendIndex * chart._vars.legendMax && i <= chart._vars.legendIndex * chart._vars.legendMax + (chart._vars.legendMax - 1)) {
                    return 'all';
                }
                return 'none';
            }).attr('opacity', '1');

            //Adding text labels for each rectangle in legend
            legendText = legend.selectAll('text').data(legendData).enter().append('text').attr('class', function (d, i) {
                return 'legendText editable editable-text editable-content editable-legend-' + i;
            }).attr('x', chart._vars.gridSize + 7).attr('y', function (d, i) {
                return chart._vars.gridSize * (i % chart._vars.legendMax) * 1.1 + 10;
            }).attr('text-anchor', 'start').attr('dy', '0.35em') //Vertically align with node
            .attr('fill', chart._vars.fontColor).attr('font-size', chart._vars.fontSize).attr('display', function (d, i) {
                if (i >= chart._vars.legendIndex * chart._vars.legendMax && i <= chart._vars.legendIndex * chart._vars.legendMax + (chart._vars.legendMax - 1)) {
                    return 'all';
                }
                return 'none';
            }).text(function (d, i) {
                var elementName = legendData[i];
                if (elementName.length > 20) {
                    return elementName.substring(0, 19) + '...';
                }
                return elementName;
            });

            //Adding info box to legend elements when hovering over
            legendText.data(legendData).append('svg:title').text(function (d) {
                return d;
            });

            //Only create carousel if the number of elements exceeds one legend "page"
            if (chart._vars.legendIndexMax > 0) {
                this.createVerticalCarousel(chart, legendData, drawFunc);
            }

            return legendRectangles;
        }

        /**createVerticalCarousel
         *
         * Draws the vertical legend carousel
         * @params chart, legendData, drawFunc
         */

    }, {
        key: 'createVerticalCarousel',
        value: function createVerticalCarousel(chart, legendData, drawFunc) {
            var _this4 = this;

            var svg = chart.svg,
                legendPolygon = void 0;

            //Adding carousel to legend
            svg.selectAll('.legend-carousel').remove();
            svg.selectAll('#legend-text-index').remove();

            legendPolygon = svg.append('g').attr('class', 'legend-carousel');

            //Creates left navigation arrow for carousel
            legendPolygon.append('polygon').attr('id', 'leftChevron').attr('class', 'pointer-cursor').style('fill', chart._vars.legendArrowColor).attr('transform', 'translate(0,' + (chart._vars.legendMax * chart._vars.gridSize + 50) + ')').attr('points', '0,7.5, 15,0, 15,15').on('click', function () {
                if (chart._vars.legendIndex >= 1) {
                    chart._vars.legendIndex--;
                }
                svg.selectAll('.legend').remove();
                var legendElements = _this4.generateVerticalLegendElements(chart, legendData, drawFunc);
                _this4.attachClickEventsToLegend(chart, legendElements, drawFunc, legendData);
            }).attr({
                display: function display() {
                    if (chart._vars.legendIndex === 0) {
                        return 'none';
                    }
                    return 'all';
                }
            });

            //Creates page number for carousel navigation
            legendPolygon.append('text').attr('id', 'legend-text-index').attr('x', 35).attr('y', 242.5).style('text-anchor', 'start').style('font-size', chart._vars.fontSize).text(function () {
                return chart._vars.legendIndex + 1 + ' / ' + (chart._vars.legendIndexMax + 1);
            }).attr({
                display: function display() {
                    if (chart._vars.legendIndexMax === 0) {
                        return 'none';
                    }
                    return 'all';
                }
            });

            //Creates right navigation arrow for carousel
            legendPolygon.append('polygon').attr('id', 'rightChevron').attr('class', 'pointer-cursor').style('fill', chart._vars.legendArrowColor).attr('transform', 'translate(85,' + (chart._vars.legendMax * chart._vars.gridSize + 50) + ')').attr('points', '15,7.5, 0,0, 0,15').on('click', function () {
                if (chart._vars.legendIndex < chart._vars.legendIndexMax) {
                    chart._vars.legendIndex++;
                }
                svg.selectAll('.legend').remove();
                var legendElements = _this4.generateVerticalLegendElements(chart, legendData, drawFunc);
                _this4.attachClickEventsToLegend(chart, legendElements, drawFunc, legendData);
            }).attr({
                display: function display() {
                    if (chart._vars.legendIndex === chart._vars.legendIndexMax) {
                        return 'none';
                    }
                    return 'all';
                }
            });
        }

        /**convertTableToTree
         *
         * Converts table data to tree structure
         * @params data, dataTable, numericCheck
         */

    }, {
        key: 'convertTableToTree',
        value: function convertTableToTree(data, dataTable, lastNodeAsValue) {
            var allHash = {},
                list = [],
                rootMap = {},
                currentMap = {},
                tableHeaders = [],
                count;
            if (dataTable) {
                for (var header in dataTable) {
                    if (header !== 'value' && header.indexOf('tooltip') === -1) {
                        tableHeaders.push(dataTable[header]);
                    }
                }
                if (dataTable.value) {
                    tableHeaders.push(dataTable.value);
                }
            }

            var _iteratorNormalCompletion26 = true;
            var _didIteratorError26 = false;
            var _iteratorError26 = undefined;

            try {
                for (var _iterator26 = data[Symbol.iterator](), _step26; !(_iteratorNormalCompletion26 = (_step26 = _iterator26.next()).done); _iteratorNormalCompletion26 = true) {
                    var dataEle = _step26.value;
                    //all of this is to change it to a tree structure and then call makeTree to structure the data appropriately for this viz
                    count = 0;
                    var _iteratorNormalCompletion27 = true;
                    var _didIteratorError27 = false;
                    var _iteratorError27 = undefined;

                    try {
                        for (var _iterator27 = tableHeaders[Symbol.iterator](), _step27; !(_iteratorNormalCompletion27 = (_step27 = _iterator27.next()).done); _iteratorNormalCompletion27 = true) {
                            var _header2 = _step27.value;

                            if (_header2 !== '') {
                                if (!dataEle[_header2.replace(/[_]/g, ' ')]) {
                                    dataEle[_header2.replace(/[_]/g, ' ')] = 'NULL_VALUE';
                                }
                                var currentValue = dataEle[_header2.replace(/[_]/g, ' ')].toString().replace(/["]/g, ''),
                                    nextMap = {};

                                if (count === 0) {
                                    //will take care of the first level and put into rootmap if it doesnt already exist in rootmap
                                    currentMap = rootMap[currentValue];
                                    if (!currentMap) {
                                        currentMap = {};
                                        rootMap[currentValue] = currentMap;
                                    }
                                    nextMap = currentMap;
                                    count++;
                                } else {
                                    nextMap = currentMap[currentValue];
                                    if (!nextMap) {
                                        nextMap = {};
                                        currentMap[currentValue] = nextMap;
                                    }
                                    currentMap = nextMap;
                                }
                            }
                        }
                    } catch (err) {
                        _didIteratorError27 = true;
                        _iteratorError27 = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion27 && _iterator27.return) {
                                _iterator27.return();
                            }
                        } finally {
                            if (_didIteratorError27) {
                                throw _iteratorError27;
                            }
                        }
                    }
                }
            } catch (err) {
                _didIteratorError26 = true;
                _iteratorError26 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion26 && _iterator26.return) {
                        _iterator26.return();
                    }
                } finally {
                    if (_didIteratorError26) {
                        throw _iteratorError26;
                    }
                }
            }

            this.makeTree(rootMap, list, lastNodeAsValue);
            allHash.name = 'root';
            allHash.children = list;
            return allHash;
        }

        /**makeTree
         *
         * Recurive function to build tree
         * @params map, list, isNumeric
         */

    }, {
        key: 'makeTree',
        value: function makeTree(map, list, lastNodeAsValue) {
            var childSet = [];
            for (var key in map) {
                if (map.hasOwnProperty(key)) {
                    var childMap = map[key],
                        dataMap = {},
                        childExists = childMap && Object.getOwnPropertyNames(childMap).length > 0,
                        numericCheck = lastNodeAsValue && Object.keys(childMap).length === 1 && !isNaN(Object.keys(childMap)[0]);
                    dataMap.name = key;
                    if (!childExists || numericCheck) {
                        dataMap.value = Object.keys(childMap)[0];
                        list.push(dataMap);
                    } else {
                        dataMap.children = childSet;
                        list.push(dataMap);
                        this.makeTree(childMap, childSet, lastNodeAsValue);
                        childSet = [];
                    }
                }
            }
        }

        /**convertTableToTreemap
         *
         * Loop through data to organize into treemap form
         * @params data, dataTableAlgin
         */

    }, {
        key: 'convertTableToTreemap',
        value: function convertTableToTreemap(data, dataTableAlign) {
            var _ref;

            var addedHeaderMap = {},
                childrenArray = [],
                seriesIndex;

            var _iteratorNormalCompletion28 = true;
            var _didIteratorError28 = false;
            var _iteratorError28 = undefined;

            try {
                for (var _iterator28 = data[Symbol.iterator](), _step28; !(_iteratorNormalCompletion28 = (_step28 = _iterator28.next()).done); _iteratorNormalCompletion28 = true) {
                    var dataEle = _step28.value;

                    var series = dataEle[dataTableAlign.series];
                    seriesIndex = addedHeaderMap[series];
                    dataEle.Parent = series;
                    if (seriesIndex) {
                        childrenArray[seriesIndex].children.push(dataEle);
                    } else {
                        var _childrenArray$push;

                        addedHeaderMap[series] = childrenArray.length;
                        childrenArray.push((_childrenArray$push = {}, _defineProperty(_childrenArray$push, dataTableAlign.series, series), _defineProperty(_childrenArray$push, 'Parent', 'Top Level'), _defineProperty(_childrenArray$push, 'children', [dataEle]), _childrenArray$push));
                    }
                }
            } catch (err) {
                _didIteratorError28 = true;
                _iteratorError28 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion28 && _iterator28.return) {
                        _iterator28.return();
                    }
                } finally {
                    if (_didIteratorError28) {
                        throw _iteratorError28;
                    }
                }
            }

            return _ref = {}, _defineProperty(_ref, dataTableAlign.series, 'Top Level'), _defineProperty(_ref, 'children', childrenArray), _ref;
        }
    }]);

    return jvCharts;
}();

module.exports = jvCharts;

},{"./jvTip.js":9}],5:[function(require,module,exports){
'use strict';
/***  jvComment ***/
'use-strict';
/**
* @name jvComment
* @desc Constructor for JV Comment - creates comments for a jv visualization and executes a callback for the comments to be saved
* @param {object} configObj - constructor object containing the jvChart and other options
* @return {undefined} - no return
*/

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function jvComment(configObj) {
    'use strict';

    var commentObj = this;
    commentObj.chartDiv = configObj.chartDiv;
    commentObj.showComments = false;
    commentObj.comments = setCommentsList(configObj.comments);
    commentObj.disabled = false;
    commentObj.drawCommentNodes();
    commentObj.onSaveCallback = configObj.onSaveCallback;
    commentObj.getMode = configObj.getMode;
}

jvComment.prototype.createMoveListener = createMoveListener;
jvComment.prototype.updatePosition = updatePosition;
jvComment.prototype.makeComment = makeComment;
jvComment.prototype.removeComment = removeComment;
jvComment.prototype.drawCommentNodes = drawCommentNodes;
jvComment.prototype.drawComment = drawComment;
jvComment.prototype.doubleClick = doubleClick;
jvComment.prototype.overlayDivPosition = overlayDivPosition;

/**
* @name setCommentsList
* @desc sets the appropriate comments object for a comments object
* @param {object} comments - list of comments to paint
* @return {comments} - object with comments list and max id
*/
function setCommentsList(comments) {
    var newComments = {};
    if ((typeof comments === 'undefined' ? 'undefined' : _typeof(comments)) === 'object') {
        if (!comments.list) {
            newComments.list = comments;
        }
        if (Object.keys(newComments.list).length > 0) {
            var maxId = 0;
            for (var id in newComments.list) {
                if (Number(id) > maxId) maxId = Number(id);
            }
            newComments.maxId = maxId;
        } else {
            newComments.maxId = 0;
        }
    } else {
        newComments.list = {};
        newComments.maxId = 0;
    }
    return newComments;
}

/**
* @name createMoveListener
* @desc creates the mousemove listener to determine if the user moves or resizes a comment
* @param {object} commentNode - comment that the user clicked on
* @return {undefined} - no return
*/
function createMoveListener(commentNode) {
    var commentObj = this,
        timeMouseDown = new Date().getTime();
    commentObj.chartDiv.on('mousemove', function () {
        //mouse move happend too quickly, chrome bug
        var timeMouseMove = new Date().getTime(),
            node = commentNode.node(),
            mouse = d3.mouse(node),
            mouseOnChartDiv = d3.mouse(commentObj.chartDiv.node()),
            resizeNode;
        if (timeMouseDown + 10 > timeMouseMove) {
            return;
        }
        //set the moved node, so we know to do a mouse up event
        commentObj.moved = commentNode;

        //resize in the right corner of the comment
        if (commentNode.select('.comment-padding')._groups[0][0] && (mouse[0] + 15 > node.clientWidth && mouse[1] + 15 > node.clientHeight || commentObj.moved.mouse)) {
            if (!commentObj.moved.mouse) {
                resizeNode = commentNode.select('.comment-padding');
                resizeNode.style('width', 'auto');
                resizeNode.style('height', 'auto');
            }
            //set the mouse event so we can update the location on mouse up
            commentObj.moved.mouse = mouse;
        } else {
            //move the comment node around the visual
            if (commentNode._groups[0][0].nodeName === 'text') {
                commentObj.chartDiv.select('.commentbox-readonly').remove();
            }
            commentNode.style('left', mouseOnChartDiv[0] + 'px').style('top', mouseOnChartDiv[1] + 'px');
            commentNode.attr('x', mouseOnChartDiv[0]).attr('y', mouseOnChartDiv[1]);
        }
    });
}

/**
* @name updatePosition
* @desc determines whether the user dragged a comment on the screen or updated its size and then creates the appropriate save function
* @return {undefined} - no return
*/
function updatePosition() {
    var commentObj = this,
        nodeToUpdate = commentObj.moved._groups[0][0],
        nodeId = nodeToUpdate.id.split('node')[1],
        comment = commentObj.comments.list[nodeId],
        x = void 0,
        y = void 0;
    if (Array.isArray(commentObj.moved.mouse)) {
        comment.binding.width = commentObj.moved.mouse[0];
        comment.binding.height = commentObj.moved.mouse[1];
    } else {
        x = Math.round(nodeToUpdate.getAttribute('x'));
        y = Math.round(nodeToUpdate.getAttribute('y'));
        comment.binding = {
            'x': x,
            'y': y,
            'xChartArea': commentObj.chartDiv._groups[0][0].clientWidth,
            'yChartArea': commentObj.chartDiv._groups[0][0].clientHeight,
            'currentX': x,
            'currentY': y,
            'showAsMarker': comment.binding.showAsMarker,
            'height': comment.binding.height,
            'width': comment.binding.width
        };
    }

    commentObj.onSaveCallback(comment, nodeId, 'edit');
}

/**
* @name makeComment
* @desc creates the comment entry box on the screen and attaches listeners to the save delete and cancel options
* @param {object} event - event that holds the mouse position for where the user wants to place the comment
* @return {undefined} - no return
*/
function makeComment(event) {
    if (this.chartDiv.select('.commentbox')._groups[0][0] || this.chartDiv.select('.commentbox-edit')._groups[0][0]) {
        //dont create new comment
        return;
    }

    var commentObj = this,
        x = parseInt(d3.mouse(event)[0], 10),
        y = parseInt(d3.mouse(event)[1], 10),
        commentHeight = 145,
        commentWidth = 200,

    //calculate position of overlay div
    position = commentObj.overlayDivPosition(commentWidth, commentHeight, x, y),
        commentType = 'svgMain';

    commentObj.chartDiv.selectAll('.commentbox-readonly').remove();

    commentObj.showComments = false;
    commentObj.chartDiv.append('div').attr('class', 'commentbox').attr('id', 'commentbox').style('opacity', 1).html("<div class='title'><b>Add New Comment</b></div>" + "<textarea placeholder='Enter comment...' form='commentform' class='comment-textarea' style='width:155px; height: 90px;' name='comment' id = 'textarea1'></textarea>" + "<br><input type='checkBox' class='commentbox-display' id ='display'> Display as marker" + "<br><button class='commentbox-close' id ='cancel'><i class='fa fa-close'></i></button>" + "<button class='smss-btn commentbox-submit' id = 'submit'>Submit Comment</button>").style('position', 'absolute').style('left', position.x + 'px').style('top', position.y + 'px');

    //Autofocus on the text area
    document.getElementById('textarea1').focus();

    commentObj.chartDiv.selectAll('.commentbox').select('#cancel').on('click.delete', function () {
        commentObj.removeComment();
    });

    commentObj.chartDiv.selectAll('.commentbox').select('#submit').on('click.save', function () {
        var commentText = commentObj.chartDiv.select('#commentbox').select('#textarea1')._groups[0][0].value,
            showAsMarker = commentObj.chartDiv.select('#commentbox').select('#display')._groups[0][0].checked,
            newCommentObj = void 0;

        newCommentObj = {
            'commentText': commentText,
            'groupID': 'group0',
            'type': commentType,
            'binding': {
                'x': x,
                'y': y,
                'xChartArea': commentObj.chartDiv._groups[0][0].clientWidth,
                'yChartArea': commentObj.chartDiv._groups[0][0].clientHeight,
                'currentX': x,
                'currentY': y,
                'showAsMarker': showAsMarker ? 'true' : 'false',
                'height': false,
                'width': false
            }
        };
        commentObj.chartDiv.select('.commentbox').remove();
        if (isNaN(commentObj.comments.maxId)) {
            commentObj.comments.maxId = -1;
        }
        commentObj.onSaveCallback(newCommentObj, ++commentObj.comments.maxId, 'add');
    });
}

/**
* @name removeComment
* @desc function to remove comment entry box
* @return {undefined} - no return
*/
function removeComment() {
    var commentObj = this;
    commentObj.chartDiv.selectAll('.commentbox').remove();
}

/**
* @name drawCommentNodes
* @desc function to draw a all comments on the visual
* @return {undefined} - no return
*/
function drawCommentNodes() {
    var commentObj = this,
        comments = commentObj.comments.list;

    commentObj.chartDiv.selectAll('.min-comment').remove();

    for (var id in comments) {
        if (comments.hasOwnProperty(id)) {
            commentObj.drawComment(comments[id], id);
        }
    }
}

/**
* @name drawComment
* @desc function to draw a single comment on the visual
* @param {object} comment - data used to pain the comment
* @param {number} id - id of the specific comment
* @return {undefined} - no return
*/
function drawComment(comment, id) {
    if (typeof this.chartDiv._groups === 'undefined') {
        console.log('Comment data is in old format, will not display or chart div doesnt exist');
        return;
    }

    if (!comment.binding || !this.chartDiv._groups[0][0]) {
        console.log('Comment data is in old format, will not display or chart div doesnt exist');
        return;
    }

    var commentObj = this,
        chartDiv = commentObj.chartDiv,
        binding = comment.binding,
        chartAreaWidth = chartDiv._groups[0][0].clientWidth,
        chartAreaHeight = chartDiv._groups[0][0].clientHeight,
        x = binding.x / binding.xChartArea * chartAreaWidth,
        y = binding.y / binding.yChartArea * chartAreaHeight,
        styleString = '',
        text = '',
        resize = false;

    binding.currentX = binding.x / binding.xChartArea * chartAreaWidth;
    binding.currentY = binding.y / binding.yChartArea * chartAreaHeight;

    if (comment.binding.showAsMarker === 'false') {
        if (comment.binding.width && comment.binding.height) {
            styleString = "style='width: " + comment.binding.width + 'px; height: ' + comment.binding.height + "px'";
        }
        if (comment.commentText.indexOf('<iframe') > -1 || comment.commentText.indexOf('<img') > -1 || comment.commentText.indexOf('<svg') > -1) {
            //contains elents that should resize
            text = "<div class='comment-padding text'" + styleString + "><div class='user-comment'>" + comment.commentText + '</div></div>';
            resize = true;
        } else {
            text = '<div class="text editable editable-text editable-comment-' + id + '">' + comment.commentText + '<div/>';
        }
        chartDiv.append('div').attr('class', 'min-comment').attr('id', 'node' + id).style('opacity', 1).style('position', 'absolute')
        //.style("border", "1px solid black")
        .html(text).style('left', x + 'px').style('top', y + 'px').on('dblclick.comment', function () {
            //Edit text or delete the comment
            commentObj.doubleClick(this, x, y);
        });
        if (resize) {
            var parent = d3.select('.user-comment');
            rescale(parent, parent.node());
        }
    } else {
        chartDiv.select('svg').append('text').attr('class', 'min-comment').attr('id', 'node' + id).attr('fill', '#e6e6e6').attr('x', x).attr('y', y).attr('font-family', 'FontAwesome').attr('stroke', 'darkgray').attr('font-size', '15px').text('\uF0E5').attr('opacity', 1).on('dblclick.comment', function () {
            //Edit text or delete the comment
            commentObj.doubleClick(this, x, y);
        }).on('mouseenter.comment', function () {
            //Show hover over box when mouse enters node
            if (commentObj.showComments === false) {
                var commentText = '',
                    commentHeight = 80,
                    commentWidth = 185,
                    position = void 0;

                for (var j in commentObj.comments.list) {
                    if (Math.round(commentObj.comments.list[j].binding.currentX) === Math.round(this.x.baseVal[0].value)) {
                        if (Math.round(commentObj.comments.list[j].binding.currentY) === Math.round(this.y.baseVal[0].value)) {
                            commentText = commentObj.comments.list[j].commentText;
                            x = commentObj.comments.list[j].binding.currentX;
                            y = commentObj.comments.list[j].binding.currentY;
                        }
                    }
                }
                position = commentObj.overlayDivPosition(commentWidth, commentHeight, x, y);

                chartDiv.append('div').attr('class', 'commentbox-readonly').style('opacity', 1).style('position', 'absolute').html("<textarea readonly rows='4' cols='27' class='textarea' name='comment'>" + commentText + '</textarea>').style('left', position.x + 'px').style('top', position.y + 'px');
            }
        }).on('mouseout.comment', function () {
            //Remove hover over box when mouse moves away
            if (commentObj.showComments === false) {
                chartDiv.select('.commentbox-readonly').remove();
            }
        });
    }
}

/**
* @name rescale
* @desc sets the children of the ele param to 100 percent height and width
* @param {d3node} ele - node to start recursive function
* @param {htmlNode} commentNode - unused parent node that can be used to calcualte percent height and widths
* @return {undefined} - no return
*/
function rescale(ele, commentNode) {
    var node = ele.node(),
        width = 100,
        height = 100;
    //width = node.clientWidth / commentNode.clientWidth * 100;
    //height = node.clientHeight / commentNode.clientHeight * 100;
    //if (width > 100) {
    //width = 100;
    //}

    //if (height > 100) {
    //height = 100;
    //}

    ele.style('width', width + '%');
    ele.style('height', height + '%');
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = node.childNodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var child = _step.value;

            rescale(d3.select(child), commentNode);
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
}

/**
* @name doubleClick
* @desc click function after the user clicks on an existing comment
* @param {object} commentNode - current comment that the user clicked
* @param {number} x - x position of the click event
* @param {number} y - y position of the click event
* @return {undefined} - no return
*/
function doubleClick(commentNode, x, y) {
    if (this.chartDiv.select('.commentbox-edit')._groups[0][0] || this.getMode() !== 'comment-mode') {
        //dont create new comment
        return;
    }
    var commentObj = this,
        chartDiv = commentObj.chartDiv,
        currentComment = commentNode.id.split('node')[1],
        commentText = commentObj.comments.list[currentComment].commentText,
        commentHeight = 145,
        commentWidth = 200,
        position = commentObj.overlayDivPosition(commentWidth, commentHeight, x, y);

    commentObj.showComments = false;
    chartDiv.selectAll('.commentbox-readonly').remove();
    chartDiv.selectAll('.commentbox-edit').remove();
    chartDiv.selectAll('.commentbox').remove();

    chartDiv.append('div').attr('class', 'commentbox-edit').style('opacity', 1).style('left', position.x + 'px').style('top', position.y + 'px').style('position', 'absolute').html("<div class='title'><b>Edit Comment</b></div>" + "<textarea id='edit' class='comment-textarea' style='width:155px; height: 90px;' name='comment'>" + commentText + '</textarea>' + "<br><input type='checkBox' class='commentbox-display' id ='display'> Display as marker" + "<br><button class='commentbox-close' id ='cancel-edit'><i class='fa fa-close'></i></button>" + "<button class='smss-btn' id ='delete'>Delete</button>" + "<button class='smss-btn' id = 'save'>Save</button>");

    chartDiv.select('.commentbox-edit').select('#display')._groups[0][0].checked = commentObj.comments.list[currentComment].binding.showAsMarker === 'true';

    chartDiv.selectAll('.commentbox-edit').select('#delete').on('click.delete', function () {
        chartDiv.select('.commentbox-edit').remove();
        chartDiv.select('.commentbox-readonly').remove();
        chartDiv.select('#node' + currentComment).attr('display', 'none');
        //redraw comment nodes with new indexes
        commentObj.onSaveCallback(commentObj.comments.list[currentComment], currentComment, 'remove');
    });

    chartDiv.selectAll('.commentbox-edit').select('#save').on('click.save', function () {
        var text = chartDiv.select('.commentbox-edit').select('#edit')._groups[0][0].value,
            showAsMarker = chartDiv.select('.commentbox-edit').select('#display')._groups[0][0].checked;
        commentObj.comments.list[currentComment].commentText = text;
        commentObj.comments.list[currentComment].binding.showAsMarker = showAsMarker ? 'true' : 'false';
        chartDiv.select('.commentbox-readonly').remove();
        chartDiv.select('.commentbox-edit').remove();
        commentObj.onSaveCallback(commentObj.comments.list[currentComment], currentComment, 'edit');
    });

    chartDiv.selectAll('.commentbox-edit').select('#cancel-edit').on('click.cancel-edit', function () {
        chartDiv.select('.commentbox-readonly').remove();
        chartDiv.select('.commentbox-edit').remove();
    });
}

/******************************* Utility functions **********************************************/
/**
* @name overlayDivPosition
* @desc function to determine the placement of the div on the visual
* @param {number} divWidth - width of the comment entry box
* @param {number} divHeight - height of the comment entry box
* @param {number} mouseX - x position of the click event
* @param {number} mouseY - y position of the click event
* @return {object} - position of div
*/
function overlayDivPosition(divWidth, divHeight, mouseX, mouseY) {
    var editObj = this,
        position = {
        x: mouseX,
        y: mouseY + 10
    };
    if (mouseX > parseInt(editObj.chartDiv.style('width'), 10) / 2) {
        position.x = mouseX - divWidth;
    }
    if (mouseY - divHeight - 10 > 0) {
        position.y = mouseY - divHeight - 10;
    }
    return position;
}

module.exports = jvComment;

},{}],6:[function(require,module,exports){
/***  jvEdit ***/
'use strict';

var editTemplate = require('./editOptionsTemplate.js');

/**
* @name jvEdit
* @desc Constructor for JV Edit - creates edits to a jv visualization and executes a callback for the edit options to be saved
* @param {object} configObj - constructor object containing the jvChart and other options
* @return {undefined} - no return
*/
function jvEdit(configObj) {
    var editObj = this;
    editObj.chartDiv = configObj.chartDiv;
    editObj.vizOptions = configObj.vizOptions ? configObj.vizOptions : {};
    editObj.chartDiv.selectAll('.edit-div').remove();
    editObj.editDiv = editObj.chartDiv.append('div').attr('class', 'edit-div');
    editObj.onSaveCallback = configObj.onSaveCallback;
}

jvEdit.prototype.displayEdit = displayEdit;
jvEdit.prototype.changeFontSize = changeFontSize;
jvEdit.prototype.submitEditMode = submitEditMode;
jvEdit.prototype.applyEditMode = applyEditMode;
jvEdit.prototype.applyAllEdits = applyAllEdits;
jvEdit.prototype.removeEdit = removeEdit;
jvEdit.prototype.overlayDivPosition = overlayDivPosition;

/**
* @name displayEdit
* @desc Displays the edit div, grabbing it from the template
* @param {array} mouse - mouse location of the click event, used to place the edit mode div on the visual
* @param {string} options - css class of clicked element, provides the options that are editable by edit mode
* @return {undefined} - no return
*/
function displayEdit(mouse, options) {
    var editObj = this,
        mouseX = mouse[0],
        mouseY = mouse[1],
        optionValues = [],
        itemToChange = '',
        editOptionElement,
        editHeight = parseFloat(editObj.editDiv.style('height')),
        editWidth = parseFloat(editObj.editDiv.style('width')),
        position;

    //return if you click on the same element twice, no need to display a second edit div if the current one is still open
    if (editObj.editOptions === options) {
        return;
    }
    editObj.editDiv.html('');
    editObj.editOptions = options;

    //assign html to editDiv (basically displays the div)
    editObj.editDiv.html(editTemplate);

    //optionValues - an array of strings.
    //String is the id to the element in the editDiv form.
    //This string contains the specific option that is being changed

    //itemToChange
    //String that is the class of the svg element to be changed on the viz itself
    editOptionElement = editObj.editDiv.select('#edit-option-element');

    //if statements to determine which edit options to display
    if (options.indexOf('editable-yAxis') >= 0) {
        editOptionElement.html('&nbsp;for Y Axis');
        editOptionElement.style('visibility', 'visible');
        itemToChange = 'yAxis';
    } else if (options.indexOf('editable-xAxis') >= 0) {
        editOptionElement.html('&nbsp;for X Axis');
        editOptionElement.style('visibility', 'visible');
        itemToChange = 'xAxis';
    } else if (options.indexOf('yLabel') >= 0) {
        editOptionElement.html('&nbsp;for Y Label');
        editOptionElement.style('visibility', 'visible');
        itemToChange = 'yLabel';
    } else if (options.indexOf('xLabel') >= 0) {
        editOptionElement.html('&nbsp;for X Label');
        editOptionElement.style('visibility', 'visible');
        itemToChange = 'xLabel';
    } else if (options.indexOf('legendText') >= 0) {
        editOptionElement.html('&nbsp;for Legend Item');
        editOptionElement.style('visibility', 'visible');
        itemToChange = options.substring(options.indexOf('editable-legend-')).split(' ')[0];
    } else if (options.indexOf('editable-bar') >= 0) {
        editOptionElement.html('&nbsp;for Bar Chart');
        editOptionElement.style('visibility', 'visible');
        editObj.editDiv.select('.editable-bar').style('display', 'block');
        optionValues.push('editable-bar');
        itemToChange = options.substring(options.indexOf('bar-col-')).split(' ')[0];
    } else if (options.indexOf('editable-pie') >= 0) {
        editOptionElement.html('&nbsp;for Pie Slice');
        editOptionElement.style('visibility', 'visible');
        editObj.editDiv.select('.editable-pie').style('display', 'block');
        optionValues.push('editable-pie');
        itemToChange = options.substring(options.indexOf('pie-slice-')).split(' ')[0];
    } else if (options.indexOf('editable-scatter') >= 0) {
        editOptionElement.html('&nbsp;for Scatter Plot');
        editOptionElement.style('visibility', 'visible');
        editObj.editDiv.select('.editable-scatter').style('display', 'block');
        optionValues.push('editable-scatter');
        itemToChange = options.substring(options.indexOf('scatter-circle-')).split(' ')[0];
    } else if (options.indexOf('editable-bubble') >= 0) {
        editOptionElement.html('&nbsp;for Bubble Chart');
        editOptionElement.style('visibility', 'visible');
        editObj.editDiv.select('.editable-bubble').style('display', 'block');
        optionValues.push('editable-bubble');
        itemToChange = options.substring(options.indexOf('bubble-')).split(' ')[0];
    } else if (options.indexOf('editable-box') >= 0) {
        editOptionElement.html('&nbsp;for Box and Whisker Plot');
        editOptionElement.style('visibility', 'visible');
        editObj.editDiv.select('.editable-box').style('display', 'block');
        optionValues.push('editable-box');
        itemToChange = options.substring(options.indexOf('box-')).split(' ')[0];
    } else if (options.indexOf('editable-comment') >= 0) {
        editOptionElement.html('&nbsp;for Comment');
        editOptionElement.style('visibility', 'visible');
        itemToChange = options.substring(options.indexOf('editable-comment-')).split(' ')[0];
    } else if (options.indexOf('editable-svg') >= 0) {
        editOptionElement.html('&nbsp;for All Text');
        editOptionElement.style('visibility', 'visible');
        editObj.editDiv.select('.editable-text-size-buttons').style('display', 'block');
        optionValues.push('editable-text-size');
        itemToChange = 'svg';
    } else {
        console.log('Still need to add option to display edit');
    }

    if (options.indexOf('editable-num') >= 0) {
        editObj.editDiv.select('.editable-num-format').style('display', 'block');
        optionValues.push('editable-num-format');
    }
    if (options.indexOf('editable-text') >= 0) {
        editObj.editDiv.select('.editable-text-color').style('display', 'block');
        optionValues.push('editable-text-color');
        editObj.editDiv.select('.editable-text-size').style('display', 'block');
        optionValues.push('editable-text-size');
    }
    if (options.indexOf('editable-content') >= 0) {
        editObj.editDiv.select('.editable-content').style('display', 'block');
        optionValues.push('editable-content');
    }

    //populate edit div with initial values
    if (editObj.vizOptions[itemToChange]) {
        populateSelectionsEditMode(editObj.editDiv, editObj.vizOptions[itemToChange]);
    }
    editObj.editDiv.style('display', 'block').style('left', 0 + 'px').style('top', 0 + 'px');

    //calculate position of overlay div
    editHeight = parseFloat(editObj.editDiv.style('height'));
    editWidth = parseFloat(editObj.editDiv.style('width'));
    position = editObj.overlayDivPosition(editWidth, editHeight, mouseX, mouseY);

    //show the new edit div
    editObj.editDiv.style('left', position.x + 'px').style('top', position.y + 'px');

    //add submit, default, and exit listeners to the div
    editObj.editDiv.select('#submitEditMode').on('click', function () {
        editObj.submitEditMode(optionValues, itemToChange);
        editObj.removeEdit();
    });
    editObj.editDiv.select('#submitEditModeDefault').on('click', function () {
        editObj.submitEditMode(optionValues, itemToChange, true);
        editObj.removeEdit();
    });
    editObj.editDiv.select('#exitEditMode').on('click', function () {
        editObj.removeEdit();
    });
    editObj.fontSizeIncrement = 0;

    //Click events for increase/decrease font size buttons
    editObj.editDiv.select('#increaseFontSize').on('click', increaseFontSize.bind(editObj));
    editObj.editDiv.select('#decreaseFontSize').on('click', decreaseFontSize.bind(editObj));
}

/**
* @name increaseFontSize
* @desc Increases font size by an increment
* @return {undefined} - no return
*/
function increaseFontSize() {
    var editObj = this,
        fontIncrement = 1,
        maxSize = 28;
    if (editObj.fontSizeIncrement < maxSize) {
        editObj.changeFontSize(fontIncrement);
        editObj.fontSizeIncrement++;
        editObj.vizOptions.text = { 'editable-text-increment': editObj.fontSizeIncrement };
    }
}

/**
* @name decreaseFontSize
* @desc Decreases font size by an increment
* @return {undefined} - no return
*/
function decreaseFontSize() {
    var editObj = this,
        fontDecrement = -1,
        minSize = -12;
    //min size is neg 12 because default size is 12px on our charts
    if (editObj.fontSizeIncrement > minSize) {
        editObj.changeFontSize(fontDecrement);
        editObj.fontSizeIncrement--;
        editObj.vizOptions.text = { 'editable-text-increment': editObj.fontSizeIncrement };
    }
}

/**
* @name changeFontSize
* @desc Increases or decreases font size by a certain increment
* @param {integer} increment - number of increment
* @return {undefined} - no return
*/
function changeFontSize(increment) {
    var editObj = this;
    editObj.chartDiv.selectAll('text').each(function () {
        updateFont(this, increment);
    });
    editObj.chartDiv.selectAll('.text').each(function () {
        updateFont(this, increment);
    });
}

/**
* @name updateFont
* @desc changes the size of the font by a given increment
* @param {htmlNode} thisDiv - node to change font size
* @param {integer} increment - number of increment
* @return {undefined} - no return
*/
function updateFont(thisDiv, increment) {
    var newSize,
        textSize = 12;
    if (thisDiv && thisDiv.getAttribute('font-size')) {
        textSize = thisDiv.getAttribute('font-size');
        newSize = parseInt(textSize, 10) + increment;
        thisDiv.setAttribute('font-size', newSize + 'px');
    } else if (thisDiv) {
        textSize = parseInt(window.getComputedStyle(thisDiv, null).getPropertyValue('font-size'), 10) + increment;
        thisDiv.style.fontSize = textSize + 'px';
    }
}

/**
* @name populateSelectionsEditMode
* @desc Initially populates the editDiv if there are vizOptions
* @param {htmlNode} editDiv - edit mode options div
* @param {object} vizOptions - current user options to apply to the edit div
* @return {undefined} - no return
*/
function populateSelectionsEditMode(editDiv, vizOptions) {
    for (var option in vizOptions) {
        if (vizOptions.hasOwnProperty(option)) {
            var selectedObject = editDiv.select('#' + option)._groups[0][0];
            //default color inputs to gray
            if (vizOptions[option] === 'default') {
                if (selectedObject.type === 'color') {
                    if (selectedObject.id.indexOf('text') > 0) {
                        selectedObject.value = '#000000';
                    } else {
                        selectedObject.value = '#aaaaaa';
                    }
                }
            } else {
                selectedObject.value = vizOptions[option];
            }
        }
    }
}

/**
* @name submitEditMode
* @desc calls save callback on edit mode with edit options
* @param {object} optionValues - new user options to save
* @param {object} possibleItemToChange - item that the user clicked (might not be the actual item to update)
* @param {object} defaultBtnClicked - reset viz option to default
* @return {undefined} - no return
*/
function submitEditMode(optionValues, possibleItemToChange, defaultBtnClicked) {
    var editObj = this,
        optionArray = optionValues,
        selectedEditOptions = {},
        editValue = void 0,
        selectedObj = void 0,
        itemToChange = possibleItemToChange;

    for (var i = 0; i < optionArray.length; i++) {
        if (optionArray[i].indexOf('editable-legend') > 0) {
            //change item to change for legend elements
            itemToChange = optionArray[i];
        }
        selectedObj = editObj.editDiv.select('#' + optionArray[i]);
        //see if selected object exists
        if (selectedObj && selectedObj._groups[0] && selectedObj._groups[0][0]) {
            editValue = selectedObj._groups[0][0].value;
            //get selected option from edit div
            if (optionArray[i] === 'editable-content' && editValue === '') {
                //dont add an empty string to the viz options for editable content
                break;
            }
            selectedEditOptions[optionArray[i]] = editValue;
            if (!selectedEditOptions[optionArray[i]] && optionArray[i].indexOf('content') < 0) {
                selectedEditOptions[optionArray[i]] = 'default';
            }
        }
    }

    if (defaultBtnClicked) {
        if (itemToChange === 'svg') {
            delete editObj.vizOptions.text;
        }
        delete editObj.vizOptions[itemToChange];
    } else {
        editObj.vizOptions[itemToChange] = selectedEditOptions;
    }

    if (itemToChange === 'svg') {
        delete editObj.vizOptions.svg;
    }

    //save vizOptions
    editObj.onSaveCallback(editObj.vizOptions);
}

/**
* @name applyEditMode
* @desc applies individual viz option on the visual
* @param {string} itemToChange - viz option to update
* @param {object} options - viz option properties
* @return {undefined} - no return
*/
function applyEditMode(itemToChange, options) {
    var editObj = this,
        object = editObj.chartDiv.select('.' + itemToChange),
        objectGroups = object._groups,
        objectTagName = objectGroups[0][0] ? objectGroups[0][0].tagName.toLowerCase() : null;

    if (itemToChange === 'text') {
        //do something if it is all the text that is being changed
        object = editObj.chartDiv.selectAll('text');
    }

    //options by tagName
    if (objectTagName === 'g') {
        object = editObj.chartDiv.select('.' + itemToChange).selectAll('text');
    } else if (objectTagName === 'rect') {
        if (options['editable-bar']) {
            object.attr('fill', options['editable-bar']);
        }
        if (options['editable-box']) {
            object.attr('fill', options['editable-box']);
        }
    } else if (objectTagName === 'circle') {
        if (options['editable-scatter']) {
            object.attr('fill', options['editable-scatter']);
        }
        if (options['editable-bubble']) {
            object.attr('fill', options['editable-bubble']);
        }
    } else if (objectTagName === 'path') {
        if (options['editable-pie']) {
            object.attr('fill', options['editable-pie']);
        }
    }

    //standard options
    //If a text increment exists, apply it based on the sign of the variable
    if (options.hasOwnProperty('editable-text-increment')) {
        editObj.changeFontSize(options['editable-text-increment']);
    }

    if (options.hasOwnProperty('editable-text-size')) {
        object.style('font-size', options['editable-text-size'] + 'px');
    }
    if (options.hasOwnProperty('editable-text-color')) {
        object.style('fill', options['editable-text-color']);
        object.style('color', options['editable-text-color']);
    }
    if (options.hasOwnProperty('editable-num-format')) {
        var expression = getFormatExpression(options['editable-num-format']);
        object.transition().text(function (d) {
            if (!isNaN(d) && typeof expression === 'function') {
                return expression(d);
            }
            return d;
        });
    }
    if (options.hasOwnProperty('editable-content')) {
        if (options['editable-content'].length > 0) {
            object.html(options['editable-content']);
        }
    }
    editObj.removeEdit();
}

/**
* @name applyAllEdits
* @desc applies all viz options in the edit mode object
* @return {undefined} - no return
*/
function applyAllEdits() {
    var editObj = this;
    for (var option in editObj.vizOptions) {
        if (editObj.vizOptions.hasOwnProperty(option) && editObj.chartDiv.select(option)) {
            editObj.applyEditMode(option, editObj.vizOptions[option]);
        }
    }
}

/**
* @name removeEdit
* @desc removes edit div from the visual
* @return {undefined} - no return
*/
function removeEdit() {
    var editObj = this;
    if (editObj.editDiv) {
        editObj.editDiv.html('');
        editObj.editDiv.style('display', 'none');
    }
    editObj.editOptions = '';
}

/**
* @name overlayDivPosition
* @desc function to determine the placement of the div on the visual
* @param {number} divWidth - width of the comment entry box
* @param {number} divHeight - height of the comment entry box
* @param {number} mouseX - x position of the click event
* @param {number} mouseY - y position of the click event
* @return {object} - position of div
*/
function overlayDivPosition(divWidth, divHeight, mouseX, mouseY) {
    var editObj = this,
        position = {
        x: mouseX,
        y: mouseY + 10
    };
    if (mouseX > parseInt(editObj.chartDiv.style('width'), 10) / 2) {
        position.x = mouseX - divWidth;
    }
    if (mouseY - divHeight - 10 > 0) {
        position.y = mouseY - divHeight - 10;
    }
    return position;
}

/**
* @name getFormatExpression
* @desc returns the d3 format expression for a given option
* @param {string} option - type of data format
* @return {function} - expression
*/
function getFormatExpression(option) {
    var expression = '',
        p = void 0;
    if (option === 'currency') {
        expression = d3.format('$,');
    } else if (option === 'fixedCurrency') {
        expression = d3.format('($.2f');
    } else if (option === 'percent') {
        p = Math.max(0, d3.precisionFixed(0.05) - 2);
        expression = d3.format('.' + p + '%');
    } else if (option === 'millions') {
        p = d3.precisionPrefix(1e5, 1.3e6);
        expression = d3.formatPrefix('.' + p, 1.3e6);
    } else if (option === 'commas') {
        expression = d3.format(',.0f');
    } else {
        expression = d3.format('');
    }
    return expression;
}

module.exports = jvEdit;

},{"./editOptionsTemplate.js":1}],7:[function(require,module,exports){
/***jvEvents
 * Eventing layer on top of JV Charts to allow custom callbacks to be attached to mouse events
 */
'use strict';

var jvCharts = require('./jvCharts.js'),
    jvComment = require('./jvComment.js'),
    jvEdit = require('./jvEdit.js'),
    jvBrush = require('./jvBrush.js');

jvCharts.prototype.initializeModes = initializeModes;
jvCharts.prototype.createDefaultMode = createDefaultMode;
jvCharts.prototype.createCommentMode = createCommentMode;
jvCharts.prototype.createEditMode = createEditMode;
jvCharts.prototype.createBrushMode = createBrushMode;
jvCharts.prototype.createSelectMode = createSelectMode;
jvCharts.prototype.toggleModes = toggleModes;
jvCharts.prototype.toggleDefaultMode = toggleDefaultMode;
jvCharts.prototype.toggleCommentMode = toggleCommentMode;
jvCharts.prototype.toggleEditMode = toggleEditMode;
jvCharts.prototype.toggleBrushMode = toggleBrushMode;
jvCharts.prototype.toggleSelectMode = toggleSelectMode;
jvCharts.prototype.addBrushEvents = addBrushEvents;

/**
* @name initializeModes
* @desc function that initializes and creates the chart toolbar
* @return {undefined} - no return
*/
function initializeModes() {
    var chart = this,
        callbacks = chart.config.callbacks;

    //check if callbacks are needed
    if (callbacks) {
        for (var mode in callbacks) {
            //loop through all the types of modes to initialize the mode and register the appropriate events
            if (callbacks.hasOwnProperty(mode) && callbacks[mode]) {
                var camelCaseMode = mode.charAt(0).toUpperCase() + mode.slice(1);
                chart[mode] = chart['create' + camelCaseMode]();
            }
        }
        if (chart.editMode) {
            chart.editMode.applyAllEdits();
        }
        chart.toggleModes(chart.mode);
    } else {
        chart.createDefaultMode();
        //user has not defined any other modes, so just use default mode
        chart.toggleDefaultMode('default-mode');
    }
}

/**
* @name createDefaultMode
* @desc function that initializes and creates the default mode
* @return {undefined} - no return
*/
function createDefaultMode() {
    var chart = this;
    if (chart.config.callbacks && chart.config.callbacks.defaultMode.onBrush) {
        chart.brushMode = chart.createBrushMode(chart.config.callbacks.defaultMode.onBrush);
    }
}

/**
* @name createCommentMode
* @desc function that initializes and creates the comment mode
* @return {jvComment} - created comment mode
*/
function createCommentMode() {
    var chart = this;
    return new jvComment({
        chartDiv: chart.chartDiv,
        comments: chart.config.comments || {},
        onSaveCallback: chart.config.callbacks.commentMode.onSave,
        getMode: function getMode() {
            return chart.mode;
        }
    });
}

/**
* @name createEditMode
* @desc function that initializes and creates the edit mode
* @return {jvEdit} - created edit mode object
*/
function createEditMode() {
    var chart = this;
    return new jvEdit({
        chartDiv: chart.chartDiv,
        vizOptions: chart.config.editOptions || {},
        onSaveCallback: chart.config.callbacks.editMode.onSave
    });
}

/**
* @name createBrushMode
* @desc function that initializes and creates the brush mode
* @param {function} callbackParam - function that is an optional callback for brush mode
* @return {jvBrush} - created brush mode object
*/
function createBrushMode(callbackParam) {
    var chart = this,
        callback = callbackParam;
    if (!callback) {
        if (chart.config.callbacks.brushMode && typeof chart.config.callbacks.brushMode.onBrush === 'function') {
            callback = chart.config.callbacks.brushMode.onBrush;
        } else {
            console.log('no brush callback, pass it into the callbacks option');
            return null;
        }
    }
    return new jvBrush({
        chartDiv: chart.chartDiv,
        jvChart: chart,
        onBrushCallback: callback
    });
}

/**
* @name createSelectMode
* @desc function that initializes and creates the select mode
* @return {boolean} - true since the creation of a mode is only called when callbacks for the mode exist
*/
function createSelectMode() {
    return true;
}

/**
* @name toggleModes
* @desc sets the correct events for the specific mode param
* @param {string} mode - specified mode to toggle to
* @return {undefined} - no return
*/
function toggleModes(mode) {
    var chart = this;
    chart.toggleDefaultMode(mode);
    chart.commentMode && chart.toggleCommentMode(mode);
    chart.editMode && chart.toggleEditMode(mode);
    chart.brushMode && chart.toggleBrushMode(mode);
    chart.selectMode && chart.toggleSelectMode(mode);
}

/**
* @name toggleDefaultMode
* @desc updates event listeners for default mode
* @param {string} mode - specified mode to toggle to
* @return {undefined} - no return
*/
function toggleDefaultMode(mode) {
    var chart = this;
    if (mode === 'default-mode') {
        var defaultMode = chart.config.callbacks ? chart.config.callbacks.defaultMode : false,
            entireSvg = chart.chartDiv.select('svg'),
            callbacks = void 0;
        //change cursor and show tooltips
        chart.chartDiv.style('cursor', 'default');
        chart.showToolTip = true;

        //return if no callbacks exist
        if (!defaultMode) {
            return;
        }
        callbacks = {
            onDoubleClick: function onDoubleClick(event, mouse) {
                if (typeof defaultMode.onDoubleClick === 'function') {
                    defaultMode.onDoubleClick(getEventObj(event, mouse, chart, 'doubleClick'));
                }
            },
            onClick: function onClick(event, mouse) {
                if (typeof defaultMode.onClick === 'function') {
                    defaultMode.onClick(getEventObj(event, mouse, chart, 'click'));
                }
            },
            onHover: function onHover(event, mouse) {
                if (typeof defaultMode.onHover === 'function') {
                    defaultMode.onHover(getEventObj(event, mouse, chart, 'onHover'));
                }
            },
            offHover: function offHover(event, mouse, prevEventData) {
                if (typeof defaultMode.offHover === 'function') {
                    var newEventData = event;
                    if (prevEventData && prevEventData.eventType === 'onHover') {
                        newEventData = prevEventData;
                    }
                    defaultMode.offHover(getEventObj(newEventData, mouse, chart, 'offHover'));
                }
            },
            onKeyUp: function onKeyUp() {
                if (typeof defaultMode.onKeyUp === 'function') {
                    var e = d3.event;
                    defaultMode.onKeyUp({
                        eventType: 'onKeyUp',
                        key: e.key,
                        event: e,
                        keyCode: e.keyCode
                    });
                }
            },
            onKeyDown: function onKeyDown() {
                if (typeof defaultMode.onKeyDown === 'function') {
                    var e = d3.event;
                    defaultMode.onKeyDown({
                        eventType: 'onKeyDown',
                        key: e.key,
                        event: e,
                        keyCode: e.keyCode
                    });
                }
            }
        };

        if (defaultMode.onBrush && chart.brushMode) {
            callbacks.mousedown = addBrushMousedown.bind(chart);
            callbacks.mouseup = function () {
                chart.chartDiv.select('svg').on('mousemove', false);
                chart.chartDiv.select('svg').style('cursor', 'default');
                chart.brushMode.removeBrush();
            };
        }
        registerClickEvents(entireSvg, callbacks, chart.config.currentEvent);
    } else {
        //remove tooltips and any highlights
        chart.showToolTip = false;
        chart.removeHighlight();
    }
}

function getEventObj(event, mouse, chart, eventType) {
    var returnObj = {};
    if (event.hasOwnProperty('eventType')) {
        returnObj = event;
    } else {
        returnObj = chart[chart.config.type].getEventData.call(chart, event, mouse);
        returnObj.mouse = mouse;
    }
    returnObj.eventType = eventType;
    return returnObj;
}

/**
* @name toggleCommentMode
* @desc updates event listeners for comment mode
* @param {string} mode - specified mode to toggle to
* @return {undefined} - no return
*/
function toggleCommentMode(mode) {
    var chart = this,
        commentObj = chart.commentMode;
    if (mode === 'comment-mode') {
        var entireSvg = chart.chartDiv.select('svg'),
            callbacks = {
            onDoubleClick: function onDoubleClick(event, mouse) {
                commentObj.makeComment(event.target);
                if (typeof chart.config.callbacks.commentMode.onDoubleClick === 'function') {
                    var returnObj = chart[chart.config.type].getEventData.call(chart, event, mouse);
                    returnObj.eventType = 'doubleClick';
                    chart.config.callbacks.commentMode.onDoubleClick(returnObj);
                }
            },
            onClick: function onClick(event, mouse) {
                if (typeof chart.config.callbacks.commentMode.onClick === 'function') {
                    var returnObj = chart[chart.config.type].getEventData.call(chart, event, mouse);
                    returnObj.eventType = 'click';
                    chart.config.callbacks.commentMode.onClick(returnObj);
                }
            }
        };
        registerClickEvents(entireSvg, callbacks, chart.config.currentEvent);
        //set cursor for comment mode
        chart.chartDiv.style('cursor', 'pointer');
        //add movementlisteners
        chart.chartDiv.selectAll('.min-comment').on('mousedown', function () {
            //logic to move comments
            commentObj.createMoveListener(d3.select(this));
        }).on('mouseup', function () {
            if (commentObj.moved) {
                commentObj.updatePosition(commentObj);
            }
            commentObj.moved = false;
            chart.chartDiv.on('mousemove', false);
        });
    } else {
        commentObj.removeComment();
    }
}

/**
* @name toggleEditMode
* @desc updates event listeners for edit mode
* @param {string} mode - specified mode to toggle to
* @return {undefined} - no return
*/
function toggleEditMode(mode) {
    var chart = this,
        editObj = chart.editMode,
        entireSvg = editObj.chartDiv.select('svg');
    if (mode === 'edit-mode') {
        editObj.chartDiv.style('cursor', 'default');
        entireSvg.selectAll('.event-rect').attr('display', 'none');

        var callbacks = {
            onDoubleClick: function onDoubleClick(event, mouse) {
                if (typeof chart.config.callbacks.editMode.onDoubleClick === 'function') {
                    var returnObj = chart[chart.config.type].getEventData.call(chart, event, mouse);
                    returnObj.eventType = 'doubleClick';
                    chart.config.callbacks.editMode.onDoubleClick(returnObj);
                }
            },
            onClick: function onClick(event, mouse) {
                //edit mode events
                //going to be mouseover to highlight options for whatever piece you hover over
                var classText = d3.select(event.target).attr('class');
                if (classText) {
                    if (classText.indexOf('editable') >= 0) {
                        editObj.displayEdit(mouse, classText);
                    }
                }

                if (typeof chart.config.callbacks.editMode.onClick === 'function') {
                    var returnObj = chart[chart.config.type].getEventData.call(chart, event, mouse);
                    returnObj.eventType = 'click';
                    chart.config.callbacks.editMode.onClick(returnObj);
                }
            }
        };
        //clear svg listeners
        registerClickEvents(entireSvg, {}, chart.config.currentEvent);
        //add chart div level listeners
        registerClickEvents(editObj.chartDiv, callbacks, chart.config.currentEvent);

        editObj.chartDiv.selectAll('.editable').classed('pointer', true);
    } else {
        //clear chart div level listeners
        editObj.removeEdit();
        entireSvg.selectAll('.editable').classed('pointer', false);
        entireSvg.selectAll('.event-rect').attr('display', 'block');
    }
}

/**
* @name toggleBrushMode
* @desc updates event listeners for brush mode
* @param {string} mode - specified mode to toggle to
* @return {undefined} - no return
*/
function toggleBrushMode(mode) {
    var chart = this;
    if (mode === 'brush-mode' && chart.config.callbacks.brushMode) {
        chart.addBrushEvents();
    }
}

/**
* @name toggleSelectMode
* @desc updates event listeners for select mode
* @param {string} mode - specified mode to toggle to
* @return {undefined} - no return
*/
function toggleSelectMode(mode) {
    var chart = this;
    if (mode === 'select-mode') {
        var callbacks = {
            onDoubleClick: function onDoubleClick(event, mouse) {
                if (typeof chart.config.callbacks.selectMode.onDoubleClick === 'function') {
                    var returnObj = chart[chart.config.type].getEventData.call(chart, event, mouse);
                    returnObj.eventType = 'doubleClick';
                    chart.config.callbacks.selectMode.onDoubleClick(returnObj);
                }
            },
            onClick: function onClick(event, mouse) {
                if (typeof chart.config.callbacks.selectMode.onClick === 'function') {
                    var returnObj = chart[chart.config.type].getEventData.call(chart, event, mouse);
                    returnObj.eventType = 'click';
                    chart.config.callbacks.selectMode.onClick(returnObj);
                }
            }
        };
        registerClickEvents(chart.chartDiv.select('svg'), callbacks, chart.config.currentEvent);
    }
}

/**
* @name addBrushEvents
* @desc registers events for brush mode
* @return {undefined} - no return
*/
function addBrushEvents() {
    var chart = this,
        entireSvg = chart.chartDiv.select('svg'),
        callbacks = {
        mousedown: addBrushMousedown.bind(chart),
        mouseup: function mouseup() {
            chart.chartDiv.select('svg').on('mousemove', false);
            chart.brushMode.removeBrush();
        }
    };
    registerClickEvents(entireSvg, callbacks, chart.config.currentEvent);
}

/**
* @name addBrushMousedown
* @desc creates mousedown event for brush mode
* @return {undefined} - no return
*/
function addBrushMousedown() {
    var chart = this,
        brushStarted = false,
        brushContainer = chart.chartDiv.select('.' + chart.config.type + '-container').node(),
        entireSvg = chart.chartDiv.select('svg'),
        timeMouseDown = new Date().getTime();
    entireSvg.on('mousemove', function () {
        var timeMouseMove = new Date().getTime();
        if (timeMouseDown > timeMouseMove - 10) {
            //mouse move happend too quickly, chrome bug
            return;
        }
        if (brushStarted) {
            return;
        }
        var containerBox = void 0,
            x = void 0,
            y = void 0,
            mouse = void 0;
        if (brushContainer === undefined) {
            chart.brushMode.startBrush(d3.event);
            brushStarted = true;
        } else {
            containerBox = brushContainer.getBoundingClientRect();
            mouse = d3.mouse(entireSvg.node());
            x = mouse[0];
            y = mouse[1];

            if (x < containerBox.right && y < containerBox.bottom && x > containerBox.left && y > containerBox.top) {
                chart.brushMode.startBrush(d3.event);
                brushStarted = true;
            }
        }
    });
}

/**
* @name registerClickEvents
* @desc register handler for jv events
* @param {d3element} svg - d3 selected element to bind events on
* @param {object} callbacks - callbacks to run for each type of click event
* @return {undefined} - no return
*/
function registerClickEvents(svg) {
    var callbacks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var currentEvent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    //using default parameters to show available parts of the callbacks object
    var down,
        clickedSpot,
        tolerance = 5,
        clickTimer = null,
        CLICK_TIMER = 250,
        clickTimerStarted = false;

    svg.on('mousedown', false);
    svg.on('mouseup', false);
    svg.on('mousemove', false);
    svg.on('mouseout', false);
    svg.on('keyup', false);
    svg.on('focus', false);

    if (typeof callbacks.onHover === 'function' || typeof callbacks.offHover === 'function') {
        registerHoverEvents(svg, callbacks, currentEvent);
    }

    if (typeof callbacks.onKeyUp === 'function') {
        svg.on('keyup', callbacks.onKeyUp);
        svg.on('focus', function () {});
        svg.node().focus();
    }

    if (typeof callbacks.onKeyDown === 'function') {
        svg.on('keydown', callbacks.onKeyDown);
        svg.on('focus', function () {});
        svg.node().focus();
    }

    if (typeof callbacks.mousedown === 'function') {
        svg.on('mousedown', function () {
            down = d3.mouse(svg.node());
            callbacks.mousedown();
        });
    }

    svg.on('mouseup', function () {
        if (typeof callbacks.mouseup === 'function') {
            callbacks.mouseup();
        }
        if (typeof callbacks.onDoubleClick !== 'function') {
            //run single click if double click doesnt exist
            onClickEvent(d3.event, d3.mouse(this), callbacks.onClick);
        } else {
            if (dist(down, d3.mouse(svg.node())) > tolerance) {
                //drag not click so return
                return;
            }
            //need to determine whether single or double click
            if (clickedSpot && dist(clickedSpot, d3.mouse(svg.node())) < tolerance && clickTimerStarted) {
                window.clearTimeout(clickTimer);
                clickTimer = null;
                clickTimerStarted = false;
                callbacks.onDoubleClick(d3.event, d3.mouse(this), this);
            } else {
                //d3.event and d3.mouse both lose their scope in a timeout and no longer return the expected value, so binding is necessary
                clickTimer = window.setTimeout(onClickEvent.bind(this, d3.event, d3.mouse(this), callbacks.onClick), CLICK_TIMER);
                clickTimerStarted = true;
                clickedSpot = d3.mouse(svg.node());
            }
        }
    });

    function onClickEvent(e, mouse, onClick) {
        if (typeof onClick === 'function') {
            onClick(e, mouse, this);
        }
    }
}

function registerHoverEvents(svg, callbacks, currentEvent, _vars) {
    var hoverData = {},
        hoverTimer = null,
        hoverTimerStarted = false,
        HOVER_TIMER = 2000,
        prevEvent = currentEvent,
        fakeHoverTimer = false;

    svg.on('mouseout', function () {
        if (prevEvent.type === 'onHover') {
            offHoverEvent(callbacks.offHover, prevEvent.data);
        }
        hoverTimer = window.clearTimeout(hoverTimer);
        hoverTimerStarted = false;
    });

    svg.on('mousemove', function () {
        if (hoverTimerStarted || fakeHoverTimer) {
            //determine to clear timer
            if (!sameNode(hoverData.ele, d3.event.target)) {
                //create new timer and assign to hover target ele
                hoverTimer = window.clearTimeout(hoverTimer);
                hoverTimerStarted = false;
                fakeHoverTimer = false;
            }
            hoverData.ele = d3.event.target;
        } else {
            //add timer
            //same element, we want to fire the hover if more than x seconds
            if (prevEvent.type === 'onHover') {
                if (hoverData.ele) {
                    offHoverEvent(callbacks.offHover, prevEvent.data);
                } else {
                    fakeHoverTimer = true;
                }
                return;
            }
            hoverData.ele = d3.event.target;

            //clear before setting
            hoverTimer = window.clearTimeout(hoverTimer);
            hoverData.ele = d3.event.target;
            hoverTimer = window.setTimeout(onHoverEvent.bind(this, callbacks.onHover, d3.event, d3.mouse(this)), HOVER_TIMER);
            hoverTimerStarted = true;
        }
    });

    function offHoverEvent(offHover, prevEventData) {
        if (typeof offHover === 'function') {
            prevEvent.type = 'offHover';
            //rely on refresh to rebuild event
            if (true || _vars.eventRefresh) {
                svg.on('mousemove', false);
                svg.on('mouseout', false);
            }

            offHover(hoverData.event, hoverData.mouse, prevEventData);
        }
    }

    function onHoverEvent(onHover, e, m) {
        if (typeof onHover === 'function') {
            hoverData = {
                mouse: m,
                event: e
            };
            //rely on refresh to rebuild event
            if (true || _vars.eventRefresh) {
                svg.on('mousemove', false);
                svg.on('mouseout', false);
            }

            onHover(hoverData.event, hoverData.mouse);
        }
    }

    function sameNode(node1, node2) {
        var response = void 0;
        if (node1 && node2) {
            //both exist, check for equality
            if (node1.classList.value === node2.classList.value) {
                response = true;
            } else {
                response = false;
            }
        } else if (node1 || node2) {
            //one empty and one not
            response = true;
        } else {
            //both null
            response = true;
        }
        return response;
    }
}

/**
* @name dist
* @desc euclidean distance to determine if the mouse moved in between clicks for double click
* @param {array} a - point a
* @param {array} b - point b
* @return {number} - distance between a and b
*/
function dist(a, b) {
    if (a && b && Array.isArray(a) && Array.isArray(b)) {
        return Math.sqrt(Math.pow(a[0] - b[0], 2), Math.pow(a[1] - b[1], 2));
    }
    return 0;
}

},{"./jvBrush.js":3,"./jvCharts.js":4,"./jvComment.js":5,"./jvEdit.js":6}],8:[function(require,module,exports){
'use strict';

/***  jvEdit ***/
function jvSelect(configObj) {
    'use strict';

    var selectObj = this;
    selectObj.chartDiv = configObj.chartDiv;
    selectObj.jvChart = configObj.jvChart;
    selectObj.singleClickCallback = configObj.singleClickCallback;
    selectObj.doubleClickCallback = configObj.doubleClickCallback;
}

function singleClick(selectObj, event) {
    if (typeof selectObj.singleClickCallback === 'function') {
        selectObj.singleClickCallback(event);
    }
}
function dblclick(selectObj, event) {
    if (typeof selectObj.doubleClickCallback === 'function') {
        selectObj.doubleClickCallback(event);
    }
}

/********************************************* Select Mode Functions **************************************************/

module.exports = jvSelect;

},{}],9:[function(require,module,exports){
'use strict';

/***  jvTip ***/

function jvTip(configObj) {
    'use strict';

    var tip = this,
        defaultConfig = {
        type: 'simple'
    };

    tip.tipConfig = configObj.tipConfig || defaultConfig;
    tip.chartDiv = configObj.chartDiv;

    //Create initial div
    tip.chartDiv.select('.jv-tooltip').remove();

    tip.chartDiv.append('div').attr('class', 'tooltip jv-tooltip').style('pointer-events', 'none');
}

jvTip.prototype.showTip = showTip;
jvTip.prototype.hideTip = hideTip;
jvTip.prototype.generateSimpleTip = generateSimpleTip;

function showTip() {
    var transitionDuration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 50;

    var tip = this,
        left = 'auto',
        top = 'auto',
        mouse = d3.mouse(tip.chartDiv.select('svg').node()),

    //Logic to determine where tooltip will be placed on page
    leftOfMouse = mouse[0] > tip.chartDiv._groups[0][0].clientWidth / 2,
        topOfMouse = mouse[1] < tip.chartDiv._groups[0][0].clientHeight / 2,
        tooltipHeight = tip.toolTip._groups[0][0].clientHeight === 0 ? 75 : tip.toolTip._groups[0][0].clientHeight,
        tooltipWidth = tip.toolTip._groups[0][0].clientWidth,
        t = void 0;

    if (leftOfMouse) {
        if (tooltipWidth === 0) {
            tooltipWidth = 250;
        }
        left = mouse[0] - tooltipWidth;
    } else {
        left = mouse[0];
    }
    if (topOfMouse) {
        top = mouse[1];
    } else {
        if (tooltipHeight === 0) {
            tooltipHeight = 75;
        }
        top = mouse[1] - tooltipHeight;
    }

    if (!leftOfMouse && topOfMouse) {
        left = mouse[0] + 13;
    }

    //COOL CURSOR, a function of the height and width of the container
    //var container = tip.chartDiv.select('.bar-container').node().getBoundingClientRect();
    //svgMouse = d3.mouse(tip.chartDiv.select('.bar-container').node());

    //var tooltipHeight = tip.toolTip._groups[0][0].clientHeight === 0 ? 75 : tip.toolTip._groups[0][0].clientHeight;
    //top = mouse[1] - (tooltipHeight * svgMouse[1] / container.height);

    //var tooltipWidth = tip.toolTip._groups[0][0].clientWidth;
    //left = mouse[0] - (tooltipWidth * svgMouse[0] / container.width);

    //STICKY CURSOR IN THE BOTTOM RIGHT
    //top = mouse[1];
    //left = mouse[0];
    //set max left
    //if(left > container.width - tooltipWidth + container.left) {
    //left = container.width - tooltipWidth + container.left;
    //}

    ////set max top
    //if (top > container.height - tooltipHeight + container.top) {
    //top = container.height - tooltipHeight + container.top;
    //}

    t = d3.transition().duration(transitionDuration).ease(d3.easeLinear);

    tip.toolTip.transition(t).style('left', left + 'px').style('top', top + 'px').style('display', 'block').style('opacity', 1);
}

function hideTip() {
    var tip = this,
        t = d3.transition().duration('100').ease(d3.easeLinear);
    if (tip.toolTip) {
        // tip.toolTip.transition(t).style('display', 'none');
    }
}

/************************************************  Declare jv tip components *******************************************************************************/
var jvHr = '<hr style=\'margin:3px 0 3px 0;\'/>';

function getValueContent(item, value, colorTile) {
    var valueString = value ? ': ' + value : '',
        colorTileString = colorTile ? colorTile : '';
    return '<span class=\'jv-tip-content jv-tip-side-padding\'>' + colorTileString + item + valueString + '</span><br/>';
}

function getTitleTemplate(dataObj) {
    return '<div class=\'title jv-top-margin jv-inline jv-full-width\'><b>' + dataObj.title + '</b></div>' + jvHr;
}

function getColorTile(color) {
    if (color) {
        return '<div class=\'d3-tooltip-circle jv-inline jv-full-width jv-tip-side-padding\' style=\'background:' + color + '\'></div>';
    }
    return "<div class='jv-inline jv-full-width jv-tip-side-padding'>";
}

/************************************************* Viz Specific Functions **********************************************************************************/
function generateSimpleTip(dataObj, dataTable) {
    var tip = this,
        tooltipHtml = '';

    if (dataObj.hasOwnProperty('title') && dataObj.title === '') {
        dataObj.title = 'Empty';
    }

    if (dataObj.viz === 'clusters' || dataObj.viz === 'circleviewplot' || dataObj.viz === 'scatterplot' || dataObj.viz === 'treemap' || dataObj.viz === 'singleaxis') {
        tooltipHtml = generateSingleColorHTML(dataObj, dataTable);
    } else if (dataObj.viz === 'radial' || dataObj.viz === 'pie') {
        tooltipHtml = generatePieHTML(dataObj, dataTable);
    } else if (dataObj.viz === 'circlepack' || dataObj.viz === 'sunburst') {
        tooltipHtml = generatePackHTML(dataObj, dataTable);
    } else if (dataObj.viz === 'heatmap' || dataObj.viz === 'cloud') {
        tooltipHtml = generateHeatmapHTML(dataObj, dataTable);
    } else if (dataObj.viz === 'sankey') {
        tooltipHtml = generateSankeyHTML(dataObj, dataTable);
    } else if (dataObj.viz === 'bubble') {
        tooltipHtml = generateBubbleHTML(dataObj);
    } else if (dataObj.viz === 'boxwhisker') {
        tooltipHtml = generateBoxHTML(dataObj);
    } else if (dataObj.viz === 'clustergram') {
        tooltipHtml = generateClustergramHTML(dataObj);
    } else if (dataObj.viz === 'gantt') {
        tooltipHtml = generateGanttHTML(dataObj, dataTable);
    } else {
        tooltipHtml = generateSimpleHTML(dataObj, dataTable);
    }

    //add content to tooltip
    tip.toolTip = tip.chartDiv.select('.tooltip').html(tooltipHtml);

    //paint the tooltip
    tip.showTip(0);

    return tip.tooltip;
}

function generateSimpleHTML(dataObj) {
    var tooltipText = void 0;
    tooltipText = '<div><div class=\'title jv-tip-container jv-tip-side-padding jv-top-margin\'><b>' + dataObj.title + '</b></div>' + jvHr;

    for (var item in dataObj.tipData) {
        tooltipText += getValueContent(item, formatValue(dataObj.tipData[item]), getColorTile(dataObj.color[item]));
    }
    tooltipText += '</div>';
    return tooltipText;
}

function generateSingleColorHTML(dataObj, dataTable) {
    var tooltipText = void 0,
        tooltipColor = void 0,
        showColorCircle = true,
        colorCircle = '';

    if (!!dataObj.color[dataObj.data[dataTable.series]]) {
        tooltipColor = dataObj.color[dataObj.data[dataTable.series]];
    } else if (!!dataObj.color[dataTable.label] && dataObj.viz !== 'singleaxis') {
        tooltipColor = dataObj.color[dataTable.label];
    } else {
        showColorCircle = false;
    }

    if (showColorCircle) {
        colorCircle = getColorTile(tooltipColor);
    } else {
        colorCircle = getColorTile();
    }

    tooltipText = '<div class=\'jv-inline jv-full-width\'>' + colorCircle + '<div class=\'title jv-tip-side-padding jv-inline jv-full-width jv-top-margin\'><b>' + dataObj.title + '</b></div>' + jvHr;

    for (var item in dataObj.tipData) {
        tooltipText += getValueContent(item, formatValue(dataObj.tipData[item]));
    }
    tooltipText += '</div>';
    return tooltipText;
}

function generatePackHTML(dataObj) {
    var tooltipText = void 0;
    tooltipText = '<div class=\'jv-inline jv-full-width\'>\n        ' + getColorTile(dataObj.data.color) + '\n        ' + getTitleTemplate(dataObj);

    for (var item in dataObj.tipData) {
        tooltipText += getValueContent(item, formatValue(dataObj.tipData[item]));
    }
    tooltipText += '</div>';
    return tooltipText;
}

function generateBubbleHTML(dataObj) {
    var tooltipText = void 0;
    tooltipText = '<div class=\'jv-inline jv-full-width\'>\n        ' + getColorTile(dataObj.data.color) + '\n        ' + getTitleTemplate(dataObj);

    for (var item in dataObj.tipData) {
        if (item === 'color') {
            continue;
        }
        tooltipText += getValueContent(item, formatValue(dataObj.tipData[item]));
    }
    tooltipText += '</div>';
    return tooltipText;
}

function generateBoxHTML(dataObj) {
    var tooltipText = void 0;
    tooltipText = '<div class="jv-inline jv-full-width">';

    for (var item in dataObj.tipData) {
        if (dataObj.tipData.hasOwnProperty(item)) {
            tooltipText += getValueContent(item, formatValue(dataObj.tipData[item]));
        }
    }
    tooltipText += '</div>';
    return tooltipText;
}

function generateHeatmapHTML(dataObj) {
    var tooltipText = void 0;
    if (dataObj.xAxisCat) {
        tooltipText = '<div class=\'jv-inline jv-full-width\'>\n            ' + getColorTile(dataObj.color) + "<div class='title jv-top-margin jv-inline jv-full-width'><b>" + dataObj.data.xAxisName + "</b></div><hr style='margin:3px 0 3px 0;'/>";

        tooltipText += "<span class='jv-tip-content jv-tip-side-padding'>" + dataObj.xAxisCat + '</span><br/>';
        tooltipText += '</div>';
        return tooltipText;
    } else if (dataObj.yAxisCat) {
        tooltipText = '<div class=\'jv-inline jv-full-width\'>\n            ' + getColorTile(dataObj.color) + "<div class='title jv-top-margin jv-inline jv-full-width'><b>" + dataObj.data.yAxisName + "</b></div><hr style='margin:3px 0 3px 0;'/>";

        tooltipText += "<span class='jv-tip-content jv-tip-side-padding'>" + dataObj.yAxisCat + '</span><br/>';
        tooltipText += '</div>';
        return tooltipText;
    }
    tooltipText = '<div class=\'jv-inline jv-full-width\'>\n            ' + getColorTile(dataObj.color) + '\n            ' + getTitleTemplate(dataObj);

    for (var item in dataObj.tipData) {
        tooltipText += getValueContent(item, formatValue(dataObj.tipData[item]));
    }
    tooltipText += '</div>';
    return tooltipText;
}

function generateClustergramHTML(dataObj) {
    var tooltipText = void 0;
    dataObj.title = dataObj.title.replace(/_/g, ' ');
    tooltipText = '<div class=\'jv-inline jv-full-width\'>\n    ' + getColorTile(dataObj.color) + '\n    ' + getTitleTemplate(dataObj);

    for (var item in dataObj.tipData) {
        tooltipText += getValueContent(item, formatValue(dataObj.tipData[item]));
    }
    tooltipText += '</div>';

    return tooltipText;
}

function generateGanttHTML(dataObj, dataTable) {
    var tooltipText;

    dataObj.title = dataObj.title.replace(/_/g, " ");

    tooltipText = '<div class=\'jv-inline jv-full-width\'>\n    ' + getTitleTemplate(dataObj);

    for (var i = 1; i <= dataObj.data.length; i++) {
        var startValue = dataObj.tipData[dataTable["start " + i]];
        var endValue = dataObj.tipData[dataTable["end " + i]];
        var durationValue = dataObj.tipData["Duration " + i];
        if (durationValue !== "0 days" && durationValue != null && startValue != null && endValue != null) {
            endValue = endValue.substring(0, 10);
            startValue = startValue.substring(0, 10);
            var item = dataTable["start " + i];
            // if (item.substring(0,6) === "Start ") {
            //     item = item.substring(6);
            // }

            var value = startValue + " to " + endValue;
            tooltipText += getValueContent(item, value, getColorTile(dataObj.color[dataTable["start " + i]]));
            tooltipText += getValueContent("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Duration", durationValue);
        }
    }
    tooltipText += "</div>";

    return tooltipText;
}

function generatePieHTML(dataObj, dataTable) {
    var tooltipText = void 0;
    tooltipText = '<div class=\'jv-inline jv-full-width\'>\n    ' + getColorTile(dataObj.color[dataObj.data.label]) + '\n    ' + getTitleTemplate(dataObj);

    for (var item in dataObj.tipData) {
        tooltipText += getValueContent(dataTable[item], formatValue(dataObj.tipData[item]));
    }
    tooltipText += '</div>';
    return tooltipText;
}

function generateSankeyHTML(dataObj) {
    var tooltipText = void 0;
    tooltipText = '<div class=\'jv-inline jv-full-width\'>' + getTitleTemplate(dataObj);

    for (var item in dataObj.tipData) {
        tooltipText += getValueContent(dataObj.valueName, formatValue(dataObj.tipData[item]));
    }
    tooltipText += '</div>';
    return tooltipText;
}

function formatValue(val) {
    if (!isNaN(val)) {
        var formatNumber = d3.format(',.0f');
        if (val >= 1000000) {
            //millions
            //var p = d3.precisionPrefix(1e5, 1.3e6);
            //formatNumber = d3.formatPrefix("." + p, 1.3e6);
            formatNumber = d3.format(',.2f');
        } else if (val <= 100) {
            //2 decimals
            formatNumber = d3.format(',.2f');
        }
        return formatNumber(val);
    }
    return val;
}

module.exports = jvTip;

},{}],10:[function(require,module,exports){
'use strict';

var jvCharts = require('./jvCharts.js');

jvCharts.prototype.getDefaultOptions = getDefaultOptions;

function getDefaultOptions() {
    var userOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    var _vars = {};

    //General Styles/Attributes
    //CONST variables - try to not use in jvCharts as they do not have much context
    _vars.GRAY = '#cccccc';
    _vars.WHITE = '#FFFFFF';
    _vars.BLACK = '#000000';
    _vars.SMALL_STROKE_WIDTH = '1px';
    _vars.light = '#BBBBBB';
    _vars.strokeWidth = '2px';

    //Action Attributes
    _vars.highlightBorderColor = _vars.BLACK;
    _vars.highlightBorderWidth = '2px';

    //Component Specific Styles/Attributes
    _vars.thresholds = 'none'; //if not none, expected to be an array
    _vars.thresholdLegend = false;
    _vars.backgroundColor = 'none';
    _vars.axisColor = _vars.GRAY;
    _vars.gridLineColor = _vars.WHITE;
    _vars.axisWidth = _vars.strokeWidth;
    _vars.gridLineStrokeWidth = _vars.SMALL_STROKE_WIDTH;
    _vars.displayValues = false;
    _vars.toggleLegend = false;

    //_vars.legendArrowColor = 'c2c2d6';
    //_vars.legendArrowColor = '000000';
    _vars.legendArrowColor = 'e7e7e7';

    _vars.legendMax = 9;
    _vars.gridSize = 12;
    _vars.xReversed = false;
    _vars.yReversed = false;

    //font styles
    _vars.fontSize = '12px';
    _vars.fontColor = _vars.BLACK;
    _vars.xLabelFontSize = 'none';
    _vars.yLabelFontSize = 'none';

    //Heatmap Specific Styles/Attributes
    _vars.color = '#ff0000';
    _vars.toggleLegend = false;
    _vars.buckets = '10';
    _vars.opacity = '10';
    _vars.colorLabel = 'none';
    _vars.min = '0';
    _vars.max = '10';
    _vars.domainArray = '';
    _vars.step = '1';
    _vars.quantiles = true;
    _vars.heatLegendSpacing = 2;
    _vars.heatGridSize = 20;
    _vars.colors = ['#fbf2d2', '#fdedb5', '#fee7a0', '#ffda84', '#ffc665', '#feb44e', '#fea743', '#fd9b3f', '#fd8c3c', '#fd7735', '#fd602f', '#fb4b29', '#f43723', '#ea241e', '#e0161c', '#d60b20', '#c80324', '#b10026', '#870025', '#620023'];
    _vars.clusterColors = ['#00009C', '#003399', '#002FA7', '#2A52BE', '#0000FF', '#8C92AC', '#92A1CF', '#C4C3D0', '#CCCCFF', '#F8F8FF', '#FFFAFA', '#F4C2C2', '#FF6961', '#FF5C5C', '#FF1C00', '#FF0800', '#FF0000', '#CD5C5C', '#E34234', '#D73B3E'];

    //pie specific
    _vars.pieBorder = _vars.WHITE;
    _vars.pieBorderWidth = _vars.SMALL_STROKE_WIDTH;
    _vars.pieTextColor = _vars.WHITE;
    _vars.emptyLegendSquare = _vars.WHITE;

    //line specific
    _vars.lineCurveType = 'Linear';

    //bar specific
    _vars.displayValuesStackAsPercent = false;
    _vars.displayValuesStackTotal = false;
    _vars.displayYAxisLabel = true;

    _vars.transitionTime = 200;

    //scatter specific
    _vars.toggleZ = true;
    _vars.lineGuide = true;

    //single axis specific
    _vars.singleAxisFillHoverColor = 'red';

    Object.assign(_vars, userOptions);
    return _vars;
}

},{"./jvCharts.js":4}],11:[function(require,module,exports){
'use strict';

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var jvCharts = require('../visuals/jvLine.js');

jvCharts.prototype.area = {
    paint: paint,
    setData: setData,
    getEventData: getEventData,
    highlightFromEventData: highlightFromEventData
};

jvCharts.prototype.fillArea = fillArea;

/************************************************ Line functions ******************************************************/

/**setLineData
 *  gets line data and adds it to the chart object
 *
 * @params data, dataTable, colors
 */
function setData() {
    var chart = this;
    //sort chart data if there is a sort type and label in the _vars
    if (chart._vars.sortType) {
        if (chart._vars.sortLabel && chart._vars.sortType !== 'default') {
            chart.organizeChartData(chart._vars.sortLabel, chart._vars.sortType);
        }
    }

    //remove if we add non linear to area chart
    chart._vars.lineCurveType = 'Linear';

    chart.data.legendData = setBarLineLegendData(chart.data);
    chart.data.xAxisData = chart.setAxisData('x', chart.data);
    chart.data.yAxisData = chart.setAxisData('y', chart.data);

    if (chart._vars.seriesFlipped) {
        chart.setFlippedSeries(chart.data.dataTableKeys);
        chart.flippedData.color = jvCharts.setChartColors(chart._vars.color, chart.flippedData.legendData, chart.colors);
    }

    //define color object for chartData
    chart.data.color = jvCharts.setChartColors(chart._vars.color, chart.data.legendData, chart.colors);
}

/**setBarLineLegendData
 *  gets legend info from chart Data
 *
 * @params data, type
 * @returns [] of legend tex
 */
function setBarLineLegendData(data) {
    var legendArray = [];
    for (var item in data.dataTable) {
        if (data.dataTable.hasOwnProperty(item)) {
            if (item !== 'label' && item.indexOf('tooltip') === -1) {
                legendArray.push(data.dataTable[item]);
            }
        }
    }
    return legendArray;
}
/**paintLineChart
 *
 * The initial starting point for line chart, begins the drawing process. Must already have the data stored in the chart
 * object
 */
function paint() {
    var chart = this,

    //Uses the original data and then manipulates it based on any existing options
    dataObj = chart.getBarDataFromOptions();

    //assign current data which is used by all bar chart operations
    chart.currentData = dataObj;

    //Overwrite any pre-existing zoom
    chart.config.zoomEvent = null;

    //generate svg dynamically based on legend data
    chart.generateSVG(dataObj.legendData);
    chart.generateXAxis(dataObj.xAxisData);
    chart.generateYAxis(dataObj.yAxisData);
    chart.generateLegend(dataObj.legendData, 'generateLine');

    if (typeof dataObj.xAxisScale.ticks === 'function') {
        chart.formatXAxisLabels(dataObj.xAxisScale.ticks().length);
    } else {
        chart.formatXAxisLabels(dataObj.xAxisScale.domain().length);
    }

    chart.generateLine(dataObj);
}

function getEventData(event) {
    var chart = this;
    if (event.target.classList.value.split('bar-col-')[1]) {
        return {
            data: _defineProperty({}, chart.currentData.dataTable.label, [event.target.classList.value.split('bar-col-')[1].replace(/_/g, ' ').replace(/_colon_/g, ':').replace(/_dot_/g, '.')]),
            node: event.target
        };
    } else if (event.target.classList.value.indexOf('area-container') > -1) {
        return {
            data: {}
        };
    }
    return {
        data: false
    };
}

function highlightFromEventData(event) {
    var chart = this,
        label = event.data[chart.currentData.dataTable.label][0],
        cssClass = '.highlight-class-' + label.replace(/\s/g, '_').replace(/\./g, '_dot_'),
        node = chart.svg.selectAll(cssClass);

    chart.svg.select('.area-container').selectAll('circle').attr('stroke', 0).attr('stroke-width', 0);
    //highlight necessary circles
    node.attr('stroke', chart._vars.highlightBorderColor).attr('stroke-width', chart._vars.highlightBorderWidth);
}

/**
 *
 */
function fillArea(lineData) {
    var chart = this,
        svg = chart.svg,
        xAxisData = chart.currentData.xAxisData,
        yAxisData = chart.currentData.yAxisData,
        legendData = chart.currentData.legendData,
        container = chart.config.container,
        colors = chart._vars.color,
        x = jvCharts.getAxisScale('x', xAxisData, container, chart._vars, 'no-padding'),
        y = jvCharts.getAxisScale('y', yAxisData, container, chart._vars, 'no-padding'),
        area,
        data = {};

    //If a legend element is toggled off, use the new list of headers
    if (chart._vars.hasOwnProperty('legendHeaders')) {
        legendData = chart._vars.legendHeaders;
    }
    //If axis are normal
    if (!chart._vars.rotateAxis) {
        area = d3.area().x(function (d) {
            if (d.x === '') {
                return x('EMPTY_STRING');
            }
            return x(d.x);
        }).y0(container.height).y1(function (d) {
            return y(d.y);
        });
    } else {
        area = d3.area().y(function (d) {
            return y(d.y);
        }).x1(0).x0(function (d) {
            return x(d.x);
        });
    }

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = lineData[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var dataEle = _step.value;
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
                for (var _iterator2 = legendData[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    var legendEle = _step2.value;

                    if (legendEle.toggle === false) {
                        //Don't write anything to data
                        continue;
                    }
                    if (!data[legendEle]) {
                        data[legendEle] = [];
                    }
                    if (!chart._vars.rotateAxis) {
                        data[legendEle].push({
                            'x': dataEle[xAxisData.label],
                            'y': parseFloat(dataEle[legendEle])
                        });
                    } else {
                        data[legendEle].push({
                            'y': dataEle[yAxisData.label],
                            'x': parseFloat(dataEle[legendEle])
                        });
                    }
                }
            } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
                        _iterator2.return();
                    }
                } finally {
                    if (_didIteratorError2) {
                        throw _iteratorError2;
                    }
                }
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    svg.selectAll('.area').remove();
    for (var key in data) {
        if (data.hasOwnProperty(key)) {
            svg.append('path').datum(data[key]).attr('class', function () {
                if (chart._vars.colorLine == true && chart._vars.thresholds != 'none' && chart._vars.colorChart != false) {
                    return 'area area-threshold';
                }
                return 'area';
            }).attr('d', area).attr('fill', jvCharts.getColors(colors, null, key)).attr('opacity', 0.6).attr('transform', function () {
                return chart._vars.rotateAxis ? 'translate(0, ' + container.height / lineData.length / 2 + ')' : 'translate(' + container.width / lineData.length / 2 + ', 0)';
            }).attr('pointer-events', 'none');
        }
    }
}

module.exports = jvCharts;

},{"../visuals/jvLine.js":18}],12:[function(require,module,exports){
'use strict';

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var jvCharts = require('../jvCharts.js');

jvCharts.prototype.bar = {
    paint: paint,
    setData: setData,
    getEventData: getEventData,
    highlightFromEventData: highlightFromEventData
};

jvCharts.prototype.generateBarThreshold = generateBarThreshold;
jvCharts.prototype.generateBars = generateBars;

/**paint
 *
 * The initial starting point for bar chart, begins the drawing process. Must already have the data stored in the chart
 * object
 */
function paint() {
    var transitionTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 800;

    var chart = this,

    //Uses the original data and then manipulates it based on any existing options
    dataObj = chart.getBarDataFromOptions();

    if (transitionTime || transitionTime === 0) {
        chart._vars.transitionTime = transitionTime;
    }

    //assign current data which is used by all bar chart operations
    chart.currentData = dataObj;

    //generate svg dynamically based on legend data
    chart.generateSVG(dataObj.legendData);
    chart.generateXAxis(dataObj.xAxisData);
    chart.generateYAxis(dataObj.yAxisData);
    chart.generateLegend(dataObj.legendData, 'generateBars');
    chart.generateBars(dataObj);

    if (typeof dataObj.xAxisScale.ticks === 'function') {
        chart.formatXAxisLabels(dataObj.xAxisScale.ticks().length);
    } else {
        chart.formatXAxisLabels(dataObj.xAxisScale.domain().length);
    }
}

/**Sets the data for the bar chart prior to painting
 *  @function
 * @params {Object} data - Data passed into the chart
 * @params {Object} dataTable - Shows which data column is associated with each field in visual panel
 * @params {Object} dataTableKeys - Contains the data type for each column of data
 * @params {Object} colors - Colors object used to color the bars
 */
function setData() {
    var chart = this;
    //sort chart data if there is a sort type and label in the _vars
    if (chart._vars.hasOwnProperty('sortType') && chart._vars.sortType) {
        if (chart._vars.sortLabel && chart._vars.sortType !== 'default') {
            chart.organizeChartData(chart._vars.sortLabel, chart._vars.sortType);
        }
    }
    chart.data.legendData = setBarLineLegendData(chart.data);
    chart.data.xAxisData = chart.setAxisData('x', chart.data);
    chart.data.yAxisData = chart.setAxisData('y', chart.data);
    if (chart._vars.seriesFlipped) {
        chart.setFlippedSeries(chart.data.dataTableKeys);
        chart.flippedData.color = jvCharts.setChartColors(chart._vars.color, chart.flippedData.legendData, chart.colors);
    }

    //define color object for chartData
    chart.data.color = jvCharts.setChartColors(chart._vars.color, chart.data.legendData, chart.colors);
}

function getEventData(event) {
    var chart = this;
    if (event.target.classList.value.split('bar-col-')[1]) {
        return {
            data: _defineProperty({}, chart.currentData.dataTable.label, [event.target.classList.value.split('bar-col-')[1].replace(/_/g, ' ').replace(/_dot_/g, '.')]),
            node: event.target
        };
    } else if (event.target.classList.value.indexOf('bar-container') > -1) {
        return {
            data: {}
        };
    }
    return {
        data: false
    };
}

function highlightFromEventData(event) {
    var chart = this,
        labelArray = event.data[chart.currentData.dataTable.label],
        node = void 0,
        cssClass = void 0;
    chart.svg.select('.bar-container').selectAll('rect').attr('stroke', 0).attr('stroke-width', 0);

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = labelArray[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var label = _step.value;

            cssClass = '.highlight-class-' + label.replace(/\s/g, '_').replace(/\./g, '_dot_');
            node = chart.svg.selectAll(cssClass);

            //highlight necessary bars
            node.attr('stroke', chart._vars.highlightBorderColor).attr('stroke-width', chart._vars.highlightBorderWidth);
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
}

/**setBarLineLegendData
 *  gets legend info from chart Data
 *
 * @params data, type
 * @returns [] of legend text
 */
function setBarLineLegendData(data) {
    var legendArray = [];
    for (var item in data.dataTable) {
        if (data.dataTable.hasOwnProperty(item)) {
            if (item !== 'label' && item.indexOf('tooltip') === -1) {
                legendArray.push(data.dataTable[item]);
            }
        }
    }
    return legendArray;
}

/************************************************ Bar functions ******************************************************/
function generateBarThreshold() {
    var chart = this,
        svg = chart.svg,
        width = chart.config.container.width,
        height = chart.config.container.height,
        thresholds = chart._vars.thresholds,
        length = thresholds !== 'none' ? Object.keys(thresholds).length : 0,
        x = chart.currentData.xAxisScale,
        y = chart.currentData.yAxisScale;

    if (thresholds !== 'none') {
        var thresholdRects = void 0,
            threshold = void 0;
        for (var i = 0; i < length; i++) {
            threshold = thresholds[i];
            if (!chart._vars.xAxisThreshold) {
                if (chart._vars.rotateAxis) {
                    if (chart._vars.yMin === 'none') {
                        svg.append('line').style('stroke', threshold.thresholdColor).attr('x1', x(threshold.threshold)).attr('y1', 0).attr('x2', x(threshold.threshold)).attr('y2', height).attr('stroke-dasharray', '3, 3');
                    } else if (threshold.threshold > chart._vars.yMin) {
                        svg.append('line').style('stroke', threshold.thresholdColor).attr('x1', x(threshold.threshold)).attr('y1', 0).attr('x2', x(threshold.threshold)).attr('y2', height).attr('stroke-dasharray', '3, 3');
                    }
                } else if (chart._vars.yMin === 'none') {
                    svg.append('line').style('stroke', threshold.thresholdColor).attr('x1', 0).attr('y1', y(threshold.threshold)).attr('x2', width).attr('y2', y(threshold.threshold)).attr('stroke-dasharray', '3, 3');
                } else if (threshold.threshold > chart._vars.yMin) {
                    svg.append('line').style('stroke', threshold.thresholdColor).attr('x1', 0).attr('y1', y(threshold.threshold)).attr('x2', width).attr('y2', y(threshold.threshold)).attr('stroke-dasharray', '3, 3');
                }
            }

            if (chart._vars.colorChart == true) {
                thresholdRects = d3.selectAll('rect.rect-' + i);
                thresholdRects.attr('fill', threshold.thresholdColor);
            }
        }
    }
}

/**generateBars
 *
 * Does the actual painting of bars on the bar chart
 * @params barData
 */

function generateBars(barData) {
    var chart = this,
        svg = chart.svg,


    //Used to draw line that appears when tool tips are visible
    tipLineX = 0,
        tipLineWidth = 0,
        tipLineHeight = 0,
        tipLineY = 0,

    //Add logic to filter bardata
    dataHeaders = barData.legendData,
        bars,
        barDataNew,
        eventGroups;

    //Removes any existing bar containers and creates a new one
    svg.selectAll('g.bar-container').remove();

    bars = svg.append('g').attr('class', 'bar-container').selectAll('g');

    if (chart._vars.seriesFlipped && chart._vars.flippedLegendHeaders) {
        dataHeaders = chart._vars.flippedLegendHeaders;
    } else if (chart._vars.legendHeaders) {
        dataHeaders = chart._vars.legendHeaders;
    }

    chart._vars.legendHeaders = dataHeaders;

    barDataNew = jvCharts.getToggledData(barData, dataHeaders);

    generateBarGroups(bars, barDataNew, chart);

    eventGroups = jvCharts.generateEventGroups(bars, barDataNew, chart);

    //Add listeners

    eventGroups.on('mouseover', function (d, i, j) {
        //Transitions in D3 don't support the 'on' function They only exist on selections. So need to move that event listener above transition and after append
        if (chart.showToolTip) {
            //Get tip data
            var tipData = chart.setTipData(d, i),
                mouseItem = d3.select(this);

            //Draw tip line
            chart.tip.generateSimpleTip(tipData, chart.data.dataTable);
            chart.tip.d = d;
            chart.tip.i = i;
            svg.selectAll('.tip-line').remove();

            tipLineX = mouseItem.node().getBBox().x;
            tipLineWidth = mouseItem.node().getBBox().width;
            tipLineHeight = mouseItem.node().getBBox().height;
            tipLineY = mouseItem.node().getBBox().y;

            //Draw line in center of event-rect
            svg.append('line').attr('class', 'tip-line').attr('x1', function () {
                return chart._vars.rotateAxis ? 0 : tipLineX + tipLineWidth / 2;
            }).attr('x2', function () {
                return chart._vars.rotateAxis ? tipLineWidth : tipLineX + tipLineWidth / 2;
            }).attr('y1', function () {
                return chart._vars.rotateAxis ? tipLineY + tipLineHeight / 2 : 0;
            }).attr('y2', function () {
                return chart._vars.rotateAxis ? tipLineY + tipLineHeight / 2 : tipLineHeight;
            }).attr('fill', 'none').attr('shape-rendering', 'crispEdges').attr('stroke', 'black').attr('stroke-width', '1px');
        }
    }).on('mousemove', function (d, i) {
        if (chart.showToolTip) {
            if (chart.tip.d === d && chart.tip.i === i) {
                chart.tip.showTip();
            } else {
                //Get tip data
                var tipData = chart.setTipData(d, i);
                //Draw tip line
                chart.tip.generateSimpleTip(tipData, chart.data.dataTable);
            }
        }
    }).on('mouseout', function () {
        if (chart.showToolTip) {
            chart.tip.hideTip();
            svg.selectAll('line.tip-line').remove();
        }
    });

    chart.displayValues();
    chart.generateClipPath();
    chart.generateBarThreshold();
}

/**generateBarGroups
 *
 * Paints the groups of the bars
 * @params chartContainer, barData, chart
 */
function generateBarGroups(chartContainer, barData, chart) {
    var container = chart.config.container,
        xAxisData = chart.currentData.xAxisData,
        yAxisData = chart.currentData.yAxisData,
        colors = chart._vars.color,
        x = jvCharts.getAxisScale('x', xAxisData, container, chart._vars),
        y = jvCharts.getAxisScale('y', yAxisData, container, chart._vars),
        posCalc = jvCharts.getPosCalculations(barData, chart._vars, xAxisData, yAxisData, container, chart),
        dataToPlot = jvCharts.getPlotData(barData, chart),
        barGroups,
        externalCounterForJ,
        bars;

    if (xAxisData.dataType === 'STRING' || !xAxisData.hasOwnProperty('min')) {
        //Creates bar groups
        barGroups = chartContainer.data(dataToPlot).enter().append('g').attr('class', 'bar-group')
        //Translate the bar groups by (outer padding * step) and the width of the bars (container.width / barData.length * i)
        .attr('transform', function (d, i) {
            return 'translate(' + (x.paddingOuter() * x.step() + x.step() * i) + ' ,0)';
        });
    } else if (xAxisData.dataType === 'NUMBER') {
        //Creates bar groups
        barGroups = chartContainer.data(dataToPlot).enter().append('g').attr('class', 'bar-group')
        //Translate the bar groups by (outer padding * step) and the width of the bars (container.width / barData.length * i)
        .attr('transform', function (d, i) {
            return 'translate(0, ' + (y.paddingOuter() * y.step() + y.step() * i) + ' )';
        });
    }

    //Creates bars within bar groups
    externalCounterForJ = -1;
    bars = barGroups.selectAll('rect').data(function (d) {
        return d;
    }).enter().append('rect').attr('class', function (d, i) {
        var keys = Object.keys(barData[0]),
            filteredKeys = [],
            label = void 0,
            legendVal = void 0,
            thresholdDir = void 0;

        if (i === 0) {
            externalCounterForJ++;
        }

        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
            for (var _iterator2 = keys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var key = _step2.value;

                if (key !== chart.currentData.dataTable.label) {
                    filteredKeys.push(key);
                }
            }
        } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                    _iterator2.return();
                }
            } finally {
                if (_didIteratorError2) {
                    throw _iteratorError2;
                }
            }
        }

        label = String(barData[externalCounterForJ][chart.currentData.dataTable.label]).replace(/\s/g, '_').replace(/\./g, '_dot_');
        legendVal = String(filteredKeys[i]).replace(/\s/g, '_').replace(/\./g, '_dot_');
        thresholdDir;

        if (chart._vars.xAxisThreshold) {
            thresholdDir = chart.setThreshold(barData[externalCounterForJ][chart.currentData.dataTable.label]);
        } else {
            thresholdDir = chart.setThreshold(d);
        }

        return 'editable editable-bar bar-col-' + label + '-index-' + legendVal + ' highlight-class-' + label + ' rect ' + thresholdDir;
    }).attr('x', function (d, i) {
        return posCalc.startx(d, i);
    }).attr('y', function (d, i) {
        return posCalc.starty(d, i);
    }).attr('width', function (d, i) {
        return posCalc.startwidth(d, i);
    }).attr('height', function (d, i) {
        return posCalc.startheight(d, i);
    }).attr('fill', function (d, i) {
        if (chart._vars.seriesFlipped) {
            return jvCharts.getColors(colors, i, chart._vars.flippedLegendHeaders[i]);
        }
        return jvCharts.getColors(colors, i, chart._vars.legendHeaders[i]);
    }).attr('rx', 0).attr('ry', 0).attr('opacity', 0.9).attr('clip-path', function (d) {
        return d > 30000000 ? 'url(#clip-above)' : 'url(#clip-below)';
    });
    if (chart._vars.transitionTime > 0) {
        bars.transition().duration(chart._vars.transitionTime).ease(d3.easePolyOut).attr('x', function (d, i, j) {
            return posCalc.x(d, i, j);
        }).attr('y', function (d, i, j) {
            return posCalc.y(d, i, j);
        }).attr('width', function (d, i) {
            return posCalc.width(d, i);
        }).attr('height', function (d, i) {
            return posCalc.height(d, i);
        });
    } else {
        bars.attr('x', function (d, i, j) {
            return posCalc.x(d, i, j);
        }).attr('y', function (d, i, j) {
            return posCalc.y(d, i, j);
        }).attr('width', function (d, i) {
            return posCalc.width(d, i);
        }).attr('height', function (d, i) {
            return posCalc.height(d, i);
        });
    }

    return barGroups; //returns the bar containers
}

module.exports = jvCharts;

},{"../jvCharts.js":4}],13:[function(require,module,exports){
'use strict';

var jvCharts = require('../jvCharts.js'),
    box;

jvCharts.prototype.boxwhisker = {
    paint: paint,
    setData: setData,
    getEventData: getEventData
};

jvCharts.prototype.generateBoxes = generateBoxes;

/**setBoxData
 *  gets cloud data and adds it to the chart object
 *
 * @params data, dataTable, colors
 */
function setData() {
    var chart = this;
    chart.data.xAxisData = chart.setAxisData('x', chart.data, chart._vars);
    chart.data.yAxisData = chart.setAxisData('y', chart.data, chart._vars);
}

/** paintBoxChart
 *
 *  @desc The initial starting point for bar chart, begins the drawing process. Must already have the data stored in the chart object
 */
function paint(transitionTime) {
    var chart = this,
        dataObj,
        axisData;

    if (transitionTime || transitionTime === 0) {
        chart._vars.transitionTime = transitionTime;
    } else if (!chart._vars.transitionTime) {
        chart._vars.transitionTime = 800;
    }

    dataObj = getBoxDataFromOptions(chart);
    axisData = chart.getBarDataFromOptions();
    //assign current data which is used by all bar chart operations
    if (chart._vars.rotateAxis) {
        chart.currentData = dataObj;
    } else {
        chart.currentData = axisData;
    }
    //Overwrite any pre-existing zoom
    chart.config.zoomEvent = null;
    //generate svg dynamically based on legend data
    chart.generateSVG();
    chart.generateXAxis(axisData.xAxisData);
    chart.generateYAxis(axisData.yAxisData);

    chart.generateBoxes(dataObj);
}

function getEventData() {
    return {};
}

/** getBoxDataFromOptions
 *
 *  @desc Assigns the correct chart data to current data using the chart._vars
 */
function getBoxDataFromOptions(chart) {
    //creating these two data variables to avoid having to reference the chart object everytime
    var csv = chart.data.chartData,
        dataTable = chart.data.dataTable,
        min = Infinity,
        max = -Infinity,
        yAxis = [],
        dataObj = {},
        data = {},
        yAxisLabel = dataTable.label,
        xAxisLabel = dataTable.value,
        xAxisData,
        yAxisData,
        keys = csv.map(function (d) {
        return d[yAxisLabel];
    }),
        keys2 = csv.map(function (d) {
        return d[xAxisLabel];
    }),
        unique = keys.filter(function (item, i, ar) {
        return ar.indexOf(item) === i;
    }),
        temp = [];

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        var _loop = function _loop() {
            var uniqueEle = _step.value;

            var tempData = csv.filter(function (d) {
                return d[yAxisLabel] === uniqueEle;
            });
            temp.push([uniqueEle, tempData.map(function (d) {
                return d[xAxisLabel];
            })]);
        };

        for (var _iterator = unique[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            _loop();
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    max = Math.max.apply(Math, keys2);
    min = Math.min.apply(Math, keys2);
    yAxis.push(min);
    yAxis.push(max);

    xAxisData = { 'label': yAxisLabel, 'dataType': 'STRING', 'values': unique };
    yAxisData = { 'label': xAxisLabel, 'dataType': 'NUMBER', 'values': yAxis };

    dataObj.chartData = temp;
    dataObj.dataTable = data.dataTable;
    chart._vars.color = data.color;

    dataObj.xAxisData = xAxisData;
    dataObj.yAxisData = yAxisData;
    data = {
        yAxisData: dataObj.yAxisData,
        xAxisData: dataObj.xAxisData
    };

    if (chart._vars.rotateAxis) {
        dataObj.xAxisData = data.yAxisData;
        dataObj.yAxisData = data.xAxisData;
    } else {
        dataObj.xAxisData = data.xAxisData;
        dataObj.yAxisData = data.yAxisData;
    }

    return dataObj;
}

/** generateBars
 *
 * @desc Does the actual painting of bars on the bar chart
 * @params boxData
 */
function generateBoxes(boxData) {
    var chart = this,
        svg = chart.svg,
        options = chart._vars,
        container = chart.config.container,
        height = container.height,
        width = container.width,
        x,
        boxChart,
        margin = { top: 0, right: 50, bottom: 70, left: 50 };

    if (options.rotateAxis) {
        x = d3.scaleBand().domain(boxData.chartData.map(function (d) {
            return d[0];
        })).rangeRound([0, height]).paddingInner(0.7).paddingOuter(0.3);
        boxChart = box().whiskers(iqr(1.5)).height(width).domain([boxData.xAxisData.values[0], boxData.xAxisData.values[1]]).showLabels(options.displayValues).flipped(options.rotateAxis).duration(options.transitionTime).chart(chart);
    } else {
        x = d3.scaleBand().domain(boxData.chartData.map(function (d) {
            return d[0];
        })).rangeRound([0, width]).paddingInner(0.7).paddingOuter(0.3);
        boxChart = box().whiskers(iqr(1.5)).height(height).domain([boxData.yAxisData.values[0], boxData.yAxisData.values[1]]).showLabels(options.displayValues).flipped(options.rotateAxis).duration(options.transitionTime).chart(chart);
    }
    //draw the boxplots
    svg.attr('class', 'boxwhisker-container').selectAll('.box').data(boxData.chartData).enter().append('g').attr('class', 'box-container').attr('style', 'pointer-events: all;').attr('transform', function (d) {
        return options.rotateAxis ? 'translate(' + margin.top + ', ' + x(d[0]) + ')' : 'translate(' + x(d[0]) + ', ' + margin.top + ')';
    }).call(boxChart.width(x.bandwidth()));

    d3.selectAll('rect.box').attr('class', function (d, i) {
        return 'editable editable-box box-' + i + ' highlight-class-' + i + 'box';
    });
    hideLabelsOnOverlap(x, width, svg);
}

/**
 * @name hideLabelsOnOverlap
 * @desc determines if text on graph should be displayed or not
 */
function hideLabelsOnOverlap(x, width, svg) {
    var numSpacesBetween = x.domain().length - 1,
        totalBoxWidth = x.bandwidth() * x.domain().length,
        widthOfSpaces = (width - totalBoxWidth) / numSpacesBetween,
        xAxisLabelLengthLimit = x.bandwidth() + widthOfSpaces,
        ticks = svg.selectAll('.xAxis text');

    ticks.each(function () {
        if (this.getBBox().width > xAxisLabelLengthLimit) {
            svg.selectAll('.xAxis text').attr('style', 'display:none');
            svg.selectAll('text.box').attr('style', 'display:none');
            svg.selectAll('text.whisker').attr('style', 'display:none');
        }
    });
}

/**
 * @name iqr
 * @desc Returns a function to compute the interquartile range.
 */
function iqr(k) {
    return function (d, i) {
        var q1 = d.quartiles[0],
            q3 = d.quartiles[2],
            iqr = (q3 - q1) * k,
            i = -1,
            j = d.length;
        while (d[++i] < q1 - iqr) {}
        while (d[--j] > q3 + iqr) {}
        return [i, j];
    };
}

//Inspired by http://informationandvisualization.de/blog/box-plot
box = function box() {
    var width = 1,
        height = 1,
        duration = 0,
        domain = null,
        value = Number,
        whiskers = boxWhiskers,
        quartiles = boxQuartiles,
        showLabels = true,
        //whether or not to show text labels
    numBars = 4,
        curBar = 1,
        tickFormat = null,
        chart = {},
        flipped = false;

    //For each small multiple…
    function box(g) {
        g.each(function (data, i) {
            var d = data[1].sort(d3.ascending),
                g = d3.select(this),
                n = d.length,
                min = d[0],
                max = d[n - 1],
                outlierLabel = data[0];

            //Compute quartiles. Must return exactly 3 elements.
            var quartileData = d.quartiles = quartiles(d);

            //Compute whiskers. Must return exactly 2 elements, or null.
            var whiskerIndices = whiskers && whiskers.call(this, d, i),
                whiskerData = whiskerIndices && whiskerIndices.map(function (i) {
                return d[i];
            });

            //Compute outliers. If no whiskers are specified, all data are 'outliers'.
            //We compute the outliers as indices, so that we can join across transitions!
            var outlierIndices = whiskerIndices ? d3.range(0, whiskerIndices[0]).concat(d3.range(whiskerIndices[1] + 1, n)) : d3.range(n);

            //Compute the new x-scale.
            if (flipped) {
                var x1 = d3.scaleLinear().domain(domain && domain.call(this, d, i) || [min, max]).range([0, height]);
            } else {
                var x1 = d3.scaleLinear().domain(domain && domain.call(this, d, i) || [min, max]).range([height, 0]);
            }

            //Retrieve the old x-scale, if this is an update.
            var x0 = this.__chart__ || d3.scaleLinear().domain([0, Infinity])
            //.domain([0, max])
            .range(x1.range());

            //Stash the new scale.
            this.__chart__ = x1;

            //Note: the box, median, and box tick elements are fixed in number,
            //so we only have to handle enter and update. In contrast, the outliers
            //and other elements are variable, so we need to exit them! Variable
            //elements also fade in and out.

            //Update outliers.
            var outlier = g.selectAll('circle.outlier').data(outlierIndices, Number);

            outlier = outlier.enter().append('g');

            if (flipped) {
                outlier.insert('circle', 'text').attr('class', 'outlier').attr('fill', 'white').attr('r', function () {
                    if (width > 10) {
                        return 5;
                    }

                    return width / 2;
                }).attr('cy', width / 2).attr('cx', function (i) {
                    return x0(d[i]);
                }).style('opacity', 1e-6).transition().duration(duration).attr('cx', function (i) {
                    return x1(d[i]);
                }).style('opacity', 1);

                outlier.append('text').text(function (i) {
                    return d[i];
                }).attr('y', width / 2 + 7).attr('x', function (i) {
                    return x1(d[i]) + 4;
                }).attr('class', 'outlier-label').attr('font-size', '10px').attr('style', function () {
                    if (!showLabels) {
                        return 'display:none;';
                    }

                    return '';
                });
                outlier.exit().transition().duration(duration).attr('cx', function (i) {
                    return x1(d[i]);
                }).style('opacity', 1e-6).remove();
            } else {
                outlier.insert('circle', 'text').attr('class', 'outlier').attr('fill', 'white').attr('r', function () {
                    if (width > 10) {
                        return 5;
                    }

                    return width / 2;
                }).attr('cx', width / 2).attr('cy', function (i) {
                    return x0(d[i]);
                }).style('opacity', 1e-6).transition().duration(duration).attr('cy', function (i) {
                    return x1(d[i]);
                }).style('opacity', 1);

                outlier.append('text').text(function (i) {
                    return d[i];
                }).attr('x', width / 2 + 7).attr('y', function (i) {
                    return x1(d[i]) + 4;
                }).attr('class', 'outlier-label').attr('font-size', '10px').attr('style', function () {
                    if (!showLabels) {
                        return 'display:none;';
                    }

                    return '';
                });

                outlier.transition().duration(duration).attr('cy', function (i) {
                    return x1(d[i]);
                }).style('opacity', 1);

                outlier.exit().transition().duration(duration).attr('cy', function (i) {
                    return x1(d[i]);
                }).style('opacity', 1e-6).remove();
            }

            outlier.on('mouseover', function (i) {
                if (chart.showToolTip) {
                    var _outlier = [d[i]];
                    var _data = { Outlier: _outlier, Label: outlierLabel };
                    var tipData = chart.setTipData(_data, i);

                    chart.tip.generateSimpleTip(tipData, _data);
                    chart.tip.d = d.data;
                    chart.tip.i = i;
                }
            }).on('mousemove', function (i) {
                if (chart.showToolTip) {
                    var _outlier2 = [d[i]];
                    var _data2 = { Outlier: _outlier2, Label: outlierLabel };
                    var tipData = chart.setTipData(_data2, i);

                    chart.tip.generateSimpleTip(tipData, _data2);
                    chart.tip.d = d.data;
                    chart.tip.i = i;
                }
            }).on('mouseout', function () {
                if (chart.showToolTip) {
                    chart.tip.hideTip();
                }
            });

            //set separate tooltips for quartiles and whiskers
            g = g.append('g').attr('class', 'inner-box-container').on('mouseover', function (label) {
                if (chart.showToolTip) {
                    var _data3 = {
                        Quartiles: d.quartiles,
                        Whiskers: whiskerData,
                        Label: label[0]
                    };
                    var tipData = chart.setTipData(_data3, i);

                    chart.tip.generateSimpleTip(tipData, _data3);
                    chart.tip.d = d.data;
                    chart.tip.i = i;
                }
            }).on('mousemove', function (label) {
                if (chart.showToolTip) {
                    var _data4 = {
                        Quartiles: d.quartiles,
                        Whiskers: whiskerData,
                        Label: label[0]
                    };
                    var tipData = chart.setTipData(_data4, i);

                    chart.tip.generateSimpleTip(tipData, _data4);
                    chart.tip.d = d.data;
                    chart.tip.i = i;
                }
            }).on('mouseleave', function () {
                if (chart.showToolTip) {
                    chart.tip.hideTip();
                }
            });

            //Update center line: the vertical line spanning the whiskers.
            var center = g.selectAll('line.center').data(whiskerData ? [whiskerData] : []);
            //vertical line
            if (flipped) {
                center.enter().insert('line', 'rect').attr('class', 'center').attr('y1', width / 2).attr('x1', function (d) {
                    return x0(d[0]);
                }).attr('y2', width / 2).attr('x2', function (d) {
                    return x0(d[1]);
                }).style('opacity', 1e-6).transition().duration(duration).style('opacity', 1).attr('x1', function (d) {
                    return x1(d[0]);
                }).attr('x2', function (d) {
                    return x1(d[1]);
                });

                center.transition().duration(duration).style('opacity', 1).attr('x1', function (d) {
                    return x1(d[0]);
                }).attr('x2', function (d) {
                    return x1(d[1]);
                });

                center.exit().transition().duration(duration).style('opacity', 1e-6).attr('x1', function (d) {
                    return x1(d[0]);
                }).attr('x2', function (d) {
                    return x1(d[1]);
                }).remove();
            } else {
                center.enter().insert('line', 'rect').attr('class', 'center').attr('x1', width / 2).attr('y1', function (d) {
                    return x0(d[0]);
                }).attr('x2', width / 2).attr('y2', function (d) {
                    return x0(d[1]);
                }).style('opacity', 1e-6).transition().duration(duration).style('opacity', 1).attr('y1', function (d) {
                    return x1(d[0]);
                }).attr('y2', function (d) {
                    return x1(d[1]);
                });

                center.transition().duration(duration).style('opacity', 1).attr('y1', function (d) {
                    return x1(d[0]);
                }).attr('y2', function (d) {
                    return x1(d[1]);
                });

                center.exit().transition().duration(duration).style('opacity', 1e-6).attr('y1', function (d) {
                    return x1(d[0]);
                }).attr('y2', function (d) {
                    return x1(d[1]);
                }).remove();
            }

            var hoverArea = g.selectAll('line.hover-area').data(whiskerData ? [whiskerData] : []);
            //vertical line
            if (flipped) {
                hoverArea.enter().insert('line', 'rect').attr('class', 'hover-area').attr('y1', width / 2).attr('x1', function (d) {
                    return x0(d[0]);
                }).attr('y2', width / 2).attr('x2', function (d) {
                    return x0(d[1]);
                }).style('opacity', 0).style('stroke-width', width).transition().duration(duration).style('opacity', 0).attr('x1', function (d) {
                    return x1(d[0]);
                }).attr('x2', function (d) {
                    return x1(d[1]);
                });

                hoverArea.transition().duration(duration).style('opacity', 0).attr('x1', function (d) {
                    return x1(d[0]);
                }).attr('x2', function (d) {
                    return x1(d[1]);
                });

                hoverArea.exit().transition().duration(duration).style('opacity', 0).attr('x1', function (d) {
                    return x1(d[0]);
                }).attr('x2', function (d) {
                    return x1(d[1]);
                }).remove();
            } else {
                hoverArea.enter().insert('line', 'rect').attr('class', 'hover-area').attr('x1', width / 2).attr('y1', function (d) {
                    return x0(d[0]);
                }).attr('x2', width / 2).attr('y2', function (d) {
                    return x0(d[1]);
                }).style('opacity', 0).style('stroke-width', width).transition().duration(duration).style('opacity', 0).attr('y1', function (d) {
                    return x1(d[0]);
                }).attr('y2', function (d) {
                    return x1(d[1]);
                });

                hoverArea.transition().duration(duration).style('opacity', 0).attr('y1', function (d) {
                    return x1(d[0]);
                }).attr('y2', function (d) {
                    return x1(d[1]);
                });

                hoverArea.exit().transition().duration(duration).style('opacity', 0).attr('y1', function (d) {
                    return x1(d[0]);
                }).attr('y2', function (d) {
                    return x1(d[1]);
                }).remove();
            }
            //Update innerquartile box.
            var box = g.selectAll('rect.box').data([quartileData]);
            if (flipped) {
                box.enter().append('rect').attr('fill', 'steelblue').attr('class', 'box').attr('y', 0).attr('x', function (d) {
                    return x0(d[2]) - Math.abs(x0(d[0]) - x0(d[2]));
                }).attr('height', width).attr('width', function (d) {
                    return Math.abs(x0(d[0]) - x0(d[2]));
                }).transition().duration(duration).attr('x', function (d) {
                    return x1(d[2]) - Math.abs(x1(d[0]) - x1(d[2]));
                }).attr('width', function (d) {
                    return Math.abs(x1(d[0]) - x1(d[2]));
                });

                box.transition().duration(duration).attr('x', function (d) {
                    return x1(d[2]) - Math.abs(x1(d[0]) - x1(d[2]));
                }).attr('width', function (d) {
                    return Math.abs(x1(d[0]) - x1(d[2]));
                });
            } else {
                box.enter().append('rect').attr('fill', 'steelblue').attr('class', 'box').attr('x', 0).attr('y', function (d) {
                    return x0(d[2]);
                }).attr('width', width).attr('height', function (d) {
                    return x0(d[0]) - x0(d[2]);
                }).transition().duration(duration).attr('y', function (d) {
                    return x1(d[2]);
                }).attr('height', function (d) {
                    return x1(d[0]) - x1(d[2]);
                });

                box.transition().duration(duration).attr('y', function (d) {
                    return x1(d[2]);
                }).attr('height', function (d) {
                    return x1(d[0]) - x1(d[2]);
                });
            }
            //Update median line.
            var medianLine = g.selectAll('line.median').data([quartileData[1]]);
            if (flipped) {
                medianLine.enter().append('line').attr('class', 'median').attr('y1', 0).attr('x1', x0).attr('y2', width).attr('x2', x0).transition().duration(duration).attr('x1', x1).attr('x2', x1);

                medianLine.transition().duration(duration).attr('x1', x1).attr('x2', x1);
            } else {
                medianLine.enter().append('line').attr('class', 'median').attr('x1', 0).attr('y1', x0).attr('x2', width).attr('y2', x0).transition().duration(duration).attr('y1', x1).attr('y2', x1);

                medianLine.transition().duration(duration).attr('y1', x1).attr('y2', x1);
            }
            //Update whiskers.
            var whisker = g.selectAll('line.whisker').data(whiskerData || []);
            if (flipped) {
                whisker.enter().insert('line', 'circle, text').attr('class', 'whisker').attr('y1', 0).attr('x1', x0).attr('y2', 0 + width).attr('x2', x0).style('opacity', 1e-6).transition().duration(duration).attr('x1', x1).attr('x2', x1).style('opacity', 1);

                whisker.transition().duration(duration).attr('x1', x1).attr('x2', x1).style('opacity', 1);

                whisker.exit().transition().duration(duration).attr('x1', x1).attr('x2', x1).style('opacity', 1e-6).remove();
            } else {
                whisker.enter().insert('line', 'circle, text').attr('class', 'whisker').attr('x1', 0).attr('y1', x0).attr('x2', 0 + width).attr('y2', x0).style('opacity', 1e-6).transition().duration(duration).attr('y1', x1).attr('y2', x1).style('opacity', 1);

                whisker.transition().duration(duration).attr('y1', x1).attr('y2', x1).style('opacity', 1);

                whisker.exit().transition().duration(duration).attr('y1', x1).attr('y2', x1).style('opacity', 1e-6).remove();
            }
            //Compute the tick format.
            var format = tickFormat || x1.tickFormat(8);

            //Update box ticks.
            var boxTick = g.selectAll('text.box').data(quartileData);

            if (flipped) {
                boxTick.enter().append('text').attr('class', 'box').attr('dx', '.3em').attr('dy', function (d, i) {
                    return i & 1 ? 6 : -6;
                }).attr('y', function (d, i) {
                    return i & 1 ? +width : 0;
                }).attr('x', x0).attr('text-anchor', function (d, i) {
                    return i & 1 ? 'start' : 'end';
                }).attr('style', function () {
                    if (!showLabels) {
                        return 'display: none;';
                    }
                }).text(format).transition().duration(duration).attr('x', x1);

                boxTick.transition().duration(duration).text(format).attr('x', x1);
            } else {
                boxTick.enter().append('text').attr('class', 'box').attr('dy', '.3em').attr('dx', function (d, i) {
                    return i & 1 ? 6 : -6;
                }).attr('x', function (d, i) {
                    return i & 1 ? +width : 0;
                }).attr('y', x0).attr('text-anchor', function (d, i) {
                    return i & 1 ? 'start' : 'end';
                }).attr('style', function () {
                    if (!showLabels) {
                        return 'display: none;';
                    }
                }).text(format).transition().duration(duration).attr('y', x1);

                boxTick.transition().duration(duration).text(format).attr('y', x1);
            }
            //Update whisker ticks. These are handled separately from the box
            //ticks because they may or may not exist, and we want don't want
            //to join box ticks pre-transition with whisker ticks post-.
            var whiskerTick = g.selectAll('text.whisker').data(whiskerData || []);

            if (flipped) {
                whiskerTick.enter().append('text').attr('class', 'whisker').attr('dx', '.3em').attr('dy', 6).attr('y', width).attr('x', x0).attr('style', function () {
                    if (!showLabels) {
                        return 'display:none;';
                    }
                }).text(format).style('opacity', 1e-6).transition().duration(duration).attr('x', x1).style('opacity', 1);

                whiskerTick.transition().duration(duration).text(format).attr('x', x1).style('opacity', 1);

                whiskerTick.exit().transition().duration(duration).attr('x', x1).style('opacity', 1e-6).remove();
            } else {
                whiskerTick.enter().append('text').attr('class', 'whisker').attr('dy', '.3em').attr('dx', 6).attr('x', width).attr('y', x0).attr('style', function () {
                    if (!showLabels) {
                        return 'display:none;';
                    }
                }).text(format).style('opacity', 1e-6).transition().duration(duration).attr('y', x1).style('opacity', 1);

                whiskerTick.transition().duration(duration).text(format).attr('y', x1).style('opacity', 1);

                whiskerTick.exit().transition().duration(duration).attr('y', x1).style('opacity', 1e-6).remove();
            }
        });
        //d3.timer.flush();
        d3.timerFlush();
    }

    box.width = function (x) {
        if (!arguments.length) return width;
        width = x;
        return box;
    };

    box.height = function (x) {
        if (!arguments.length) return height;
        height = x;
        return box;
    };

    box.tickFormat = function (x) {
        if (!arguments.length) return tickFormat;
        tickFormat = x;
        return box;
    };

    box.duration = function (x) {
        if (!arguments.length) return duration;
        duration = x;
        return box;
    };

    function constant(x) {
        return function () {
            return x;
        };
    }
    box.domain = function (x) {
        if (!arguments.length) return domain;
        //domain = x == null ? x : d3.functor(x);
        domain = x == null ? x : constant(x);

        return box;
    };

    box.value = function (x) {
        if (!arguments.length) return value;
        value = x;
        return box;
    };

    box.whiskers = function (x) {
        if (!arguments.length) return whiskers;
        whiskers = x;
        return box;
    };

    box.showLabels = function (x) {
        if (!arguments.length) return showLabels;
        showLabels = x;
        return box;
    };

    box.flipped = function (x) {
        if (!arguments.length) return flipped;
        flipped = x;
        return box;
    };

    box.chart = function (x) {
        if (!arguments.length) return chart;
        chart = x;
        return box;
    };

    box.quartiles = function (x) {
        if (!arguments.length) return quartiles;
        quartiles = x;
        return box;
    };

    return box;
};

function boxWhiskers(d) {
    return [0, d.length - 1];
}

function boxQuartiles(d) {
    return [d3.quantile(d, 0.25), d3.quantile(d, 0.5), d3.quantile(d, 0.75)];
}

module.exports = jvCharts;

},{"../jvCharts.js":4}],14:[function(require,module,exports){
'use strict';

var jvCharts = require('../jvCharts.js');

jvCharts.prototype.bubble = {
    paint: paint,
    setData: setData,
    getEventData: getEventData
};

jvCharts.prototype.generateBubble = generateBubble;

/************************************************ Bubble functions ******************************************************/

function paint(transitionTime) {
    var chart = this,
        bubbleMargins = {
        top: 15,
        right: 15,
        left: 15,
        bottom: 15
    };
    if (transitionTime || transitionTime === 0) {
        chart._vars.transitionTime = transitionTime;
    } else if (!chart._vars.transitionTime) {
        chart._vars.transitionTime = 800;
    }
    if (!chart.smallerFontRepaint) {
        chart._vars.fontSizeMax = 80;
        chart.currentData = chart.data;
    } else {
        chart.currentData = JSON.parse(JSON.stringify(chart.data));
    }

    chart._vars.color = chart.data.color;

    //Generate SVG-legend data is used to determine the size of the bottom margin (set to null for no legend)
    chart.generateSVG(null, bubbleMargins);
    chart.generateVerticalLegend('generateBubble');
    chart.generateBubble(chart.currentData);
}

/**setData
 *  gets Bubble data and adds it to the chart object
 *
 * @params data, dataTable, colors
 */
function setData() {
    var chart = this;
    //define color object for chartData
    chart.data.legendData = setBubbleLegendData(chart.data);
    chart.data.color = jvCharts.setChartColors(chart._vars.color, chart.data.legendData, chart.colors);
}

function getEventData() {
    return {};
}

/**setBubbleLegendData
 *  gets legend info from chart Data
 *
 * @params data, type
 * @returns [] of legend text
 */
function setBubbleLegendData(data) {
    var legendArray = [],
        item = data.dataTable.label;

    for (var value in data.chartData) {
        if (data.chartData.hasOwnProperty(value)) {
            var legendElement = data.chartData[value][item];
            if (legendArray.indexOf(legendElement) === -1) {
                legendArray.push(legendElement);
            }
        }
    }

    return legendArray;
}

/** generateBubble
 *
 * paints the bubble  on the chart
 * @params bubble Data
 */
function generateBubble(bubbleData) {
    var chart = this,
        svg = chart.svg,
        container = chart.config.container,
        width = container.width,
        height = container.height,
        pack = d3.pack().size([width, height]).padding(1.5),
        legendData = chart.data.legendData,
        valueKey = chart.data.dataTable.value,
        labelKey = chart.data.dataTable.label,
        colors = chart._vars.color,
        dataHeaders,
        bubbleDataNew,
        legendElementToggleArray,
        root,
        bubble;

    if (!chart._vars.legendHeaders) {
        chart._vars.legendHeaders = legendData;
    }
    dataHeaders = chart._vars.legendHeaders;
    if (!chart._vars.legendHeaders) {
        chart._vars.legendHeaders = legendData;
    }
    bubbleDataNew = jvCharts.getToggledData(bubbleData, dataHeaders);
    legendElementToggleArray = jvCharts.getLegendElementToggleArray(dataHeaders, legendData);

    if (legendElementToggleArray) {
        for (var j = 0; j < bubbleDataNew.length; j++) {
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = legendElementToggleArray[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var legendEle = _step.value;

                    if (legendEle.element === bubbleDataNew[j][labelKey] && legendEle.toggle === false) {
                        bubbleDataNew.splice(j, 1);
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
        }
    }
    svg.selectAll('.bubble').remove();
    //assigns the data to a hierarchy using parent-child relationships
    root = d3.hierarchy({ children: bubbleDataNew }).sum(function (d) {
        return d[valueKey];
    });

    bubble = svg.selectAll('.bubble').data(pack(root).leaves()).enter().append('g').attr('class', 'bubble').attr('transform', function (d) {
        return 'translate(' + d.x + ',' + d.y + ')';
    });

    bubble.append('circle').attr('fill', function (d) {
        return jvCharts.getColors(colors, legendData.indexOf(d.data[labelKey]), d.data[labelKey]);
    }).attr('class', function (d, i) {
        return 'editable editable-bubble bubble-' + i + ' highlight-class-' + i;
    }).attr('r', function (d) {
        return d.r;
    }).on('mouseover', function (d, i) {
        if (chart.showToolTip) {
            //Get tip data
            var tipData = chart.setTipData(d.data, i);
            //Draw tip line
            tipData.data.color = jvCharts.getColors(colors, tipData.index, d.data[labelKey]);
            chart.tip.generateSimpleTip(tipData, chart.data.dataTable);
            chart.tip.d = d.data;
            chart.tip.i = i;
        }
    }).on('mousemove', function (d, i) {
        if (chart.showToolTip) {
            if (chart.tip.d === d && chart.tip.i === i) {
                chart.tip.showTip(0);
            } else {
                //Get tip data
                var tipData = chart.setTipData(d.data, i);
                //Draw tip line
                chart.tip.generateSimpleTip(tipData, chart.data.dataTable);
            }
        }
    }).on('mouseout', function (d) {
        if (chart.showToolTip) {
            chart.tip.hideTip();
        }
    });

    bubble.append('text').attr('class', 'bubble-text').text(function (d) {
        return d.data[labelKey];
    }).attr('fill', 'white')
    //hide text if its too wide
    .attr('style', function (d) {
        if (this.clientWidth > d.r * 2) {
            return 'display: none';
        }
        return '';
    })
    //center the text on the bubble
    .attr('transform', function (d) {
        var diameter = d.r * 2,
            textWidth = this.clientWidth,
            emptySpace = diameter - textWidth;

        if (emptySpace < 0) {
            return '';
        }
        return 'translate(-' + (d.r - emptySpace / 2) + ', 0)';
    }).on('mouseover', function (d, i) {
        if (chart.showToolTip) {
            //Get tip data
            var tipData = chart.setTipData(d.data, i);

            //Draw tip line
            tipData.data.color = jvCharts.getColors(colors, tipData.index, d.data[labelKey]);
            chart.tip.generateSimpleTip(tipData, chart.data.dataTable);
            chart.tip.d = d.data;
            chart.tip.i = i;
        }
    }).on('mousemove', function (d, i) {
        if (chart.showToolTip) {
            if (chart.tip.d === d && chart.tip.i === i) {
                chart.tip.showTip(0);
            } else {
                //Get tip data
                var tipData = chart.setTipData(d.data, i);
                //Draw tip line
                chart.tip.generateSimpleTip(tipData, chart.data.dataTable);
            }
        }
    }).on('mouseout', function () {
        if (chart.showToolTip) {
            chart.tip.hideTip();
        }
    });

    bubble.append('text').text(function (d) {
        return d.data[valueKey];
    }).attr('fill', 'white')
    //hide text if its too wide
    .attr('style', function (d) {
        if (this.clientWidth > d.r * 2) {
            return 'display: none';
        }
        return '';
    })
    //center the text on the bubble
    .attr('transform', function (d) {
        var diameter = d.r * 2,
            textWidth = this.clientWidth,
            emptySpace = diameter - textWidth;

        if (emptySpace < 0) {
            return '';
        }
        return 'translate(-' + (d.r - emptySpace / 2) + ', 15)';
    }).on('mouseover', function (d, i) {
        if (chart.showToolTip) {
            //Get tip data
            var tipData = chart.setTipData(d.data, i);

            //Draw tip line
            tipData.data.color = jvCharts.getColors(colors, tipData.index, d.data[labelKey]);
            chart.tip.generateSimpleTip(tipData, chart.data.dataTable);
            chart.tip.d = d.data;
            chart.tip.i = i;
        }
    }).on('mousemove', function (d, i) {
        if (chart.showToolTip) {
            if (chart.tip.d === d && chart.tip.i === i) {
                chart.tip.showTip(0);
            } else {
                //Get tip data
                var tipData = chart.setTipData(d.data, i);
                //Draw tip line
                chart.tip.generateSimpleTip(tipData, chart.data.dataTable);
            }
        }
    }).on('mouseout', function () {
        if (chart.showToolTip) {
            chart.tip.hideTip();
        }
    });
}

module.exports = jvCharts;

},{"../jvCharts.js":4}],15:[function(require,module,exports){
'use strict';

var jvCharts = require('../jvCharts.js');

jvCharts.prototype.clustergram = {
    paint: paint,
    setData: setData,
    getEventData: null
};

jvCharts.prototype.generateClustergram = generateClustergram;

/************************************************ Clustergram functions ******************************************************/

/**setClustergramData
 *  gets heatmap data and adds it to the chart object
 *
 * @params data, dataTable, colors
 */
function setData() {
    var chart = this,
        leftTreeData = chart.data.chartData[0],
        rightTreeData = chart.data.chartData[1];

    chart.leftLabels = {};
    chart.leftLabels.values = [];
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = leftTreeData.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var leftEle = _step.value;

            if (leftEle.name) {
                chart.leftLabels.values.push(leftEle.name);
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    chart.rightLabels = {};
    chart.rightLabels.values = [];
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
        for (var _iterator2 = rightTreeData.children[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var rightEle = _step2.value;

            if (rightEle.name) {
                chart.rightLabels.values.push(rightEle.name);
            }
        }
    } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
            }
        } finally {
            if (_didIteratorError2) {
                throw _iteratorError2;
            }
        }
    }

    chart.leftLeaves = getLeafNodes([leftTreeData]);
    chart.rightLeaves = getLeafNodes([rightTreeData]);
}

function getLeafNodes(nodes) {
    var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

    var returnData = result;
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
        for (var _iterator3 = nodes[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var node = _step3.value;

            if (node.children.length === 0) {
                returnData.push(node.name);
            } else {
                returnData = getLeafNodes(node.children, returnData);
            }
        }
    } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
            }
        } finally {
            if (_didIteratorError3) {
                throw _iteratorError3;
            }
        }
    }

    return returnData;
}

function paint() {
    var chart = this,
        customMargin = {
        top: 20,
        right: 40,
        left: 0,
        bottom: 20
    };
    chart._vars.color = chart.data.color;
    chart.currentData = chart.data; //Might have to move into method bc of reference/value relationship

    //Generate SVG-legend data is used to determine the size of the bottom margin (set to null for no legend)
    chart.generateSVG(null, customMargin);
    //chart.generateLegend(chart.currentData.legendData, 'generateClustergram');
    chart.generateClustergram();
}

/**generateClustergram
 *
 * paints the Clustergram on the chart
 * @params ClustergramData
 */
function generateClustergram() {
    var chart = this,
        svg = chart.svg,
        container = chart.config.container,
        leftTreeData = chart.data.chartData[0],
        rightTreeData = chart.data.chartData[1],
        gridData = chart.data.chartData[2],
        sizeWidth = chart.rightLeaves.length * 20,
        sizeHeight = chart.leftLeaves.length * 20,
        vis,
        leftG,
        bottomG,
        heatG,
        newWidth,
        newHeight,
        leftChildCount,
        rightChildCount;

    chart.data.yAxisData = [];
    chart.data.xAxisData = [];

    if (sizeWidth < container.width) {
        sizeWidth = container.width;
    }

    if (sizeHeight < container.height) {
        sizeHeight = container.height;
    }

    //remove svg elements
    svg.selectAll('*').remove();

    vis = svg.append('g').attr('transform', 'translate(0, 0)').attr('class', 'heatmap');
    leftG = vis.append('g').attr('id', 'left-tree');
    bottomG = vis.append('g').attr('id', 'bottom-tree');
    heatG = vis.append('g').attr('class', 'clustergram-container').attr('id', 'heat');

    d3.select('body').append('div').attr('class', 'tooltip').style('opacity', 0);
    //calc new width and height
    newWidth = sizeWidth / 2;
    newHeight = sizeHeight / 2;

    leftChildCount = buildTree(leftTreeData, chart.data.yAxisData, leftG, newHeight, newWidth, 'left');
    rightChildCount = buildTree(rightTreeData, chart.data.xAxisData, bottomG, newHeight, newWidth, 'right');
    buildHeat(chart, gridData, heatG, newHeight, newWidth, leftChildCount, rightChildCount);

    chart.zoomed = function () {
        return svg.attr('transform', d3.event.transform);
    };
    chart.chartDiv.select('.editable-svg').call(d3.zoom().on('zoom', chart.zoomed));

    //align G tags
    chart._vars.leftTreeWidth = leftG.node().getBBox().width;
    chart._vars.topTreeHeight = bottomG.node().getBBox().height;
    leftG.attr('transform', 'translate(' + 0 + ',' + chart._vars.topTreeHeight + ')');
    bottomG.attr('transform', 'translate(' + chart._vars.leftTreeWidth + ',' + 0 + ')');
    heatG.attr('transform', 'translate(' + chart._vars.leftTreeWidth + ',' + chart._vars.topTreeHeight + ')');

    chart.config.container.height = heatG.node().getBBox().height;
    chart.config.container.width = heatG.node().getBBox().width;
}

function findPath(child) {
    var str = '';
    var childNode = child;
    while (childNode.parent) {
        str += childNode.data.name + '.';
        childNode = childNode.parent;
    }
    return str.slice(0, -1);
}

function buildTree(data, axisData, gEle, newHeight, newWidth, sideOfTree) {
    var makeTree,
        root,
        childCount = 0;

    makeTree = d3.cluster().size(sideOfTree === 'left' ? [newHeight, newWidth] : [newWidth, newHeight]);

    root = d3.hierarchy(data);
    makeTree(root);

    gEle.selectAll('.cluster-link').data(root.descendants().slice(1)).enter().append('path').attr('class', 'cluster-link').style('fill', 'none').style('stroke', 'black').attr('d', function (d) {
        if (sideOfTree === 'left') {
            return 'M' + d.y / 8 + ',' + d.x + 'V' + d.parent.x + 'H' + d.parent.y / 8;
        }
        return 'M' + d.x + ',' + d.y / 8 + 'V' + d.parent.y / 8 + 'H' + d.parent.x;
    });

    gEle.selectAll('.cluster-node').data(root.descendants()).enter().append('g').attr('class', function (d) {
        return 'cluster-node ' + (d.children ? 'cluster-node--internal' : 'cluster-node--leaf');
    }).attr('transform', function (d) {
        if (sideOfTree === 'left') {
            return 'translate(' + d.y / 8 + ', ' + d.x + ')';
        }
        return 'translate(' + d.x + ', ' + d.y / 8 + ')rotate(15)';
    });

    if (sideOfTree === 'left') {
        gEle.selectAll('.cluster-node').append('text').attr('dy', 3).attr('x', function (d) {
            return d.children ? -8 : 0;
        }).style('text-anchor', 'end').text(function (d) {
            if (!d.children) {
                childCount++;
                axisData.push(findPath(d));
            }
            //return d.data.name;
            if (d.data.name === 'root') {
                return '';
            }
            return d.children ? d.data.name.replace(/_/g, ' ') : '';
        });
        gEle.selectAll('.cluster-node').append('line').style('stroke', 'black').attr('x1', function (d) {
            return d.children ? 0 : 0;
        }).attr('x2', function (d) {
            return d.children ? 0 : 15;
        });
    } else if (sideOfTree === 'right') {
        gEle.selectAll('.cluster-node').append('text').attr('dy', 8).style('text-anchor', function (d) {
            return d.children ? 'end' : 'start';
        }).attr('y', function (d) {
            return d.children ? -8 : 8;
        }).text(function (d) {
            if (!d.children) {
                childCount++;
                axisData.push(findPath(d));
            }
            if (d.data.name === 'root') {
                return '';
            }
            return d.children ? d.data.name.replace(/_/g, ' ') : '';
        });
    }
    return childCount;
}

function buildHeat(chart, gridData, heatG, newHeight, newWidth, leftChildCount, rightChildCount) {
    var heatScores = [],
        gridHeight,
        gridWidth,
        color;

    for (var i = 0; i < gridData.length; i++) {
        var cell = gridData[i];
        heatScores.push(cell.value);
    }

    //heat variables
    color = d3.scaleThreshold().domain(heatScores).range(['#fbf2d2', '#fee7a0', '#ffc665', '#fea743', '#fd8c3c', '#fb4b29', '#ea241e', '#d60b20', '#b10026', '#620023']);

    gridHeight = newHeight / leftChildCount;
    gridWidth = newWidth / rightChildCount;

    chart._vars.clustergramGridWidth = gridWidth;
    chart._vars.clustergramGridHeight = gridHeight;

    //grid
    heatG.selectAll('.heat').data(gridData).enter().append('rect').attr('class', 'cluster-rect').attr('x', function (d) {
        return d.x_index * gridWidth;
    }).attr('y', function (d) {
        return d.y_index * gridHeight;
    }).attr('width', function () {
        return gridWidth;
    }).attr('height', function () {
        return gridHeight;
    }).attr('stroke', '#E6E6E6').attr('stroke-width', '1px').style('fill', function (d) {
        return color(d.value);
    }).on('mouseover', function (d, i) {
        if (chart.showToolTip) {
            if (chart.tip.d === d && chart.tip.i === i) {
                chart.tip.showTip(d3.event);
            } else {
                //Get tip data
                var tipData = chart.setTipData(d, i);
                tipData.color = color(d.value);
                //Draw tip line
                chart.tip.generateSimpleTip(tipData, chart.data.dataTable, d3.event);
            }
        }
    }).on('mouseout', function () {
        chart.tip.hideTip();
    });
}

module.exports = jvCharts;

},{"../jvCharts.js":4}],16:[function(require,module,exports){
'use strict';

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var jvCharts = require('../jvCharts.js');

jvCharts.prototype.gantt = {
    paint: paint,
    setData: setData,
    getEventData: getEventData
};

jvCharts.prototype.generateGanttBars = generateGanttBars;
jvCharts.prototype.setGanttLegendData = setGanttLegendData;
jvCharts.prototype.setGanttAxisData = setGanttAxisData;

/************************************************ Gantt functions ******************************************************/

/**
*
* @param data
* @param dataTable
* @param colors
*/
function setData() {
    var chart = this;
    chart.data.legendData = chart.setGanttLegendData(chart.data);
    chart.data.xAxisData = chart.setGanttAxisData(chart, 'x');
    chart.data.yAxisData = chart.setGanttAxisData(chart, 'y');
    //define color object for chartData
    chart.data.color = jvCharts.setChartColors(chart._vars.color, chart.data.legendData, chart.colors);
}

function getEventData(event) {
    var chart = this;
    var ele = event.target.classList.value.split('bar-col-')[1];
    if (ele) {
        return {
            data: _defineProperty({}, chart.currentData.dataTable.group, [ele.replace(/_/g, ' ').replace(/_dot_/g, '.')]),
            node: event.target
        };
    }
    return {};
}

function setGanttLegendData(data) {
    var legendArray = [];
    for (var i = 1; i <= Object.keys(data.dataTable).length; i++) {
        var key = ' ' + i;
        if (i == 1) {
            key = '';
        }

        if (data.dataTable.hasOwnProperty(["start" + key])) {
            //check to make sure it has a matching end date
            if (data.dataTable.hasOwnProperty(["end" + key])) {
                legendArray.push(data.dataTable["start" + key]);
            }
        }
    }
    return legendArray;
}

function setGanttAxisData(chart, axis) {
    var axisData = [],
        data = chart.data,
        chartData = data.chartData,
        dataType;

    if (axis === 'x') {
        var label = data.dataTable.group;
        dataType = 'DATE';

        var numBars = data.legendData.length;
        //Loop through dataTable and assign labels based on how many groups there are
        var valueContainer = [];
        valueContainer.push(data.dataTable["start"]);
        valueContainer.push(data.dataTable["end"]);
        for (var i = 1; i < numBars; i++) {
            valueContainer.push(data.dataTable["start " + (i + 1)]);
            valueContainer.push(data.dataTable["end " + (i + 1)]);
        }

        //Get all the start and end dates and add them to axis data
        for (var i = 0; i < valueContainer.length; i++) {
            for (var ii = 0; ii < chartData.length; ii++) {
                if (chartData[ii][valueContainer[i]] != null) {
                    axisData.push(chartData[ii][valueContainer[i]]);
                }
            }
        }

        //Add any axis formatting to this object, need to use when painting
        chart._vars.xAxisFormatting = {};
    } else {
        dataType = "STRING";
        var label = data.dataTable.group;

        //Add any axis formatting to this object, need to use when painting
        chart._vars.yAxisFormatting = {};

        for (var i = 0; i < chartData.length; i++) {
            axisData.push(chartData[i][label]);
        }
    }

    return {
        'label': label,
        'values': axisData,
        'dataType': dataType
    };
}

function paint() {
    var chart = this;

    chart._vars.color = chart.data.color;

    chart.currentData = chart.data;

    chart.generateSVG(chart.currentData.legendData);
    chart.generateXAxis(chart.currentData.xAxisData);
    chart.generateYAxis(chart.currentData.yAxisData);
    chart.generateLegend(chart.currentData.legendData, 'generateGanttBars');
    chart.drawGridlines(chart.currentData.xAxisData);
    chart.generateGanttBars(chart.currentData);
    if (typeof chart.currentData.xAxisScale.ticks === "function") {
        chart.formatXAxisLabels(chart.currentData.xAxisScale.ticks().length);
    } else {
        chart.formatXAxisLabels(chart.currentData.xAxisScale.domain().length);
    }
}

function generateGanttBars(ganttData) {
    var chart = this,
        svg = chart.svg,
        colors = ganttData.color,
        container = chart.config.container,
        yAxisData = ganttData.yAxisData;

    //Remove existing bars from page
    svg.selectAll("g.gantt-container").remove();
    var bars = svg.append("g").attr("class", "gantt-container"),
        dataHeaders = chart._vars.legendHeaders ? chart._vars.legendHeaders : ganttData.legendData,
        ganttDataNew = jvCharts.getToggledData(ganttData, dataHeaders),
        x = jvCharts.getAxisScale('x', ganttData.xAxisData, container, chart._vars),
        y = jvCharts.getAxisScale('y', ganttData.yAxisData, container, chart._vars),
        sampleData = ganttDataNew;

    chart._vars.rotateAxis = true;

    var numBars = ganttData.legendData.length;
    var ganttBars = [];
    //create array of start dates and end dates to iterate through
    var startDates = [];
    var endDates = [];
    for (var i = 1; i <= numBars; i++) {
        var key = ' ' + i;
        if (i == 1) {
            key = '';
        }
        startDates.push(chart.currentData.dataTable["start" + key]);
        endDates.push(chart.currentData.dataTable["end" + key]);
    }

    for (var ii = 0; ii < numBars; ii++) {
        var externalCounterForJ = -1;
        ganttBars[ii] = bars.selectAll(".gantt-bar" + ii).data(sampleData).enter().append("rect").attr('class', function (d, i, j) {
            externalCounterForJ++;
            var label = String(sampleData[externalCounterForJ][chart.currentData.dataTable.group]).replace(/\s/g, '_').replace(/\./g, '_dot_');

            return 'gantt-bar' + ii + ' editable editable-bar bar-col-' + label + '-index-' + ii + ' highlight-class-' + label + ' rect ';
        }).attr("width", 0).attr("height", y.bandwidth() / numBars).attr("x", function (d, i) {
            if (d[startDates[ii]]) {
                return x(new Date(d[startDates[ii]]));
            }
            return 0;
        }).attr("y", function (d, i) {
            return y(d[yAxisData.label]) + y.bandwidth() / numBars * ii;
        }).attr("rx", 3).attr("ry", 3).attr("fill", function (d, i, j) {
            var typeVal = chart.currentData.dataTable["Type" + (ii + 1)];
            if (chart._vars.legendHeaders) {
                var color = jvCharts.getColors(colors, 0, chart._vars.legendHeaders[ii]);
            } else {
                var color = jvCharts.getColors(colors, 0, chart.currentData.legendData[ii]);
            }
            return color;
        });

        ganttBars[ii].transition().duration(400).delay(100).attr("width", function (d, i) {
            var width = x(new Date(d[endDates[ii]])) - x(new Date(d[startDates[ii]])); //(x(d.StartDate) - x(d.EndDate));
            if (width >= 0) {
                return width;
            } else {
                return 0;
            }
        });
    }
    var externalCounterForJJ = -1;
    var dataToPlot = jvCharts.getPlotData(ganttDataNew, chart);
    var eventGroups = bars.selectAll(".event-rect").data(dataToPlot).enter().append('rect').attr("class", "event-rect").attr('class', function (d, i, j) {
        externalCounterForJJ++;
        var label = String(sampleData[externalCounterForJJ][chart.currentData.dataTable.group]).replace(/\s/g, '_').replace(/\./g, '_dot_');
        return 'event-rect bar-col-' + label;
    }).attr("x", 0).attr("y", function (d, i) {
        return container.height / ganttDataNew.length * i;
    }).attr("width", container.width).attr("height", function (d, i) {
        return container.height / ganttDataNew.length;
    }).attr("fill", "transparent").attr("transform", "translate(0,0)");
    eventGroups.on("mouseover", function (d, i, j) {
        // Transitions in D3 don't support the 'on' function They only exist on selections. So need to move that event listener above transition and after append
        if (chart.showToolTip) {
            //Get tip data
            var tipData = chart.setTipData(d, i);
            //Draw tip
            chart.tip.generateSimpleTip(tipData, chart.data.dataTable);
            chart.tip.d = d;
            chart.tip.i = i;
        }
    }).on("mousemove", function (d, i) {
        if (chart.showToolTip) {
            if (chart.tip.d === d && chart.tip.i === i) {
                chart.tip.showTip(d3.event);
            } else {
                //Get tip data
                var tipData = chart.setTipData(d, i);
                //Draw tip line
                chart.tip.generateSimpleTip(tipData, chart.data.dataTable);
            }
        }
    }).on("mouseout", function (d) {
        if (chart.showToolTip) {
            chart.tip.hideTip();
        }
    });

    var currentDate = new Date();
    var dateData = [currentDate];
    //Draws a line representing the current date
    svg.selectAll(".currentDateLine").data(dateData).enter().append("line").attr("x1", function (d, i) {
        return x(d);
    }).attr("x2", function (d, i) {
        return x(d);
    }).attr("y1", function (d, i) {
        return "0px";
    }).attr("y2", function (d, i) {
        return chart.config.container.height;
    }).attr("class", "currentDateLine").attr("stroke", chart._vars.axisColor).attr("stroke-width", chart._vars.STROKE_WIDTH).attr("stroke-dasharray", "3, 3");

    svg.selectAll(".currentDateLabel").data(dateData).enter().append("text").text(function () {
        var today = new Date();
        var dd = today.getDate();
        var mm = today.getMonth() + 1; //January is 0!

        var yyyy = today.getFullYear();
        if (dd < 10) {
            dd = '0' + dd;
        }
        if (mm < 10) {
            mm = '0' + mm;
        }
        var today = mm + '/' + dd + '/' + yyyy;
        return today;
    }).attr("x", function (d, i) {
        return x(d);
    }).attr("y", function (d, i) {
        return "-10px";
    }).attr("text-anchor", "middle").attr('fill', chart._vars.fontColor);
}

module.exports = jvCharts;

},{"../jvCharts.js":4}],17:[function(require,module,exports){
'use strict';

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var jvCharts = require('../jvCharts.js');

jvCharts.prototype.heatmap = {
    paint: paint,
    setData: setData,
    getEventData: getEventData
};

jvCharts.prototype.generateHeatMap = generateHeatMap;

/************************************************ HeatMap functions ******************************************************/

function quantized(chart, min, max) {
    var bucketCount = chart._vars.buckets,
        sectionValue = (max - min) / bucketCount,
        quantizedArray = [];
    for (var i = 0; i < bucketCount; i++) {
        quantizedArray[i] = min + i * sectionValue;
    }
    return quantizedArray;
}

/**setData
 *  gets heatmap data and adds it to the chart object
 *
 * @params data, dataTable, colors
 */
function setData() {
    var chart = this,
        axisNames = setHeatAxisNames(chart.data);
    chart.data.xAxisData = axisNames.xAxisData;
    chart.data.yAxisData = axisNames.yAxisData;
    chart.data.processedData = setProcessedData(chart, chart.data, chart.data.xAxisData.values, chart.data.yAxisData.values);
    //define color object for chartData
    chart._vars.color = jvCharts.setChartColors(chart._vars.color, chart.data.xAxisData.values, chart.colors);
    chart.data.heatData = setHeatmapLegendData(chart, chart.data);
}

function getEventData(event, mouse) {
    var chart = this,

    //determine if the click event happens inside the container
    brushContainer = chart.chartDiv.select('.' + chart.config.type + '-container').node(),
        containerBox = brushContainer.getBoundingClientRect(),
        x = mouse[0],
        y = mouse[1],
        insideContainer = false;

    if (x < containerBox.right && y < containerBox.bottom && x > containerBox.left && y > containerBox.top) {
        insideContainer = true;
    }
    if (insideContainer && event.target.__data__) {
        var _data;

        var data = event.target.__data__;
        return {
            data: (_data = {}, _defineProperty(_data, chart.currentData.dataTable.x, [data.xAxisName]), _defineProperty(_data, chart.currentData.dataTable.y, [data.yAxisName]), _data),
            node: event.target
        };
    } else if (insideContainer) {
        return {
            data: {}
        };
    }
    return {
        data: false
    };
}

function setHeatmapLegendData(chart, data) {
    var heatData = void 0;

    chart._vars.colors = organizeColors(chart);
    data.heatScores.sort(function (a, b) {
        return a - b;
    });

    chart.data.colorScale = d3.scaleQuantile().domain(data.heatScores).range(chart._vars.colors);

    if (chart._vars.quantiles === true) {
        var temp = chart.data.colorScale.quantiles();
        if (temp[0] === 0) {
            heatData = chart.data.colorScale.quantiles();
        } else {
            heatData = [0].concat(chart.data.colorScale.quantiles());
        }
    } else {
        heatData = quantized(chart, data.heatScores[0], data.heatScores[data.heatScores.length - 1]);
    }

    return heatData;
}

function organizeColors(chart) {
    var colorSelectedBucket = [],
        sValue = chart._vars.buckets,
        newColors = [],
        bucketMapper = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
        bucketCount = bucketMapper[sValue - 1],
        colors = void 0;

    for (var c in chart._vars.colors) {
        if (chart._vars.colors.hasOwnProperty(c)) {
            colorSelectedBucket.push(chart._vars.colors[c]);
        }
    }

    for (var i = 0; i < bucketCount; i++) {
        if (i >= bucketCount / 2) {
            newColors[i] = colorSelectedBucket[Math.round((i + 1) / bucketCount * 20) - 1];
        } else {
            newColors[i] = colorSelectedBucket[Math.round(i / bucketCount * 20)];
        }
    }

    colors = newColors.slice(0);
    return colors;
}

function setHeatAxisNames(data) {
    var chartData = data.chartData,
        xAxisName = data.dataTable.x,
        yAxisName = data.dataTable.y,
        xAxisArray = [],
        yAxisArray = [],
        returnObj = {};

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = data.dataTableKeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var key = _step.value;

            if (key.model === 'x') {
                returnObj.xAxisData = {};
                returnObj.xAxisData.dataType = key.type;
                returnObj.xAxisData.label = data.dataTable.x;
            } else if (key.model === 'y') {
                returnObj.yAxisData = {};
                returnObj.yAxisData.dataType = key.type;
                returnObj.yAxisData.label = data.dataTable.y;
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
        for (var _iterator2 = chartData[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var ele = _step2.value;

            if (xAxisArray.indexOf(ele[xAxisName]) === -1) {
                xAxisArray.push(ele[xAxisName]);
                //TODO make into 1 function for min max... waste of space
                if (returnObj.xAxisData.dataType === 'NUMBER') {
                    //push min and max info
                    if (!returnObj.xAxisData.min) {
                        returnObj.xAxisData.min = ele[xAxisName];
                    } else if (ele[xAxisName] < returnObj.xAxisData.min) {
                        returnObj.xAxisData.min = ele[xAxisName];
                    }

                    if (!returnObj.xAxisData.max) {
                        returnObj.xAxisData.max = ele[xAxisName];
                    } else if (ele[xAxisName] < returnObj.xAxisData.max) {
                        returnObj.xAxisData.max = ele[xAxisName];
                    }
                }
            }
            if (yAxisArray.indexOf(ele[yAxisName]) === -1) {
                yAxisArray.push(ele[yAxisName]);
                if (returnObj.yAxisData.dataType === 'NUMBER') {
                    //push min and max info
                    if (!returnObj.yAxisData.min) {
                        returnObj.yAxisData.min = ele[yAxisName];
                    } else if (ele[yAxisName] < returnObj.yAxisData.min) {
                        returnObj.yAxisData.min = ele[yAxisName];
                    }

                    if (!returnObj.yAxisData.max) {
                        returnObj.yAxisData.max = ele[yAxisName];
                    } else if (ele[yAxisName] < returnObj.yAxisData.max) {
                        returnObj.yAxisData.max = ele[yAxisName];
                    }
                }
            }
        }
    } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
            }
        } finally {
            if (_didIteratorError2) {
                throw _iteratorError2;
            }
        }
    }

    returnObj.xAxisData.values = xAxisArray;
    returnObj.yAxisData.values = yAxisArray;

    return returnObj;
}

function setProcessedData(chart, data, xAxisArray, yAxisArray) {
    var chartData = data.chartData,
        xAxisName = data.dataTable.x,
        yAxisName = data.dataTable.y,
        heat = data.dataTable.heat,
        dataArray = [],
        keys;

    data.heatScores = [];
    /*Assign each name a number and place matrix coordinates inside of dataArray */
    for (var i = 0; i < chartData.length; i++) {
        dataArray.push({
            value: chartData[i][heat],
            xAxisName: chartData[i][xAxisName],
            yAxisName: chartData[i][yAxisName]
        });

        keys = Object.keys(data.dataTable);
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
            for (var _iterator3 = keys[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                var key = _step3.value;

                if (key.indexOf('tooltip') > -1) {
                    dataArray[i][key] = chartData[i][data.dataTable[key]];
                }
            }

            //This array stores the values as numbers
        } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion3 && _iterator3.return) {
                    _iterator3.return();
                }
            } finally {
                if (_didIteratorError3) {
                    throw _iteratorError3;
                }
            }
        }

        data.heatScores.push(chartData[i][heat]);
        for (var j = 0; j < xAxisArray.length; j++) {
            if (xAxisArray[j] === dataArray[i].xAxisName) {
                dataArray[i].xAxis = j;
                break;
            }
        }
        for (var _j = 0; _j < yAxisArray.length; _j++) {
            if (yAxisArray[_j] === dataArray[i].yAxisName) {
                dataArray[i].yAxis = _j;
                break;
            }
        }
    }

    return dataArray;
}

function paint() {
    var chart = this,
        customMargin = {
        top: 0,
        right: 40,
        left: 0,
        bottom: 20
    };

    chart._vars.color = chart.data.color;
    chart.currentData = chart.data; //Might have to move into method bc of reference/value relationship

    //Generate SVG-legend data is used to determine the size of the bottom margin (set to null for no legend)
    chart.generateSVG(null, customMargin);
    //chart.generateLegend(chart.currentData.legendData, 'generateHeatMap');
    chart.generateHeatMap();
}

/**generateHeatMap
 *
 * paints the HeatMap on the chart
 * @params HeatMapData
 */
function generateHeatMap() {
    var chart = this,
        svg = chart.svg,
        colors = chart._vars.colors,
        quantiles = chart._vars.quantiles,
        data = chart.data.processedData,
        heatMapData = chart.currentData,
        gridSize = chart._vars.heatGridSize,
        legendSpacing = chart._vars.heatLegendSpacing,
        vis,
        yAxisTitle;

    d3.select('body').append('div').attr('class', 'tooltip').style('opacity', 0);
    vis = svg.append('g').attr('transform', 'translate(0,0)').attr('class', 'heatmap');

    yAxisTitle = vis.selectAll('.heatmap').data([heatMapData.dataTable.y]);

    yAxisTitle.enter().append('text').attr('class', 'axisLabels bold').attr('x', -21).attr('y', -5).attr('text-anchor', 'end').attr('transform', function () {
        return 'translate(-' + (chart._vars.heatmapYmargin + 10) + ',' + 0 + ')rotate(-90)';
    }).text(function (d) {
        return d;
    });

    yAxisTitle.exit().remove();
    var formatType = jvCharts.jvFormatValueType(chart.currentData.yAxisData.values, chart.currentData.yAxisData.dataType);

    var yAxisSection = vis.append('svg:g').attr('class', 'yAxisSection');

    var yAxis = yAxisSection.selectAll('.xAxis').data(heatMapData.yAxisData.values).enter().append('svg:g');

    yAxis.append('text').text(function (d) {
        var str = jvCharts.jvFormatValue(d, formatType);
        if (str.length > 15) {
            return str.substring(0, 14) + '...';
        }
        return str;
    }).attr('x', 0).attr('y', function (d, i) {
        return i * gridSize;
    }).style('text-anchor', 'end').style('font-size', chart._vars.fontSize).attr('transform', 'translate(-6,' + gridSize / 1.5 + ')').attr('class', 'rowLabel pointer').on('click', function (d) {
        //removing styling
        d3.selectAll('.rowLabel').classed('text-highlight', false);
        d3.selectAll('.colLabel').classed('text-highlight', false);
        d3.selectAll('.heat').classed('rect-highlight', false);
        d3.selectAll('.heat').classed('rect-border', false);

        var paintBool = true;
        if (d === chart._vars.selectedX) {
            chart._vars.selectedX = '';
            paintBool = false;
        } else {
            chart._vars.selectedX = d;
        }

        //fade all rects except in this row
        d3.selectAll('.heat').classed('rect-highlight', function (r) {
            for (var i = 0; i < chart.currentData.yAxisData.values.length; i++) {
                if (chart.currentData.yAxisData.values[i] === d && d) {
                    if (r.yAxis !== i && paintBool) {
                        return true;
                    }
                }
            }
            return false;
        });
    });

    yAxis.append('title').text(function (d) {
        return d;
    });

    var xAxisTitle = vis.selectAll('.xAxisTitle').data([heatMapData.dataTable.x]);

    xAxisTitle.enter().append('text').attr('class', 'axisLabels bold').attr('x', 6).attr('y', 9).attr('transform', 'translate(0, -' + (chart._vars.heatmapXmargin - 10) + ')').text(function (d) {
        return d;
    });

    xAxisTitle.exit().remove();

    var xAxisSection = vis.append('svg:g').attr('class', 'xAxisSection');

    var xAxis = xAxisSection.selectAll('.xAxis').data(heatMapData.xAxisData.values).enter().append('svg:g');

    formatType = jvCharts.jvFormatValueType(chart.currentData.xAxisData.values, chart.currentData.xAxisData.dataType);

    xAxis.append('text').text(function (d) {
        var str = jvCharts.jvFormatValue(d, formatType);
        if (str.length > 15) {
            return str.substring(0, 14) + '...';
        }
        return str;
    }).style('text-anchor', 'start').attr('x', 6).attr('y', 7).attr('class', 'colLabel pointer').attr('transform', function (d, i) {
        return 'translate(' + i * gridSize + ', -6)rotate(-45)';
    }).attr('title', function (d) {
        return d;
    }).style('font-size', chart._vars.fontSize).on('click', function (d) {
        //removing styling
        d3.selectAll('.rowLabel').classed('text-highlight', false);
        d3.selectAll('.colLabel').classed('text-highlight', false);
        d3.selectAll('.heat').classed('rect-highlight', false);
        d3.selectAll('.heat').classed('rect-border', false);

        var paintBool = true;
        if (d === chart._vars.selectedX) {
            chart._vars.selectedX = '';
            paintBool = false;
        } else {
            chart._vars.selectedX = d;
        }
        //fade all rects except in this column
        d3.selectAll('.heat').classed('rect-highlight', function (r) {
            for (var i = 0; i < chart.currentData.xAxisData.values.length; i++) {
                if (chart.currentData.xAxisData.values[i] === d) {
                    if (r.xAxis !== i && paintBool) {
                        return true;
                    }
                }
            }
            return false;
        });
    });

    xAxis.append('title').text(function (d) {
        return d;
    });

    var width = heatMapData.xAxisData.values.length * gridSize;
    var height = heatMapData.yAxisData.values.length * gridSize;
    var formatValueType = jvCharts.jvFormatValueType(chart.data.heatData);

    //vertical lines
    var vLine = vis.append('svg:g').attr('class', 'vLineSection');

    vLine.selectAll('.vLineSection').data(d3.range(heatMapData.xAxisData.values.length + 1)).enter().append('line').attr('x1', function (d) {
        return d * gridSize;
    }).attr('x2', function (d) {
        return d * gridSize;
    }).attr('y1', 0).attr('y2', height).style('stroke', chart._vars.gridLineColor);

    //horizontal lines
    var hLine = vis.append('svg:g').attr('class', 'heatmap-container');

    hLine.selectAll('.heatmap-container').data(d3.range(heatMapData.yAxisData.values.length + 1)).enter().append('line').attr('x1', 0).attr('x2', width).attr('y1', function (d) {
        return d * gridSize;
    }).attr('y2', function (d) {
        return d * gridSize;
    }).style('stroke', chart._vars.gridLineColor);

    var heatMap = vis.append('svg:g').attr('class', 'heatSection');

    heatMap.selectAll('.heatSection').data(data).enter().append('rect').attr('x', function (d) {
        return d.xAxis * gridSize;
    }).attr('y', function (d) {
        return d.yAxis * gridSize;
    }).attr('rx', 2).attr('ry', 2).attr('class', 'heat').attr('width', gridSize - 1).attr('height', gridSize - 1).style('fill', function (d) {
        if (quantiles === true) {
            if (chart._vars.domainArray.length === 0 || d.value >= chart._vars.domainArray[0] && d.value <= chart._vars.domainArray[1]) {
                return chart.data.colorScale(d.value);
            }
            return 'white';
        }
        if (chart._vars.domainArray.length === 0 || d.value >= chart._vars.domainArray[0] && d.value <= chart._vars.domainArray[1]) {
            return getQuantizedColor(chart.data.heatData, d.value);
        }
        return 'white';
    }).on('mouseover', function (d, i) {
        //Get tip data
        var tipData = chart.setTipData(d, i);
        tipData.color = chart.data.colorScale(d.value);

        //Draw tip
        chart.tip.generateSimpleTip(tipData, chart.data.dataTable);
        chart.tip.d = d;
        chart.tip.i = i;
    }).on('mousemove', function (d, i) {
        if (chart.showToolTip) {
            if (chart.tip.d === d && chart.tip.i === i) {
                chart.tip.showTip(d3.event);
            } else {
                //Get tip data
                var tipData = chart.setTipData(d, i);
                //Draw tip line
                chart.tip.generateSimpleTip(tipData, chart.data.dataTable);
            }
        }
    }).on('mouseout', function () {
        chart.tip.hideTip();
    }).on('dblclick', function (d) {
        chart.clicked = !chart.clicked;
        if (chart.clicked) {
            //border around selected rect
            d3.select(this).classed('rect-border', true);
            //Fade row labels
            d3.selectAll('.rowLabel').classed('text-highlight', function (r, ri) {
                return ri != d.yAxis;
            });
            //fade column labels
            d3.selectAll('.colLabel').classed('text-highlight', function (r, ri) {
                return ri != d.xAxis;
            });
            //fade all rects except selected
            d3.selectAll('.heat').classed('rect-highlight', function (r) {
                return r.yAxis != d.yAxis || r.xAxis != d.xAxis;
            });
        } else {
            //removing styling
            d3.selectAll('.rowLabel').classed('text-highlight', false);
            d3.selectAll('.colLabel').classed('text-highlight', false);
            d3.selectAll('.heat').classed('rect-highlight', false);
            d3.selectAll('.heat').classed('rect-border', false);
        }
    });

    chart.chartDiv.select('svg.heatLegend').remove();

    if (chart._vars.toggleLegend) {
        var legendContainer = chart.chartDiv.append('svg').style('top', chart.config.margin.top + 'px').style('background', chart._vars.backgroundColor).attr('class', 'heatLegend').attr('width', chart.config.heatWidth);

        var legend = legendContainer.selectAll('.legend').data(chart.data.heatData).enter().append('g').attr('transform', function (d, i) {
            return 'translate(0, ' + gridSize * i + ' )';
        });

        legend.append('rect').attr('class', 'legend').attr('width', gridSize).attr('height', gridSize).style('fill', function (d, i) {
            return colors[i];
        }).on('click', function () {
            return d3.selectAll('.heat').classed('rect-highlight', false);
        })
        //removing styling
        //fade all rects except selected
        .on('dblclick', function (d) {
            return d3.selectAll('.heat').classed('rect-highlight', function (r) {
                return r.value < d;
            });
        });

        legend.append('text').attr('class', 'legendText').attr('x', gridSize + legendSpacing).attr('y', gridSize - legendSpacing).text(function (d) {
            if (isNaN(d)) {
                return d;
            }
            return jvCharts.jvFormatValue(d, formatValueType);
        }).style('fill', chart._vars.black);
    }

    function getQuantizedColor(quantizedArray, value) {
        for (var i = 1; i < quantizedArray.length; i++) {
            if (value < quantizedArray[i]) {
                return colors[i - 1];
            }
        }
        return colors[quantizedArray.length - 1];
    }
}

module.exports = jvCharts;

},{"../jvCharts.js":4}],18:[function(require,module,exports){
'use strict';

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var jvCharts = require('../jvCharts.js');

jvCharts.prototype.line = {
    paint: paint,
    setData: setData,
    getEventData: getEventData,
    highlightFromEventData: highlightFromEventData
};

jvCharts.prototype.generateLine = generateLine;
jvCharts.prototype.setLineThresholdData = setLineThresholdData;

/************************************************ Line functions ******************************************************/

/**setLineData
 *  gets line data and adds it to the chart object
 *
 * @params data, dataTable, colors
 */
function setData() {
    var chart = this;
    //sort chart data if there is a sort type and label in the _vars
    if (chart._vars.sortType) {
        if (chart._vars.sortLabel && chart._vars.sortType !== 'default') {
            chart.organizeChartData(chart._vars.sortLabel, chart._vars.sortType);
        }
    }
    chart.data.legendData = setBarLineLegendData(chart.data);
    chart.data.xAxisData = chart.setAxisData('x', chart.data);
    chart.data.yAxisData = chart.setAxisData('y', chart.data);

    if (chart._vars.seriesFlipped) {
        chart.setFlippedSeries(chart.data.dataTableKeys);
        chart.flippedData.color = jvCharts.setChartColors(chart._vars.color, chart.flippedData.legendData, chart.colors);
    }

    if (chart.data.dataTable.hasOwnProperty('series')) {
        chart.data.chartData = setSeriesData(chart.data.chartData, chart.data.dataTable);
    }

    //define color object for chartData
    chart.data.color = jvCharts.setChartColors(chart._vars.color, chart.data.legendData, chart.colors);
}

function getEventData(event) {
    var chart = this;
    if (event.target.classList.value.split('bar-col-')[1]) {
        return {
            data: _defineProperty({}, chart.currentData.dataTable.label, [event.target.classList.value.split('bar-col-')[1].replace(/_/g, ' ').replace(/_colon_/g, ':').replace(/_dot_/g, '.')]),
            node: event.target
        };
    } else if (event.target.classList.value.indexOf('line-container') > -1) {
        return {
            data: {}
        };
    }
    return {
        data: false
    };
}

function highlightFromEventData(event) {
    var chart = this,
        label = event.data[chart.currentData.dataTable.label][0],
        cssClass = '.highlight-class-' + label.replace(/\s/g, '_').replace(/\./g, '_dot_'),
        node = chart.svg.selectAll(cssClass);

    chart.svg.select('.line-container').selectAll('circle').attr('stroke', 0).attr('stroke-width', 0);
    //highlight necessary circles
    node.attr('stroke', chart._vars.highlightBorderColor).attr('stroke-width', chart._vars.highlightBorderWidth);
}

/**
 * @name setSeriesData
 * @desc Sets chartData to contain a series data if the series field exists in visual panel
 */
function setSeriesData(data, dataTable) {
    var labelList = [],
        add,
        newData = [];
    //Get unique label list
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var dataEle = _step.value;

            add = true;
            for (var _j = 0; _j < labelList.length; _j++) {
                if (dataEle[dataTable.label] === labelList[_j]) {
                    add = false;
                    break;
                }
            }
            if (add) {
                labelList.push(dataEle[dataTable.label]);
            }
        }
        //Iterate over label list
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    var newData = [];
    for (var i = 0; i < labelList.length; i++) {
        var dataObj = {};
        dataObj[dataTable.label] = labelList[i];
        for (var j = 0; j < data.length; j++) {
            if (data[j][dataTable.label] === labelList[i]) {
                var newEntry = data[j][dataTable.series] + ' ' + dataTable['value 1'];
                dataObj[newEntry] = data[j][dataTable['value 1']];
            }
        }
        newData.push(dataObj);
    }
    return newData;
}

/**setBarLineLegendData
 *  gets legend info from chart Data
 *
 * @params data, type
 * @returns [] of legend tex
 */
function setBarLineLegendData(data) {
    var legendArray = [];

    if (data.dataTable.hasOwnProperty('series')) {
        for (var i = 0; i < data.chartData.length; i++) {
            var addToLegend = true;
            for (var j = 0; j < legendArray.length; j++) {
                var entry = data.chartData[i][data.dataTable.series] + ' ' + data.dataTable['value 1'];
                if (entry === legendArray[j]) {
                    addToLegend = false;
                    break;
                }
            }
            if (addToLegend) {
                var newEntry = data.chartData[i][data.dataTable.series] + ' ' + data.dataTable['value 1'];
                legendArray.push(newEntry);
            }
        }
    } else {
        for (var item in data.dataTable) {
            if (data.dataTable.hasOwnProperty(item)) {
                if (item !== 'label' && item.indexOf('tooltip') === -1) {
                    legendArray.push(data.dataTable[item]);
                }
            }
        }
    }

    return legendArray;
}
/**paintLineChart
 *
 * The initial starting point for line chart, begins the drawing process. Must already have the data stored in the chart
 * object
 */
function paint() {
    var chart = this;
    //Uses the original data and then manipulates it based on any existing options
    var dataObj = chart.getBarDataFromOptions();

    //assign current data which is used by all bar chart operations
    chart.currentData = dataObj;

    //generate svg dynamically based on legend data
    chart.generateSVG(dataObj.legendData);
    chart.generateXAxis(dataObj.xAxisData);
    chart.generateYAxis(dataObj.yAxisData);
    chart.generateLegend(dataObj.legendData, 'generateLine');
    if (chart._vars.rotateAxis) {
        chart.formatXAxisLabels(dataObj.xAxisScale.ticks().length);
    } else {
        chart.formatXAxisLabels(dataObj.xAxisScale.domain().length);
    }

    chart.generateLine(dataObj);
}

/**generateLine
 *
 * Paints the lines
 * @params lineData
 */
function generateLine(lineData) {
    var chart = this,
        svg = chart.svg;

    svg.selectAll('g.' + chart.config.type + '-container').remove();
    var lines = svg.append('g').attr('class', chart.config.type + '-container').selectAll('g');

    var dataHeaders = lineData.legendData;

    if (chart._vars.seriesFlipped && chart._vars.flippedLegendHeaders) {
        dataHeaders = chart._vars.flippedLegendHeaders;
    } else if (chart._vars.legendHeaders) {
        dataHeaders = chart._vars.legendHeaders;
    }

    var lineDataNew = jvCharts.getToggledData(lineData, dataHeaders);

    //If it's an area chart, add the area
    if (chart.config.type === 'area') {
        chart.fillArea(lineDataNew);
    }

    generateLineGroups(lines, lineDataNew, chart);
    var eventGroups = jvCharts.generateEventGroups(lines, lineDataNew, chart);

    eventGroups.on('mouseover', function (d, i, j) {
        //Transitions in D3 don't support the 'on' function They only exist on selections. So need to move that event listener above transition and after append
        if (chart.showToolTip) {
            //Get tip data
            var tipData = chart.setTipData(d, i);

            //Draw tip
            chart.tip.generateSimpleTip(tipData, chart.data.dataTable);
            chart.tip.d = d;
            chart.tip.i = i;
        }
    }).on('mousemove', function (d, i) {
        if (chart.showToolTip) {
            if (chart.tip.d === d && chart.tip.i === i) {
                chart.tip.showTip(d3.event);
            } else {
                //Get tip data
                var tipData = chart.setTipData(d, i);
                //Draw tip line
                chart.tip.generateSimpleTip(tipData, chart.data.dataTable);
            }
        }
    }).on('mouseout', function (d) {
        chart.tip.hideTip();
        svg.selectAll('.tip-line').remove();
    });

    chart.displayValues();
    chart.generateClipPath();
    chart.generateLineThreshold();

    return lines;
}

/**generateLineGroups
 *
 * Paints the groups of the lines
 * @params chartContainer, barData, chart
 */
function generateLineGroups(lineContainer, lineData, chart) {
    var container = chart.config.container,
        xAxisData = chart.currentData.xAxisData,
        yAxisData = chart.currentData.yAxisData,
        legendData = chart.currentData.legendData,
        colors = chart._vars.color,
        lines,
        lineLength = lineData.length,
        legendLength = legendData.length;

    //Get Position Calculations
    var x = jvCharts.getAxisScale('x', xAxisData, container, chart._vars, 'no-padding');
    var y = jvCharts.getAxisScale('y', yAxisData, container, chart._vars, 'no-padding');

    var xTranslate, yTranslate;

    if (chart._vars.rotateAxis === true) {
        xTranslate = function xTranslate(d, i) {
            if (d === '') {
                return x('EMPTY_STRING');
            }
            return x(d);
        };
        yTranslate = function yTranslate(d, i) {
            return y(lineData[i][yAxisData.label]) + container.height / lineLength / 2; //+ container.height / (lineLength) / 2  - y.paddingInner());
        };
    } else {
        xTranslate = function xTranslate(d, i) {
            if (lineData[i][xAxisData.label] === '') {
                lineData[i][xAxisData.label] = 'EMPTY_STRING';
            }
            return x(lineData[i][xAxisData.label]) + container.width / lineLength / 2; //+ container.width / (lineLength) / 2 - x.paddingInner());
        };
        yTranslate = function yTranslate(d, i) {
            return y(d);
        };
    }

    //Append lines and circles

    var uniqueXAxisData = [];
    for (var i = 0; i < chart.data.xAxisData.values.length; i++) {
        var add = true;
        for (var j = 0; j < uniqueXAxisData.length; j++) {
            if (chart.data.xAxisData.values[i] === uniqueXAxisData[j]) {
                add = false;
                break;
            }
        }
        if (add) {
            uniqueXAxisData.push(chart.data.xAxisData.values[i]);
        }
    }

    var data = {};
    for (var _i = 0; _i < lineLength; _i++) {
        for (var _k = 0; _k < legendLength; _k++) {
            if (typeof chart._vars.legendOptions !== 'undefined') {
                //Accounting for legend toggles
                if (chart._vars.legendOptions[_k].toggle === false) {
                    //Don't write anything to data
                    continue;
                } else {
                    //Write something to data
                    if (!data[legendData[_k]]) {
                        data[legendData[_k]] = [];
                    }
                    data[legendData[_k]].push(parseFloat(lineData[_i][legendData[_k]]));
                }
            } else {
                //Initial creation of visualization w/o legend options
                if (!data[legendData[_k]]) {
                    data[legendData[_k]] = [];
                }
                if (data[legendData[_k]].length < lineLength) {
                    data[legendData[_k]].push(parseFloat(lineData[_i][legendData[_k]]));
                }
            }
        }
    }

    chart.svg.selectAll('.lines').remove();
    chart.svg.selectAll('.line').remove();
    chart.svg.selectAll('.circle').remove();
    chart.svg.selectAll('#line-gradient').remove();

    lines = chart.svg.selectAll('.' + chart.config.type + '-container');

    //curves object
    var curves = {
        'Linear': d3.curveLinear,
        'Step': d3.curveStep,
        'Step Before': d3.curveStepBefore,
        'Step After': d3.curveStepAfter,
        'Basis': d3.curveBasis,
        'Cardinal': d3.curveCardinal,
        'Monotone X': d3.curveMonotoneX,
        'Catmull Rom': d3.curveCatmullRom
    };

    var valueline = {};
    var circles = {};
    var index = 0;
    var lineColors = [];
    var thresholding = false;
    for (var k in data) {
        //Create path generator for each series
        if (data.hasOwnProperty(k)) {
            if (data[k] === '') {
                data[k] = 'EMPTY_STRING';
            }

            valueline[k] = d3.line() //line drawing function
            .curve(curves[chart._vars.lineCurveType]).defined(function (d) {
                return !isNaN(d);
            }).x(function (d, i) {
                if (isNaN(d)) {
                    return;
                }
                return xTranslate(d, i);
            }).y(function (d, i) {
                if (isNaN(d)) {
                    return;
                }
                return yTranslate(d, i);
            });

            //Add lines to the chart.config.type + '-container'
            lines.append('g').attr('class', 'line ' + k).append('path') //draws the line
            .attr('stroke', function (d, i, j) {
                var colorObj = jvCharts.getColors(colors, i, k);
                lineColors.push(colorObj);
                return colorObj;
            }) //fills the bar with color
            .attr('stroke-width', '2').attr('fill', 'none').attr('d', function (d, i) {
                return valueline[k](data[k]);
            });

            //Color Thresholding for each tier
            if (chart._vars.thresholds != 'none' && chart._vars.colorChart != false) {
                if (chart._vars.colorLine) {
                    var thresholdPercents = [];
                    var thresholdLength = Object.keys(chart._vars.thresholds).length;
                    if (chart._vars.rotateAxis) {
                        var zero = { percent: 0, color: lineColors[index] };
                        thresholdPercents.push(zero);

                        for (var z = 0; z < thresholdLength; z++) {
                            var pCent = chart._vars.thresholds[z].threshold * 100 / (xAxisData.max - xAxisData.min);
                            var temp = { percent: pCent, color: chart._vars.thresholds[z].thresholdColor };
                            thresholdPercents.push(temp);
                        }
                    } else {
                        var zero = { percent: 0, color: lineColors[index] };
                        thresholdPercents.push(zero);

                        for (var _z = 0; _z < thresholdLength; _z++) {
                            var pCent = chart._vars.thresholds[_z].threshold * 100 / (yAxisData.max - yAxisData.min);
                            var temp = { percent: pCent, color: chart._vars.thresholds[_z].thresholdColor };
                            thresholdPercents.push(temp);
                        }
                    }

                    var thresholdData = chart.setLineThresholdData(chart, thresholdPercents, lineColors[index]);

                    lines.selectAll('path').attr('class', 'line-threshold');

                    if (chart._vars.rotateAxis) {
                        chart.svg.append('linearGradient').attr('id', 'line-gradient').attr('gradientUnits', 'userSpaceOnUse').attr('x1', xTranslate(xAxisData.min)).attr('y1', 0).attr('x2', xTranslate(xAxisData.max)).attr('y2', 0).selectAll('stop').data(thresholdData).enter().append('stop').attr('offset', function (d) {
                            return d.offset;
                        }).attr('stop-color', function (d) {
                            return d.color;
                        });
                    } else {
                        chart.svg.append('linearGradient').attr('id', 'line-gradient').attr('gradientUnits', 'userSpaceOnUse').attr('x1', 0).attr('y1', yTranslate(yAxisData.min)).attr('x2', 0).attr('y2', yTranslate(yAxisData.max)).selectAll('stop').data(thresholdData).enter().append('stop').attr('offset', function (d) {
                            return d.offset;
                        }).attr('stop-color', function (d) {
                            return d.color;
                        });
                    }
                }
                thresholding = true;
            }

            //Add circles at joints in the lines
            circles[k] = lines.append('g').attr('class', 'circle ' + k).selectAll('circle').data(data[k]).enter().append('circle') //Circles for the joints in the line
            .attr('class', function (d, i) {
                return 'circle-' + chart.currentData.chartData[i][chart.currentData.dataTable.label].replace(/\s/g, '_').replace(/\./g, '_dot_') + ' highlight-class-' + chart.currentData.chartData[i][chart.currentData.dataTable.label].replace(/\s/g, '_').replace(/\./g, '_dot_');
            }).attr('cx', function (d, i) {
                if (isNaN(d)) {
                    return null;
                }
                return xTranslate(d, i);
            }).attr('cy', function (d, i) {
                if (isNaN(d)) {
                    return null;
                }
                return yTranslate(d, i);
            }).attr('fill', function (d, i, j) {
                if (isNaN(d)) {
                    return null;
                } else if (thresholding == true) {
                    var length = Object.keys(chart._vars.thresholds).length - 1;
                    if (chart._vars.rotateAxis) {
                        for (var z = length; z > -1; z--) {
                            var threshold = chart._vars.thresholds[z];
                            if (d >= threshold.threshold) {
                                return threshold.thresholdColor;
                            }
                        }
                    } else {
                        for (var z = length; z > -1; z--) {
                            var threshold = chart._vars.thresholds[z];
                            if (d >= threshold.threshold) {
                                return threshold.thresholdColor;
                            }
                        }
                    }
                }

                return jvCharts.getColors(colors, i, k);
            }).attr('opacity', function (d, i, j) {
                if (isNaN(d)) {
                    return 0;
                }
                return 1;
            }).attr('r', 2.5);

            index++;
        }
    }

    //Return line groups
    return lines.selectAll('.circle');
}

function setLineThresholdData(chart, thresholds) {
    var data = [];
    var thresholdLength = thresholds.length;
    for (var k = 0; k < thresholdLength; k++) {
        var gradientOne = { offset: thresholds[k].percent + '%', color: thresholds[k].color };
        data.push(gradientOne);

        if (k + 1 < thresholdLength) {
            var gradientTwo = { offset: thresholds[k + 1].percent + '%', color: thresholds[k].color };
            data.push(gradientTwo);
        }

        if (k == thresholdLength - 1) {
            var last = { offset: '100%', color: thresholds[k].color };
            data.push(last);
        }
    }

    return data;
}

module.exports = jvCharts;

},{"../jvCharts.js":4}],19:[function(require,module,exports){
'use strict';

var jvCharts = require('../jvCharts.js');

jvCharts.prototype.circlepack = {
    paint: paint,
    setData: setData,
    getEventData: getEventData
};

jvCharts.prototype.generatePack = generatePack;

/************************************************ Pack functions ******************************************************/

/**setPackChartData
 *  gets pack data and adds it to the chart object
 *
 * @params data, dataTable, colors
 */
function setData() {
    var chart = this;
    chart.data.legendData = setPackLegendData(chart.data.dataTable);
    if (!chart.data.chartData.hasOwnProperty('children')) {
        chart.data.chartData = jvCharts.convertTableToTree(chart.data.chartData, chart.data.dataTable);
    }

    //define color object for chartData
    chart.data.color = chart.colors;
}

function getEventData() {
    return {};
}

/**setPackLegendData
 *  gets legend info from chart Data
 *
 * @params data, type
 * @returns [] of legend text
 */
function setPackLegendData(dataTable) {
    var legendArray = [],
        label = '';
    for (var key in dataTable) {
        if (dataTable.hasOwnProperty(key)) {
            if (key === 'value') {
                label = dataTable[key];
            } else if (key !== 'tooltip 1') {
                legendArray.push(dataTable[key]);
            }
        }
    }
    legendArray.unshift(label);
    return legendArray;
}

function paint() {
    var chart = this,
        packMargins = {
        top: 30,
        right: 20,
        bottom: 15,
        left: 20
    };
    chart._vars.color = chart.data.color;

    chart.currentData = chart.data; //Might have to move into method bc of reference/value relationship

    //Generate SVG-legend data is used to determine the size of the bottom margin (set to null for no legend)
    chart.generateSVG(null, packMargins);
    chart.generateVerticalLegend('generatePack');
    chart.generatePack(chart.currentData);
}

/**generatePack
 *
 * paints the pack on the chart
 * @params packData
 */
function generatePack() {
    var chart = this,
        svg = chart.svg,
        container = chart.config.container,
        w = container.width,
        h = container.height,
        r = Math.min(h / 2, w / 3),
        margin = 20,
        diameter = r * 2,
        color,
        root,
        pack,
        vis,
        circle,
        node,
        view;

    chart.children = chart.data.chartData;

    color = d3.scaleOrdinal().range(chart.data.color.map(function (c) {
        c = d3.rgb(c);
        c.opacity = 0.8;
        return c;
    }));

    //assigns the data to a hierarchy using parent-child relationships
    root = d3.hierarchy(chart.children, function (d) {
        return d.children;
    });

    pack = d3.pack().size([container.width, container.height]).padding(2);

    pack(root.sum(function (d) {
        return d.hasOwnProperty('children') ? 0 : d.name;
    }).sort(function (a, b) {
        return b.height - a.height || b.value - a.value;
    })).descendants();

    svg.selectAll('.pack').remove();

    vis = svg.append('g').attr('class', 'pack').attr('transform', 'translate(' + w / 2 + ',' + r + ')');

    circle = vis.selectAll('circle').data(root.descendants()).enter().append('circle').attr('class', function (d) {
        return d.parent ? d.children ? 'node' : 'node node--leaf' : 'node node--root';
    }).style('fill', function (d) {
        d.color = color(d.depth);
        return d.children ? color(d.depth) : null;
    }).on('click', function (d) {
        if (focus !== d) {
            zoom(d);
            d3.event.stopPropagation();
        }
    }).on('mouseover', function (d, i) {
        //Get tip data
        var tipData = chart.setTipData(d, i);
        //Draw tip line
        chart.tip.generateSimpleTip(tipData, chart.data.dataTable);
        chart.tip.d = d;
        chart.tip.i = i;
    }).on('mousemove', function (d, i) {
        if (chart.showToolTip) {
            if (chart.tip.d === d && chart.tip.i === i) {
                chart.tip.showTip(d3.event);
            } else {
                //Get tip data
                var tipData = chart.setTipData(d, i);
                //Draw tip line
                chart.tip.generateSimpleTip(tipData, chart.data.dataTable);
            }
        }
    }).on('mouseout', function () {
        chart.tip.hideTip();
    });

    node = svg.selectAll('circle,text');

    d3.select('body').on('click', function () {
        zoom(root);
    });

    zoomTo([root.x, root.y, root.r * 2 + margin]);

    function zoom(d) {
        var focus = d;
        d3.transition().duration(d3.event.altKey ? 7500 : 750).tween('zoom', function (d) {
            var i = d3.interpolateZoom(view, [focus.x, focus.y, focus.r * 2 + margin]);
            return function (t) {
                zoomTo(i(t));
            };
        });
    }
    function zoomTo(v) {
        var k = diameter / v[2];

        //set global zoom
        view = v;

        node.attr('transform', function (d) {
            if (d && d.x && d.y) {
                return 'translate(' + (d.x - v[0]) * k + ',' + (d.y - v[1]) * k + ')';
            }
            return '';
        });

        circle.attr('r', function (d) {
            return d.r * k;
        });
    }
}

module.exports = jvCharts;

},{"../jvCharts.js":4}],20:[function(require,module,exports){
'use strict';

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var jvCharts = require('../jvCharts.js');

jvCharts.prototype.pie = {
    paint: paint,
    setData: setData,
    getEventData: getEventData,
    highlightFromEventData: highlightFromEventData
};

jvCharts.prototype.generatePie = generatePie;

/************************************************ Pie Data functions ******************************************************/

/**setPieData
 *  gets pie data and adds it to the chart object
 *
 * @params data, dataTable, colors
 */
function setData() {
    var chart = this;

    //Set data if a 'bucket' is specified--paints # specified, groups rest into other category
    if (chart._vars.hasOwnProperty('buckets') && parseInt(chart._vars.buckets, 10) !== 0) {
        //bucket the data
        var data = chart.data,
            other = {},
            categorizedData = [],
            i = void 0;

        data.chartData.sort(function (a, b) {
            return b[data.dataTable.value] - a[data.dataTable.value];
        });
        other[data.dataTable.label] = 'Other';
        other[data.dataTable.value] = 0;
        for (i = 0; i < data.chartData.length; i++) {
            if (i < chart._vars.buckets) {
                categorizedData.push(data.chartData[i]);
            } else {
                other[data.dataTable.value] += data.chartData[i][data.dataTable.value];
            }
        }
        categorizedData.push(other);
        data.chartData = categorizedData;
    }
    //Set legend data after determining if the data is bucketed
    chart.data.legendData = setPieLegendData(chart.data);
    //define color object for chartData
    chart.data.color = jvCharts.setChartColors(chart._vars.color, chart.data.legendData, chart.colors);
}

function getEventData(event) {
    var chart = this,
        ele = event.target.classList.value.split('pie-data-')[1];
    if (ele) {
        return {
            data: _defineProperty({}, chart.currentData.dataTable.label, [ele.replace(/_/g, ' ').replace(/_colon_/g, ':').replace(/_dot_/g, '.')]),
            node: event.target
        };
    } else if (event.target.classList.value.indexOf('pie-container') > -1) {
        return {
            data: {}
        };
    }
    return {
        data: false
    };
}

function highlightFromEventData(event) {
    var chart = this,
        label = event.data[chart.currentData.dataTable.label][0],
        cssClass = '.highlight-class-' + label.replace(/\s/g, '_').replace(/\./g, '_dot_'),
        node = chart.svg.selectAll(cssClass);

    chart.svg.select('.pie-container').selectAll('.slice').attr('stroke', 0).attr('stroke-width', 0);
    //highlight necessary slices
    node.attr('stroke', chart._vars.highlightBorderColor).attr('stroke-width', chart._vars.highlightBorderWidth);
}

/**setPieLegendData
 *  gets legend info from chart Data
 *
 * @params data, type
 * @returns [] of legend text
 */
function setPieLegendData(data) {
    var legendArray = [];
    for (var i = data.chartData.length - 1; i >= 0; i--) {
        legendArray.push(data.chartData[i][data.dataTable.label]);
    }
    return legendArray;
}

function paint() {
    var chart = this,
        customMargins = {
        top: 40,
        right: 20,
        bottom: 20,
        left: 20
    };

    chart.currentData = chart.data;
    chart._vars.color = chart.data.color;
    chart.legendData = chart.data.legendData;
    chart.generateSVG(chart.data.legendData, customMargins);

    //If the container size is small, don't generate a legend
    if (chart.config.container.width > 550) {
        chart.generateVerticalLegend('generatePie');
    }

    chart.generatePie(chart.currentData);
}

/**generatePie
 *
 * creates and draws a pie chart on the svg element
 * @params svg, pieData, _vars, container
 * @returns {{}}
 */
function generatePie(currentData) {
    var chart = this,
        svg = chart.svg,
        pieData = currentData.chartData,
        container = chart.config.container,
        legendData = chart.currentData.legendData,
        colors = chart._vars.color,
        w = container.width,
        h = container.height,
        r = Math.min(h / 2, w / 3),
        data = [],
        total = 0,
        pieDataNew,
        legendElementToggleArray,
        vis,
        pie,
        arc,
        arcs;

    //define variables to change attr's
    svg.select('g.pie-container').remove();

    for (var i = 0; i < pieData.length; i++) {
        var obj = {};
        for (var j in chart.data.dataTable) {
            if (chart.data.dataTable.hasOwnProperty(j)) {
                obj[j] = pieData[i][chart.data.dataTable[j]];
            }
        }
        data[i] = obj;
    }

    pieDataNew = data;

    if (!chart._vars.legendHeaders) {
        chart._vars.legendHeaders = legendData;
    }

    legendElementToggleArray = jvCharts.getLegendElementToggleArray(chart._vars.legendHeaders, legendData);

    if (legendElementToggleArray) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = pieDataNew[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var slice = _step.value;
                var _iteratorNormalCompletion2 = true;
                var _didIteratorError2 = false;
                var _iteratorError2 = undefined;

                try {
                    for (var _iterator2 = legendElementToggleArray[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                        var legendEle = _step2.value;

                        if (legendEle.element === slice.label && legendEle.toggle === false) {
                            slice.value = 0;
                        }
                    }
                } catch (err) {
                    _didIteratorError2 = true;
                    _iteratorError2 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion2 && _iterator2.return) {
                            _iterator2.return();
                        }
                    } finally {
                        if (_didIteratorError2) {
                            throw _iteratorError2;
                        }
                    }
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                    _iterator.return();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
    }

    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
        for (var _iterator3 = pieDataNew[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var _slice = _step3.value;

            total += parseFloat(_slice.value);
        }
    } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
            }
        } finally {
            if (_didIteratorError3) {
                throw _iteratorError3;
            }
        }
    }

    vis = svg.append('g').data([pieDataNew]).attr('class', 'pie-container').attr('height', 200).attr('transform', 'translate(' + w / 2 + ', ' + r + ')');

    pie = d3.pie().value(function (d) {
        return d.value;
    });

    //declare an arc generator function
    arc = d3.arc().innerRadius(0) //Normal pie chart when this = 0, can be changed to create donut chart
    .outerRadius(r);

    //select paths, use arc generator to draw
    arcs = vis.selectAll('g.slice').data(pie).enter().append('g').attr('class', 'slice');

    arcs.append('path').attr('fill', function (d, i) {
        return jvCharts.getColors(colors, i, d.data.label);
    }).attr('d', function (d) {
        return arc(d);
    }).attr('class', function (d, i) {
        if (typeof d.data.label !== 'string') {
            return '';
        }

        return 'editable editable-pie pie-slice-' + d.data.label.replace(/\s/g, '_').replace(/\./g, '_dot_') + ' highlight-class-' + d.data.label.replace(/\s/g, '_').replace(/\./g, '_dot_') + ' pie-data-' + d.data.label.replace(/\s/g, '_').replace(/\./g, '_dot_');
    }).attr('stroke', chart._vars.pieBorder).attr('stroke-width', chart._vars.pieBorderWidth).on('mouseover', function (d, i) {
        if (chart.showToolTip) {
            //Get tip data
            var tipData = chart.setTipData(d.data, i);
            // Draw tip line
            chart.tip.generateSimpleTip(tipData, chart.data.dataTable);
            chart.tip.d = d;
            chart.tip.i = i;
        }
    }).on('mousemove', function (d, i) {
        if (chart.showToolTip) {
            if (chart.tip.d === d && chart.tip.i === i) {
                chart.tip.showTip(d3.event);
            } else {
                //Get tip data
                var tipData = chart.setTipData(d, i);
                //Draw tip line
                chart.tip.generateSimpleTip(tipData, chart.data.dataTable);
            }
        }
    }).on('mouseout', function () {
        chart.tip.hideTip();
    });

    arcs.append('svg:text').attr('class', 'sliceLabel').attr('transform', function (d) {
        var centroid = arc.centroid(d);
        centroid[0] = centroid[0] * 1.6;
        centroid[1] = centroid[1] * 1.6;
        return 'translate(' + centroid + ')';
    }).attr('dy', '.35em').attr('text-anchor', 'middle').text(function (d, i) {
        var percent = pieDataNew[i].value / total * 100;
        percent = d3.format('.1f')(percent);
        if (percent > 1) {
            return percent + '%';
        }
    }).attr('font-size', chart._vars.fontSize).attr('fill', chart._vars.pieTextColor).attr('pointer-events', 'none');
}

module.exports = jvCharts;

},{"../jvCharts.js":4}],21:[function(require,module,exports){
'use strict';

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var jvCharts = require('../jvCharts.js');

jvCharts.prototype.radial = {
    paint: paint,
    setData: setData,
    getEventData: getEventData,
    highlightFromEventData: highlightFromEventData
};

jvCharts.prototype.generateRadial = generateRadial;

/************************************************ Radial Data functions ******************************************************/
/**setRadialChartData
 *  gets bar data and adds it to the chart object
 *
 * @params data, dataTable, colors
 */
function setData() {
    var chart = this;
    chart.data.legendData = setRadialLegendData(chart.data);
    //define color object for chartData
    chart.data.color = jvCharts.setChartColors(chart._vars.color, chart.data.legendData, chart.colors);
}

function paint() {
    var chart = this,
        radialMargins = {
        top: 40,
        right: 20,
        bottom: 20,
        left: 20
    };
    chart._vars.color = chart.data.color;
    chart.currentData = chart.data; //Might have to move into method bc of reference/value relationship

    //Generate SVG-legend data is used to determine the size of the bottom margin (set to null for no legend)
    chart.generateSVG(null, radialMargins);
    chart.generateVerticalLegend('generateRadial');
    chart.generateRadial();
}

function getEventData(event) {
    var chart = this,
        ele = event.target.classList.value.split('radial-data-')[1];
    if (ele) {
        return {
            data: _defineProperty({}, chart.currentData.dataTable.label, [ele.replace(/_/g, ' ').replace(/_colon_/g, ':').replace(/_dot_/g, '.')]),
            node: event.target
        };
    } else if (event.target.classList.value.indexOf('radial-container') > -1) {
        return {
            data: {}
        };
    }
    return {
        data: false
    };
}

function highlightFromEventData(event) {
    var chart = this,
        label = event.data[chart.currentData.dataTable.label][0],
        cssClass = '.highlight-class-' + label.replace(/\s/g, '_').replace(/\./g, '_dot_'),
        node = chart.svg.selectAll(cssClass);

    chart.svg.select('.radial-container').selectAll('path').attr('stroke', 0).attr('stroke-width', 0);
    //highlight necessary slices
    node.attr('stroke', chart._vars.highlightBorderColor).attr('stroke-width', chart._vars.highlightBorderWidth);
}

/**setRadialLegendData
 *  gets legend info from chart Data
 *
 * @params data, type
 * @returns [] of legend text
 */
function setRadialLegendData(data) {
    var legendArray = [];
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = data.chartData[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var chartEle = _step.value;

            if (legendArray.indexOf(chartEle[data.dataTable.label]) === -1) {
                legendArray.push(chartEle[data.dataTable.label]);
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    return legendArray;
}

/**generateRadial
 *
 * paints the radil bar chart on the chart
 * @params radialData
 */

function generateRadial() {
    var chart = this,
        svg = chart.svg,
        colors = chart._vars.color,
        container = chart.config.container,
        legendData = chart.data.legendData,
        radialData = chart.data.chartData,
        tickNumber = 3,
        barHeight = container.height / 2 - 40,
        width = container.width,
        height = container.height,
        r = Math.min(height / 2, width / 3),
        data = [],
        radialDataNew,
        dataHeaders,
        legendElementToggleArray = [],
        radialDataFiltered,
        obj,
        vis,
        extent,
        formatNumber,
        barScale,
        keys,
        numBars,
        x,
        xAxis,
        arc,
        segments,
        axisGroup;

    for (var i = 0, len = radialData.length; i < len; i++) {
        obj = {};
        for (var j in chart.data.dataTable) {
            obj[j] = radialData[i][chart.data.dataTable[j]];
        }
        data[i] = obj;
    }

    radialDataNew = JSON.parse(JSON.stringify(data)); //copy of pie data


    if (!chart._vars.legendHeaders) {
        chart._vars.legendHeaders = legendData;
    }

    dataHeaders = chart._vars.legendHeaders;
    legendElementToggleArray = jvCharts.getLegendElementToggleArray(dataHeaders, legendData);
    radialDataFiltered = [];

    if (legendElementToggleArray) {
        for (var _j = 0; _j < radialDataNew.length; _j++) {
            for (var _i = 0; _i < legendElementToggleArray.length; _i++) {
                if (legendElementToggleArray[_i].element === radialDataNew[_j].label && legendElementToggleArray[_i].toggle === false) {
                    radialDataNew[_j].value = -1;
                }
            }
        }
    }

    for (var _j2 = 0; _j2 < radialDataNew.length; _j2++) {
        if (radialDataNew[_j2].value !== -1) {
            radialDataFiltered.push(radialDataNew[_j2]);
        }
    }

    //Remove existing bars from page
    svg.selectAll('g.radial-container').remove();

    vis = svg.append('g').attr('class', 'radial-container').attr('height', height).attr('transform', 'translate( ' + width / 2 + ' , ' + r + ' )');

    extent = d3.extent(radialDataFiltered, function (d) {
        return d.value;
    });

    //commas and 0 decimals
    formatNumber = d3.format(',.0f');
    if (extent[1] >= 1000000) {
        //millions
        var p = d3.precisionPrefix(1e5, 1.3e6);
        formatNumber = d3.formatPrefix('.' + p, 1.3e6);
    } else if (extent[1] <= 100) {
        //2 decimals
        formatNumber = d3.format(',.2f');
    }

    if (extent[0] !== 0) {
        extent[0] = 0;
    }
    barScale = d3.scaleLinear().domain(extent).range([0, barHeight]);

    keys = radialDataFiltered.map(function (d) {
        return d.label;
    });
    numBars = keys.length;

    x = d3.scaleLinear().domain(extent).range([0, -barHeight]);

    //create xAxis drawing function
    xAxis = d3.axisLeft().scale(x).ticks(tickNumber).tickFormat(formatNumber);

    vis.selectAll('circle').data(x.ticks(3)).enter().append('circle').attr('r', function (d) {
        return barScale(d);
    }).style('fill', 'none').style('stroke', 'black').style('stroke-dasharray', '2,2').style('stroke-width', '.5px');

    arc = d3.arc().startAngle(function (d, i) {
        return i * 2 * Math.PI / numBars;
    }).endAngle(function (d, i) {
        return (i + 1) * 2 * Math.PI / numBars;
    }).innerRadius(0);

    segments = vis.selectAll('path').data(radialDataFiltered).enter().append('g').append('path').attr('class', function (d) {
        var label = d.label.replace(/\s/g, '_').replace(/\./g, '_dot_');
        return 'radial-data-' + label + ' highlight-class-' + label;
    }).each(function (d) {
        d.outerRadius = 0;
    }).style('fill', function (d, i) {
        return jvCharts.getColors(colors, i, d.label);
    }).attr('d', arc).on('mouseover', function (d, i) {
        if (chart.showToolTip) {
            //Get tip data
            var tipData = chart.setTipData(d, i);
            //Draw tip line
            chart.tip.generateSimpleTip(tipData, chart.data.dataTable);
            chart.tip.d = d;
            chart.tip.i = i;
        }
    }).on('mousemove', function (d, i) {
        if (chart.showToolTip) {
            if (chart.tip.d === d && chart.tip.i === i) {
                chart.tip.showTip(d3.event);
            } else {
                //Get tip data
                var tipData = chart.setTipData(d, i);
                //Draw tip line
                chart.tip.generateSimpleTip(tipData, chart.data.dataTable);
            }
        }
    }).on('mouseout', function (d) {
        if (chart.showToolTip) {
            chart.tip.hideTip();
            svg.selectAll('line.tip-line').remove();
        }
    });

    segments.transition().duration(800).ease(d3.easeElastic).delay(function (d, i) {
        return 750 - 50 * i;
    }).attrTween('d', function (d, index) {
        var i = d3.interpolate(d.outerRadius, barScale(+d.value));
        return function (t) {
            d.outerRadius = i(t);
            return arc(d, index);
        };
    });

    vis.append('circle').attr('r', barHeight).classed('outer', true).style('fill', 'none').style('stroke', 'black').style('stroke-width', '1.5px');

    vis.selectAll('line').data(keys).enter().append('g').attr('class', 'label').append('line').attr('y2', -barHeight - 20).style('stroke', 'black').style('stroke-width', '.5px').attr('transform', function (d, i) {
        return 'rotate( ' + i * 360 / numBars + ' )';
    });

    axisGroup = vis.append('g').attr('class', 'xAxis').style('pointer-events', 'none').call(xAxis);

    axisGroup.selectAll('text').attr('fill', 'black') //Customize the color of axis labels
    .attr('class', 'yAxisLabels editable editable-yAxis editable-text editable-num').attr('transform', function (d) {
        if (d === xAxis.scale().ticks(tickNumber)[tickNumber]) {
            return 'translate(0, 10)';
        }
        return 'translate(0,0)';
    }).attr('font-size', chart._vars.fontSize).append('svg:title');
}

module.exports = jvCharts;

},{"../jvCharts.js":4}],22:[function(require,module,exports){
'use strict';

var jvCharts = require('../jvCharts.js');

jvCharts.prototype.sankey = {
    paint: paint,
    setData: setData,
    getEventData: getEventData
};

jvCharts.prototype.generateSankey = generateSankey;

/************************************************ Sankey functions ******************************************************/
/**
 *
 * @param data
 * @param dataTable
 * @param colors
 */
function setData() {
    var chart = this;
    var sankeyData = {},
        data = chart.data.chartData,
        dataTable = chart.data.dataTable;

    sankeyData.links = [];
    sankeyData.nodes = [];

    //Iterate through sources and targets to make a node list
    var nodeList = [];
    var nodeGroup = 1;
    for (var item in dataTable) {
        var nodeListForLabel = [];
        if (item === 'value') {
            continue;
        }
        for (var i = 0; i < data.length; i++) {
            var potentialNode = data[i][dataTable[item]] + '-' + nodeGroup;
            var addToList = true;
            for (var j = 0; j < nodeListForLabel.length; j++) {
                if (potentialNode === nodeListForLabel[j]) {
                    addToList = false;
                    break;
                }
            }
            if (addToList) {
                nodeListForLabel.push(potentialNode);
            }
        }
        nodeGroup++;
        nodeList = nodeList.concat(nodeListForLabel);
    }
    //Create nodes object
    for (var i = 0; i < nodeList.length; i++) {
        sankeyData.nodes.push({
            'name': nodeList[i]
        });
    }

    //See how many sets of links you need
    var linkGroups = 0;

    for (var _item in dataTable) {
        if (_item.indexOf('label') !== -1) {
            linkGroups++;
        }
    }

    var source = void 0,
        target = void 0,
        value = void 0;

    for (var k in dataTable) {
        if (k.indexOf('value') > -1) {
            value = dataTable[k];
        } else if (!source) {
            source = dataTable[k];
        } else {
            target = dataTable[k];
        }
    }

    var _loop = function _loop(_i) {
        linkGroup = [];

        linkGroup = data.map(function (x) {
            return {
                'source': x[source] + '-' + _i,
                'target': x[target] + '-' + (_i + 1),
                'value': x[value]
            };
        });

        sankeyData.links = sankeyData.links.concat(linkGroup);
    };

    for (var _i = 1; _i < linkGroups; _i++) {
        var linkGroup;

        _loop(_i);
    }

    var nodeMap = {};
    for (i = 0; i < sankeyData.nodes.length; i++) {
        sankeyData.nodes[i].node = i;
        nodeMap[sankeyData.nodes[i].name] = i;
    }
    sankeyData.links = sankeyData.links.map(function (x) {
        return {
            source: nodeMap[x.source],
            target: nodeMap[x.target],
            value: x.value
        };
    });

    //Group common sankey links together and add the values
    var aggregateSankeyLinks = [];
    for (var _i2 = 0; _i2 < sankeyData.links.length; _i2++) {
        var currentLink = {};
        currentLink.source = sankeyData.links[_i2].source;
        currentLink.target = sankeyData.links[_i2].target;
        currentLink.value = sankeyData.links[_i2].value;

        //Make sure that only unique links are pushed to the aggregated array
        var addToAggregate = true;
        for (var _k = 0; _k < aggregateSankeyLinks.length; _k++) {
            if (aggregateSankeyLinks[_k].source === currentLink.source && aggregateSankeyLinks[_k].target === currentLink.target) {
                addToAggregate = false;
                break;
            }
        }

        if (!addToAggregate) {
            continue;
        }

        //Sum the value of identical links
        for (var _j = 0; _j < sankeyData.links.length; _j++) {
            if (sankeyData.links[_i2].source === sankeyData.links[_j].source && sankeyData.links[_i2].target === sankeyData.links[_j].target) {
                currentLink.value = currentLink.value + sankeyData.links[_j].value;
            }
        }

        aggregateSankeyLinks.push(currentLink);
    }

    sankeyData.links = aggregateSankeyLinks;

    chart.data.chartData = sankeyData;
    chart.data.color = d3.scaleOrdinal(d3.schemeCategory20);
}

function paint() {
    var chart = this;
    var data = chart.data.chartData;

    //generate SVG
    chart.generateSVG(null);
    chart.generateSankey(data);
}

function getEventData() {
    return {};
}

/**
 * Generates a sankey chart with the given data
 * @param sankeyData
 */
function generateSankey(sankeyData) {
    var chart = this,
        svg = chart.svg,
        color = chart._vars.color;

    var width = chart.config.container.width;
    var height = chart.config.container.height;

    var formatNumber = d3.format(',.0f'),
        //zero decimal places
    format = function format(d) {
        return formatNumber(d) + ' ' + 'Widgets';
    },
        color = d3.scaleOrdinal(d3.schemeCategory20);

    var sankey = d3.sankey().nodeWidth(10).nodePadding(15).size([width, height]);

    var path = sankey.link();

    ////Adding zoom v4 behavior to sankey
    d3.selectAll('svg').call(d3.zoom().scaleExtent([0.1, 10]).on('zoom', zoom)); //zoom event listener

    sankey.nodes(sankeyData.nodes).links(sankeyData.links).layout(32);

    var link = svg.append('g').selectAll('.sankey-link').data(sankeyData.links).enter().append('path').filter(function (d) {
        return d.value > 0;
    }).attr('class', 'sankey-link').attr('d', path).style('stroke-width', function (d) {
        return Math.max(1, d.dy);
    }).sort(function (a, b) {
        return b.dy - a.dy;
    }).on('mouseover', function (d, i) {
        if (chart.showToolTip) {
            var tipData = chart.setTipData(d, i);
            chart.tip.generateSimpleTip(tipData, chart.data.dataTable);
            chart.tip.d = d;
            chart.tip.i = i;
        }
    }).on('mousemove', function (d, i) {
        if (chart.showToolTip) {
            if (chart.tip.d === d && chart.tip.i === i) {
                chart.tip.showTip(d3.event);
            } else {
                //Get tip data
                var tipData = chart.setTipData(d, i);
                //Draw tip line
                chart.tip.generateSimpleTip(tipData, chart.data.dataTable);
            }
        }
    }).on('mouseout', function (d, i) {
        if (chart.showToolTip) {
            chart.tip.hideTip();
        }
    });

    var node = svg.append('g').selectAll('.node').data(sankeyData.nodes).enter().append('g').filter(function (d) {
        return d.value > 0;
    }).attr('class', 'node').attr('transform', function (d) {
        return 'translate(' + d.x + ', ' + d.y + ')';
    }).call(d3.drag().subject(function (d) {
        return d;
    }).on('start', function (d) {
        d3.event.sourceEvent.stopPropagation();
        this.parentNode.appendChild(this);
    }).on('drag', dragmove));

    node.append('rect').attr('height', function (d) {
        //return d.dy;
        return Math.abs(d.dy);
        //return Math.max(d.dy, 2);
    }).attr('width', sankey.nodeWidth()).style('fill', function (d) {
        return d.color = color(d.name);
    }).style('stroke', function (d) {
        return d3.rgb(d.color).darker(2);
    });

    node.append('text').attr('x', -6).attr('y', function (d) {
        return d.dy / 2;
    }).attr('dy', '.35em').attr('text-anchor', 'end').attr('transform', null).attr('transform', null).text(function (d) {
        //Remove the the nodeGroup tag and hyphen from the end of the label
        return d.name.slice(0, -2);
    }).filter(function (d) {
        return d.x < width / 2;
    }).attr('x', 6 + sankey.nodeWidth()).attr('text-anchor', 'start');

    function dragmove(d) {
        d3.select(this).attr('transform', 'translate(' + (d.x = Math.max(0, Math.min(width - d.dx, d3.event.x))) + ',' + (d.y = Math.max(0, Math.min(height - d.dy, d3.event.y))) + ')');
        sankey.relayout();
        link.attr('d', path);
    }

    function zoom() {
        //Implementing the v4 zooming feature
        svg.attr('transform', d3.event.transform);
    }
}

module.exports = jvCharts;

},{"../jvCharts.js":4}],23:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var jvCharts = require('../jvCharts.js');

jvCharts.prototype.scatterplot = {
    paint: paint,
    setData: setData,
    getEventData: getEventData,
    highlightFromEventData: highlightFromEventData
};

jvCharts.prototype.generateScatter = generateScatter;
jvCharts.prototype.createLineGuide = createLineGuide;

/************************************************ Scatter functions ******************************************************/

/**setScatterData
 *  gets scatter data and adds it to the chart object
 *
 * @params data, dataTable, colors
 */
function setData() {
    var chart = this;
    chart.data.legendData = setScatterLegendData(chart.data);
    chart.data.xAxisData = setScatterAxisData(chart.data, 'x', chart._vars);
    chart.data.yAxisData = setScatterAxisData(chart.data, 'y', chart._vars);
    chart.data.zAxisData = chart.data.dataTable.hasOwnProperty('z') ? setScatterAxisData(chart.data, 'z', chart._vars) : {};
    //define color object for chartData
    chart.data.color = jvCharts.setChartColors(chart._vars.color, chart.data.legendData, chart.colors);
}

function getEventData(event, mouse) {
    var chart = this,
        ele = event.target.__data__;

    //determine if the click event happens inside the container
    var brushContainer = chart.chartDiv.select('.' + chart.config.type + '-container').node(),
        containerBox = brushContainer.getBoundingClientRect(),
        x = mouse[0],
        y = mouse[1],
        insideContainer = false;

    if (x < containerBox.right && y < containerBox.bottom && x > containerBox.left && y > containerBox.top) {
        insideContainer = true;
    }

    if (insideContainer && ele) {
        return {
            data: _defineProperty({}, chart.currentData.dataTable.label, [ele[chart.currentData.dataTable.label].replace(/_/g, ' ').replace(/_colon_/g, ':').replace(/_dot_/g, '.')]),
            node: event.target
        };
    } else if (insideContainer) {
        return {
            data: {}
        };
    }
    return {
        data: false
    };
}

function highlightFromEventData(event) {
    var chart = this,
        label = event.data[chart.currentData.dataTable.label][0],
        cssClass = '.highlight-class-' + label.replace(/\s/g, '_').replace(/\./g, '_dot_'),
        node = chart.svg.selectAll(cssClass);

    chart.svg.select('.scatter-circle').selectAll('circle').attr('stroke', 0).attr('stroke-width', 0);
    //highlight necessary circles
    node.attr('stroke', chart._vars.highlightBorderColor).attr('stroke-width', chart._vars.highlightBorderWidth);
}

/**setScatterLegendData
 *  gets legend info from chart Data
 *
 * @params data, type
 * @returns [] of legend text
 */
function setScatterLegendData(data) {
    var legendArray = [];
    if (data.dataTable.hasOwnProperty('series')) {
        var series = data.dataTable.series;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = data.chartData[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var chartEle = _step.value;

                if (legendArray.indexOf(chartEle[series]) === -1) {
                    legendArray.push(chartEle[series]);
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                    _iterator.return();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
    }

    if (legendArray.length === 0 || typeof legendArray[0] === 'undefined') {
        legendArray.push(data.dataTable.label);
        data.dataTable.series = data.dataTable.label;
    }

    //order legend data in alphabetical order
    legendArray.sort();
    return legendArray;
}

/**setScatterAxisData
 *  gets z axis data based on the chartData
 *
 * @params data, dataTable
 * @returns object with label and values
 */
function setScatterAxisData(data, axis, _vars) {
    //declare vars
    var axisData = [],
        chartData = data.chartData,
        scatterLabel = data.dataTable[axis],
        min = scatterLabel ? chartData[0][scatterLabel] : 0,
        max = scatterLabel ? chartData[0][scatterLabel] : 0;

    //loop over data to find max and min
    //also determines the y axis total if the data is stacked
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
        for (var _iterator2 = chartData[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var chartEle = _step2.value;

            if (chartEle.hasOwnProperty(scatterLabel)) {
                var num = chartEle[scatterLabel];
                if (!isNaN(num)) {
                    num = parseFloat(num);
                    if (num > max) {
                        max = num;
                    } else if (num < min) {
                        min = num;
                    }
                }
            }
        }
    } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
            }
        } finally {
            if (_didIteratorError2) {
                throw _iteratorError2;
            }
        }
    }

    if (axis !== 'z') {
        min *= 0.9;
        max *= 1.1;
    }

    if (_vars.yMin && !isNaN(_vars.yMin) && axis === 'y') {
        min = _vars.yMin;
    }
    if (_vars.yMax && !isNaN(_vars.yMax) && axis === 'y') {
        max = _vars.yMax;
    }
    if (_vars.xMin && !isNaN(_vars.xMin) && axis === 'x') {
        min = _vars.xMin;
    }
    if (_vars.xMax && !isNaN(_vars.xMax) && axis === 'x') {
        max = _vars.xMax;
    }

    axisData.push(min);
    axisData.push(max);
    return {
        'label': scatterLabel,
        'values': axisData,
        'dataType': 'NUMBER',
        'min': min,
        'max': max
    };
}

function paint() {
    var chart = this,
        dataObj = {};

    dataObj.chartData = chart.data.chartData;
    dataObj.legendData = chart.data.legendData;
    dataObj.dataTable = chart.data.dataTable;
    chart._vars.color = chart.data.color;
    dataObj.xAxisData = chart.data.xAxisData;
    dataObj.yAxisData = chart.data.yAxisData;
    dataObj.zAxisData = chart.data.zAxisData;
    chart.currentData = dataObj;

    //generate svg dynamically based on legend data
    chart.generateSVG(dataObj.legendData);

    //TODO remove these from draw object
    chart.generateXAxis(chart.currentData.xAxisData);
    chart.generateYAxis(chart.currentData.yAxisData);
    chart.generateLegend(chart.currentData.legendData, 'generateScatter');

    chart.generateScatter();

    if (chart._vars.lineGuide) {
        chart.createLineGuide();
    }

    if (typeof dataObj.xAxisScale.ticks === 'function') {
        chart.formatXAxisLabels(dataObj.xAxisScale.ticks().length);
    } else {
        chart.formatXAxisLabels(dataObj.xAxisScale.domain().length);
    }
}

function calculateMean(data, type) {
    return d3.mean(data, function (value) {
        return +value[type];
    });
}

function createLineGuide() {
    var chart = this,
        svg = chart.svg,
        container = chart.config.container,
        chartData = chart.currentData.chartData,
        dataTable = chart.currentData.dataTable,
        xAxisData = chart.currentData.xAxisData,
        yAxisData = chart.currentData.yAxisData,
        xMean = calculateMean(chartData, dataTable.x),
        yMean = calculateMean(chartData, dataTable.y),
        xScale = jvCharts.getAxisScale('x', xAxisData, container, chart._vars),
        yScale = jvCharts.getAxisScale('y', yAxisData, container, chart._vars),
        lineGroup;

    svg.selectAll('g.lineguide.x').remove();
    svg.selectAll('g.lineguide.y').remove();

    lineGroup = svg.append('g').attr('class', 'line-group scatterplot-container');

    //create crosshair based on median x (up/down)
    lineGroup.append('g').attr('class', 'lineguide x').append('line').style('stroke', 'gray').style('stroke-dasharray', '3, 3').style('fill', 'black').attr('x1', xScale(xMean)).attr('y1', 0).attr('x2', xScale(xMean)).attr('y2', container.height);

    //create crosshair based on median y (left/right)
    lineGroup.append('g').attr('class', 'lineguide y').append('line').style('stroke', 'gray').style('stroke-dasharray', '3, 3').style('fill', 'black').attr('x1', 0).attr('y1', yScale(yMean)).attr('x2', container.width).attr('y2', yScale(yMean));
}

/**generateScatter
 *
 * creates and draws a scatter plot on the svg element
 * @params svg, scatterData, _vars, xAxisData, yAxisData, zAxisData, container, dataTable legendData
 * @returns {{}}
 */
function generateScatter() {
    var chart = this,
        svg = chart.svg,
        container = chart.config.container,
        scatterData = chart.currentData.chartData,
        dataTable = chart.currentData.dataTable,
        xAxisData = chart.currentData.xAxisData,
        yAxisData = chart.currentData.yAxisData,
        zAxisData = chart.currentData.zAxisData,
        legendData = chart.currentData.legendData,
        colors = chart._vars.color,
        legendElementToggleArray,
        scatterDataFiltered = [],
        x,
        y,
        z;

    if (!chart._vars.NODE_MIN_SIZE) {
        chart._vars.NODE_MIN_SIZE = 4.5;
    }
    if (!chart._vars.NODE_MAX_SIZE) {
        chart._vars.NODE_MAX_SIZE = 25;
    }

    //set clip path rectangle
    svg.append('clipPath').attr('id', 'scatter-area').append('rect').attr('x', 1).attr('width', container.width - 1).attr('height', container.height).attr('fill', chart._vars.backgroundColor);

    svg.selectAll('g.scatterplot-container').remove();
    svg.selectAll('g.scatterplot-container.editable-scatter').remove();

    if (!chart._vars.legendHeaders) {
        chart._vars.legendHeaders = legendData;
    }

    legendElementToggleArray = jvCharts.getLegendElementToggleArray(chart._vars.legendHeaders, legendData);

    if (legendElementToggleArray) {
        for (var j = 0; j < scatterData.length; j++) {
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
                for (var _iterator3 = legendElementToggleArray[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                    var legendEle = _step3.value;

                    if (typeof scatterData[j][dataTable.label] === 'undefined' || scatterData[j][dataTable.label] === '') {
                        if (legendEle.toggle !== false) {
                            scatterDataFiltered.push(scatterData[j]);
                        }
                    } else if (legendEle.element !== scatterData[j][dataTable.series] || legendEle.toggle !== false) {
                        scatterDataFiltered.push(scatterData[j]);
                    }
                }
            } catch (err) {
                _didIteratorError3 = true;
                _iteratorError3 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion3 && _iterator3.return) {
                        _iterator3.return();
                    }
                } finally {
                    if (_didIteratorError3) {
                        throw _iteratorError3;
                    }
                }
            }
        }
    }

    x = jvCharts.getAxisScale('x', xAxisData, container, chart._vars);
    y = jvCharts.getAxisScale('y', yAxisData, container, chart._vars);
    z;

    if (zAxisData && (typeof zAxisData === 'undefined' ? 'undefined' : _typeof(zAxisData)) === 'object' && Object.keys(zAxisData).length > 0) {
        z = jvCharts.getZScale(zAxisData, container, chart._vars);
    }

    svg.append('g').attr('class', 'scatterplot-circles').selectAll('g').data(scatterData).enter().append('circle').attr('clip-path', 'url(#scatter-area)').attr('class', function (d, i) {
        return 'editable editable-scatter scatter-circle-' + chart.currentData.chartData[i][chart.currentData.dataTable.label].replace(/\s/g, '_').replace(/\./g, '_dot_') + ' highlight-class-' + chart.currentData.chartData[i][chart.currentData.dataTable.label].replace(/\s/g, '_').replace(/\./g, '_dot_');
    }).attr('cx', function (d, i) {
        return x(scatterData[i][xAxisData.label]);
    }).attr('cy', function (d, i) {
        return y(scatterData[i][yAxisData.label]);
    }).attr('opacity', 0.8).attr('r', function (d, i) {
        if (dataTable.hasOwnProperty('z')) {
            if (chart._vars.toggleZ && zAxisData && (typeof zAxisData === 'undefined' ? 'undefined' : _typeof(zAxisData)) === 'object' && Object.keys(zAxisData).length > 0 && scatterData[i][dataTable.z]) {
                return z(scatterData[i][dataTable.z]);
            }
        }
        return chart._vars.NODE_MIN_SIZE;
    }).on('mouseover', function (d, i, j) {
        if (chart.showToolTip) {
            this.setAttribute('clip-path', '');
            var tipData = chart.setTipData(d, i);

            //Draw tip line
            chart.tip.generateSimpleTip(tipData, chart.data.dataTable);
            chart.tip.d = d;
            chart.tip.i = i;
        }
    }).on('mousemove', function (d, i) {
        if (chart.showToolTip) {
            if (chart.tip.d === d && chart.tip.i === i) {
                chart.tip.showTip(d3.event);
            } else {
                //Get tip data
                var tipData = chart.setTipData(d, i);
                //Draw tip line
                chart.tip.generateSimpleTip(tipData, chart.data.dataTable);
            }
        }
    }).on('mouseout', function () {
        if (chart.showToolTip) {
            this.setAttribute('clip-path', 'url(#scatter-area)');
            chart.tip.hideTip();
        }
    }).attr('fill', function (d, i) {
        return jvCharts.getColors(colors, i, scatterData[i][dataTable.series]);
    });
}

module.exports = jvCharts;

},{"../jvCharts.js":4}],24:[function(require,module,exports){
'use strict';

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var jvCharts = require('../jvCharts.js');

jvCharts.prototype.singleaxis = {
    paint: paint,
    setData: setData,
    getEventData: getEventData,
    highlightFromEventData: highlightFromEventData
};

jvCharts.prototype.getSingleAxisData = getSingleAxisData;
jvCharts.prototype.getSingleAxisZ = getSingleAxisZ;
jvCharts.prototype.generatePoints = generatePoints;

function isEmpty(value) {
    return typeof value === 'undefined' || value === null;
}

/************************************************ Single Axis Cluster functions ******************************************************/

function setData() {
    var chart = this;
    chart.currentData = { chartData: chart.data.chartData, dataTable: chart.data.dataTable };

    //Set the legend Data to the label from dataTable Keys
    chart.currentData.legendData = [chart.currentData.dataTable.x];
    chart.currentData.xAxisData = chart.getSingleAxisData(chart.currentData.chartData, chart.currentData.dataTable);

    if (chart.currentData.dataTable.hasOwnProperty('size')) {
        chart.currentData.zAxisData = chart.getSingleAxisZ(chart.currentData.chartData);
    }

    chart.currentData.color = 'red'; //chart.setChartColors (chart._vars.color, chart.data.legendData, colors);
}

function getEventData(event) {
    var chart = this;
    if (event.target.classList.value.split('cell-')[1]) {
        return {
            data: _defineProperty({}, chart.currentData.dataTable.label, [event.target.classList.value.split('cell-')[1].replace(/_/g, ' ').replace(/_colon_/g, ':').replace(/_dot_/g, '.')]),
            node: event.target
        };
    } else if (event.target.classList.value.indexOf('editable-svg') > -1) {
        return {
            data: {}
        };
    }
    return {
        data: false
    };
}

function highlightFromEventData(event) {
    var chart = this,
        label = event.data[chart.currentData.dataTable.label][0],
        cssClass = '.highlight-class-' + label.replace(/\s/g, '_').replace(/\./g, '_dot_'),
        node = chart.svg.selectAll(cssClass);

    chart.svg.select('.singleaxis-container').selectAll('circle').attr('stroke', 0).attr('stroke-width', 0);
    //highlight necessary circles
    node.attr('stroke', chart._vars.highlightBorderColor).attr('stroke-width', chart._vars.highlightBorderWidth);
}

function paint() {
    var chart = this,
        splitData = {},
        //If there is a split, the data that has been split
    numVizzes,
        //If there is a split, the number of single axis clusters that are created
    customSize = {},
        //If there is a split, the svg needs to be a custom predefined height
    margin = {
        top: 50,
        left: 100,
        right: 100,
        bottom: 50
    };

    //If there is a split on the viz, run through this logic
    if (chart.data.dataTable.facet) {
        var splitDataKeys = [],
            splitOptionName = chart.data.dataTable.facet.replace(/_/g, ' ');

        //Check to see how many vizzes need to be created because of the split
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = chart.currentData.chartData[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var ele = _step.value;

                var addToKeys = true;
                var _iteratorNormalCompletion4 = true;
                var _didIteratorError4 = false;
                var _iteratorError4 = undefined;

                try {
                    for (var _iterator4 = splitDataKeys[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                        var key = _step4.value;

                        if (ele[splitOptionName] === key) {
                            addToKeys = false;
                            break;
                        }
                    }
                } catch (err) {
                    _didIteratorError4 = true;
                    _iteratorError4 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion4 && _iterator4.return) {
                            _iterator4.return();
                        }
                    } finally {
                        if (_didIteratorError4) {
                            throw _iteratorError4;
                        }
                    }
                }

                if (addToKeys) {
                    splitDataKeys.push(ele[splitOptionName]);
                }
            }

            //Create Object with keys and assign each element of the data array to corresponding object
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                    _iterator.return();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }

        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
            for (var _iterator2 = splitDataKeys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var _key = _step2.value;

                splitData[_key] = []; //Assign empty array to each location
            }

            //Assign Data elements to appropriate place in splitData object
        } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                    _iterator2.return();
                }
            } finally {
                if (_didIteratorError2) {
                    throw _iteratorError2;
                }
            }
        }

        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
            for (var _iterator3 = chart.currentData.chartData[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                var _ele = _step3.value;

                splitData[_ele[splitOptionName]].push(_ele);
            }
        } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion3 && _iterator3.return) {
                    _iterator3.return();
                }
            } finally {
                if (_didIteratorError3) {
                    throw _iteratorError3;
                }
            }
        }

        numVizzes = splitDataKeys.length;
        customSize.height = numVizzes * 300;

        chart.generateSVG(chart.currentData.legendData, margin, customSize);
        chart.generateXAxis(chart.currentData.xAxisData);
        chart.drawGridlines(chart.currentData.xAxisData);

        for (var i = 0; i < numVizzes; i++) {
            chart.generatePoints(splitData[splitDataKeys[i]], i);
        }
    } else {
        //When there isn't a split, the base case
        chart.generateSVG(chart.currentData.legendData, margin, customSize);
        chart.generateXAxis(chart.currentData.xAxisData);
        chart.drawGridlines(chart.currentData.xAxisData);
        chart.generatePoints(chart.currentData.chartData);
    }

    if (typeof chart.currentData.xAxisScale.ticks === 'function') {
        chart.formatXAxisLabels(chart.currentData.xAxisScale.ticks().length);
    } else {
        chart.formatXAxisLabels(chart.currentData.xAxisScale.domain().length);
    }
}

function getSingleAxisZ(data) {
    var chart = this,
        size = chart.currentData.dataTable.size,
        min = data[0][size],
        max = data[0][size];
    //Find min and max of the data
    for (var i = 0; i < data.length; i++) {
        var num = data[i][size];
        if (num > max) {
            max = num;
        } else if (num < min) {
            min = num;
        }
    }

    return {
        'min': min,
        'max': max,
        'label': size
    };
}

function generatePoints(data, yLevel) {
    var chart = this,
        svg = chart.svg,
        width = chart.config.container.width,
        height = chart.config.container.height,
        dataTable = chart.currentData.dataTable,
        xAxisData = chart.currentData.xAxisData,
        zAxisData = chart.currentData.zAxisData,
        container = chart.config.container,
        pointColor = '#609cdb',
        coloredPoint = '#e88a17',
        x = jvCharts.getAxisScale('x', xAxisData, chart.config.container, chart._vars),
        currentAxisHeight,
        simulation,
        cell;

    var SPLIT_CLUSTER_HEIGHT = 300,
        TRANSLATE_SPLIT_CLUSTER = 150;

    //If there's a split, account for the multiple axes
    if (!isEmpty(yLevel)) {
        currentAxisHeight = yLevel * SPLIT_CLUSTER_HEIGHT + TRANSLATE_SPLIT_CLUSTER; //Each height is 100px
    } else {
        currentAxisHeight = height / 2;
    }

    if (!chart._vars.NODE_MIN_SIZE) {
        chart._vars.NODE_MIN_SIZE = 4.5;
    }
    if (!chart._vars.NODE_MAX_SIZE) {
        chart._vars.NODE_MAX_SIZE = 25;
    }

    chart.chartDiv.select('.container').attr('class', 'singleaxis-container');

    //Add a path line through the height of the axis
    if (!isEmpty(yLevel)) {
        svg.append('line').attr('x1', 0).attr('x2', container.width).attr('y1', currentAxisHeight).attr('y2', currentAxisHeight).attr('stroke', 'white').attr('stroke-width', '20px').attr('transform', 'translate(0, ' + TRANSLATE_SPLIT_CLUSTER + ')');

        svg.append('text').datum(data).attr('x', 0).attr('y', currentAxisHeight).text(function (d) {
            if (chart.data.dataTable.facet) {
                d[0][chart.data.dataTable.facet.replace(/_/g, ' ')];
            }
        }).attr('transform', 'translate(-85, 0)');
    }

    simulation = d3.forceSimulation(data).alphaDecay(0.05).force('x', d3.forceX(function (d) {
        return x(d[dataTable.x]);
    }).strength(1)).force('y', d3.forceY(currentAxisHeight)).force('collide', d3.forceCollide(function (d) {
        var norm = void 0,
            val = chart._vars.NODE_MIN_SIZE;
        //Set collision radius equal to the radius of the circle
        if (dataTable.hasOwnProperty('size')) {
            norm = (d[dataTable.size] - zAxisData.min) / (zAxisData.max - zAxisData.min);
            val = (chart._vars.NODE_MAX_SIZE - chart._vars.NODE_MIN_SIZE) * norm + chart._vars.NODE_MIN_SIZE;
        }
        return val;
    }).strength(1)).force('charge', d3.forceManyBody().strength(-6)).stop();

    for (var i = 0; i < 120; ++i) {
        simulation.tick();
    }cell = svg.append('g').attr('class', 'cells').selectAll('g').data(d3.voronoi().extent([[0, 0], [width, height]]).x(function (d) {
        return d.x;
    }).y(function (d) {
        return d.y;
    }).polygons(data)).enter().append('g');

    cell.append('circle').attr('class', function (d) {
        return 'cell-' + d.data[chart.currentData.dataTable.label].replace(/\s/g, '_').replace(/\./g, '_dot_') + ' highlight-class-' + d.data[chart.currentData.dataTable.label].replace(/\s/g, '_').replace(/\./g, '_dot_');;
    }).attr('r', function (d) {
        var val = chart._vars.NODE_MIN_SIZE; //Default node size of 15
        if (dataTable.hasOwnProperty('size') && !isEmpty(d) && d.hasOwnProperty('data')) {
            var norm = (d.data[dataTable.size] - zAxisData.min) / (zAxisData.max - zAxisData.min);
            if (!isNaN(norm)) {
                val = (chart._vars.NODE_MAX_SIZE - chart._vars.NODE_MIN_SIZE) * norm + chart._vars.NODE_MIN_SIZE;
            } else {
                //If there is only 1 node on the chart
                val = chart._vars.NODE_MIN_SIZE;
            }
        } else if (isEmpty(d)) {
            val = 0; //Don't display undefined nodes
        }
        return val;
    }).attr('cx', function (d) {
        return isEmpty(d) ? 0 : d.data.x;
    }).attr('cy', function (d) {
        return isEmpty(d) ? 0 : d.data.y;
    }).attr('fill', function (d) {
        if (!isEmpty(d) && d.data[chart._vars.colorDataCategory] === chart._vars.colorDataInstance) {
            return coloredPoint;
        }
        return pointColor;
    }).attr('opacity', 0.8).attr('stroke', 'black').attr('stroke-width', 1).on('mouseover', function (d, i) {
        if (chart.showToolTip) {
            var tipData = chart.setTipData(d, i);
            chart.tip.generateSimpleTip(tipData, dataTable);
            d3.select(this).attr('fill', chart._vars.singleAxisFillHoverColor);
            chart.tip.d = d;
            chart.tip.i = i;
        }
    }).on('mousemove', function (d, i) {
        if (chart.showToolTip) {
            if (chart.tip.d === d && chart.tip.i === i) {
                chart.tip.showTip(d3.event);
            } else {
                //Get tip data
                var tipData = chart.setTipData(d, i);
                //Draw tip line
                chart.tip.generateSimpleTip(tipData, chart.data.dataTable);
            }
        }
    }).on('mouseout', function () {
        if (chart.showToolTip) {
            chart.tip.hideTip();
        }
        d3.select(this).attr('fill', function (d) {
            if (!isEmpty(d) && d.data[chart._vars.colorDataCategory] === chart._vars.colorDataInstance) {
                return coloredPoint;
            }
            return pointColor;
        });
    });
}

function getSingleAxisData(data, dataTable) {
    var chart = this,
        label,
        dataType,
        min,
        max,
        values = [];

    if (dataTable) {
        if (dataTable.hasOwnProperty('x')) {
            label = dataTable.x;
        }
    }

    dataType = 'NUMBER';

    var _iteratorNormalCompletion5 = true;
    var _didIteratorError5 = false;
    var _iteratorError5 = undefined;

    try {
        for (var _iterator5 = data[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
            var ele = _step5.value;

            values.push(ele[dataTable.x]);
        }
    } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion5 && _iterator5.return) {
                _iterator5.return();
            }
        } finally {
            if (_didIteratorError5) {
                throw _iteratorError5;
            }
        }
    }

    min = Math.min.apply(null, values);
    max = Math.max.apply(null, values);

    //Add a 10% buffer to both sides
    min = Math.floor(min - (max - min) * 0.10);
    max = Math.ceil(max + (max - min) * 0.10);

    //For axis min/max widget
    if (chart._vars.hasOwnProperty('xMin') && chart._vars.xMin !== 'none') {
        min = chart.options.xMin;
    }
    if (chart._vars.hasOwnProperty('xMax') && chart._vars.xMax !== 'none') {
        max = chart._vars.xMax;
    }

    return {
        'label': label,
        'values': values,
        'dataType': dataType,
        'min': min,
        'max': max
    };
}

module.exports = jvCharts;

},{"../jvCharts.js":4}],25:[function(require,module,exports){
'use strict';

var jvCharts = require('../jvCharts.js');

jvCharts.prototype.sunburst = {
    paint: paint,
    setData: setData,
    getEventData: getEventData
};

jvCharts.prototype.generateSunburst = generateSunburst;

/************************************************ Sunburst functions ******************************************************/

/**setSunburstChartData
 *  gets sunburst data and adds it to the chart object
 *
 * @params data, dataTable, colors
 */
function setData() {
    var chart = this;
    if (!chart.data.chartData.hasOwnProperty('children')) {
        chart.data.chartData = jvCharts.convertTableToTree(chart.data.chartData, chart.data.dataTable, true);
    }

    chart.data.color = chart.colors;
}

function getEventData() {
    return {};
}

function paint() {
    var chart = this,
        sunburstMargins = {
        top: 15,
        right: 15,
        bottom: 15,
        left: 15
    };

    chart._vars.color = chart.data.color;
    chart.currentData = chart.data;

    //Generate SVG-legend data is used to determine the size of the bottom margin (set to null for no legend)
    chart.generateSVG(null, sunburstMargins);
    //chart.generateLegend(chart.currentData.legendData, 'generateSunburst');
    chart.generateSunburst();
}

/**generateSunburst
 *
 * paints the sunburst on the chart
 * @params sunburstData
 */
function generateSunburst() {
    var chart = this,
        svg = chart.svg,
        vis,
        text,
        container = chart.config.container,
        width = container.width,
        height = container.height,
        radius = Math.min(width, height) / 2 - 10,
        x = d3.scaleLinear().range([0, 2 * Math.PI]),
        y = d3.scaleSqrt().range([0, radius]),
        color = d3.scaleOrdinal().range(chart.data.color.map(function (c) {
        c = d3.rgb(c);
        c.opacity = 1;
        return c;
    })),
        partition = d3.partition(),
        arc = d3.arc().startAngle(function (d) {
        return Math.max(0, Math.min(2 * Math.PI, x(d.x0)));
    }).endAngle(function (d) {
        return Math.max(0, Math.min(2 * Math.PI, x(d.x1)));
    }).innerRadius(function (d) {
        return Math.max(0, y(d.y0));
    }).outerRadius(function (d) {
        return Math.max(0, y(d.y1));
    }),


    //assigns the data to a hierarchy using parent-child relationships
    root = d3.hierarchy(chart.currentData.chartData, function (d) {
        return d.children;
    });

    root.sum(function (d) {
        return d.value;
    });

    vis = svg.append('g').attr('class', 'sunburst').attr('width', width).attr('height', height).attr('transform', 'translate(' + width / 2 + ',' + height / 2 + ')');

    vis.selectAll('path').data(partition(root).descendants()).enter().append('g').attr('class', 'node');

    vis.selectAll('.node').append('path').attr('stroke', 'white').attr('d', arc).style('fill', function (d) {
        if (d.data.name === 'root') {
            d.color = chart._vars.backgroundColor;
            return chart._vars.backgroundColor;
        }
        d.color = color(d.data.name);
        return color(d.data.name);
    }).on('mouseover', function (d, i) {
        if (chart.showToolTip) {
            var tipData = chart.setTipData(d, i);

            //Draw tip line
            chart.tip.generateSimpleTip(tipData, chart.data.dataTable);
            chart.tip.d = d;
            chart.tip.i = i;
        }
    }).on('mousemove', function (d, i) {
        if (chart.showToolTip) {
            if (chart.tip.d === d && chart.tip.i === i) {
                chart.tip.showTip(d3.event);
            } else {
                //Get tip data
                var tipData = chart.setTipData(d, i);
                //Draw tip line
                chart.tip.generateSimpleTip(tipData, chart.data.dataTable);
            }
        }
    }).on('click', click).on('mouseout', function () {
        chart.tip.hideTip();
    });

    if (chart._vars.displayValues) {
        text = vis.selectAll('.node').append('text').attr('transform', function (d) {
            return 'rotate(' + computeTextRotation(d) + ')';
        }).attr('x', function (d) {
            return y(d.y0);
        }).attr('dx', '6') //margin
        .attr('dy', '.35em') //vertical-align
        .text(function (d) {
            if (Number(d.data.value) > 0) {
                return d.data.name === 'root' ? '' : d.data.name;
            }
            return '';
        });
    }

    function click(d) {
        //fade out all text elements
        if (chart._vars.displayValues) {
            text.transition().attr('opacity', 0);
        }

        vis.transition().duration(750).tween('scale', function () {
            var xd = d3.interpolate(x.domain(), [d.x0, d.x1]),
                yd = d3.interpolate(y.domain(), [d.y0, 1]),
                yr = d3.interpolate(y.range(), [d.y0 ? 20 : 0, radius]);

            return function (t) {
                x.domain(xd(t));y.domain(yd(t)).range(yr(t));
            };
        }).selectAll('path').attrTween('d', function (ele) {
            return function () {
                return arc(ele);
            };
        }).on('end', function (e, i) {
            if (chart._vars.displayValues) {
                //check if the animated element's data e lies within the visible angle span given in d
                if (e.x0 > d.x0 && e.x0 < d.x1) {
                    //get a selection of the associated text element
                    var arcText = d3.select(this.parentNode).select('text');
                    //fade in the text element and recalculate positions
                    arcText.transition().duration(750).attr('opacity', 1).attr('class', 'visible').attr('transform', function () {
                        return 'rotate(' + computeTextRotation(e) + ')';
                    }).attr('x', function (ele) {
                        return y(ele.y0);
                    }).text(function (ele) {
                        return ele.data.name === 'root' ? '' : ele.data.name;
                    });
                }
            }
        });
    }

    function computeTextRotation(d) {
        return (x((d.x0 + d.x1) / 2) - Math.PI / 2) / Math.PI * 180;
    }
}

module.exports = jvCharts;

},{"../jvCharts.js":4}],26:[function(require,module,exports){
'use strict';

var jvCharts = require('../jvCharts.js');

jvCharts.prototype.treemap = {
    paint: paint,
    setData: setData,
    getEventData: getEventData
};

jvCharts.prototype.generateTreeMap = generateTreeMap;
/************************************************ TreeMap functions ******************************************************/

/**setTreeMapData
 *  gets treemap data and adds it to the chart object
 *
 * @params data, dataTable, colors
 */
function setData() {
    var chart = this;
    if (!chart.data.chartData.hasOwnProperty('children')) {
        chart.data.chartData = jvCharts.convertTableToTreemap(chart.data.chartData, chart.data.dataTable);
    }
    chart.data.legendData = setTreeMapLegendData(chart.data);
    //define color object for chartData
    chart.data.color = jvCharts.setChartColors(chart._vars.color, chart.data.legendData, chart.colors);
}

function getEventData() {
    return {};
}

/**setTreeMapLegendData
 *  gets legend info from chart Data
 *
 * @params data, type
 * @returns [] of legend text
 */
function setTreeMapLegendData(data) {
    var legendArray = [],
        series = data.dataTable.series;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = data.chartData.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var childEle = _step.value;

            if (legendArray.indexOf(childEle[series]) === -1) {
                legendArray.push(childEle[series]);
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    return legendArray;
}

function paint() {
    var chart = this,
        treeMapMargins = {
        top: 45,
        right: 50,
        left: 50,
        bottom: 130
    };
    chart._vars.color = chart.data.color;
    chart.currentData = chart.data;

    //Generate SVG-legend data is used to determine the size of the bottom margin (set to null for no legend)
    chart.generateSVG(null, treeMapMargins);
    chart.generateLegend(chart.currentData.legendData, 'generateTreeMap');
    chart.generateTreeMap(chart.currentData);
}

/**generateTreeMap
 *
 * paints the treemap on the chart
 * @params treeMapData
 */
function generateTreeMap(treeMapData) {
    var chart = this,
        svg = chart.svg,
        colors = treeMapData.color,
        container = chart.config.container,
        relationMap = chart.data.dataTable,
        data = chart.currentData.chartData,
        dataHeaders,
        legendElementToggleArray,
        treeMapDataFiltered,
        root,
        treemapFunc,
        node,
        textNode;

    if (!chart._vars.legendHeaders) {
        chart._vars.legendHeaders = chart.currentData.legendData;
    }

    dataHeaders = chart._vars.legendHeaders;
    legendElementToggleArray = jvCharts.getLegendElementToggleArray(dataHeaders, chart.data.legendData);

    if (legendElementToggleArray) {
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
            for (var _iterator2 = data.children[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var childEle = _step2.value;
                var _iteratorNormalCompletion3 = true;
                var _didIteratorError3 = false;
                var _iteratorError3 = undefined;

                try {
                    for (var _iterator3 = legendElementToggleArray[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                        var legendEle = _step3.value;

                        if (legendEle.element === childEle[relationMap.series] && legendEle.toggle === false) {
                            childEle.show = false;
                        }
                    }
                } catch (err) {
                    _didIteratorError3 = true;
                    _iteratorError3 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion3 && _iterator3.return) {
                            _iterator3.return();
                        }
                    } finally {
                        if (_didIteratorError3) {
                            throw _iteratorError3;
                        }
                    }
                }
            }
        } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                    _iterator2.return();
                }
            } finally {
                if (_didIteratorError2) {
                    throw _iteratorError2;
                }
            }
        }
    }

    treeMapDataFiltered = {
        Parent: 'Top Level',
        children: []
    };

    var _iteratorNormalCompletion4 = true;
    var _didIteratorError4 = false;
    var _iteratorError4 = undefined;

    try {
        for (var _iterator4 = data.children[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var _childEle = _step4.value;

            if (_childEle.show !== false) {
                treeMapDataFiltered.children.push(_childEle);
            }
        }

        //assigns the data to a hierarchy using parent-child relationships
    } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion4 && _iterator4.return) {
                _iterator4.return();
            }
        } finally {
            if (_didIteratorError4) {
                throw _iteratorError4;
            }
        }
    }

    root = d3.hierarchy(treeMapDataFiltered, function (d) {
        return d.children;
    });

    treemapFunc = d3.treemap().size([container.width, container.height]).padding(2);

    treemapFunc(root.sum(function (d) {
        return d[relationMap.size];
    }).sort(function (a, b) {
        return b.height - a.height || b.value - a.value;
    })).descendants();

    //Remove existing bars from page
    svg.selectAll('g.treemap').remove();
    svg.append('g').attr('class', 'treemap');

    node = svg.select('.treemap').selectAll('g').data(root.leaves()).enter().append('g').attr('transform', 'translate(0,0)');

    node.append('rect').attr('x', function (d) {
        return d.x0 + 'px';
    }).attr('y', function (d) {
        return d.y0 + 'px';
    }).attr('width', function (d) {
        return d.x1 - d.x0 + 'px';
    }).attr('height', function (d) {
        return d.y1 - d.y0 + 'px';
    }).attr('fill', function (d, i) {
        return jvCharts.getColors(colors, i, d.data[relationMap.series]);
    }).attr('fill-opacity', 0.8).attr('stroke', chart._vars.white).attr('stroke-width', chart._vars.strokeWidth).on('mouseover', function (d, i) {
        //Get tip data
        var tipData = chart.setTipData(d.data, i);
        //Draw tip line
        chart.tip.generateSimpleTip(tipData, chart.data.dataTable);
        chart.tip.d = d;
        chart.tip.i = i;
    }).on('mousemove', function (d, i) {
        if (chart.showToolTip) {
            if (chart.tip.d === d && chart.tip.i === i) {
                chart.tip.showTip(d3.event);
            } else {
                //Get tip data
                var tipData = chart.setTipData(d, i);
                //Draw tip line
                chart.tip.generateSimpleTip(tipData, chart.data.dataTable);
            }
        }
    }).on('mouseout', function () {
        chart.tip.hideTip();
    });

    node.append('text').attr('x', function (d) {
        return d.x0 + 'px';
    }).attr('y', function (d) {
        return d.y0 + 'px';
    }).attr('width', function (d) {
        return d.x1 - d.x0 + 'px';
    }).attr('height', function (d) {
        return d.y1 - d.y0 + 'px';
    }).attr('transform', 'translate(3, 18)').text(function (d) {
        if (d.dy !== 0 && !d.children) {
            return d.data[relationMap.label];
        }
        return null;
    });

    /*Don't display text if text is wider than rect */
    textNode = node.selectAll('text');
    textNode.attr('style', function (d) {
        var bbox = this.getBBox();
        if (bbox.width >= d.x1 - d.x0 - 5 || bbox.height >= d.y1 - d.y0 - 5) {
            return 'display:none';
        }
        return '';
    });
}
module.exports = jvCharts;

},{"../jvCharts.js":4}],27:[function(require,module,exports){
'use strict';

var jvCharts = require('../jvCharts.js');

jvCharts.prototype.cloud = {
    paint: paint,
    setData: setData,
    getEventData: getEventData
};

jvCharts.prototype.generateCloud = generateCloud;

/************************************************ Cloud functions ******************************************************/

/**setCloudData
 *  gets cloud data and adds it to the chart object
 *
 * @params data, dataTable, colors
 */
function setData() {
    var chart = this;
    //define color object for chartData
    chart.data.color = chart.colors;
}

function getEventData() {
    return {};
}

/**setCloudLegendData
 *  gets legend info from chart Data
 *
 * @params data, type
 * @returns [] of legend text
 */
function setCloudLegendData(data) {
    var legendArray = [];
    for (var i = 0; i < data.chartData.children.length; i++) {
        if (legendArray.indexOf(data.chartData.children[i][data.dataTable.series]) == -1) {
            legendArray.push(data.chartData.children[i][data.dataTable.series]);
        }
    }
    return legendArray;
}

function paint() {
    var chart = this;
    if (!chart.smallerFontRepaint) {
        chart._vars.fontSizeMax = 80;
        chart.currentData = chart.data;
    } else {
        chart.currentData = JSON.parse(JSON.stringify(chart.data));
    }

    chart._vars.color = chart.data.color;

    var cloudMargins = {
        top: 15,
        right: 15,
        left: 15,
        bottom: 15
    };

    //Generate SVG-legend data is used to determine the size of the bottom margin (set to null for no legend)
    chart.generateSVG(null, cloudMargins);
    // chart.generateLegend(chart.currentData.legendData, 'generateCloud');
    chart.generateCloud(chart.currentData);
};

/** generateCloud
 *
 * paints the cloud  on the chart
 * @params cloud Data
 */
function generateCloud(cloudData) {
    var chart = this,
        svg = chart.svg,
        container = chart.config.container,
        allFilterList = [],
        relationMap = chart.data.dataTable,
        width = container.width,
        height = container.height,
        margin = chart.config.margin,
        min,
        max;

    var categories = d3.keys(d3.nest().key(function (d) {
        if (!min && !max) {
            min = d[relationMap.value];
            max = d[relationMap.value];
        } else {
            if (d[relationMap.value] > max) {
                max = d[relationMap.value];
            }
            if (d[relationMap.value] < min) {
                min = d[relationMap.value];
            }
        }

        return d[relationMap.value];
    }).map(cloudData.chartData));

    if (!chart._vars.fontSizeMax) {
        chart._vars.fontSizeMax = 80;
    }

    var color = d3.scaleOrdinal().range(chart.data.color.map(function (c) {
        c = d3.rgb(c);c.opacity = 0.8;return c;
    }));

    var fontSize = d3.scalePow().exponent(5).domain([0, 1]).range([10, chart._vars.fontSizeMax]);
    chart.smallerFontRepaint = false;
    var layout = d3.layout.cloud().timeInterval(10).size([width, height]).words(cloudData.chartData).rotate(function (d) {
        return 0;
    }).font('Roboto').fontSize(function (d, i) {
        return fontSize(max - min !== 0 ? (d[relationMap.value] - min) / (max - min) : 0);
    }).repaintWithSmallerFont(function () {
        if (chart._vars.fontSizeMax > 10) {
            chart._vars.fontSizeMax -= 5;
            chart.smallerFontRepaint = true;
            paint(chart);
        }
    }).text(function (d) {
        return d[relationMap.label];
    }).spiral("archimedean").on("end", draw).start();

    var wordcloud = svg.append("g").attr('class', 'wordcloud').attr("width", width + margin.left + margin.right).attr("height", height + margin.top + margin.bottom).attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");

    function draw(words) {
        if (chart.smallerFontRepaint) {
            return;
        }
        wordcloud.selectAll("text").data(cloudData.chartData).enter().append("text").attr('class', 'word').style("font-size", function (d) {
            return d.size + "px";
        }).style("font-family", function (d) {
            return d.font;
        }).style("fill", function (d) {
            return color(d[relationMap.value]);
        }).attr("text-anchor", "middle").text(function (d) {
            return d.text;
        }).on("mouseover", function (d, i) {
            //Get tip data
            var tipData = chart.setTipData(d, i);
            tipData.color = color(d[relationMap.value]);

            //Draw tip
            chart.tip.generateSimpleTip(tipData, chart.data.dataTable);
            chart.tip.d = d;
            chart.tip.i = i;
        }).on('mousemove', function (d, i) {
            if (chart.showToolTip) {
                if (chart.tip.d === d && chart.tip.i === i) {
                    chart.tip.showTip(d3.event);
                } else {
                    //Get tip data
                    var tipData = chart.setTipData(d, i);
                    //Draw tip line
                    chart.tip.generateSimpleTip(tipData, chart.data.dataTable);
                }
            }
        }).on("mouseout", function (d) {
            chart.tip.hideTip();
        }).transition().duration("1000").attr("transform", function (d) {
            return "translate(" + [d.x, d.y] + ")rotate(" + d.rotate + ")";
        });
    }
};

module.exports = jvCharts;

},{"../jvCharts.js":4}]},{},[2])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmNcXGVkaXRPcHRpb25zVGVtcGxhdGUuanMiLCJzcmNcXGp2LmpzIiwic3JjXFxqdkJydXNoLmpzIiwic3JjXFxqdkNoYXJ0cy5qcyIsInNyY1xcanZDb21tZW50LmpzIiwic3JjXFxqdkVkaXQuanMiLCJzcmNcXGp2RXZlbnRzLmpzIiwic3JjXFxqdlNlbGVjdC5qcyIsInNyY1xcanZUaXAuanMiLCJzcmNcXGp2VmFycy5qcyIsInNyY1xcdmlzdWFsc1xcanZBcmVhLmpzIiwic3JjXFx2aXN1YWxzXFxqdkJhci5qcyIsInNyY1xcdmlzdWFsc1xcanZCb3hXaGlza2VyLmpzIiwic3JjXFx2aXN1YWxzXFxqdkJ1YmJsZS5qcyIsInNyY1xcdmlzdWFsc1xcanZDbHVzdGVyZ3JhbS5qcyIsInNyY1xcdmlzdWFsc1xcanZHYW50dC5qcyIsInNyY1xcdmlzdWFsc1xcanZIZWF0bWFwLmpzIiwic3JjXFx2aXN1YWxzXFxqdkxpbmUuanMiLCJzcmNcXHZpc3VhbHNcXGp2UGFjay5qcyIsInNyY1xcdmlzdWFsc1xcanZQaWUuanMiLCJzcmNcXHZpc3VhbHNcXGp2UmFkaWFsLmpzIiwic3JjXFx2aXN1YWxzXFxqdlNhbmtleS5qcyIsInNyY1xcdmlzdWFsc1xcanZTY2F0dGVyLmpzIiwic3JjXFx2aXN1YWxzXFxqdlNpbmdsZUF4aXMuanMiLCJzcmNcXHZpc3VhbHNcXGp2U3VuYnVyc3QuanMiLCJzcmNcXHZpc3VhbHNcXGp2VHJlZW1hcC5qcyIsInNyY1xcdmlzdWFsc1xcanZXb3JkQ2xvdWQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7OztBQ0FBLElBQUksZ3ZJQUFKOztBQTRHQSxPQUFPLE9BQVAsR0FBaUIsSUFBakI7OztBQzVHQTtBQUNBOztBQUNBLFFBQVEsYUFBUjtBQUNBLFFBQVEsZUFBUjtBQUNBLFFBQVEsWUFBUjtBQUNBLFFBQVEsY0FBUjtBQUNBLFFBQVEsZ0JB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QixDQUFwQixDQUFkO0FBQ0E7QUFDQSwwQkFBTSxHQUFOLENBQVUsaUJBQVYsQ0FBNEIsT0FBNUIsRUFBcUMsTUFBTSxJQUFOLENBQVcsU0FBaEQ7QUFDSDtBQUNKO0FBQ0osU0FwQ0wsRUFxQ0ssRUFyQ0wsQ0FxQ1EsVUFyQ1IsRUFxQ29CLFVBQVUsQ0FBVixFQUFhO0FBQ3pCLGtCQUFNLEdBQU4sQ0FBVSxPQUFWO0FBQ0gsU0F2Q0wsRUF3Q0ssVUF4Q0wsR0F3Q2tCLFFBeENsQixDQXdDMkIsTUF4QzNCLEVBeUNLLElBekNMLENBeUNVLFdBekNWLEVBeUN1QixVQUFVLENBQVYsRUFBYTtBQUFFLG1CQUFPLGVBQWUsQ0FBQyxFQUFFLENBQUgsRUFBTSxFQUFFLENBQVIsQ0FBZixHQUE0QixVQUE1QixHQUF5QyxFQUFFLE1BQTNDLEdBQW9ELEdBQTNEO0FBQWlFLFNBekN2RztBQTBDSDtBQUVKOztBQUVELE9BQU8sT0FBUCxHQUFpQixRQUFqQiIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJ2YXIgaHRtbCA9IGA8IS0tVG9wIHRpdGxlIGJhciBvZiBlZGl0IHBvcHVwLS0+XHJcbjxkaXYgY2xhc3M9J3RpdGxlJz5cclxuICAgIDxkaXYgY2xhc3M9XCJqdi1pbmxpbmVcIj5cclxuICAgICAgICA8Yj5FZGl0IE9wdGlvbnM8ZGl2IGlkPVwiZWRpdC1vcHRpb24tZWxlbWVudFwiIGNsYXNzPVwianYtaW5saW5lXCIgc3R5bGU9XCJ2aXNpYmlsaXR5OiBoaWRkZW47XCI+PC9kaXY+OjwvYj5cclxuICAgIDwvZGl2PlxyXG5cclxuICAgIDxkaXYgaWQ9J2V4aXRFZGl0TW9kZScgY2xhc3M9J2p2LXB1bGwtcmlnaHQganYtcG9pbnRlcic+XHJcbiAgICAgICAgPGkgY2xhc3M9J2ZhIGZhLXRpbWVzJz48L2k+XHJcbiAgICA8L2Rpdj5cclxuPC9kaXY+XHJcblxyXG48IS0tTGluZSBkaXZpZGluZyB0b3AgYmFyIHdpdGggZm9ybSBvcHRpb25zIGJlbG93LS0+XHJcbjxociBzdHlsZT0nbWFyZ2luOjNweCAwIDNweCAwOycvPlxyXG5cclxuPCEtLUZvcm0gT3B0aW9ucy0tPlxyXG48ZGl2IGlkPVwiZm9ybScrY2hhcnQuY29uZmlnLm5hbWUrJ1wiPlxyXG5cclxuICAgIDwhLS1OdW1iZXIgZm9ybWF0dGluZyBvcHRpb25zLS0+XHJcbiAgICA8ZGl2IGNsYXNzPVwianYtZnVsbC13aWR0aCBlZGl0YWJsZS1udW0tZm9ybWF0XCIgc3R5bGU9XCJkaXNwbGF5OiBub25lO1wiPlxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJqdi1lZGl0LW1vZGUtaW5wdXRcIj5OdW1iZXIgRm9ybWF0OlxyXG4gICAgICAgICAgICA8c2VsZWN0IGlkPVwiZWRpdGFibGUtbnVtLWZvcm1hdFwiPlxyXG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIlwiPi0tU2VsZWN0IE9wdGlvbi0tPC9vcHRpb24+XHJcbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiY3VycmVuY3lcIj5DdXJyZW5jeTwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cImZpeGVkQ3VycmVuY3lcIj5GaXhlZCBQb2ludCBDdXJyZW5jeTwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInBlcmNlbnRcIj5QZXJjZW50PC9vcHRpb24+XHJcbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwibWlsbGlvbnNcIj5NaWxsaW9uczwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cImNvbW1hc1wiPkNvbW1hczwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIm5vbmVcIj5Ob25lPC9vcHRpb24+XHJcbiAgICAgICAgICAgIDwvc2VsZWN0PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDxici8+XHJcbiAgICA8L2Rpdj5cclxuXHJcbiAgICA8IS0tVGV4dCBmb3JtYXR0aW5nIG9wdGlvbnMtLT5cclxuICAgIDxkaXYgY2xhc3M9XCJlZGl0YWJsZS10ZXh0LXNpemUtYnV0dG9ucyBqdi1jZW50ZXIgdG9wQmFyT3B0aW9uIGluY3JlYXNlZm9udCBqdi1wb2ludGVyXCIgc3R5bGU9XCJkaXNwbGF5OiBub25lO1wiPlxyXG4gICAgICAgIDxidXR0b24gaWQ9J2RlY3JlYXNlRm9udFNpemUnIHRpdGxlPSdEZWNyZWFzZSB0aGUgZm9udCBzaXplJyBjbGFzcz0ndG9wYmFyLWJ1dHRvbiBmb250IGp2LWJ1dHRvbiBqdi1wb2ludGVyJz48aSBjbGFzcz0nZmEgZmEtZm9udCc+PC9pPjxpIGNsYXNzPSdmYSBmYS1sb25nLWFycm93LWRvd24nPjwvaT48L2J1dHRvbj5cclxuICAgICAgICA8YnV0dG9uIGlkPSdpbmNyZWFzZUZvbnRTaXplJyB0aXRsZT0nSW5jcmVhc2UgdGhlIGZvbnQgc2l6ZScgY2xhc3M9J3RvcGJhci1idXR0b24gZm9udCBqdi1idXR0b24ganYtcG9pbnRlcic+PGkgY2xhc3M9J2ZhIGZhLWZvbnQnPjwvaT48aSBjbGFzcz0nZmEgZmEtbG9uZy1hcnJvdy11cCc+PC9pPjwvYnV0dG9uPlxyXG4gICAgPC9kaXY+XHJcblxyXG5cclxuICAgIDxkaXYgY2xhc3M9XCJqdi1mdWxsLXdpZHRoIGVkaXRhYmxlLXRleHQtY29sb3JcIiBzdHlsZT1cImRpc3BsYXk6IG5vbmU7XCI+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cImp2LWVkaXQtbW9kZS1pbnB1dFwiPlRleHQgQ29sb3I6XHJcbiAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwiY29sb3JcIiBpZD1cImVkaXRhYmxlLXRleHQtY29sb3JcIiB2YWx1ZT1cIiMwMDAwMDBcIj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8YnIvPlxyXG4gICAgPC9kaXY+XHJcblxyXG4gICAgPGRpdiBjbGFzcz1cImp2LWZ1bGwtd2lkdGggZWRpdGFibGUtdGV4dC1zaXplXCIgc3R5bGU9XCJkaXNwbGF5OiBub25lO1wiPlxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJqdi1lZGl0LW1vZGUtaW5wdXRcIj5UZXh0IFNpemU6XHJcbiAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwibnVtYmVyXCIgaWQ9XCJlZGl0YWJsZS10ZXh0LXNpemVcIiBtaW49XCIwXCIgbWF4PVwiMzBcIiB2YWx1ZT1cIjEyXCIgc3RlcD1cIjAuNVwiPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDxici8+XHJcbiAgICA8L2Rpdj5cclxuXHJcbiAgICA8ZGl2IGNsYXNzPVwianYtZnVsbC13aWR0aCBlZGl0YWJsZS1jb250ZW50XCIgc3R5bGU9XCJkaXNwbGF5OiBub25lO1wiPlxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJqdi1lZGl0LW1vZGUtaW5wdXRcIj5UZXh0OlxyXG4gICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBpZD1cImVkaXRhYmxlLWNvbnRlbnRcIiBwbGFjZWhvbGRlcj1cIkVudGVyIHRleHQgaGVyZVwiPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDxici8+XHJcbiAgICA8L2Rpdj5cclxuXHJcbiAgICA8IS0tYmFyIGNoYXJ0IGZvcm1hdHRpbmctLT5cclxuICAgIDxkaXYgY2xhc3M9XCJqdi1mdWxsLXdpZHRoIGVkaXRhYmxlLWJhclwiIHN0eWxlPVwiZGlzcGxheTogbm9uZTtcIj5cclxuICAgICAgICA8ZGl2IGNsYXNzPVwianYtZWRpdC1tb2RlLWlucHV0XCI+QmFyIENvbG9yOlxyXG4gICAgICAgICAgICA8aW5wdXQgdHlwZT1cImNvbG9yXCIgaWQ9XCJlZGl0YWJsZS1iYXJcIiB2YWx1ZT1cIiNhYWFhYWFcIj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8YnIvPlxyXG4gICAgPC9kaXY+XHJcblxyXG4gICAgPCEtLXBpZSBjaGFydCBmb3JtYXR0aW5nLS0+XHJcbiAgICA8ZGl2IGNsYXNzPVwianYtZnVsbC13aWR0aCBlZGl0YWJsZS1waWVcIiBzdHlsZT1cImRpc3BsYXk6IG5vbmU7XCI+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cImp2LWVkaXQtbW9kZS1pbnB1dFwiPlBpZSBTbGljZSBDb2xvcjpcclxuICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJjb2xvclwiIGlkPVwiZWRpdGFibGUtcGllXCIgdmFsdWU9XCIjYWFhYWFhXCI+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPGJyLz5cclxuICAgIDwvZGl2PlxyXG5cclxuICAgIDwhLS1zY2F0dGVyIHBsb3QgZm9ybWF0dGluZy0tPlxyXG4gICAgPGRpdiBjbGFzcz1cImp2LWZ1bGwtd2lkdGggZWRpdGFibGUtc2NhdHRlclwiIHN0eWxlPVwiZGlzcGxheTogbm9uZTtcIj5cclxuICAgICAgICA8ZGl2IGNsYXNzPVwianYtZWRpdC1tb2RlLWlucHV0XCI+U2NhdHRlciBDaXJjbGUgQ29sb3I6XHJcbiAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwiY29sb3JcIiBpZD1cImVkaXRhYmxlLXNjYXR0ZXJcIiB2YWx1ZT1cIiNhYWFhYWFcIj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8YnIvPlxyXG4gICAgPC9kaXY+XHJcblxyXG4gICAgPCEtLWJ1YmJsZSBjaGFydCBmb3JtYXR0aW5nLS0+XHJcbiAgICA8ZGl2IGNsYXNzPVwianYtZnVsbC13aWR0aCBlZGl0YWJsZS1idWJibGVcIiBzdHlsZT1cImRpc3BsYXk6IG5vbmU7XCI+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cImp2LWVkaXQtbW9kZS1pbnB1dFwiPkJ1YmJsZSBDb2xvcjpcclxuICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJjb2xvclwiIGlkPVwiZWRpdGFibGUtYnViYmxlXCIgdmFsdWU9XCIjYWFhYWFhXCI+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPGJyLz5cclxuICAgIDwvZGl2PlxyXG5cclxuICAgIDwhLS1ib3ggYW5kIHdoaXNrZXIgcGxvdCBmb3JtYXR0aW5nLS0+XHJcbiAgICA8ZGl2IGNsYXNzPVwianYtZnVsbC13aWR0aCBlZGl0YWJsZS1ib3hcIiBzdHlsZT1cImRpc3BsYXk6IG5vbmU7XCI+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cImp2LWVkaXQtbW9kZS1pbnB1dFwiPkJveCBDb2xvcjpcclxuICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJjb2xvclwiIGlkPVwiZWRpdGFibGUtYm94XCIgdmFsdWU9XCIjYWFhYWFhXCI+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPGJyLz5cclxuICAgIDwvZGl2PlxyXG5cclxuICAgIDwhLS1TdWJtaXQgYnV0dG9uLS0+XHJcbiAgICA8ZGl2IGNsYXNzPVwiZWRpdGFibGUtZGVmYXVsdC1hbmQtYXBwbHlcIj5cclxuICAgICAgICA8YnV0dG9uIGlkPVwic3VibWl0RWRpdE1vZGVEZWZhdWx0XCIgY2xhc3M9XCJqdi1idXR0b24ganYtcHVsbC1sZWZ0XCI+RGVmYXVsdDwvYnV0dG9uPlxyXG4gICAgICAgIDxidXR0b24gaWQ9XCJzdWJtaXRFZGl0TW9kZVwiIGNsYXNzPVwianYtYnV0dG9uIGp2LWJ1dHRvbi1ncmVlbiBqdi1wdWxsLXJpZ2h0XCI+QXBwbHk8L2J1dHRvbj5cclxuICAgIDwvZGl2PlxyXG48L2Rpdj5gO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBodG1sOyIsIid1c2Ugc3RyaWN0JztcclxuLy9hZGQgYWxsIHJlcXVpcmVkIGZpbGVzXHJcbnJlcXVpcmUoJy4vanZWYXJzLmpzJyk7XHJcbnJlcXVpcmUoJy4vanZFdmVudHMuanMnKTtcclxucmVxdWlyZSgnLi9qdlRpcC5qcycpO1xyXG5yZXF1aXJlKCcuL2p2QnJ1c2guanMnKTtcclxucmVxdWlyZSgnLi9qdkNvbW1lbnQuanMnKTtcclxucmVxdWlyZSgnLi9qdkVkaXQuanMnKTtcclxucmVxdWlyZSgnLi92aXN1YWxzL2p2QmFyLmpzJyk7XHJcbnJlcXVpcmUoJy4vdmlzdWFscy9qdlBpZS5qcycpO1xyXG5yZXF1aXJlKCcuL3Zpc3VhbHMvanZMaW5lLmpzJyk7XHJcbnJlcXVpcmUoJy4vdmlzdWFscy9qdlNjYXR0ZXIuanMnKTtcclxucmVxdWlyZSgnLi92aXN1YWxzL2p2QXJlYS5qcycpO1xyXG5yZXF1aXJlKCcuL3Zpc3VhbHMvanZHYW50dC5qcycpO1xyXG5yZXF1aXJlKCcuL3Zpc3VhbHMvanZIZWF0bWFwLmpzJyk7XHJcbnJlcXVpcmUoJy4vdmlzdWFscy9qdlBhY2suanMnKTtcclxucmVxdWlyZSgnLi92aXN1YWxzL2p2UmFkaWFsLmpzJyk7XHJcbnJlcXVpcmUoJy4vdmlzdWFscy9qdlNhbmtleS5qcycpO1xyXG5yZXF1aXJlKCcuL3Zpc3VhbHMvanZTaW5nbGVBeGlzLmpzJyk7XHJcbnJlcXVpcmUoJy4vdmlzdWFscy9qdlN1bmJ1cnN0LmpzJyk7XHJcbnJlcXVpcmUoJy4vdmlzdWFscy9qdlRyZWVtYXAuanMnKTtcclxucmVxdWlyZSgnLi92aXN1YWxzL2p2V29yZENsb3VkLmpzJyk7XHJcbnJlcXVpcmUoJy4vdmlzdWFscy9qdkJveFdoaXNrZXIuanMnKTtcclxucmVxdWlyZSgnLi92aXN1YWxzL2p2QnViYmxlLmpzJyk7XHJcbnJlcXVpcmUoJy4vdmlzdWFscy9qdkNsdXN0ZXJncmFtLmpzJyk7XHJcblxyXG4vL2F0dGFjaCBqdiBjaGFydHMgb2JqZWN0cyB0byB0aGUgd2luZG93XHJcbnZhciBqdkNoYXJ0cyA9IHJlcXVpcmUoJy4vanZDaGFydHMuanMnKTtcclxudmFyIGp2QnJ1c2ggPSByZXF1aXJlKCcuL2p2QnJ1c2guanMnKTtcclxudmFyIGp2Q29tbWVudCA9IHJlcXVpcmUoJy4vanZDb21tZW50LmpzJyk7XHJcbnZhciBqdkVkaXQgPSByZXF1aXJlKCcuL2p2RWRpdC5qcycpO1xyXG52YXIganZTZWxlY3QgPSByZXF1aXJlKCcuL2p2U2VsZWN0Jyk7XHJcbi8vIHZhciBqdkRvb2RsZSA9IHJlcXVpcmUoJy4vanZEb29kbGUuanMnKTtcclxuXHJcbi8vQ29tbWVudCBvdXQgdG8gcmVtb3ZlIGZyb20gd2luZG93IG9iamVjdCAtIGlmIHlvdSBhcmUgbm90IHVzaW5nIGp2Q2hhcnRzIGFzIGEgbWluaWZpZWQgZmlsZVxyXG53aW5kb3cuanZDaGFydHMgPSBqdkNoYXJ0cztcclxud2luZG93Lmp2QnJ1c2ggPSBqdkJydXNoO1xyXG53aW5kb3cuanZDb21tZW50ID0ganZDb21tZW50O1xyXG53aW5kb3cuanZFZGl0ID0ganZFZGl0O1xyXG53aW5kb3cuanZTZWxlY3QgPSBqdlNlbGVjdDtcclxuXHJcblxyXG4vL2FkZCBwb2x5ZmlsbCBmb3IgT2JqZWN0LmFzc2lnbigpIGlmIHVuc3VwcG9ydGVkXHJcbmlmICh0eXBlb2YgT2JqZWN0LmFzc2lnbiAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgT2JqZWN0LmFzc2lnbiA9IGZ1bmN0aW9uICh0YXJnZXQpIHsgLy8ubGVuZ3RoIG9mIGZ1bmN0aW9uIGlzIDJcclxuICAgICAgICAndXNlIHN0cmljdCc7XHJcbiAgICAgICAgaWYgKHRhcmdldCA9PSBudWxsKSB7IC8vVHlwZUVycm9yIGlmIHVuZGVmaW5lZCBvciBudWxsXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdG8gPSBPYmplY3QodGFyZ2V0KTtcclxuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDE7IGluZGV4IDwgYXJndW1lbnRzLmxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgICAgICB2YXIgbmV4dFNvdXJjZSA9IGFyZ3VtZW50c1tpbmRleF07XHJcblxyXG4gICAgICAgICAgICBpZiAobmV4dFNvdXJjZSAhPSBudWxsKSB7IC8vU2tpcCBvdmVyIGlmIHVuZGVmaW5lZCBvciBudWxsXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBuZXh0S2V5IGluIG5leHRTb3VyY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL0F2b2lkIGJ1Z3Mgd2hlbiBoYXNPd25Qcm9wZXJ0eSBpcyBzaGFkb3dlZFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobmV4dFNvdXJjZSwgbmV4dEtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9bbmV4dEtleV0gPSBuZXh0U291cmNlW25leHRLZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdG87XHJcbiAgICB9O1xyXG59XHJcbiIsIi8qKiogIGp2QnJ1c2ggKioqL1xyXG4ndXNlLXN0cmljdCc7XHJcblxyXG4vKipqdiBCcnVzaCBGbG93XHJcbipcclxuKiAgMS4gY3JlYXRlIG5ldyBqdkJydXNoIG9iamVjdCB3aXRoIGEgY29uZmlnIG9iamVjdCBjb250YWluaW5nIHRoZSBzcGVjaWZpYyBqdkNoYXJ0IGFuZCBhbiBvbkJydXNoQ2FsbGJhY2tcclxuKiAgMi4ganZCcnVzaCBleHBvc2VzIHN0YXJ0QnJ1c2ggYW5kIHJlbW92ZUJydXNoIGZ1bmN0aW9uc1xyXG4qICAzLiBpZiBzdGFydEJydXNoIGlzIGNhbGxlZCB3aXRoIGEgZDMuZXZlbnQsIGJydXNoIHdpbGwgYXNzdW1lIHRoYXQgYSBmb3JjZSBjbGljayBldmVudCBzaG91bGQgYmUgZmlyZWQgYXQgdGhlIGxvY2F0aW9uIG9mIHRoZSBkMy5ldmVudFxyXG4qICA0LiBpZiBhIGQzLmV2ZW50IGlzIG5vdCBnaXZlbiB0byBzdGFydEJydXNoKCksIGEgYnJ1c2ggbGlzZW5lciB3aWxsIGJlIGFkZGVkIHRvIHRoZSB2aXN1YWwgdG8gbGlzdGVuIGZvciB0aGUgdXNlciB0byBicnVzaFxyXG4qICA1LiBBZnRlciB0aGUgdXNlciBmaW5pc2hzIGJydXNoaW5nIGFuIGFyZWEgb2YgdGhlIGNoYXJ0LCBicnVzaEVuZCgpIGlzIGNhbGxlLlxyXG4qICA2LiBicnVzaEVuZCgpIHdpbGwgY3JlYXRlIGEgZGF0YSBvYmplY3QgZm9yIHRoZSBicnVzaGVkIGFyZWEgaW4gdGhlIGZvcm1hdDpcclxuKiAgICAgIHsnbGFiZWwxJzogWyd2YWx1ZTEnLCd2YWx1ZTInXX1cclxuKiAgICAgIEV4YW1wbGVcclxuKiAgICAgIHsnTW92aWVfR2VucmUnOiBbJ0RyYW1hJywnRG9jdW1lbnRhcnknLCdBY3Rpb24nXX1cclxuKiAgNy4gYnJ1c2hFbmQgd2lsbCB0aGVuIGNhbGwgdGhlIG9uQnJ1c2hDYWxsYmFjayBmdW5jdGlvbiB3aXRoIHRoZSBhYm92ZSBkYXRhIG9iamVjdFxyXG4qICA4LiBicnVzaEVuZCB3aWxsIGZpbmFsbHkgY2FsbCB0aGUgcmVtb3ZlQnJ1c2goKSBmdW5jdGlvblxyXG4qL1xyXG5cclxuLyoqXHJcbiogQG5hbWUganZCcnVzaFxyXG4qIEBkZXNjIENvbnN0cnVjdG9yIGZvciBKViBCcnVzaCAtIGNyZWF0ZXMgYnJ1c2ggbW9kZSBmb3IgYSBqdiB2aXN1YWxpemF0aW9uIGFuZCBleGVjdXRlcyBhIGNhbGxiYWNrIGZvciB0aGUgdmlzdWFsIHRvIGJlIGZpbHRlcmVkXHJcbiogQHBhcmFtIHtvYmplY3R9IGNvbmZpZ09iaiAtIGNvbnN0cnVjdG9yIG9iamVjdCBjb250YWluaW5nIHRoZSBqdkNoYXJ0IGFuZCBvdGhlciBvcHRpb25zXHJcbiogQHJldHVybiB7dW5kZWZpbmVkfSAtIG5vIHJldHVyblxyXG4qL1xyXG5jbGFzcyBqdkJydXNoIHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ09iaikge1xyXG4gICAgICAgIHZhciBicnVzaE9iaiA9IHRoaXM7XHJcbiAgICAgICAgYnJ1c2hPYmouY2hhcnREaXYgPSBjb25maWdPYmouanZDaGFydC5jaGFydERpdjtcclxuICAgICAgICBicnVzaE9iai5qdkNoYXJ0ID0gY29uZmlnT2JqLmp2Q2hhcnQ7XHJcbiAgICAgICAgYnJ1c2hPYmoub25CcnVzaENhbGxiYWNrID0gY29uZmlnT2JqLm9uQnJ1c2hDYWxsYmFjaztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogQG5hbWUgcmVtb3ZlQnJ1c2hcclxuICAgICogQGRlc2MgcmVtb3ZlcyB0aGUgYnJ1c2ggYXJlYSBmcm9tIHRoZSB2aXN1YWxcclxuICAgICogQHJldHVybiB7dW5kZWZpbmVkfSAtIG5vIHJldHVyblxyXG4gICAgKi9cclxuICAgIHJlbW92ZUJydXNoKCkge1xyXG4gICAgICAgIGxldCBicnVzaE9iaiA9IHRoaXM7XHJcbiAgICAgICAgYnJ1c2hPYmouanZDaGFydC5jaGFydERpdi5zZWxlY3RBbGwoJy5icnVzaGFyZWEnKS5yZW1vdmUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogQG5hbWUgc3RhcnRCcnVzaFxyXG4gICAgKiBAZGVzYyByZW1vdmVzIHRoZSBicnVzaCBhcmVhIGZyb20gdGhlIHZpc3VhbFxyXG4gICAgKiBAcGFyYW0ge29iamVjdH0gZXZlbnQgLSBvcHRpb25hbCBldmVudCB0byBzdGFydCBicnVzaCBpbW1lZGlhdGVseSB3aXRoIGEgbmV3IG1vdXNlZG93blxyXG4gICAgKiBAcmV0dXJuIHt1bmRlZmluZWR9IC0gbm8gcmV0dXJuXHJcbiAgICAqL1xyXG4gICAgc3RhcnRCcnVzaChldmVudCA9IGZhbHNlKSB7XHJcbiAgICAgICAgbGV0IGJydXNoT2JqID0gdGhpcyxcclxuICAgICAgICAgICAgaGVpZ2h0ID0gYnJ1c2hPYmouanZDaGFydC5jb25maWcuY29udGFpbmVyLmhlaWdodCxcclxuICAgICAgICAgICAgd2lkdGggPSBicnVzaE9iai5qdkNoYXJ0LmNvbmZpZy5jb250YWluZXIud2lkdGgsXHJcbiAgICAgICAgICAgIHN2ZyA9IGJydXNoT2JqLmp2Q2hhcnQuc3ZnO1xyXG5cclxuICAgICAgICBpZiAoYnJ1c2hPYmouanZDaGFydC5jb25maWcudHlwZSA9PT0gJ3NpbmdsZWF4aXMnKSB7XHJcbiAgICAgICAgICAgIGJydXNoT2JqLmJydXNoVHlwZSA9ICd4JztcclxuICAgICAgICAgICAgc3ZnLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnYnJ1c2hhcmVhJylcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgnaGVpZ2h0JywgaGVpZ2h0ICsgJ3B4JylcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgnd2lkdGgnLCB3aWR0aCArICdweCcpXHJcbiAgICAgICAgICAgICAgICAuY2FsbChkMy5icnVzaFgoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5leHRlbnQoW1swLCAwXSwgW3dpZHRoLCBoZWlnaHRdXSlcclxuICAgICAgICAgICAgICAgICAgICAub24oJ2VuZCcsIGJydXNoRW5kLmJpbmQoYnJ1c2hPYmopKSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChicnVzaE9iai5qdkNoYXJ0LmNvbmZpZy50eXBlID09PSAnY2x1c3RlcmdyYW0nKSB7XHJcbiAgICAgICAgICAgIGJydXNoT2JqLmJydXNoVHlwZSA9ICd4eSc7XHJcbiAgICAgICAgICAgIHN2Zy5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2JydXNoYXJlYScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke2JydXNoT2JqLmp2Q2hhcnQuX3ZhcnMubGVmdFRyZWVXaWR0aH0sICR7YnJ1c2hPYmouanZDaGFydC5fdmFycy50b3BUcmVlSGVpZ2h0fSlgKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdoZWlnaHQnLCBoZWlnaHQgKyAncHgnKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCd3aWR0aCcsIHdpZHRoICsgJ3B4JylcclxuICAgICAgICAgICAgICAgIC5jYWxsKGQzLmJydXNoKClcclxuICAgICAgICAgICAgICAgICAgICAuZXh0ZW50KFtbMCwgMF0sIFt3aWR0aCwgaGVpZ2h0XV0pXHJcbiAgICAgICAgICAgICAgICAgICAgLm9uKCdlbmQnLCBicnVzaEVuZC5iaW5kKGJydXNoT2JqKSkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGJydXNoT2JqLmJydXNoVHlwZSA9ICd4eSc7XHJcbiAgICAgICAgICAgIHN2Zy5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2JydXNoYXJlYScpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2hlaWdodCcsIGhlaWdodCArICdweCcpXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3dpZHRoJywgd2lkdGggKyAncHgnKVxyXG4gICAgICAgICAgICAgICAgLmNhbGwoZDMuYnJ1c2goKVxyXG4gICAgICAgICAgICAgICAgICAgIC5leHRlbnQoW1swLCAwXSwgW3dpZHRoLCBoZWlnaHRdXSlcclxuICAgICAgICAgICAgICAgICAgICAub24oJ2VuZCcsIGJydXNoRW5kLmJpbmQoYnJ1c2hPYmopKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgLy9kaXNwYXRjaCBtb3VzZWRvd24gdG8gc3RhcnQgYSBicnVzaCBhdCB0aGUgZXZlbnQgY29vcmRpbmF0ZXNcclxuICAgICAgICAgICAgbGV0IGJydXNoRWxlbWVudCA9IHN2Zy5zZWxlY3QoJy5icnVzaGFyZWEnKS5ub2RlKCksXHJcbiAgICAgICAgICAgICAgICBuZXdFdmVudCA9IG5ldyBFdmVudCgnbW91c2Vkb3duJyk7XHJcbiAgICAgICAgICAgIG5ld0V2ZW50LnBhZ2VYID0gZXZlbnQucGFnZVg7XHJcbiAgICAgICAgICAgIG5ld0V2ZW50LmNsaWVudFggPSBldmVudC5jbGllbnRYO1xyXG4gICAgICAgICAgICBuZXdFdmVudC5wYWdlWSA9IGV2ZW50LnBhZ2VZO1xyXG4gICAgICAgICAgICBuZXdFdmVudC5jbGllbnRZID0gZXZlbnQuY2xpZW50WTtcclxuICAgICAgICAgICAgbmV3RXZlbnQudmlldyA9IGV2ZW50LnZpZXc7XHJcbiAgICAgICAgICAgIGJydXNoRWxlbWVudC5fX2RhdGFfXyA9IHsgdHlwZTogJ292ZXJsYXknIH07XHJcbiAgICAgICAgICAgIGJydXNoRWxlbWVudC5kaXNwYXRjaEV2ZW50KG5ld0V2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4qIEBuYW1lIGJydXNoRW5kXHJcbiogQGRlc2MgY2FsbGVkIGF0IHRoZSBlbmQgb2YgdGhlIHVzZXIgYnJ1c2hpbmcgd2hpY2ggY2FsbHMgdGhlIG9uQnJ1c2ggY2FsbGJhY2tcclxuKiBAcmV0dXJuIHt1bmRlZmluZWR9IC0gbm8gcmV0dXJuXHJcbiovXHJcbmZ1bmN0aW9uIGJydXNoRW5kKCkge1xyXG4gICAgdmFyIGJydXNoT2JqID0gdGhpcyxcclxuICAgICAgICB4U2NhbGUgPSBicnVzaE9iai5qdkNoYXJ0LmN1cnJlbnREYXRhLnhBeGlzU2NhbGUsXHJcbiAgICAgICAgeVNjYWxlID0gYnJ1c2hPYmouanZDaGFydC5jdXJyZW50RGF0YS55QXhpc1NjYWxlLFxyXG4gICAgICAgIGZpbHRlcmVkWEF4aXNMYWJlbHMgPSBbXSxcclxuICAgICAgICBmaWx0ZXJlZFlBeGlzTGFiZWxzID0gW10sXHJcbiAgICAgICAgc2hvdWxkUmVzZXQgPSBmYWxzZSxcclxuICAgICAgICBlID0gZDMuZXZlbnQuc2VsZWN0aW9uLFxyXG4gICAgICAgIHJldHVybk9iaixcclxuICAgICAgICBmaWx0ZXJlZExhYmVscyA9IFtdLFxyXG4gICAgICAgIGZpbHRlcmVkQ29uY2VwdHMgPSB7fSxcclxuICAgICAgICBpbmRleCxcclxuICAgICAgICBmaWx0ZXJDb2wsXHJcbiAgICAgICAgZmlsdGVyZWRMYWJlbHNYLFxyXG4gICAgICAgIGZpbHRlcmVkTGFiZWxzWSxcclxuICAgICAgICBjbGVhbkRhdGFGbGFnID0gdHJ1ZTtcclxuXHJcbiAgICBpZiAoZSkge1xyXG4gICAgICAgIGlmIChicnVzaE9iai5icnVzaFR5cGUgPT09ICd4eScpIHtcclxuICAgICAgICAgICAgaWYgKHhTY2FsZSAmJiB0eXBlb2YgeFNjYWxlLmludmVydCAhPT0gJ2Z1bmN0aW9uJykgeyAvL21lYW5zIHRoYXQgdGhlIHNjYWxlIGlzIG9yZGluYWwgYW5kIG5vdCBsaW5lYXJcclxuICAgICAgICAgICAgICAgIHJldHVybk9iaiA9IGNhbGN1bGF0ZUJydXNoQXJlYU9yZGluYWwoZVswXVswXSwgZVsxXVswXSwgeFNjYWxlKTtcclxuICAgICAgICAgICAgICAgIGZpbHRlcmVkWEF4aXNMYWJlbHMgPSByZXR1cm5PYmouZmlsdGVyZWRBeGlzTGFiZWxzO1xyXG4gICAgICAgICAgICAgICAgc2hvdWxkUmVzZXQgPSByZXR1cm5PYmouc2hvdWxkUmVzZXQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoeFNjYWxlKSB7XHJcbiAgICAgICAgICAgICAgICAvL2NhbGN1bGF0ZSBsYWJlbHMgZm9yIGxpbmVhciBzY2FsZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuT2JqID0gY2FsY3VsYXRlQnJ1c2hBcmVhTGluZWFyKGVbMF1bMF0sIGVbMV1bMF0sIHhTY2FsZSwgYnJ1c2hPYmouanZDaGFydC5jdXJyZW50RGF0YSwgYnJ1c2hPYmouanZDaGFydC5jb25maWcudHlwZSwgJ3gnKTtcclxuICAgICAgICAgICAgICAgIGZpbHRlcmVkWEF4aXNMYWJlbHMgPSByZXR1cm5PYmouZmlsdGVyZWRBeGlzTGFiZWxzO1xyXG4gICAgICAgICAgICAgICAgc2hvdWxkUmVzZXQgPSByZXR1cm5PYmouc2hvdWxkUmVzZXQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh5U2NhbGUgJiYgdHlwZW9mIHlTY2FsZS5pbnZlcnQgIT09ICdmdW5jdGlvbicpIHsgLy9tZWFucyB0aGF0IHRoZSBzY2FsZSBpcyBvcmlkbmFsIGFuZCBub3QgbGluZWFyXHJcbiAgICAgICAgICAgICAgICByZXR1cm5PYmogPSBjYWxjdWxhdGVCcnVzaEFyZWFPcmRpbmFsKGVbMF1bMV0sIGVbMV1bMV0sIHlTY2FsZSk7XHJcbiAgICAgICAgICAgICAgICBmaWx0ZXJlZFlBeGlzTGFiZWxzID0gcmV0dXJuT2JqLmZpbHRlcmVkQXhpc0xhYmVscztcclxuICAgICAgICAgICAgICAgIGlmIChyZXR1cm5PYmouc2hvdWxkUmVzZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICBzaG91bGRSZXNldCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoeVNjYWxlKSB7XHJcbiAgICAgICAgICAgICAgICAvL2NhbGN1bGF0ZSBsYWJlbHMgZm9yIGxpbmVhciBzY2FsZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuT2JqID0gY2FsY3VsYXRlQnJ1c2hBcmVhTGluZWFyKGVbMF1bMV0sIGVbMV1bMV0sIHlTY2FsZSwgYnJ1c2hPYmouanZDaGFydC5jdXJyZW50RGF0YSwgYnJ1c2hPYmouanZDaGFydC5jb25maWcudHlwZSwgJ3knKTtcclxuICAgICAgICAgICAgICAgIGZpbHRlcmVkWUF4aXNMYWJlbHMgPSByZXR1cm5PYmouZmlsdGVyZWRBeGlzTGFiZWxzO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJldHVybk9iai5zaG91bGRSZXNldCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNob3VsZFJlc2V0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChicnVzaE9iai5qdkNoYXJ0LmNvbmZpZy50eXBlID09PSAnaGVhdG1hcCcpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybk9iaiA9IGNhbGN1bGF0ZUhlYXRtYXBCcnVzaChlLCBicnVzaE9iai5qdkNoYXJ0LmN1cnJlbnREYXRhLCBicnVzaE9iai5qdkNoYXJ0KTtcclxuICAgICAgICAgICAgICAgIGZpbHRlcmVkTGFiZWxzWCA9IHJldHVybk9iai5maWx0ZXJlZFhBeGlzTGFiZWxzO1xyXG4gICAgICAgICAgICAgICAgZmlsdGVyZWRMYWJlbHNZID0gcmV0dXJuT2JqLmZpbHRlcmVkWUF4aXNMYWJlbHM7XHJcbiAgICAgICAgICAgICAgICBpZiAocmV0dXJuT2JqLnNob3VsZFJlc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkUmVzZXQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGJydXNoT2JqLmp2Q2hhcnQuY29uZmlnLnR5cGUgPT09ICdjbHVzdGVyZ3JhbScpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybk9iaiA9IGNhbGN1bGF0ZUNsdXN0ZXJncmFtQnJ1c2goZSwgYnJ1c2hPYmouanZDaGFydC5jdXJyZW50RGF0YSwgYnJ1c2hPYmouanZDaGFydCk7XHJcbiAgICAgICAgICAgICAgICBmaWx0ZXJlZExhYmVsc1ggPSByZXR1cm5PYmouZmlsdGVyZWRYQXhpc0xhYmVscztcclxuICAgICAgICAgICAgICAgIGZpbHRlcmVkTGFiZWxzWSA9IHJldHVybk9iai5maWx0ZXJlZFlBeGlzTGFiZWxzO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJldHVybk9iai5zaG91bGRSZXNldCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNob3VsZFJlc2V0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoYnJ1c2hPYmouYnJ1c2hUeXBlID09PSAneCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuT2JqID0gY2FsY3VsYXRlQnJ1c2hBcmVhTGluZWFyKGVbMF0sIGVbMV0sIHhTY2FsZSwgYnJ1c2hPYmouanZDaGFydC5jdXJyZW50RGF0YSwgYnJ1c2hPYmouanZDaGFydC5jb25maWcudHlwZSwgJ3gnKTtcclxuICAgICAgICAgICAgZmlsdGVyZWRYQXhpc0xhYmVscyA9IHJldHVybk9iai5maWx0ZXJlZEF4aXNMYWJlbHM7XHJcbiAgICAgICAgICAgIGlmIChyZXR1cm5PYmouc2hvdWxkUmVzZXQpIHtcclxuICAgICAgICAgICAgICAgIHNob3VsZFJlc2V0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc2hvdWxkUmVzZXQgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChmaWx0ZXJlZFhBeGlzTGFiZWxzLmxlbmd0aCA+IDAgJiYgZmlsdGVyZWRZQXhpc0xhYmVscy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgLy9tZXJnZSBheGlzTGFiZWxzXHJcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBmaWx0ZXJlZFhBeGlzTGFiZWxzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgIGluZGV4ID0gZmlsdGVyZWRZQXhpc0xhYmVscy5pbmRleE9mKGZpbHRlcmVkWEF4aXNMYWJlbHNbal0pO1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgZmlsdGVyZWRMYWJlbHMucHVzaChmaWx0ZXJlZFhBeGlzTGFiZWxzW2pdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoZmlsdGVyZWRYQXhpc0xhYmVscy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgZmlsdGVyZWRMYWJlbHMgPSBmaWx0ZXJlZFhBeGlzTGFiZWxzO1xyXG4gICAgfSBlbHNlIGlmIChmaWx0ZXJlZFlBeGlzTGFiZWxzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBmaWx0ZXJlZExhYmVscyA9IGZpbHRlcmVkWUF4aXNMYWJlbHM7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHNob3VsZFJlc2V0KSB7XHJcbiAgICAgICAgZmlsdGVyZWRMYWJlbHMgPSBbXTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoYnJ1c2hPYmouanZDaGFydC5jb25maWcudHlwZSA9PT0gJ2hlYXRtYXAnKSB7XHJcbiAgICAgICAgbGV0IGZpbHRlckNvbFggPSBicnVzaE9iai5qdkNoYXJ0LmN1cnJlbnREYXRhLmRhdGFUYWJsZS54LFxyXG4gICAgICAgICAgICBmaWx0ZXJDb2xZID0gYnJ1c2hPYmouanZDaGFydC5jdXJyZW50RGF0YS5kYXRhVGFibGUueTtcclxuICAgICAgICBpZiAoIXNob3VsZFJlc2V0KSB7XHJcbiAgICAgICAgICAgIGlmIChmaWx0ZXJlZExhYmVsc1gubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgZmlsdGVyZWRDb25jZXB0c1tmaWx0ZXJDb2xYXSA9IGZpbHRlcmVkTGFiZWxzWDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZmlsdGVyZWRMYWJlbHNZLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGZpbHRlcmVkQ29uY2VwdHNbZmlsdGVyQ29sWV0gPSBmaWx0ZXJlZExhYmVsc1k7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBmaWx0ZXJlZENvbmNlcHRzW2ZpbHRlckNvbFhdID0gW107XHJcbiAgICAgICAgICAgIGZpbHRlcmVkQ29uY2VwdHNbZmlsdGVyQ29sWV0gPSBbXTtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKGJydXNoT2JqLmp2Q2hhcnQuY29uZmlnLnR5cGUgPT09ICdjbHVzdGVyZ3JhbScpIHtcclxuICAgICAgICBpZiAoIXNob3VsZFJlc2V0KSB7XHJcbiAgICAgICAgICAgIGxldCB4TGVuZ3RoID0gT2JqZWN0LmtleXMoZmlsdGVyZWRMYWJlbHNYKS5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICB5TGVuZ3RoID0gT2JqZWN0LmtleXMoZmlsdGVyZWRMYWJlbHNZKS5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHhMZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGZpbHRlckNvbFggPSBicnVzaE9iai5qdkNoYXJ0LmN1cnJlbnREYXRhLmRhdGFUYWJsZVsneF9jYXRlZ29yeSAnICsgKHhMZW5ndGggLSBpKV07XHJcbiAgICAgICAgICAgICAgICBmaWx0ZXJlZENvbmNlcHRzW2ZpbHRlckNvbFhdID0gZmlsdGVyZWRMYWJlbHNYW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgeUxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgZmlsdGVyQ29sWSA9IGJydXNoT2JqLmp2Q2hhcnQuY3VycmVudERhdGEuZGF0YVRhYmxlWyd5X2NhdGVnb3J5ICcgKyAoeUxlbmd0aCAtIGkpXTtcclxuICAgICAgICAgICAgICAgIGZpbHRlcmVkQ29uY2VwdHNbZmlsdGVyQ29sWV0gPSBmaWx0ZXJlZExhYmVsc1lbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2xlYW5EYXRhRmxhZyA9IGZhbHNlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoYnJ1c2hPYmouanZDaGFydC5jb25maWcudHlwZSA9PT0gJ2dhbnR0Jykge1xyXG4gICAgICAgICAgICBmaWx0ZXJDb2wgPSBicnVzaE9iai5qdkNoYXJ0LmN1cnJlbnREYXRhLmRhdGFUYWJsZS5ncm91cDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBmaWx0ZXJDb2wgPSBicnVzaE9iai5qdkNoYXJ0LmN1cnJlbnREYXRhLmRhdGFUYWJsZS5sYWJlbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmlsdGVyZWRDb25jZXB0c1tmaWx0ZXJDb2xdID0gZmlsdGVyZWRMYWJlbHM7XHJcbiAgICB9XHJcblxyXG4gICAgLy9jYWxscyBiYWNrIHRvIHVwZGF0ZSBkYXRhIHdpdGggYnJ1c2hlZCBkYXRhXHJcbiAgICBicnVzaE9iai5vbkJydXNoQ2FsbGJhY2soe1xyXG4gICAgICAgIGRhdGE6IGZpbHRlcmVkQ29uY2VwdHMsXHJcbiAgICAgICAgcmVzZXQ6IHNob3VsZFJlc2V0LFxyXG4gICAgICAgIGNsZWFuOiBjbGVhbkRhdGFGbGFnXHJcbiAgICB9KTtcclxuICAgIGJydXNoT2JqLnJlbW92ZUJydXNoKCk7XHJcbn1cclxuXHJcbi8qKlxyXG4qIEBuYW1lIGNhbGN1bGF0ZUJydXNoQXJlYU9yZGluYWxcclxuKiBAZGVzYyBjYWxjdWxhdGVzIHRoZSBvcmRpbmFsIHZhbHVlcyB0aGF0IGFyZSBpbiB0aGUgYnJ1c2hlZCBhcmVhXHJcbiogQHBhcmFtIHtudW1iZXJ9IG1vdXNlUG9zTWluIC0gbG93ZXIgYm91bmQgbW91c2UgcG9zaXRpb25cclxuKiBAcGFyYW0ge251bWJlcn0gbW91c2VQb3NNYXggLSB1cHBlciBib3VuZCBtb3VzZSBwb3NpdGlvblxyXG4qIEBwYXJhbSB7b2JqZWN0fSBzY2FsZSAtIGQzIGF4aXMgc2NhbGVcclxuKiBAcmV0dXJuIHtPYmplY3R9IC0gb2JqZWN0IG9mIGZpbHRlcmVkIHZhbHVlc1xyXG4qL1xyXG5mdW5jdGlvbiBjYWxjdWxhdGVCcnVzaEFyZWFPcmRpbmFsKG1vdXNlUG9zTWluLCBtb3VzZVBvc01heCwgc2NhbGUpIHtcclxuICAgIGxldCBkb21haW4gPSBzY2FsZS5kb21haW4oKSxcclxuICAgICAgICBwYWRkaW5nID0gc2NhbGUucGFkZGluZygpLFxyXG4gICAgICAgIHN0ZXAgPSBzY2FsZS5zdGVwKCksXHJcbiAgICAgICAgbWluSW5kZXgsIG1heEluZGV4LFxyXG4gICAgICAgIHBhZGRpbmdEaXN0YW5jZSA9IHBhZGRpbmcgKiBzdGVwIC8gMixcclxuICAgICAgICBmaWx0ZXJlZEF4aXNMYWJlbHM7XHJcblxyXG4gICAgLy9kZXRlcm1pbmUgbWluIGluZGV4XHJcbiAgICBpZiAobW91c2VQb3NNaW4gJSBzdGVwID4gc3RlcCAtIHBhZGRpbmdEaXN0YW5jZSkge1xyXG4gICAgICAgIC8vZG9uJ3QgaW5jbHVkZSBvbiBtaW4gc2lkZVxyXG4gICAgICAgIG1pbkluZGV4ID0gKE1hdGguZmxvb3IobW91c2VQb3NNaW4gLyBzdGVwKSArIDEpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAvL2luY2x1ZGUgb24gbWluIHNpZGVcclxuICAgICAgICBtaW5JbmRleCA9IChNYXRoLmZsb29yKG1vdXNlUG9zTWluIC8gc3RlcCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vZGV0ZXJtaW5lIG1heCBpbmRleFxyXG4gICAgaWYgKG1vdXNlUG9zTWF4ICUgc3RlcCA8IHBhZGRpbmdEaXN0YW5jZSkge1xyXG4gICAgICAgIC8vZG9uJ3QgaW5jbHVkZSBvbiBtYXggc2lkZVxyXG4gICAgICAgIG1heEluZGV4ID0gKE1hdGguZmxvb3IobW91c2VQb3NNYXggLyBzdGVwKSAtIDEpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAvL2luY2x1ZGUgb24gbWF4IHNpZGVcclxuICAgICAgICBtYXhJbmRleCA9IChNYXRoLmZsb29yKG1vdXNlUG9zTWF4IC8gc3RlcCkpO1xyXG4gICAgICAgIGlmIChtYXhJbmRleCA9PT0gZG9tYWluLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBtYXhJbmRleCAtPSAxO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZpbHRlcmVkQXhpc0xhYmVscyA9IGRvbWFpbi5zbGljZShtaW5JbmRleCwgbWF4SW5kZXggKyAxKTtcclxuICAgIHJldHVybiB7IGZpbHRlcmVkQXhpc0xhYmVsczogZmlsdGVyZWRBeGlzTGFiZWxzLCBzaG91bGRSZXNldDogZmlsdGVyZWRBeGlzTGFiZWxzLmxlbmd0aCA9PT0gMCB9O1xyXG59XHJcblxyXG5cclxuLyoqXHJcbiogQG5hbWUgY2FsY3VsYXRlQnJ1c2hBcmVhTGluZWFyXHJcbiogQGRlc2MgY2FsY3VsYXRlcyB0aGUgbGluZWFyIHZhbHVlcyB0aGF0IGFyZSBpbiB0aGUgYnJ1c2hlZCBhcmVhXHJcbiogQHBhcmFtIHtudW1iZXJ9IG1vdXNlUG9zTWluIC0gbG93ZXIgYm91bmQgbW91c2UgcG9zaXRpb25cclxuKiBAcGFyYW0ge251bWJlcn0gbW91c2VQb3NNYXggLSB1cHBlciBib3VuZCBtb3VzZSBwb3NpdGlvblxyXG4qIEBwYXJhbSB7b2JqZWN0fSBzY2FsZSAtIGQzIGF4aXMgc2NhbGVcclxuKiBAcGFyYW0ge29iamVjdH0gZGF0YSAtIGNoYXJ0RGF0YVxyXG4qIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gdmlzdWFsIHR5cGVcclxuKiBAcGFyYW0ge3N0cmluZ30gYXhpcyAtIHggLyB5IC8gelxyXG4qIEByZXR1cm4ge09iamVjdH0gLSBvYmplY3Qgb2YgZmlsdGVyZWQgdmFsdWVzXHJcbiovXHJcbmZ1bmN0aW9uIGNhbGN1bGF0ZUJydXNoQXJlYUxpbmVhcihtb3VzZVBvc01pbiwgbW91c2VQb3NNYXgsIHNjYWxlLCBkYXRhLCB0eXBlLCBheGlzKSB7XHJcbiAgICBsZXQgZmlsdGVyZWRBeGlzTGFiZWxzID0gW10sXHJcbiAgICAgICAgbWluLFxyXG4gICAgICAgIG1heCxcclxuICAgICAgICBheGlzTGFiZWw7XHJcblxyXG4gICAgLy9zd2l0Y2ggbWluIGFuZCBtYXggaWYgc2NhbGUgaXMgeSBkdWUgdG8gc3ZnIGRyYXdpbmcgKHkgYXhpcyBpbmNyZWFzZXMgdXAgdGhlIHNjcmVlbiB3aGlsZSBtb3VzZVBvcyBkZWNyZWFzZXMpXHJcbiAgICBpZiAoYXhpcyA9PT0gJ3knKSB7XHJcbiAgICAgICAgbWF4ID0gc2NhbGUuaW52ZXJ0KG1vdXNlUG9zTWluKTtcclxuICAgICAgICBtaW4gPSBzY2FsZS5pbnZlcnQobW91c2VQb3NNYXgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBtaW4gPSBzY2FsZS5pbnZlcnQobW91c2VQb3NNaW4pO1xyXG4gICAgICAgIG1heCA9IHNjYWxlLmludmVydChtb3VzZVBvc01heCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHR5cGUgPT09ICdiYXInKSB7XHJcbiAgICAgICAgZm9yIChheGlzTGFiZWwgb2YgZGF0YS5sZWdlbmREYXRhKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGRhdGFFbGVtZW50IG9mIGRhdGEuY2hhcnREYXRhKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0YUVsZW1lbnRbYXhpc0xhYmVsXSA+PSBtaW4pIHtcclxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJlZEF4aXNMYWJlbHMucHVzaChkYXRhRWxlbWVudFtkYXRhLmRhdGFUYWJsZS5sYWJlbF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnZ2FudHQnKSB7XHJcbiAgICAgICAgbWF4ID0gbmV3IERhdGUobWF4KTtcclxuICAgICAgICBtaW4gPSBuZXcgRGF0ZShtaW4pO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZWdlbmREYXRhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBjb3VudCA9IGkgKyAxLFxyXG4gICAgICAgICAgICAgICAgc3RhcnREYXRlLFxyXG4gICAgICAgICAgICAgICAgZW5kRGF0ZTtcclxuICAgICAgICAgICAgZm9yIChsZXQgZGF0YUVsZW1lbnQgb2YgZGF0YS5jaGFydERhdGEpIHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZSA9IG5ldyBEYXRlKGRhdGFFbGVtZW50W2RhdGEuZGF0YVRhYmxlWydzdGFydCAnICsgY291bnRdXSk7XHJcbiAgICAgICAgICAgICAgICBlbmREYXRlID0gbmV3IERhdGUoZGF0YUVsZW1lbnRbZGF0YS5kYXRhVGFibGVbJ2VuZCAnICsgY291bnRdXSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHN0YXJ0RGF0ZSA8PSBtYXggJiYgc3RhcnREYXRlID49IG1pbikgfHwgKGVuZERhdGUgPD0gbWF4ICYmIGVuZERhdGUgPj0gbWluKSB8fCAoc3RhcnREYXRlIDw9IG1pbiAmJiBlbmREYXRlID49IG1heCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJlZEF4aXNMYWJlbHMucHVzaChkYXRhRWxlbWVudFtkYXRhLmRhdGFUYWJsZS5ncm91cF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnbGluZScgfHwgdHlwZSA9PT0gJ2FyZWEnIHx8IHR5cGUgPT09ICdzaW5nbGVheGlzJykge1xyXG4gICAgICAgIGZvciAoYXhpc0xhYmVsIG9mIGRhdGEubGVnZW5kRGF0YSkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBkYXRhRWxlbWVudCBvZiBkYXRhLmNoYXJ0RGF0YSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRhdGFFbGVtZW50W2F4aXNMYWJlbF0gPD0gbWF4ICYmIGRhdGFFbGVtZW50W2F4aXNMYWJlbF0gPj0gbWluKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyZWRBeGlzTGFiZWxzLnB1c2goZGF0YUVsZW1lbnRbZGF0YS5kYXRhVGFibGUubGFiZWxdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3NjYXR0ZXJwbG90Jykge1xyXG4gICAgICAgIGF4aXNMYWJlbCA9IGRhdGEuZGF0YVRhYmxlW2F4aXNdO1xyXG4gICAgICAgIGZvciAobGV0IGRhdGFFbGVtZW50IG9mIGRhdGEuY2hhcnREYXRhKSB7XHJcbiAgICAgICAgICAgIGlmIChkYXRhRWxlbWVudFtheGlzTGFiZWxdIDw9IG1heCAmJiBkYXRhRWxlbWVudFtheGlzTGFiZWxdID49IG1pbikge1xyXG4gICAgICAgICAgICAgICAgZmlsdGVyZWRBeGlzTGFiZWxzLnB1c2goZGF0YUVsZW1lbnRbZGF0YS5kYXRhVGFibGUubGFiZWxdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2JveHdoaXNrZXInKSB7XHJcbiAgICAgICAgYXhpc0xhYmVsID0gZGF0YS5kYXRhVGFibGUudmFsdWU7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGRhdGFFbGVtZW50IG9mIGRhdGEuY2hhcnREYXRhKSB7XHJcbiAgICAgICAgICAgIGlmIChkYXRhRWxlbWVudFtheGlzTGFiZWxdIDw9IG1heCAmJiBkYXRhRWxlbWVudFtheGlzTGFiZWxdID49IG1pbikge1xyXG4gICAgICAgICAgICAgICAgZmlsdGVyZWRBeGlzTGFiZWxzLnB1c2goZGF0YUVsZW1lbnRbZGF0YS5kYXRhVGFibGUubGFiZWxdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2hlYXRtYXAnKSB7XHJcbiAgICAgICAgYXhpc0xhYmVsID0gZGF0YS5kYXRhVGFibGVbYXhpc107XHJcbiAgICAgICAgZm9yIChsZXQgZGF0YUVsZW1lbnQgb2YgZGF0YS5jaGFydERhdGEpIHtcclxuICAgICAgICAgICAgaWYgKGRhdGFFbGVtZW50W2F4aXNMYWJlbF0gPD0gbWF4ICYmIGRhdGFFbGVtZW50W2F4aXNMYWJlbF0gPj0gbWluKSB7XHJcbiAgICAgICAgICAgICAgICBmaWx0ZXJlZEF4aXNMYWJlbHMucHVzaChkYXRhRWxlbWVudFtkYXRhLmRhdGFUYWJsZS5sYWJlbF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHsgZmlsdGVyZWRBeGlzTGFiZWxzOiBmaWx0ZXJlZEF4aXNMYWJlbHMsIHNob3VsZFJlc2V0OiBmaWx0ZXJlZEF4aXNMYWJlbHMubGVuZ3RoID09PSAwIH07XHJcbn1cclxuXHJcbi8qKlxyXG4qIEBuYW1lIGNhbGN1bGF0ZUhlYXRtYXBCcnVzaFxyXG4qIEBkZXNjIGNhbGN1bGF0ZXMgdmFsdWVzIGluc2lkZSBvZiBicnVzaGVkIGFyZWEgb2YgYSBoZWF0bWFwXHJcbiogQHBhcmFtIHthcnJheX0gZSAtIG1vdXNlIGV4dGVudCBmb3IgbG9jYXRpb24gb2YgYnJ1c2hlZCBhcmVhXHJcbiogQHBhcmFtIHthcnJheX0gZGF0YSAtIGNoYXJ0IGRhdGFcclxuKiBAcGFyYW0ge2FycmF5fSBjaGFydCAtIGp2Q2hhcnRcclxuKiBAcmV0dXJuIHtvYmplY3R9IC0gZmlsdGVyZWQgZGF0YVxyXG4qL1xyXG5mdW5jdGlvbiBjYWxjdWxhdGVIZWF0bWFwQnJ1c2goZSwgZGF0YSwgY2hhcnQpIHtcclxuICAgIGxldCBtb3VzZVhtaW4gPSBlWzBdWzBdLFxyXG4gICAgICAgIG1vdXNlWW1pbiA9IGVbMF1bMV0sXHJcbiAgICAgICAgbW91c2VYbWF4ID0gZVsxXVswXSxcclxuICAgICAgICBtb3VzZVltYXggPSBlWzFdWzFdLFxyXG4gICAgICAgIGZpbHRlcmVkWEF4aXNMYWJlbHMgPSBbXSxcclxuICAgICAgICBmaWx0ZXJlZFlBeGlzTGFiZWxzID0gW10sXHJcbiAgICAgICAgcmVzZXQgPSB0cnVlLFxyXG4gICAgICAgIHhCdWNrZXRNYXggPSBNYXRoLmZsb29yKG1vdXNlWG1heCAvIGNoYXJ0Ll92YXJzLmhlYXRHcmlkU2l6ZSkgKyAxLFxyXG4gICAgICAgIHlCdWNrZXRNYXggPSBNYXRoLmZsb29yKG1vdXNlWW1heCAvIGNoYXJ0Ll92YXJzLmhlYXRHcmlkU2l6ZSkgKyAxLFxyXG4gICAgICAgIHhCdWNrZXRNaW4gPSBNYXRoLmZsb29yKG1vdXNlWG1pbiAvIGNoYXJ0Ll92YXJzLmhlYXRHcmlkU2l6ZSksXHJcbiAgICAgICAgeUJ1Y2tldE1pbiA9IE1hdGguZmxvb3IobW91c2VZbWluIC8gY2hhcnQuX3ZhcnMuaGVhdEdyaWRTaXplKTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHhCdWNrZXRNYXg7IGkrKykge1xyXG4gICAgICAgIGlmIChpID49IHhCdWNrZXRNaW4pIHtcclxuICAgICAgICAgICAgZmlsdGVyZWRYQXhpc0xhYmVscy5wdXNoKGRhdGEueEF4aXNEYXRhLnZhbHVlc1tpXSk7XHJcbiAgICAgICAgICAgIHJlc2V0ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB5QnVja2V0TWF4OyBpKyspIHtcclxuICAgICAgICBpZiAoaSA+PSB5QnVja2V0TWluKSB7XHJcbiAgICAgICAgICAgIGZpbHRlcmVkWUF4aXNMYWJlbHMucHVzaChkYXRhLnlBeGlzRGF0YS52YWx1ZXNbaV0pO1xyXG4gICAgICAgICAgICByZXNldCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4geyBmaWx0ZXJlZFhBeGlzTGFiZWxzOiBmaWx0ZXJlZFhBeGlzTGFiZWxzLCBmaWx0ZXJlZFlBeGlzTGFiZWxzOiBmaWx0ZXJlZFlBeGlzTGFiZWxzLCBzaG91bGRSZXNldDogcmVzZXQgfTtcclxufVxyXG5cclxuLyoqXHJcbiogQG5hbWUgY2FsY3VsYXRlQ2x1c3RlcmdyYW1CcnVzaFxyXG4qIEBkZXNjIGNhbGN1bGF0ZXMgdmFsdWVzIGluc2lkZSBvZiBicnVzaGVkIGFyZWEgb2YgYSBjbHVzdGVyZ3JhbVxyXG4qIEBwYXJhbSB7YXJyYXl9IGUgLSBtb3VzZSBleHRlbnQgZm9yIGxvY2F0aW9uIG9mIGJydXNoZWQgYXJlYVxyXG4qIEBwYXJhbSB7YXJyYXl9IGRhdGEgLSBjaGFydCBkYXRhXHJcbiogQHBhcmFtIHthcnJheX0gY2hhcnQgLSBqdkNoYXJ0XHJcbiogQHJldHVybiB7b2JqZWN0fSAtIGZpbHRlcmVkIGRhdGFcclxuKi9cclxuZnVuY3Rpb24gY2FsY3VsYXRlQ2x1c3RlcmdyYW1CcnVzaChlLCBkYXRhLCBjaGFydCkge1xyXG4gICAgbGV0IG1vdXNlWG1pbiA9IGVbMF1bMF0sXHJcbiAgICAgICAgbW91c2VZbWluID0gZVswXVsxXSxcclxuICAgICAgICBtb3VzZVhtYXggPSBlWzFdWzBdLFxyXG4gICAgICAgIG1vdXNlWW1heCA9IGVbMV1bMV0sXHJcbiAgICAgICAgZmlsdGVyZWRYQXhpc0xhYmVscyA9IFtdLFxyXG4gICAgICAgIGZpbHRlcmVkWUF4aXNMYWJlbHMgPSBbXSxcclxuICAgICAgICByZXNldCA9IHRydWUsXHJcbiAgICAgICAgeEJ1Y2tldE1heCA9IE1hdGguZmxvb3IobW91c2VYbWF4IC8gY2hhcnQuX3ZhcnMuY2x1c3RlcmdyYW1HcmlkV2lkdGgpICsgMSxcclxuICAgICAgICB5QnVja2V0TWF4ID0gTWF0aC5mbG9vcihtb3VzZVltYXggLyBjaGFydC5fdmFycy5jbHVzdGVyZ3JhbUdyaWRIZWlnaHQpICsgMSxcclxuICAgICAgICB4QnVja2V0TWluID0gTWF0aC5mbG9vcihtb3VzZVhtaW4gLyBjaGFydC5fdmFycy5jbHVzdGVyZ3JhbUdyaWRXaWR0aCksXHJcbiAgICAgICAgeUJ1Y2tldE1pbiA9IE1hdGguZmxvb3IobW91c2VZbWluIC8gY2hhcnQuX3ZhcnMuY2x1c3RlcmdyYW1HcmlkSGVpZ2h0KSxcclxuICAgICAgICB4TGV2ZWxzID0ge30sXHJcbiAgICAgICAgeUxldmVscyA9IHt9O1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgeEJ1Y2tldE1heDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGkgPj0geEJ1Y2tldE1pbikge1xyXG4gICAgICAgICAgICBmaWx0ZXJlZFhBeGlzTGFiZWxzLnB1c2goZGF0YS54QXhpc0RhdGFbaV0pO1xyXG4gICAgICAgICAgICByZXNldCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgeUJ1Y2tldE1heDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGkgPj0geUJ1Y2tldE1pbikge1xyXG4gICAgICAgICAgICBmaWx0ZXJlZFlBeGlzTGFiZWxzLnB1c2goZGF0YS55QXhpc0RhdGFbaV0pO1xyXG4gICAgICAgICAgICByZXNldCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvL1ggQXhpc1xyXG4gICAgLy9EeW5hbWljYWxseSBjcmVhdGUgYXJyYXlzIGZvciBlYWNoIGxldmVsIG9mIHRoZSBoaWVyYXJjaHlcclxuICAgIGlmIChmaWx0ZXJlZFhBeGlzTGFiZWxzWzBdKSB7XHJcbiAgICAgICAgbGV0IHBhcmVudENvdW50WCA9IChmaWx0ZXJlZFhBeGlzTGFiZWxzWzBdLm1hdGNoKC9cXC4vZykgfHwgW10pLmxlbmd0aDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmVudENvdW50WCArIDE7IGkrKykge1xyXG4gICAgICAgICAgICB4TGV2ZWxzW2ldID0gW107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL1BvcHVsYXRlIHRoZSBoaWVyYXJjaHkgYXJyYXlzIHdpdGggdGhlIGxhYmVscyBvZiB0aGF0IHJlc3BlY3RpdmUgaGllcmFyY2h5XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWx0ZXJlZFhBeGlzTGFiZWxzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChmaWx0ZXJlZFhBeGlzTGFiZWxzW2ldKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgeEZpZWxkcyA9IGZpbHRlcmVkWEF4aXNMYWJlbHNbaV0uc3BsaXQoJy4nKTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgeEZpZWxkcy5sZW5ndGg7IGsrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh4TGV2ZWxzW2tdLmluZGV4T2YoeEZpZWxkc1trXSkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhMZXZlbHNba10ucHVzaCh4RmllbGRzW2tdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy9ZIEF4aXNcclxuICAgIC8vRHluYW1pY2FsbHkgY3JlYXRlIGFycmF5cyBmb3IgZWFjaCBsZXZlbCBvZiB0aGUgaGllcmFyY2h5XHJcbiAgICBpZiAoZmlsdGVyZWRZQXhpc0xhYmVsc1swXSkge1xyXG4gICAgICAgIGxldCBwYXJlbnRDb3VudFkgPSAoZmlsdGVyZWRZQXhpc0xhYmVsc1swXS5tYXRjaCgvXFwuL2cpIHx8IFtdKS5sZW5ndGg7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJlbnRDb3VudFkgKyAxOyBpKyspIHtcclxuICAgICAgICAgICAgeUxldmVsc1tpXSA9IFtdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9Qb3B1bGF0ZSB0aGUgaGllcmFyY2h5IGFycmF5cyB3aXRoIHRoZSBsYWJlbHMgb2YgdGhhdCByZXNwZWN0aXZlIGhpZXJhcmNoeVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlsdGVyZWRZQXhpc0xhYmVscy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZmlsdGVyZWRZQXhpc0xhYmVsc1tpXSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHlGaWVsZHMgPSBmaWx0ZXJlZFlBeGlzTGFiZWxzW2ldLnNwbGl0KCcuJyk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHlGaWVsZHMubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoeUxldmVsc1trXS5pbmRleE9mKHlGaWVsZHNba10pID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB5TGV2ZWxzW2tdLnB1c2goeUZpZWxkc1trXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7IGZpbHRlcmVkWEF4aXNMYWJlbHM6IHhMZXZlbHMsIGZpbHRlcmVkWUF4aXNMYWJlbHM6IHlMZXZlbHMsIHNob3VsZFJlc2V0OiByZXNldCB9O1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGp2QnJ1c2g7XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuLyoqKiAganZDaGFydHMgKioqL1xyXG5sZXQganZUaXAgPSByZXF1aXJlKCcuL2p2VGlwLmpzJyk7XHJcblxyXG4vKipDcmVhdGUgYSBqdkNoYXJ0cyBvYmplY3RcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdPYmogLSBDb25maWd1cmF0aW9uIG9iamVjdCBwYXNzZWQgaW50byBqdkNoYXJ0cyBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge3N0cmluZ30gY29uZmlnT2JqLnR5cGUgLSBUaGUgdHlwZSBvZiBjaGFydFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gY29uZmlnT2JqLm5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgY2hhcnRcclxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ09iai5jb250YWluZXIgLSBUaGUgY29udGFpbmVyIG9mIHRoZSBjaGFydFxyXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnT2JqLnVzZXJPcHRpb25zIC0gVUkgb3B0aW9ucyBmb3IgdGhlIGNoYXJ0XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdPYmoudGlwQ29uZmlnIC0gQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGp2VG9vbHRpcFxyXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnT2JqLmNoYXJ0RGl2IC0gQSBkaXYgd3JhcHBlciBmb3IgdGhlIGNoYXJ0IGFuZCBvdGhlciBqdiBmZWF0dXJlc1xyXG4gKi9cclxuY2xhc3MganZDaGFydHMge1xyXG4gICAgY29uc3RydWN0b3IoY29uZmlnT2JqKSB7XHJcbiAgICAgICAgbGV0IGNoYXJ0ID0gdGhpcztcclxuICAgICAgICBjb25maWdPYmoudHlwZSA9IGNvbmZpZ09iai50eXBlLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgY2hhcnQuY2hhcnREaXYgPSBjb25maWdPYmouY2hhcnREaXY7XHJcbiAgICAgICAgY29uZmlnT2JqLm9wdGlvbnMgPSBqdkNoYXJ0cy5jbGVhblRvb2xEYXRhKGNvbmZpZ09iai5vcHRpb25zLCBjb25maWdPYmouZWRpdE9wdGlvbnMpO1xyXG4gICAgICAgIGNoYXJ0Ll92YXJzID0gY2hhcnQuZ2V0RGVmYXVsdE9wdGlvbnMoY29uZmlnT2JqLm9wdGlvbnMpO1xyXG4gICAgICAgIGNoYXJ0Lm1vZGUgPSBjb25maWdPYmoubW9kZSB8fCAnZGVmYXVsdC1tb2RlJztcclxuXHJcbiAgICAgICAgLy9yZW1vdmUgcGllY2VzIGZyb20gY29uZmlnIHRoYXQgaGF2ZSBiZWVuIGNvcGllZCBzb21ld2hlcmUgZWxzZVxyXG4gICAgICAgIGRlbGV0ZSBjb25maWdPYmouY2hhcnREaXY7XHJcbiAgICAgICAgZGVsZXRlIGNvbmZpZ09iai5vcHRpb25zO1xyXG4gICAgICAgIGRlbGV0ZSBjb25maWdPYmoubW9kZTtcclxuXHJcbiAgICAgICAgY2hhcnQuY29uZmlnID0gY29uZmlnT2JqO1xyXG5cclxuICAgICAgICAvL1N0YXJ0IHBhaW50aW5nIHRoZSBqdiBDaGFydFxyXG4gICAgICAgIGNoYXJ0LmNyZWF0ZVRvb2x0aXAoKTtcclxuICAgICAgICBjaGFydC5zZXREYXRhKCk7XHJcbiAgICAgICAgY2hhcnQucGFpbnQoY2hhcnQuX3ZhcnMudHJhbnNpdGlvblRpbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIGNyZWF0ZVRvb2x0aXAoKSB7XHJcbiAgICAgICAgbGV0IGNoYXJ0ID0gdGhpcztcclxuICAgICAgICBjaGFydC50aXAgPSBuZXcganZUaXAoe1xyXG4gICAgICAgICAgICBjb25maWc6IGNoYXJ0LmNvbmZpZy50aXBDb25maWcsXHJcbiAgICAgICAgICAgIGNoYXJ0RGl2OiBjaGFydC5jaGFydERpdlxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHNldERhdGEoKSB7XHJcbiAgICAgICAgbGV0IGNoYXJ0ID0gdGhpcztcclxuICAgICAgICBpZiAoY2hhcnQuY29uZmlnLnNldERhdGEpIHtcclxuICAgICAgICAgICAgY2hhcnQuZGF0YSA9IGNoYXJ0LmNvbmZpZy5zZXREYXRhO1xyXG4gICAgICAgICAgICAvL3JlZmVyIHRvIG1haW4gZGF0YSBhcyBjaGFydERhdGEgdG8ga2VlcCBuYW1pbmcgc2VwYXJhdGUgYW5kIHVuZGVyc3RhbmRhYmxlXHJcbiAgICAgICAgICAgIGNoYXJ0LmRhdGEuY2hhcnREYXRhID0gY2hhcnQuY29uZmlnLnNldERhdGEuZGF0YTtcclxuICAgICAgICAgICAgZGVsZXRlIGNoYXJ0LmRhdGEuZGF0YTtcclxuICAgICAgICAgICAgaWYgKGNoYXJ0LmRhdGEuZGF0YVRhYmxlS2V5cykge1xyXG4gICAgICAgICAgICAgICAgY2hhcnQuY2xlYW5EYXRhVGFibGVLZXlzKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChjaGFydC5kYXRhLmhlYWRlcnMpIHtcclxuICAgICAgICAgICAgICAgIGNoYXJ0LnNldEFsaWduQW5kS2V5cygpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjaGFydC5jb2xvcnMgPSBjaGFydC5jb25maWcuc2V0RGF0YS5jb2xvcnM7XHJcbiAgICAgICAgICAgIGNoYXJ0W2NoYXJ0LmNvbmZpZy50eXBlXS5zZXREYXRhLmNhbGwoY2hhcnQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogQG5hbWUgdXBkYXRlRGF0YVRhYmxlQWxpZ25cclxuICAgICogQHBhcmFtIHthcnJheX0gY3VycmVudEtleXMgLSBhcnJheSBvZiBvYmplY3RzIHRvIGRlc2NyaWJlIGhvdyB0byBidWlsZCB0aGUgdmlzdWFsXHJcbiAgICAqIEByZXR1cm4ge29iamVjdH0gZGF0YVRhYmxlQWxpZ24gLSBrZXk6dmFsdWUgbWFwcGluZyBvZiBjdXJyZW50IGFsaWdubWVudFxyXG4gICAgKi9cclxuICAgIHNldEFsaWduQW5kS2V5cygpIHtcclxuICAgICAgICB2YXIgY2hhcnQgPSB0aGlzLFxyXG4gICAgICAgICAgICBkYXRhVGFibGVBbGlnbiA9IHt9LFxyXG4gICAgICAgICAgICBpLFxyXG4gICAgICAgICAgICBsZW4sXHJcbiAgICAgICAgICAgIGtleU1hcHBpbmcgPSB7fSxcclxuICAgICAgICAgICAga2V5cyA9IGNoYXJ0LmRhdGEuaGVhZGVycztcclxuXHJcbiAgICAgICAgLy9pdGVyYXRlIG92ZXIgY3VycmVudCBrZXlzIHRvIGNyZWF0ZSBuZXcgb2JqZWN0IHdpdGgga2V5OnZhbHVlIG1hcHBpbmcgaW5zdGVhZCBvZiBrZXk6YXJyYXkgbWFwcGluZ1xyXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGtleXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKCFrZXlNYXBwaW5nLmhhc093blByb3BlcnR5KGtleXNbaV0ubW9kZWwpKSB7XHJcbiAgICAgICAgICAgICAgICBrZXlNYXBwaW5nW2tleXNbaV0ubW9kZWxdID0gMDtcclxuICAgICAgICAgICAgICAgIGRhdGFUYWJsZUFsaWduW2tleXNbaV0ubW9kZWxdID0ga2V5c1tpXS5uYW1lO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZGF0YVRhYmxlQWxpZ25ba2V5c1tpXS5tb2RlbCArICcgJyArIGldID0ga2V5c1tpXS5uYW1lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNoYXJ0LmRhdGEuZGF0YVRhYmxlS2V5cyA9IGNoYXJ0LmRhdGEuaGVhZGVycztcclxuICAgICAgICBjaGFydC5kYXRhLmRhdGFUYWJsZSA9IGRhdGFUYWJsZUFsaWduO1xyXG4gICAgfVxyXG5cclxuICAgIGNsZWFuRGF0YVRhYmxlS2V5cygpIHtcclxuICAgICAgICBsZXQgY2hhcnQgPSB0aGlzLFxyXG4gICAgICAgICAgICBuZXdLZXlzID0gW107XHJcbiAgICAgICAgZm9yIChsZXQga2V5IG9mIGNoYXJ0LmRhdGEuZGF0YVRhYmxlS2V5cykge1xyXG4gICAgICAgICAgICBuZXdLZXlzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgbmFtZToga2V5LnZhcktleSB8fCBrZXkuYWxpYXMgfHwga2V5Lm5hbWUsXHJcbiAgICAgICAgICAgICAgICBtb2RlbDoga2V5LnZpelR5cGUgfHwga2V5Lm1vZGVsLFxyXG4gICAgICAgICAgICAgICAgdHlwZToga2V5LnR5cGVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNoYXJ0LmRhdGEuZGF0YVRhYmxlS2V5cyA9IG5ld0tleXM7XHJcbiAgICB9XHJcblxyXG4gICAgY2hlY2tEaW1lbnNpb25zKCkge1xyXG4gICAgICAgIGxldCBjaGFydCA9IHRoaXMsXHJcbiAgICAgICAgICAgIGRpbWVuc2lvbnMgPSBjaGFydC5jaGFydERpdi5ub2RlKCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgaWYgKGRpbWVuc2lvbnMuaGVpZ2h0ID4gNTAgJiYgZGltZW5zaW9ucy53aWR0aCA+IDEyMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc29sZS5sb2coJ0NoYXJ0IGNvbnRhaW5lciBpcyB0b28gc21hbGwgdG8gcGFpbnQnKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcGFpbnQoYW5uaW1hdGlvbikge1xyXG4gICAgICAgIGxldCBjaGFydCA9IHRoaXM7XHJcbiAgICAgICAgaWYgKGNoYXJ0LmNoZWNrRGltZW5zaW9ucygpKSB7XHJcbiAgICAgICAgICAgIGlmIChjaGFydC5kYXRhICYmIHR5cGVvZiBjaGFydFtjaGFydC5jb25maWcudHlwZV0gPT09ICdvYmplY3QnICYmIHR5cGVvZiBjaGFydFtjaGFydC5jb25maWcudHlwZV0ucGFpbnQgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIGNoYXJ0W2NoYXJ0LmNvbmZpZy50eXBlXS5wYWludC5jYWxsKGNoYXJ0LCBhbm5pbWF0aW9uKTtcclxuICAgICAgICAgICAgICAgIGNoYXJ0LmluaXRpYWxpemVNb2RlcygpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChjaGFydC5fdmFycy5oaWdobGlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuICAgICAgICAgICAgICAgICAgICAvL1RPRE8gZml4IHRoaXMgd2hlbiBKb24gaXMgYmFja1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wSGlnaGxpZ2h0ID0ge30sIGNvbnZlcnRlZERhdGEgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBjb2wgaW4gY2hhcnQuX3ZhcnMuaGlnaGxpZ2h0LmRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFydC5fdmFycy5oaWdobGlnaHQuZGF0YVtjb2xdLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb252ZXJ0ZWREYXRhLnB1c2goY2hhcnQuX3ZhcnMuaGlnaGxpZ2h0LmRhdGFbY29sXVtpXS5yZXBsYWNlKC9fL2csICcgJykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBIaWdobGlnaHRbY29sLnJlcGxhY2UoL18vZywgJyAnKV0gPSBjb252ZXJ0ZWREYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY2hhcnQuX3ZhcnMuaGlnaGxpZ2h0LmRhdGEgPSB0ZW1wSGlnaGxpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjaGFydFtjaGFydC5jb25maWcudHlwZV0uaGlnaGxpZ2h0RnJvbUV2ZW50RGF0YS5jYWxsKGNoYXJ0LCBjaGFydC5fdmFycy5oaWdobGlnaHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ25vIHBhaW50IGZ1bmN0aW9uIGZvcjogJyArIGNoYXJ0LmNvbmZpZy50eXBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzZXRBeGlzRGF0YShheGlzLCBkYXRhLCBrZXlzKSB7XHJcbiAgICAgICAgbGV0IGNoYXJ0ID0gdGhpcyxcclxuICAgICAgICAgICAgYXhpc0RhdGEgPSBbXSxcclxuICAgICAgICAgICAgY2hhcnREYXRhID0gZGF0YS5jaGFydERhdGEsXHJcbiAgICAgICAgICAgIGxhYmVsID0gJycsXHJcbiAgICAgICAgICAgIG1heFN0YWNrID0gMCxcclxuICAgICAgICAgICAgZGF0YVRhYmxlS2V5cyA9IGRhdGEuZGF0YVRhYmxlS2V5cyxcclxuICAgICAgICAgICAgZGF0YVR5cGU7XHJcblxyXG4gICAgICAgIGlmICghZGF0YVRhYmxlS2V5cykge1xyXG4gICAgICAgICAgICBkYXRhVGFibGVLZXlzID0ga2V5cztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vU3RlcCAxOiBmaW5kIG91dCB3aGF0IHRoZSBsYWJlbCBpcyBmb3IgdGhlIGF4aXNcclxuICAgICAgICBpZiAoYXhpcyA9PT0gJ3gnKSB7XHJcbiAgICAgICAgICAgIGlmIChkYXRhLmRhdGFUYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuZGF0YVRhYmxlLmhhc093blByb3BlcnR5KCdsYWJlbCcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwgPSBkYXRhLmRhdGFUYWJsZS5sYWJlbDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkxhYmVsIGRvZXNuJ3QgZXhpc3QgaW4gZGF0YVRhYmxlXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0RhdGFUYWJsZSBkb2VzIG5vdCBleGlzdCcpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBkYXRhVHlwZSA9ICdTVFJJTkcnO1xyXG5cclxuICAgICAgICAgICAgLy9SZXBsYWNlIHVuZGVyc2NvcmVzIHdpdGggc3BhY2VzXHJcbiAgICAgICAgICAgIGxhYmVsID0gbGFiZWwucmVwbGFjZSgvXy9nLCAnICcpO1xyXG5cclxuICAgICAgICAgICAgLy9sb29wIHRocm91Z2ggZGF0YSB0byBwb3B1bGF0ZSBheGlzRGF0YVxyXG4gICAgICAgICAgICBmb3IgKGxldCBjaGFydEVsZSBvZiBjaGFydERhdGEpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjaGFydEVsZVtsYWJlbF0gPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBheGlzRGF0YS5wdXNoKCdOVUxMX1ZBTFVFJyk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoYXJ0RWxlW2xhYmVsXSA9PT0gJycpIHtcclxuICAgICAgICAgICAgICAgICAgICBheGlzRGF0YS5wdXNoKCdFTVBUWV9TVFJJTkcnKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hhcnRFbGVbbGFiZWxdIHx8IGNoYXJ0RWxlW2xhYmVsXSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGF4aXNEYXRhLnB1c2goY2hhcnRFbGVbbGFiZWxdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChkYXRhVGFibGVLZXlzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2RhdGFUYWJsZUtleXMgZG8gbm90IGV4aXN0Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9GaW5kIHRoZSBtYXggdmFsdWUgZm9yIFkgRGF0YVxyXG4gICAgICAgICAgICBsZXQgY291bnQgPSAwO1xyXG5cclxuICAgICAgICAgICAgZm9yIChsZXQga2V5IG9mIGRhdGFUYWJsZUtleXMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChrZXkubW9kZWwgIT09ICdsYWJlbCcgJiYga2V5Lm1vZGVsICE9PSAndG9vbHRpcCcgJiYga2V5Lm1vZGVsICE9PSAnc2VyaWVzJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsID0ga2V5Lm5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgY291bnQrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkYXRhVHlwZSA9IGp2Q2hhcnRzLmdldERhdGFUeXBlRnJvbUtleXMobGFiZWwsIGRhdGFUYWJsZUtleXMsICdOVU1CRVInKTtcclxuXHJcbiAgICAgICAgICAgIC8vQWRkIGFsbCB2YWx1ZXMgdGhhdCBhcmUgb24geWF4aXMgdG8gYXhpcyBkYXRhXHJcbiAgICAgICAgICAgIGZvciAobGV0IGNoYXJ0RWxlIG9mIGNoYXJ0RGF0YSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHN0YWNrID0gMDsgLy9LZWVwcyB0cmFjayBvZiB0aGUgbWF4aW11bSBzaXplIG9mIHN0YWNrZWQgZGF0YSBzbyB0aGF0IGF4aXMgY2FuIGJlIHNjYWxlZCB0byBmaXQgbWF4IHNpemVcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGsgaW4gZGF0YS5kYXRhVGFibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhcnRFbGUuaGFzT3duUHJvcGVydHkoZGF0YS5kYXRhVGFibGVba10pICYmIGsgIT09ICdsYWJlbCcgJiYgay5pbmRleE9mKCd0b29sdGlwJykgPT09IC0xICYmIGsgIT09ICdzZXJpZXMnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrICs9IGNoYXJ0RWxlW2RhdGEuZGF0YVRhYmxlW2tdXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXhpc0RhdGEucHVzaChjaGFydEVsZVtkYXRhLmRhdGFUYWJsZVtrXV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChzdGFjayA+IG1heFN0YWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF4U3RhY2sgPSBzdGFjaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9JZiB0aGVyZSBhcmUgbXVsdGlwbGUgdmFsdWVzIG9uIHRoZSB5QXhpcywgZG9uJ3Qgc3BlY2lmeSBhIGxhYmVsXHJcbiAgICAgICAgICAgIGlmIChjb3VudCA+IDEpIHtcclxuICAgICAgICAgICAgICAgIGxhYmVsID0gJyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGFiZWwgPSBsYWJlbC5yZXBsYWNlKC9fL2csICcgJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL0ZpbmQgdGhlIG1pbiBhbmQgbWF4IG9mIG51bWVyaWMgZGF0YSBmb3IgYnVpbGRpbmcgYXhlcyBhbmQgYWRkIGl0IHRvIHRoZSByZXR1cm5lZCBvYmplY3RcclxuICAgICAgICBpZiAoZGF0YVR5cGUgPT09ICdOVU1CRVInKSB7XHJcbiAgICAgICAgICAgIGxldCBtYXgsXHJcbiAgICAgICAgICAgICAgICBtaW4sXHJcbiAgICAgICAgICAgICAgICB0ZW1wLFxyXG4gICAgICAgICAgICAgICAgdGVtcE1pbixcclxuICAgICAgICAgICAgICAgIHRlbXBNYXg7XHJcbiAgICAgICAgICAgIGlmIChjaGFydC5fdmFycy5zdGFja1RvZ2dsZSkge1xyXG4gICAgICAgICAgICAgICAgbWF4ID0gbWF4U3RhY2s7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBtYXggPSBNYXRoLm1heC5hcHBseShudWxsLCBheGlzRGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIG1pbiA9IE1hdGgubWluLmFwcGx5KG51bGwsIGF4aXNEYXRhKTtcclxuICAgICAgICAgICAgbWluID0gTWF0aC5taW4oMCwgbWluKTtcclxuXHJcbiAgICAgICAgICAgIC8vQ2hlY2sgaWYgdGhlcmUncyBhbiBheGlzIG1pbi9tYXggc2V0XHJcbiAgICAgICAgICAgIGlmIChheGlzID09PSAneCcpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjaGFydC5fdmFycy54TWluICE9IG51bGwgJiYgY2hhcnQuX3ZhcnMueE1pbiAhPT0gJ25vbmUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWluID0gY2hhcnQuX3ZhcnMueE1pbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChjaGFydC5fdmFycy54TWF4ICE9IG51bGwgJiYgY2hhcnQuX3ZhcnMueE1heCAhPT0gJ25vbmUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gY2hhcnQuX3ZhcnMueE1heDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChheGlzID09PSAneScpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjaGFydC5fdmFycy55TWluICE9IG51bGwgJiYgY2hhcnQuX3ZhcnMueU1pbiAhPT0gJ25vbmUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWluID0gY2hhcnQuX3ZhcnMueU1pbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChjaGFydC5fdmFycy55TWF4ICE9IG51bGwgJiYgY2hhcnQuX3ZhcnMueU1heCAhPT0gJ25vbmUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gY2hhcnQuX3ZhcnMueU1heDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGRhdGFUeXBlID09PSAnTlVNQkVSJyAmJiBheGlzRGF0YS5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIGlmIChheGlzRGF0YVswXSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXhpc0RhdGEudW5zaGlmdCgwKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXhpc0RhdGEucHVzaCgwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGVtcE1pbiA9IHBhcnNlSW50KG1pbiwgMTApO1xyXG4gICAgICAgICAgICB0ZW1wTWF4ID0gcGFyc2VJbnQobWF4LCAxMCk7XHJcbiAgICAgICAgICAgIC8vTWFrZSBzdXJlIHRoYXQgYXhpcyBtaW4gYW5kIG1heCBkb24ndCBnZXQgZmxpcHBlZFxyXG4gICAgICAgICAgICBpZiAodGVtcE1pbiA+IHRlbXBNYXgpIHtcclxuICAgICAgICAgICAgICAgIHRlbXAgPSBtaW47XHJcbiAgICAgICAgICAgICAgICBtaW4gPSBtYXg7XHJcbiAgICAgICAgICAgICAgICBtYXggPSB0ZW1wO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgJ2xhYmVsJzogbGFiZWwsXHJcbiAgICAgICAgICAgICAgICAndmFsdWVzJzogYXhpc0RhdGEsXHJcbiAgICAgICAgICAgICAgICAnZGF0YVR5cGUnOiBkYXRhVHlwZSxcclxuICAgICAgICAgICAgICAgICdtaW4nOiBtaW4sXHJcbiAgICAgICAgICAgICAgICAnbWF4JzogbWF4XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAnbGFiZWwnOiBsYWJlbCxcclxuICAgICAgICAgICAgJ3ZhbHVlcyc6IGF4aXNEYXRhLFxyXG4gICAgICAgICAgICAnZGF0YVR5cGUnOiBkYXRhVHlwZVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKnNldEZsaXBwZWRTZXJpZXNcclxuICAgICAqICBmbGlwcyBzZXJpZXMgYW5kIHJldHVybnMgZmxpcHBlZCBkYXRhXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtcyBjaGFydERhdGEsIGRhdGFUYWJsZSwgZGF0YUxhYmVsXHJcbiAgICAgKiBAcmV0dXJucyBPYmplY3Qgb2YgZGF0YSBhbmQgdGFibGUgZm9yIGZsaXBwZWQgc2VyaWVzXHJcbiAgICAgKi9cclxuICAgIHNldEZsaXBwZWRTZXJpZXMoZGF0YVRhYmxlS2V5cykge1xyXG4gICAgICAgIGxldCBjaGFydCA9IHRoaXMsXHJcbiAgICAgICAgICAgIGNoYXJ0RGF0YSA9IGNoYXJ0LmRhdGEuY2hhcnREYXRhLFxyXG4gICAgICAgICAgICBkYXRhVGFibGUgPSBjaGFydC5kYXRhLmRhdGFUYWJsZSxcclxuICAgICAgICAgICAgZGF0YUxhYmVsID0gY2hhcnQuZGF0YS54QXhpc0RhdGEubGFiZWwsXHJcbiAgICAgICAgICAgIGZsaXBwZWREYXRhID0gW10sXHJcbiAgICAgICAgICAgIGZsaXBwZWREYXRhVGFibGUgPSB7fSxcclxuICAgICAgICAgICAgdmFsdWVDb3VudCA9IDEsXHJcbiAgICAgICAgICAgIGZpbHRlcmVkRGF0YVRhYmxlQXJyYXkgPSBbXTtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgayBpbiBkYXRhVGFibGUpIHtcclxuICAgICAgICAgICAgaWYgKGRhdGFUYWJsZS5oYXNPd25Qcm9wZXJ0eShrKSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGZsaXBwZWRPYmplY3QgPSB7fTtcclxuICAgICAgICAgICAgICAgIGlmIChkYXRhVGFibGVba10gIT09IGRhdGFMYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZsaXBwZWRPYmplY3RbZGF0YUxhYmVsXSA9IGRhdGFUYWJsZVtrXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjaGFydEVsZSBvZiBjaGFydERhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmxpcHBlZE9iamVjdFtjaGFydEVsZVtkYXRhTGFiZWxdXSA9IGNoYXJ0RWxlW2RhdGFUYWJsZVtrXV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJlZERhdGFUYWJsZUFycmF5LmluZGV4T2YoY2hhcnRFbGVbZGF0YUxhYmVsXSkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbGlwcGVkRGF0YVRhYmxlWyd2YWx1ZSAnICsgdmFsdWVDb3VudF0gPSBjaGFydEVsZVtkYXRhTGFiZWxdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVDb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyZWREYXRhVGFibGVBcnJheS5wdXNoKGNoYXJ0RWxlW2RhdGFMYWJlbF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZsaXBwZWREYXRhLnB1c2goZmxpcHBlZE9iamVjdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZmxpcHBlZERhdGFUYWJsZS5sYWJlbCA9IGRhdGFMYWJlbDtcclxuICAgICAgICBjaGFydC5mbGlwcGVkRGF0YSA9IHsgY2hhcnREYXRhOiBmbGlwcGVkRGF0YSwgZGF0YVRhYmxlOiBmbGlwcGVkRGF0YVRhYmxlIH07XHJcblxyXG4gICAgICAgIGlmIChjaGFydC5jb25maWcudHlwZSA9PT0gJ2JhcicgfHwgY2hhcnQuY29uZmlnLnR5cGUgPT09ICdsaW5lJyB8fCBjaGFydC5jb25maWcudHlwZSA9PT0gJ2FyZWEnKSB7XHJcbiAgICAgICAgICAgIGNoYXJ0LmZsaXBwZWREYXRhLnhBeGlzRGF0YSA9IGNoYXJ0LnNldEF4aXNEYXRhKCd4JywgY2hhcnQuZmxpcHBlZERhdGEsIGRhdGFUYWJsZUtleXMpO1xyXG4gICAgICAgICAgICBjaGFydC5mbGlwcGVkRGF0YS55QXhpc0RhdGEgPSBjaGFydC5zZXRBeGlzRGF0YSgneScsIGNoYXJ0LmZsaXBwZWREYXRhLCBkYXRhVGFibGVLZXlzKTtcclxuICAgICAgICAgICAgY2hhcnQuZmxpcHBlZERhdGEubGVnZW5kRGF0YSA9IGp2Q2hhcnRzLnNldEJhckxpbmVMZWdlbmREYXRhKGNoYXJ0LmZsaXBwZWREYXRhKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnQWRkIGFkZGl0aW9uYWwgY2hhcnQgdHlwZSB0byBzZXQgZmxpcHBlZCBzZXJpZXMnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqb3JnYW5pemVDaGFydERhdGFcclxuICAgICAqICByZW9yZGVycyBhbGwgZGF0YSBiYXNlZCBvbiB0aGUgc29ydExhYmVsIGFuZCBzb3J0VHlwZVxyXG4gICAgICogIC1Pbmx5IGZvciBjaGFydERhdGEsIGRvZXMgbm90IHdvcmsgd2l0aCBmbGlwcGVkIGRhdGFcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW1zIHNvcnRMYWJlbCAsIHNvcnRUeXBlXHJcbiAgICAgKiBAcmV0dXJucyBbXSBzb3J0ZWQgZGF0YVxyXG4gICAgICovXHJcbiAgICBvcmdhbml6ZUNoYXJ0RGF0YShzb3J0UGFyYW0sIHNvcnRUeXBlKSB7XHJcbiAgICAgICAgbGV0IGNoYXJ0ID0gdGhpcyxcclxuICAgICAgICAgICAgb3JnYW5pemVkRGF0YSxcclxuICAgICAgICAgICAgZGF0YVR5cGUsXHJcbiAgICAgICAgICAgIGRhdGFUYWJsZUtleXMgPSBjaGFydC5kYXRhLmRhdGFUYWJsZUtleXMsXHJcbiAgICAgICAgICAgIHNvcnRMYWJlbCA9IHNvcnRQYXJhbTtcclxuXHJcbiAgICAgICAgLy9JZiBzb3J0TGFiZWwgZG9lc24ndCBleGlzdCwgc29ydCBvbiB0aGUgeCBheGlzIGxhYmVsIGJ5IGRlZmF1bHRcclxuICAgICAgICBpZiAoc29ydExhYmVsID09PSAnbm9uZScpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQga2V5IG9mIGRhdGFUYWJsZUtleXMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChrZXkubW9kZWwgPT09ICdsYWJlbCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBzb3J0TGFiZWwgPSBrZXkubmFtZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9SZW1vdmUgdW5kZXJzY29yZXMgZnJvbSBzb3J0TGFiZWxcclxuICAgICAgICBpZiAoc29ydExhYmVsKSB7XHJcbiAgICAgICAgICAgIHNvcnRMYWJlbCA9IHNvcnRMYWJlbC5yZXBsYWNlKC9fL2csICcgJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWNoYXJ0LmRhdGEuY2hhcnREYXRhWzBdW3NvcnRMYWJlbF0pIHtcclxuICAgICAgICAgICAgLy9DaGVjayBpZiB0aGUgc29ydCBsYWJlbCBpcyBhIGNhbGN1bGF0ZWRCeSBmaWVsZFxyXG4gICAgICAgICAgICBsZXQgaXNWYWxpZFNvcnRMYWJlbCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgb2YgZGF0YVRhYmxlS2V5cykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGtleS5vcGVyYXRpb24uaGFzT3duUHJvcGVydHkoJ2NhbGN1bGF0ZWRCeScpICYmIGtleS5vcGVyYXRpb24uY2FsY3VsYXRlZEJ5WzBdID09PSBzb3J0TGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBzb3J0TGFiZWwgPSBrZXkubmFtZS5yZXBsYWNlKC9fL2csICcgJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNWYWxpZFNvcnRMYWJlbCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9JZiBpdCdzIG5vdCBhIHZhbGlkIHNvcnQgbGFiZWwsIHJldHVybiBhbmQgZG9uJ3Qgc29ydCB0aGUgZGF0YVxyXG4gICAgICAgICAgICBpZiAoIWlzVmFsaWRTb3J0TGFiZWwpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ05vdCBhIHZhbGlkIHNvcnQnKTtcclxuICAgICAgICAgICAgICAgIC8vdGhyb3cgbmV3IEVycm9yKCdOb3QgYSB2YWxpZCBzb3J0Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vQ2hlY2sgdGhlIGRhdGEgdHlwZSB0byBkZXRlcm1pbmUgd2hpY2ggbG9naWMgdG8gZmxvdyB0aHJvdWdoXHJcbiAgICAgICAgZm9yIChsZXQga2V5IG9mIGRhdGFUYWJsZUtleXMpIHtcclxuICAgICAgICAgICAgLy9Mb29wIHRocm91Z2ggZGF0YVRhYmxlS2V5cyB0byBmaW5kIHNvcnRMYWJlbFxyXG4gICAgICAgICAgICBpZiAoa2V5Lm5hbWUucmVwbGFjZSgvXy9nLCAnICcpID09PSBzb3J0TGFiZWwpIHtcclxuICAgICAgICAgICAgICAgIGRhdGFUeXBlID0ga2V5LnR5cGU7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9EYXRlIHNvcnRpbmdcclxuICAgICAgICBpZiAoZGF0YVR5cGUgIT0gbnVsbCAmJiBkYXRhVHlwZSA9PT0gJ0RBVEUnKSB7XHJcbiAgICAgICAgICAgIG9yZ2FuaXplZERhdGEgPSBjaGFydC5kYXRhLmNoYXJ0RGF0YS5zb3J0KChhLCBiKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoYVtzb3J0TGFiZWxdKSAtIG5ldyBEYXRlKGJbc29ydExhYmVsXSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YVR5cGUgIT0gbnVsbCAmJiBkYXRhVHlwZSA9PT0gJ05VTUJFUicpIHtcclxuICAgICAgICAgICAgb3JnYW5pemVkRGF0YSA9IGNoYXJ0LmRhdGEuY2hhcnREYXRhLnNvcnQoKGEsIGIpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghaXNOYU4oYVtzb3J0TGFiZWxdKSAmJiAhaXNOYU4oYltzb3J0TGFiZWxdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhW3NvcnRMYWJlbF0gLSBiW3NvcnRMYWJlbF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG9yZ2FuaXplZERhdGEgPSBjaGFydC5kYXRhLmNoYXJ0RGF0YS5zb3J0KChhLCBiKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKGFbc29ydExhYmVsXSkgJiYgIWlzTmFOKGJbc29ydExhYmVsXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VGbG9hdChhW3NvcnRMYWJlbF0pIDwgcGFyc2VGbG9hdChiW3NvcnRMYWJlbF0pKSB7IC8vc29ydCBzdHJpbmcgYXNjZW5kaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlRmxvYXQoYVtzb3J0TGFiZWxdKSA+IHBhcnNlRmxvYXQoYltzb3J0TGFiZWxdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoYVtzb3J0TGFiZWxdLnRvTG93ZXJDYXNlKCkgPCBiW3NvcnRMYWJlbF0udG9Mb3dlckNhc2UoKSkgeyAvL3NvcnQgc3RyaW5nIGFzY2VuZGluZ1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChhW3NvcnRMYWJlbF0udG9Mb3dlckNhc2UoKSA+IGJbc29ydExhYmVsXS50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzd2l0Y2ggKHNvcnRUeXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ3NvcnRBc2NlbmRpbmcnOlxyXG4gICAgICAgICAgICBjYXNlICdhc2NlbmRpbmcnOlxyXG4gICAgICAgICAgICAgICAgY2hhcnQuZGF0YS5jaGFydERhdGEgPSBvcmdhbml6ZWREYXRhO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ3NvcnREZXNjZW5kaW5nJzpcclxuICAgICAgICAgICAgY2FzZSAnZGVzY2VuZGluZyc6XHJcbiAgICAgICAgICAgICAgICBjaGFydC5kYXRhLmNoYXJ0RGF0YSA9IG9yZ2FuaXplZERhdGEucmV2ZXJzZSgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICBjaGFydC5kYXRhLmNoYXJ0RGF0YSA9IG9yZ2FuaXplZERhdGE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKnNldFRpcERhdGFcclxuICAgICAqXHJcbiAgICAgKiBjcmVhdGVzIGRhdGEgb2JqZWN0IHRvIGRpc3BsYXkgaW4gdG9vbHRpcFxyXG4gICAgICogQHBhcmFtc1xyXG4gICAgICogQHJldHVybnMge3t9fVxyXG4gICAgICovXHJcbiAgICBzZXRUaXBEYXRhKGQsIGkpIHtcclxuICAgICAgICBsZXQgY2hhcnQgPSB0aGlzLFxyXG4gICAgICAgICAgICBkYXRhID0gY2hhcnQuY3VycmVudERhdGEuY2hhcnREYXRhLFxyXG4gICAgICAgICAgICAvL0dldCBDb2xvciBmcm9tIGNoYXJ0RGF0YSBhbmQgYWRkIHRvIG9iamVjdFxyXG4gICAgICAgICAgICBjb2xvciA9IGNoYXJ0Ll92YXJzLmNvbG9yLFxyXG4gICAgICAgICAgICB0aXRsZSA9IGRbY2hhcnQuZGF0YS5kYXRhVGFibGUubGFiZWxdLFxyXG4gICAgICAgICAgICBkYXRhVGFibGUgPSB7fTtcclxuXHJcbiAgICAgICAgaWYgKGNoYXJ0LmNvbmZpZy50eXBlID09PSAndHJlZW1hcCcpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaXRlbSBpbiBkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXRlbSAhPT0gY2hhcnQuZGF0YS5kYXRhVGFibGUubGFiZWwgJiYgaXRlbSAhPT0gJ1BhcmVudCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhVGFibGVbaXRlbV0gPSBkW2l0ZW1dO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChjaGFydC5jb25maWcudHlwZSA9PT0gJ2JhcicgfHwgY2hhcnQuY29uZmlnLnR5cGUgPT09ICdsaW5lJyB8fCBjaGFydC5jb25maWcudHlwZSA9PT0gJ2FyZWEnKSB7XHJcbiAgICAgICAgICAgIHRpdGxlID0gZGF0YVtpXVtjaGFydC5kYXRhLmRhdGFUYWJsZS5sYWJlbF07XHJcbiAgICAgICAgICAgIGZvciAobGV0IGl0ZW0gaW4gZGF0YVtpXSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0gIT09IGNoYXJ0LmRhdGEuZGF0YVRhYmxlLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YVRhYmxlW2l0ZW1dID0gZGF0YVtpXVtpdGVtXTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKGNoYXJ0LmNvbmZpZy50eXBlID09PSAnZ2FudHQnKSB7XHJcbiAgICAgICAgICAgIC8vQ2FsY3VsYXRlIGxlbmd0aCBvZiBkYXRlc1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpdGVtIGluIGRhdGFbaV0pIHtcclxuICAgICAgICAgICAgICAgIGlmIChkYXRhW2ldLmhhc093blByb3BlcnR5KGl0ZW0pICYmIGl0ZW0gIT09IGNoYXJ0LmRhdGEuZGF0YVRhYmxlLmdyb3VwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YVRhYmxlW2l0ZW1dID0gZGF0YVtpXVtpdGVtXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbGV0IHN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgZW5kLFxyXG4gICAgICAgICAgICAgICAgZGlmZmVyZW5jZSxcclxuICAgICAgICAgICAgICAgIC8vQ2FsY3VsdGluZyBkdXJhdGlvbiBvZiBkYXRlIHJhbmdlcyB0byBhZGQgdG8gdG9vbHRpcFxyXG4gICAgICAgICAgICAgICAgbnVtUGFpcnMgPSBNYXRoLmZsb29yKE9iamVjdC5rZXlzKGNoYXJ0LmRhdGEuZGF0YVRhYmxlKS5sZW5ndGggLyAyKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAxOyBqIDw9IG51bVBhaXJzOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gbmV3IERhdGUoZGF0YVtpXVtjaGFydC5kYXRhLmRhdGFUYWJsZVsnc3RhcnQgJyArIGpdXSk7XHJcbiAgICAgICAgICAgICAgICBlbmQgPSBuZXcgRGF0ZShkYXRhW2ldW2NoYXJ0LmRhdGEuZGF0YVRhYmxlWydlbmQgJyArIGpdXSk7XHJcbiAgICAgICAgICAgICAgICBkaWZmZXJlbmNlID0gZW5kLmdldFRpbWUoKSAtIHN0YXJ0LmdldFRpbWUoKTtcclxuICAgICAgICAgICAgICAgIGRhdGFUYWJsZVsnRHVyYXRpb24gJyArIGpdID0gTWF0aC5jZWlsKGRpZmZlcmVuY2UgLyAoMTAwMCAqIDYwICogNjAgKiAyNCkpICsgJyBkYXlzJztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGl0bGUgPSBkYXRhW2ldW2NoYXJ0LmRhdGEuZGF0YVRhYmxlLmdyb3VwXTtcclxuICAgICAgICB9IGVsc2UgaWYgKGNoYXJ0LmNvbmZpZy50eXBlID09PSAncGllJyB8fCBjaGFydC5jb25maWcudHlwZSA9PT0gJ3JhZGlhbCcpIHtcclxuICAgICAgICAgICAgdGl0bGUgPSBkLmxhYmVsO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpdGVtIGluIGQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpdGVtICE9PSAnbGFiZWwnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YVRhYmxlW2l0ZW1dID0gZFtpdGVtXTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGVsZXRlIGRhdGFUYWJsZS5vdXRlclJhZGl1cztcclxuICAgICAgICB9IGVsc2UgaWYgKGNoYXJ0LmNvbmZpZy50eXBlID09PSAnY2lyY2xlcGFjaycgfHwgY2hhcnQuY29uZmlnLnR5cGUgPT09ICdzdW5idXJzdCcpIHtcclxuICAgICAgICAgICAgdGl0bGUgPSBkLmRhdGEubmFtZTtcclxuICAgICAgICAgICAgZGF0YVRhYmxlW2NoYXJ0LmRhdGEuZGF0YVRhYmxlLnZhbHVlXSA9IGQudmFsdWU7XHJcbiAgICAgICAgfSBlbHNlIGlmIChjaGFydC5jb25maWcudHlwZSA9PT0gJ2Nsb3VkJykge1xyXG4gICAgICAgICAgICB0aXRsZSA9IGRbY2hhcnQuZGF0YS5kYXRhVGFibGUubGFiZWxdO1xyXG4gICAgICAgICAgICBkYXRhVGFibGVbY2hhcnQuZGF0YS5kYXRhVGFibGUudmFsdWVdID0gZFtjaGFydC5kYXRhLmRhdGFUYWJsZS52YWx1ZV07XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZFtjaGFydC5kYXRhLmRhdGFUYWJsZVsndG9vbHRpcCAxJ11dICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgZGF0YVRhYmxlW2NoYXJ0LmRhdGEuZGF0YVRhYmxlWyd0b29sdGlwIDEnXV0gPSBkW2NoYXJ0LmRhdGEuZGF0YVRhYmxlWyd0b29sdGlwIDEnXV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKGNoYXJ0LmNvbmZpZy50eXBlID09PSAnaGVhdG1hcCcpIHtcclxuICAgICAgICAgICAgdGl0bGUgPSBkLnlBeGlzTmFtZSArICcgdG8gJyArIGQueEF4aXNOYW1lO1xyXG4gICAgICAgICAgICBpZiAoZC5oYXNPd25Qcm9wZXJ0eSgndmFsdWUnKSkge1xyXG4gICAgICAgICAgICAgICAgZGF0YVRhYmxlLnZhbHVlID0gZC52YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGxldCB0b29sdGlwIGluIGQpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0b29sdGlwLmluZGV4T2YoJ3Rvb2x0aXAnKSA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YVRhYmxlW2NoYXJ0LmRhdGEuZGF0YVRhYmxlW3Rvb2x0aXBdXSA9IGRbdG9vbHRpcF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKGNoYXJ0LmNvbmZpZy50eXBlID09PSAnY2x1c3RlcmdyYW0nKSB7XHJcbiAgICAgICAgICAgIC8vdGl0bGUgPSBkLnlfcGF0aC5yZXBsYWNlKC9cXC4vZywgJ+KGkicpICsgJzwvYnI+JyArIGQueF9wYXRoLnJlcGxhY2UoL1xcLi9nLCAn4oaSJyk7XHJcbiAgICAgICAgICAgIC8vQnVpbGQgc3RyaW5ncyBmb3IgdG9vbHRpcFxyXG4gICAgICAgICAgICBsZXQgeVRlbXAgPSBkLnlfcGF0aC5zcGxpdCgnLicpLFxyXG4gICAgICAgICAgICAgICAgeVRlbXBTdHJpbmcgPSAnJyxcclxuICAgICAgICAgICAgICAgIHhUZW1wID0gZC54X3BhdGguc3BsaXQoJy4nKSxcclxuICAgICAgICAgICAgICAgIHhUZW1wU3RyaW5nID0gJyc7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHlUZW1wLmxlbmd0aDsgaysrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hhcnQuZGF0YS5kYXRhVGFibGVbJ3lfY2F0ZWdvcnkgJyArIChrICsgMSldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeVRlbXBTdHJpbmcgKz0geVRlbXBba10gKz0gJyAoJyArIGNoYXJ0LmRhdGEuZGF0YVRhYmxlWyd5X2NhdGVnb3J5ICcgKyAoayArIDEpXSArICcpJztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeVRlbXBTdHJpbmcgKz0geVRlbXBba10gKz0gJyAoJyArIGNoYXJ0LmRhdGEuZGF0YVRhYmxlLnlfY2F0ZWdvcnkgKyAnKSc7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGsgIT09IHlUZW1wLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICB5VGVtcFN0cmluZyArPSAnIOKGkiAnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgeFRlbXAubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChjaGFydC5kYXRhLmRhdGFUYWJsZVsneF9jYXRlZ29yeSAnICsgKGsgKyAxKV0pIHtcclxuICAgICAgICAgICAgICAgICAgICB4VGVtcFN0cmluZyArPSB4VGVtcFtrXSArPSAnICgnICsgY2hhcnQuZGF0YS5kYXRhVGFibGVbJ3hfY2F0ZWdvcnkgJyArIChrICsgMSldICsgJyknO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB4VGVtcFN0cmluZyArPSB4VGVtcFtrXSArPSAnICgnICsgY2hhcnQuZGF0YS5kYXRhVGFibGUueF9jYXRlZ29yeSArICcpJztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoayAhPT0geFRlbXAubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHhUZW1wU3RyaW5nICs9ICcg4oaSICc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRpdGxlID0gJ1kgPiAnICsgeVRlbXBTdHJpbmcgKyAnPGJyPicgKyAnWCA+ICcgKyB4VGVtcFN0cmluZztcclxuICAgICAgICAgICAgaWYgKGQuaGFzT3duUHJvcGVydHkoJ3ZhbHVlJykpIHtcclxuICAgICAgICAgICAgICAgIGRhdGFUYWJsZS52YWx1ZSA9IGQudmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChsZXQgdG9vbHRpcCBpbiBkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodG9vbHRpcC5pbmRleE9mKCd0b29sdGlwJykgPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFUYWJsZVtjaGFydC5kYXRhLmRhdGFUYWJsZVt0b29sdGlwXV0gPSBkW3Rvb2x0aXBdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChjaGFydC5jb25maWcudHlwZSA9PT0gJ3NhbmtleScpIHtcclxuICAgICAgICAgICAgdGl0bGUgPSBkLnNvdXJjZS5uYW1lLnNsaWNlKDAsIC0yKSArICcgdG8gJyArIGQudGFyZ2V0Lm5hbWUuc2xpY2UoMCwgLTIpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGQuaGFzT3duUHJvcGVydHkoJ3ZhbHVlJykpIHtcclxuICAgICAgICAgICAgICAgIGRhdGFUYWJsZS52YWx1ZSA9IGQudmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKGNoYXJ0LmNvbmZpZy50eXBlID09PSAnc2luZ2xlYXhpcycpIHtcclxuICAgICAgICAgICAgdGl0bGUgPSBkLmRhdGFbY2hhcnQuZGF0YS5kYXRhVGFibGUubGFiZWxdO1xyXG5cclxuICAgICAgICAgICAgZm9yIChsZXQgaXRlbSBpbiBjaGFydC5kYXRhLmRhdGFUYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0gIT09ICdsYWJlbCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhVGFibGVbY2hhcnQuZGF0YS5kYXRhVGFibGVbaXRlbV1dID0gZC5kYXRhW2NoYXJ0LmRhdGEuZGF0YVRhYmxlW2l0ZW1dXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGl0ZW0gaW4gZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0gIT09IGNoYXJ0LmRhdGEuZGF0YVRhYmxlLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YVRhYmxlW2l0ZW1dID0gZFtpdGVtXTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICByZXR1cm4geyAnZGF0YSc6IGQsICd0aXBEYXRhJzogZGF0YVRhYmxlLCAnaW5kZXgnOiBpLCAndGl0bGUnOiB0aXRsZSwgJ2NvbG9yJzogY29sb3IsICd2aXonOiBjaGFydC5jb25maWcudHlwZSB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogRHJhdyBmdW5jdGlvbnMgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuICAgIC8qKmdlbmVyYXRlU1ZHXHJcbiAgICAgKmNyZWF0ZXMgYW4gU1ZHIGVsZW1lbnQgb24gdGhlIHBhbmVsXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtcyBjb250YWluZXIsIG1hcmdpbiwgbmFtZVxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgZ2VuZXJhdGVTVkcobGVnZW5kRGF0YSwgY3VzdG9tTWFyZ2luUGFyYW0sIGN1c3RvbVNpemVQYXJhbSkge1xyXG4gICAgICAgIGxldCBjaGFydCA9IHRoaXMsXHJcbiAgICAgICAgICAgIG1hcmdpbiA9IHt9LFxyXG4gICAgICAgICAgICBjb250YWluZXIgPSB7fSxcclxuICAgICAgICAgICAgZGltZW5zaW9ucyA9IGNoYXJ0LmNoYXJ0RGl2Lm5vZGUoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcclxuICAgICAgICAgICAgY3VzdG9tTWFyZ2lucyA9IGN1c3RvbU1hcmdpblBhcmFtLFxyXG4gICAgICAgICAgICBjdXN0b21TaXplID0gY3VzdG9tU2l6ZVBhcmFtLFxyXG4gICAgICAgICAgICB0ZXh0V2lkdGg7XHJcblxyXG4gICAgICAgIGlmIChjaGFydC5fdmFycy5jdXN0b21NYXJnaW5zKSB7XHJcbiAgICAgICAgICAgIGN1c3RvbU1hcmdpbnMgPSBjaGFydC5fdmFycy5jdXN0b21NYXJnaW5zO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9zZXQgbWFyZ2luc1xyXG4gICAgICAgIGlmICghY3VzdG9tTWFyZ2lucykge1xyXG4gICAgICAgICAgICAvL2RlY2xhcmUgbWFyZ2lucyBpZiB0aGV5IGFyZW50IHBhc3NlZCBpblxyXG4gICAgICAgICAgICBtYXJnaW4gPSB7XHJcbiAgICAgICAgICAgICAgICB0b3A6IDU1LFxyXG4gICAgICAgICAgICAgICAgcmlnaHQ6IDUwLFxyXG4gICAgICAgICAgICAgICAgbGVmdDogMTAwLFxyXG4gICAgICAgICAgICAgICAgYm90dG9tOiA3MFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpZiAobGVnZW5kRGF0YSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobGVnZW5kRGF0YS5sZW5ndGggPD0gMykge1xyXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbi5ib3R0b20gPSA3MDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGVnZW5kRGF0YS5sZW5ndGggPD0gNikge1xyXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbi5ib3R0b20gPSA4NTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luLmJvdHRvbSA9IDEzMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG1hcmdpbiA9IGN1c3RvbU1hcmdpbnM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL3JlZHVjZSBtYXJnaW5zIGlmIGxlZ2VuZCBpcyB0b2dnbGVkIG9mZlxyXG4gICAgICAgIC8vVE9ETyBtYWtlIHRoaXMgYmV0dGVyXHJcbiAgICAgICAgaWYgKGNoYXJ0Ll92YXJzLnRvZ2dsZUxlZ2VuZCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgaWYgKGNoYXJ0LmNvbmZpZy50eXBlID09PSAncGllJyB8fCBjaGFydC5jb25maWcudHlwZSA9PT0gJ3JhZGlhbCcgfHwgY2hhcnQuY29uZmlnLnR5cGUgPT09ICdjaXJjbGVwYWNrJyB8fCBjaGFydC5jb25maWcudHlwZSA9PT0gJ2hlYXRtYXAnKSB7XHJcbiAgICAgICAgICAgICAgICBtYXJnaW4ubGVmdCA9IDQwO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoYXJ0LmNvbmZpZy50eXBlID09PSAndHJlZW1hcCcgfHwgY2hhcnQuY29uZmlnLnR5cGUgPT09ICdiYXInIHx8IGNoYXJ0LmNvbmZpZy50eXBlID09PSAnZ2FudHQnIHx8IGNoYXJ0LmNvbmZpZy50eXBlID09PSAnc2NhdHRlcicgfHwgY2hhcnQuY29uZmlnLnR5cGUgPT09ICdsaW5lJykge1xyXG4gICAgICAgICAgICAgICAgbWFyZ2luLmJvdHRvbSA9IDQwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoY2hhcnQuY29uZmlnLnR5cGUgPT09ICdjbHVzdGVyZ3JhbScpIHtcclxuICAgICAgICAgICAgdGV4dFdpZHRoID0ganZDaGFydHMuZ2V0TWF4V2lkdGhGb3JBeGlzRGF0YSgneScsIGNoYXJ0LmxlZnRMYWJlbHMsIGNoYXJ0Ll92YXJzLCBkaW1lbnNpb25zLCBtYXJnaW4sIGNoYXJ0LmNoYXJ0RGl2LCBjaGFydC5jb25maWcudHlwZSk7XHJcbiAgICAgICAgICAgIG1hcmdpbi5sZWZ0ID0gTWF0aC5jZWlsKHRleHRXaWR0aCk7XHJcbiAgICAgICAgICAgIGlmIChtYXJnaW4ubGVmdCA8IDMwKSB7XHJcbiAgICAgICAgICAgICAgICBtYXJnaW4ubGVmdCA9IDMwO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0ZXh0V2lkdGggPSBqdkNoYXJ0cy5nZXRNYXhXaWR0aEZvckF4aXNEYXRhKCd5JywgY2hhcnQucmlnaHRMYWJlbHMsIGNoYXJ0Ll92YXJzLCBkaW1lbnNpb25zLCBtYXJnaW4sIGNoYXJ0LmNoYXJ0RGl2LCBjaGFydC5jb25maWcudHlwZSk7XHJcbiAgICAgICAgICAgIG1hcmdpbi50b3AgPSBNYXRoLmNlaWwodGV4dFdpZHRoKTtcclxuICAgICAgICAgICAgaWYgKG1hcmdpbi50b3AgPCAzMCkge1xyXG4gICAgICAgICAgICAgICAgbWFyZ2luLnRvcCA9IDMwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL3NldCB5QXhpcyBtYXJnaW5zXHJcbiAgICAgICAgaWYgKGNoYXJ0LmN1cnJlbnREYXRhICYmIGNoYXJ0LmN1cnJlbnREYXRhLnlBeGlzRGF0YSkge1xyXG4gICAgICAgICAgICB0ZXh0V2lkdGggPSBqdkNoYXJ0cy5nZXRNYXhXaWR0aEZvckF4aXNEYXRhKCd5JywgY2hhcnQuY3VycmVudERhdGEueUF4aXNEYXRhLCBjaGFydC5fdmFycywgZGltZW5zaW9ucywgbWFyZ2luLCBjaGFydC5jaGFydERpdiwgY2hhcnQuY29uZmlnLnR5cGUpO1xyXG4gICAgICAgICAgICBpZiAodGV4dFdpZHRoID4gMTAwICYmIGNoYXJ0LmNvbmZpZy50eXBlID09PSAnaGVhdG1hcCcpIHtcclxuICAgICAgICAgICAgICAgIHRleHRXaWR0aCA9IDEwMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjaGFydC5fdmFycy5oZWF0bWFwWW1hcmdpbiA9IHRleHRXaWR0aDtcclxuICAgICAgICAgICAgbWFyZ2luLmxlZnQgPSBNYXRoLmNlaWwodGV4dFdpZHRoKSArIDMwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9zZXQgeEF4aXMgdG9wIG1hcmdpbnNcclxuICAgICAgICBpZiAoY2hhcnQuY29uZmlnLnR5cGUgPT09ICdoZWF0bWFwJyAmJiBjaGFydC5jdXJyZW50RGF0YSAmJiBjaGFydC5jdXJyZW50RGF0YS54QXhpc0RhdGEpIHtcclxuICAgICAgICAgICAgdGV4dFdpZHRoID0ganZDaGFydHMuZ2V0TWF4V2lkdGhGb3JBeGlzRGF0YSgneCcsIGNoYXJ0LmN1cnJlbnREYXRhLnhBeGlzRGF0YSwgY2hhcnQuX3ZhcnMsIGRpbWVuc2lvbnMsIG1hcmdpbiwgY2hhcnQuY2hhcnREaXYsIGNoYXJ0LmNvbmZpZy50eXBlKTtcclxuICAgICAgICAgICAgLy9zdWJ0cmFjdCBzcGFjZSBmb3IgdGlsdFxyXG4gICAgICAgICAgICB0ZXh0V2lkdGggPSBNYXRoLmNlaWwodGV4dFdpZHRoKTtcclxuICAgICAgICAgICAgaWYgKHRleHRXaWR0aCA+IDEwMCkge1xyXG4gICAgICAgICAgICAgICAgdGV4dFdpZHRoID0gMTAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vc3BlY2lmaWMgdG8gaGVhdG1hcFxyXG4gICAgICAgICAgICAvL2lmIChjaGFydC5jb25maWcudHlwZSA9PT0gJ2hlYXRtYXAnKSB7XHJcbiAgICAgICAgICAgIGlmICh0ZXh0V2lkdGggPiAxMDApIHtcclxuICAgICAgICAgICAgICAgIHRleHRXaWR0aCA9IDEwMDtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0ZXh0V2lkdGggPCA4MCkge1xyXG4gICAgICAgICAgICAgICAgdGV4dFdpZHRoID0gODA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy99XHJcbiAgICAgICAgICAgIGNoYXJ0Ll92YXJzLmhlYXRtYXBYbWFyZ2luID0gdGV4dFdpZHRoO1xyXG4gICAgICAgICAgICBtYXJnaW4udG9wID0gdGV4dFdpZHRoO1xyXG4gICAgICAgICAgICBjdXN0b21TaXplID0ge307XHJcbiAgICAgICAgICAgIC8vc2V0IGNvbnRhaW5lclxyXG4gICAgICAgICAgICBjdXN0b21TaXplLndpZHRoID0gY2hhcnQuY3VycmVudERhdGEueEF4aXNEYXRhLnZhbHVlcy5sZW5ndGggKiAyMDtcclxuICAgICAgICAgICAgY3VzdG9tU2l6ZS5oZWlnaHQgPSBjaGFydC5jdXJyZW50RGF0YS55QXhpc0RhdGEudmFsdWVzLmxlbmd0aCAqIDIwO1xyXG5cclxuICAgICAgICAgICAgaWYgKGNoYXJ0Ll92YXJzLnRvZ2dsZUxlZ2VuZCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGR1bW15T2JqID0ge307XHJcbiAgICAgICAgICAgICAgICBkdW1teU9iai52YWx1ZXMgPSBjaGFydC5kYXRhLmhlYXREYXRhO1xyXG4gICAgICAgICAgICAgICAgZHVtbXlPYmoudmFsdWVzLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcclxuICAgICAgICAgICAgICAgIGR1bW15T2JqLmxhYmVsID0gJyc7XHJcbiAgICAgICAgICAgICAgICBkdW1teU9iai5taW4gPSBkdW1teU9iai52YWx1ZXNbMF07XHJcbiAgICAgICAgICAgICAgICBkdW1teU9iai5tYXggPSBkdW1teU9iai52YWx1ZXNbZHVtbXlPYmoudmFsdWVzLmxlbmd0aCAtIDFdO1xyXG5cclxuICAgICAgICAgICAgICAgIHRleHRXaWR0aCA9IGp2Q2hhcnRzLmdldE1heFdpZHRoRm9yQXhpc0RhdGEoJ3knLCBkdW1teU9iaiwgY2hhcnQuX3ZhcnMsIGRpbWVuc2lvbnMsIG1hcmdpbiwgY2hhcnQuY2hhcnREaXYsIGNoYXJ0LmNvbmZpZy50eXBlKTtcclxuICAgICAgICAgICAgICAgIGNoYXJ0LmNvbmZpZy5oZWF0V2lkdGggPSBNYXRoLmNlaWwodGV4dFdpZHRoKSArIDMwO1xyXG4gICAgICAgICAgICAgICAgbWFyZ2luLmxlZnQgPSBtYXJnaW4ubGVmdCArIGNoYXJ0LmNvbmZpZy5oZWF0V2lkdGg7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChjdXN0b21TaXplLndpZHRoICsgbWFyZ2luLmxlZnQgKyBtYXJnaW4ucmlnaHQgPCBkaW1lbnNpb25zLndpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICBtYXJnaW4ucmlnaHQgPSBwYXJzZUludChkaW1lbnNpb25zLndpZHRoLCAxMCkgLSBtYXJnaW4ubGVmdCAtIGN1c3RvbVNpemUud2lkdGggLSAyMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY3VzdG9tU2l6ZS5oZWlnaHQgKyBtYXJnaW4udG9wICsgbWFyZ2luLmJvdHRvbSA8IGRpbWVuc2lvbnMuaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICBtYXJnaW4uYm90dG9tID0gcGFyc2VJbnQoZGltZW5zaW9ucy5oZWlnaHQsIDEwKSAtIG1hcmdpbi50b3AgLSBjdXN0b21TaXplLmhlaWdodCAtIDEwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN1c3RvbVNpemUud2lkdGggKz0gbWFyZ2luLnJpZ2h0ICsgbWFyZ2luLmxlZnQ7XHJcbiAgICAgICAgICAgIGN1c3RvbVNpemUuaGVpZ2h0ICs9IG1hcmdpbi50b3AgKyBtYXJnaW4uYm90dG9tO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9zZXQgY29udGFpbmVyIGF0dHJpYnV0ZXNcclxuICAgICAgICAvL1NldCBzdmcgc2l6ZSBiYXNlZCBvbiBjYWxjdWxhdGlvbiBtYXJnaW5zIG9yIGN1c3RvbSBzaXplIGlmIHNwZWNpZmllZFxyXG4gICAgICAgIGlmIChjdXN0b21TaXplICYmIGN1c3RvbVNpemUuaGFzT3duUHJvcGVydHkoJ2hlaWdodCcpKSB7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lci5oZWlnaHQgPSBjdXN0b21TaXplLmhlaWdodCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lci5oZWlnaHQgPSBwYXJzZUludChkaW1lbnNpb25zLmhlaWdodCwgMTApIC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b207XHJcbiAgICAgICAgICAgIGlmIChjb250YWluZXIuaGVpZ2h0IDw9IDUwKSB7XHJcbiAgICAgICAgICAgICAgICBtYXJnaW4udG9wID0gMTA7XHJcbiAgICAgICAgICAgICAgICBtYXJnaW4uYm90dG9tID0gMTA7XHJcbiAgICAgICAgICAgICAgICBjb250YWluZXIuaGVpZ2h0ID0gcGFyc2VJbnQoZGltZW5zaW9ucy5oZWlnaHQsIDEwKSAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tO1xyXG4gICAgICAgICAgICAgICAgY2hhcnQuX3ZhcnMueExhYmVsRm9udFNpemUgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoY3VzdG9tU2l6ZSAmJiBjdXN0b21TaXplLmhhc093blByb3BlcnR5KCd3aWR0aCcpKSB7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lci53aWR0aCA9IGN1c3RvbVNpemUud2lkdGggLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb250YWluZXIud2lkdGggPSBwYXJzZUludChkaW1lbnNpb25zLndpZHRoLCAxMCkgLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vYWRkIG1hcmdpbiBhbmQgY29udGFpbmVyIHRvIGNoYXJ0IGNvbmZpZyBvYmplY3RcclxuICAgICAgICBjaGFydC5jb25maWcubWFyZ2luID0gbWFyZ2luO1xyXG4gICAgICAgIGNoYXJ0LmNvbmZpZy5jb250YWluZXIgPSBjb250YWluZXI7XHJcblxyXG4gICAgICAgIC8vcmVtb3ZlIG9sZCBzdmcgaWYgaXQgZXhpc3RzXHJcbiAgICAgICAgY2hhcnQuc3ZnID0gY2hhcnQuY2hhcnREaXYuc2VsZWN0KCdzdmcnKS5yZW1vdmUoKTtcclxuXHJcbiAgICAgICAgLy9zdmcgbGF5ZXJcclxuICAgICAgICBpZiAoY2hhcnQuY29uZmlnLnR5cGUgPT09ICdoZWF0bWFwJyB8fCBjaGFydC5jb25maWcudHlwZSA9PT0gJ3NpbmdsZWF4aXMnKSB7XHJcbiAgICAgICAgICAgIGNoYXJ0LnN2ZyA9IGNoYXJ0LmNoYXJ0RGl2LmFwcGVuZCgnc3ZnJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdlZGl0YWJsZS1zdmcnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgY29udGFpbmVyLndpZHRoICsgbWFyZ2luLmxlZnQgKyBtYXJnaW4ucmlnaHQpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgY29udGFpbmVyLmhlaWdodCArIG1hcmdpbi50b3AgKyBtYXJnaW4uYm90dG9tKVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnY29udGFpbmVyJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBtYXJnaW4ubGVmdCArICcsJyArIChtYXJnaW4udG9wKSArICcpJyk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChjaGFydC5jb25maWcudHlwZSA9PT0gJ2NsdXN0ZXJncmFtJykge1xyXG4gICAgICAgICAgICB2YXIgc2l6ZVdpZHRoID0gY2hhcnQucmlnaHRMZWF2ZXMubGVuZ3RoICogMjA7XHJcbiAgICAgICAgICAgIGlmIChzaXplV2lkdGggPCBjb250YWluZXIud2lkdGgpIHtcclxuICAgICAgICAgICAgICAgIHNpemVXaWR0aCA9IGNvbnRhaW5lci53aWR0aDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHNpemVIZWlnaHQgPSBjaGFydC5sZWZ0TGVhdmVzLmxlbmd0aCAqIDIwO1xyXG4gICAgICAgICAgICBpZiAoc2l6ZUhlaWdodCA8IGNvbnRhaW5lci5oZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgIHNpemVIZWlnaHQgPSBjb250YWluZXIuaGVpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjaGFydC5zdmcgPSBjaGFydC5jaGFydERpdi5hcHBlbmQoJ3N2ZycpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZWRpdGFibGUtc3ZnJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIHNpemVXaWR0aCArIG1hcmdpbi5sZWZ0ICsgbWFyZ2luLnJpZ2h0KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIHNpemVIZWlnaHQgKyBtYXJnaW4udG9wICsgbWFyZ2luLmJvdHRvbSlcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIG1hcmdpbi5sZWZ0ICsgJywnICsgKG1hcmdpbi50b3ApICsgJyknKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjaGFydC5zdmcgPSBjaGFydC5jaGFydERpdi5hcHBlbmQoJ3N2ZycpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZWRpdGFibGUtc3ZnJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIGNvbnRhaW5lci53aWR0aCArIG1hcmdpbi5sZWZ0ICsgbWFyZ2luLnJpZ2h0KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGNvbnRhaW5lci5oZWlnaHQgKyBtYXJnaW4udG9wICsgbWFyZ2luLmJvdHRvbSlcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIG1hcmdpbi5sZWZ0ICsgJywnICsgKG1hcmdpbi50b3ApICsgJyknKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vVE9ETyBtb3ZlIHRvIGVkaXQgbW9kZVxyXG4gICAgICAgIGlmIChjaGFydC5fdmFycy5iYWNrZ3JvdW5kQ29sb3IgIT09ICdub25lJykge1xyXG4gICAgICAgICAgICBjaGFydC5jb2xvckJhY2tncm91bmQoY2hhcnQuX3ZhcnMuYmFja2dyb3VuZENvbG9yKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqZ2VuZXJhdGVYQXhpc1xyXG4gICAgICogY3JlYXRlcyB4IGF4aXMgb24gdGhlIHN2Z1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbXMgeEF4aXNEYXRhXHJcbiAgICAgKi9cclxuICAgIGdlbmVyYXRlWEF4aXMoeEF4aXNEYXRhLCB0aWNrcykge1xyXG4gICAgICAgIC8vZGVjbGFyZSB2YXJpYWJsZXNcclxuICAgICAgICBsZXQgY2hhcnQgPSB0aGlzLFxyXG4gICAgICAgICAgICB4QXhpcyxcclxuICAgICAgICAgICAgLy9OZWVkIHRvIGdldFhBeGlzU2NhbGUgZWFjaCB0aW1lIHNvIHRoYXQgYXhpcyB1cGRhdGVzIG9uIHJlc2l6ZVxyXG4gICAgICAgICAgICB4QXhpc1NjYWxlID0ganZDaGFydHMuZ2V0QXhpc1NjYWxlKCd4JywgeEF4aXNEYXRhLCBjaGFydC5jb25maWcuY29udGFpbmVyLCBjaGFydC5fdmFycyksXHJcbiAgICAgICAgICAgIGNvbnRhaW5lckhlaWdodCA9IGNoYXJ0LmNvbmZpZy5jb250YWluZXIuaGVpZ2h0LFxyXG4gICAgICAgICAgICBjb250YWluZXJXaWR0aCA9IGNoYXJ0LmNvbmZpZy5jb250YWluZXIud2lkdGgsXHJcbiAgICAgICAgICAgIHhBeGlzQ2xhc3MgPSAneEF4aXNMYWJlbHMgZWRpdGFibGUgZWRpdGFibGUteEF4aXMgZWRpdGFibGUtdGV4dCcsXHJcbiAgICAgICAgICAgIHRpY2tTaXplID0gMCxcclxuICAgICAgICAgICAgYXhpc0hlaWdodCA9IGNvbnRhaW5lckhlaWdodCxcclxuICAgICAgICAgICAgeENvbnRlbnQsXHJcbiAgICAgICAgICAgIHhBeGlzR3JvdXAsXHJcbiAgICAgICAgICAgIGZvcm1hdFZhbHVlVHlwZTtcclxuXHJcbiAgICAgICAgLy9hc3NpZ24gY3NzIGNsYXNzIGZvciBlZGl0IG1vZGVcclxuICAgICAgICAvL2lmIHRoZSBheGlzIGlzIG51bWJlcnMgYWRkIGVkaXRhYmxlLW51bVxyXG4gICAgICAgIGlmICh4QXhpc0RhdGEuZGF0YVR5cGUgPT09ICdOVU1CRVInKSB7XHJcbiAgICAgICAgICAgIHhBeGlzQ2xhc3MgKz0gJyBlZGl0YWJsZS1udW0nO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9yZW1vdmUgcHJldmlvdXMgeEF4aXMgY29udGFpbmVyIGlmIGl0cyB0aGVyZVxyXG4gICAgICAgIGNoYXJ0LnN2Zy5zZWxlY3RBbGwoJy54QXhpc0NvbnRhaW5lcicpLnJlbW92ZSgpO1xyXG5cclxuICAgICAgICAvL1NhdmUgdGhlIGF4aXMgc2NhbGUgdG8gY2hhcnQgb2JqZWN0XHJcbiAgICAgICAgY2hhcnQuY3VycmVudERhdGEueEF4aXNTY2FsZSA9IHhBeGlzU2NhbGU7XHJcblxyXG4gICAgICAgIGlmIChjaGFydC5jdXJyZW50RGF0YS54QXhpc0RhdGEuZGF0YVR5cGUgPT09ICdOVU1CRVInKSB7XHJcbiAgICAgICAgICAgIHRpY2tTaXplID0gNTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vY3JlYXRlIHhBeGlzIGRyYXdpbmcgZnVuY3Rpb25cclxuICAgICAgICBpZiAoY2hhcnQuY29uZmlnLnR5cGUgPT09ICdzaW5nbGVheGlzJykge1xyXG4gICAgICAgICAgICB4QXhpcyA9IGQzLmF4aXNUb3AoeEF4aXNTY2FsZSlcclxuICAgICAgICAgICAgICAgIC50aWNrU2l6ZSh0aWNrU2l6ZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgeEF4aXMgPSBkMy5heGlzQm90dG9tKHhBeGlzU2NhbGUpXHJcbiAgICAgICAgICAgICAgICAudGlja1NpemUodGlja1NpemUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRpY2tzKSB7XHJcbiAgICAgICAgICAgIHhBeGlzLnRpY2tzKHRpY2tzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChjaGFydC5jb25maWcudHlwZSA9PT0gJ3NpbmdsZWF4aXMnKSB7Ly9Gb3IgYW55IGF4ZXMgdGhhdCBhcmUgb24gdG9wIG9mIHRoZSBkYXRhXHJcbiAgICAgICAgICAgIGF4aXNIZWlnaHQgPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgeENvbnRlbnQgPSBjaGFydC5zdmcuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3hBeGlzQ29udGFpbmVyJylcclxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwnICsgKGF4aXNIZWlnaHQpICsgJyknKTtcclxuXHJcbiAgICAgICAgeEF4aXNHcm91cCA9IHhDb250ZW50LmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICd4QXhpcycpXHJcbiAgICAgICAgICAgIC5jYWxsKHhBeGlzKTtcclxuXHJcbiAgICAgICAgZm9ybWF0VmFsdWVUeXBlID0ganZDaGFydHMuanZGb3JtYXRWYWx1ZVR5cGUoeEF4aXNEYXRhLnZhbHVlcyk7XHJcblxyXG4gICAgICAgIC8vU3R5bGluZyB0aGUgYXhpc1xyXG4gICAgICAgIHhBeGlzR3JvdXAuc2VsZWN0KCdwYXRoJylcclxuICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsIGNoYXJ0Ll92YXJzLmF4aXNDb2xvcilcclxuICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIGNoYXJ0Ll92YXJzLnN0cm9rZVdpZHRoKTtcclxuXHJcbiAgICAgICAgLy9TdHlsaW5nIGZvciB0aWNrc1xyXG4gICAgICAgIHhBeGlzR3JvdXAuc2VsZWN0QWxsKCdsaW5lJylcclxuICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsIGNoYXJ0Ll92YXJzLmF4aXNDb2xvcilcclxuICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIGNoYXJ0Ll92YXJzLnN0cm9rZSk7XHJcblxyXG4gICAgICAgIC8vU3R5bGluZyB0aGUgbGFiZWxzIGZvciBlYWNoIHBpZWNlIG9mIGRhdGFcclxuICAgICAgICB4QXhpc0dyb3VwLnNlbGVjdEFsbCgndGV4dCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgY2hhcnQuX3ZhcnMuZm9udENvbG9yKS8vQ3VzdG9taXplIHRoZSBjb2xvciBvZiBheGlzIGxhYmVsc1xyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCB4QXhpc0NsYXNzKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCdmb250LXNpemUnLCBjaGFydC5fdmFycy5mb250U2l6ZSlcclxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwgMyknKVxyXG4gICAgICAgICAgICAudGV4dCgoZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHhBeGlzRGF0YS5kYXRhVHlwZSA9PT0gJ05VTUJFUicgfHwgY2hhcnQuX3ZhcnMucm90YXRlQXhpcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBqdkNoYXJ0cy5qdkZvcm1hdFZhbHVlKGQsIGZvcm1hdFZhbHVlVHlwZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZDtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vU3R5bGluZyB0aGUgbGFiZWwgZm9yIHRoZSBlbnRpcmUgYXhpc1xyXG4gICAgICAgIHhDb250ZW50LmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICd4TGFiZWwnKVxyXG4gICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3hMYWJlbCBlZGl0YWJsZSBlZGl0YWJsZS10ZXh0IGVkaXRhYmxlLWNvbnRlbnQnKVxyXG4gICAgICAgICAgICAuYXR0cigndGV4dC1hbmNob3InLCAnbWlkZGxlJylcclxuICAgICAgICAgICAgLmF0dHIoJ2ZvbnQtc2l6ZScsIGNoYXJ0Ll92YXJzLmZvbnRTaXplKVxyXG4gICAgICAgICAgICAudGV4dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoeEF4aXNEYXRhLmRhdGFUeXBlID09PSAnREFURScpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geEF4aXNEYXRhLmxhYmVsO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgY29udGFpbmVyV2lkdGggLyAyICsgJywgMzMpJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqRm9ybWF0WEF4aXNMYWJlbHNcclxuICAgICAqXHJcbiAgICAgKiBJZiB4LWF4aXMgbGFiZWxzIGFyZSB0b28gbG9uZy9vdmVybGFwcGluZywgdGhleSB3aWxsIGJlIGhpZGRlbi9zaG9ydGVuZWRcclxuICAgICAqL1xyXG4gICAgZm9ybWF0WEF4aXNMYWJlbHMoZGF0YUxlbmd0aCwgcmVjdXJzaW9uKSB7XHJcbiAgICAgICAgbGV0IGNoYXJ0ID0gdGhpcyxcclxuICAgICAgICAgICAgc2hvd0F4aXNMYWJlbHMgPSB0cnVlLFxyXG4gICAgICAgICAgICB4QXhpc0xlbmd0aCA9IGNoYXJ0LmNvbmZpZy5jb250YWluZXIud2lkdGgsXHJcbiAgICAgICAgICAgIHRleHRXaWR0aCA9IFtdLFxyXG4gICAgICAgICAgICBmb3JtYXRWYWx1ZVR5cGUgPSBudWxsLFxyXG4gICAgICAgICAgICBkYXRhVHlwZSA9IGNoYXJ0LmN1cnJlbnREYXRhLnhBeGlzRGF0YS5kYXRhVHlwZSxcclxuICAgICAgICAgICAgYXhpc1ZhbHVlcyA9IGNoYXJ0LmN1cnJlbnREYXRhLnhBeGlzRGF0YS52YWx1ZXM7XHJcblxyXG4gICAgICAgIGlmIChkYXRhVHlwZSA9PT0gJ05VTUJFUicpIHtcclxuICAgICAgICAgICAgZm9ybWF0VmFsdWVUeXBlID0ganZDaGFydHMuanZGb3JtYXRWYWx1ZVR5cGUoYXhpc1ZhbHVlcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2NyZWF0ZSBkdW1teSB0ZXh0IHRvIGRldGVybWluZSBjb21wdXRlZCB0ZXh0IGxlbmd0aCBmb3IgdGhlIGF4aXMgbGFiZWxzXHJcbiAgICAgICAgLy9uZWNlc3NhcnkgdG8gZG8gdGhpcyBiZWNhdXNlIGF4aXMgbGFiZWxzIGdldEJCb3goKSBpcyByZXR1cm5pbmcgMCBzaW5jZSB0aGV5IGRvIG5vdCBzZWVtIHRvIGJlIGRyYXduIHlldFxyXG4gICAgICAgIGNoYXJ0LnN2Zy5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAuc2VsZWN0QWxsKCcuZHVtbXlUZXh0JylcclxuICAgICAgICAgICAgLmRhdGEoYXhpc1ZhbHVlcylcclxuICAgICAgICAgICAgLmVudGVyKClcclxuICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdmb250LWZhbWlseScsICdzYW5zLXNlcmlmJylcclxuICAgICAgICAgICAgLmF0dHIoJ2ZvbnQtc2l6ZScsIGNoYXJ0Ll92YXJzLmZvbnRTaXplKVxyXG4gICAgICAgICAgICAudGV4dCgoZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IHJldHVyblZhbCA9IGQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0YVR5cGUgPT09ICdOVU1CRVInKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsID0ganZDaGFydHMuanZGb3JtYXRWYWx1ZShkLCBmb3JtYXRWYWx1ZVR5cGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbDtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgLy9hZGRpbmcgMTBweCBidWZmZXJcclxuICAgICAgICAgICAgICAgIGxldCB0aGlzV2lkdGggPSB0aGlzLmdldENvbXB1dGVkVGV4dExlbmd0aCgpICsgMTA7XHJcbiAgICAgICAgICAgICAgICB0ZXh0V2lkdGgucHVzaCh0aGlzV2lkdGgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmUoKTsgLy9yZW1vdmUgdGhlbSBqdXN0IGFmdGVyIGRpc3BsYXlpbmcgdGhlbVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgdGV4dEVsZSBvZiB0ZXh0V2lkdGgpIHtcclxuICAgICAgICAgICAgaWYgKHRleHRFbGUgPiB4QXhpc0xlbmd0aCAvIGRhdGFMZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHNob3dBeGlzTGFiZWxzID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzaG93QXhpc0xhYmVscykge1xyXG4gICAgICAgICAgICBpZiAocmVjdXJzaW9uKSB7XHJcbiAgICAgICAgICAgICAgICBjaGFydC5nZW5lcmF0ZVhBeGlzKGNoYXJ0LmN1cnJlbnREYXRhLnhBeGlzRGF0YSwgZGF0YUxlbmd0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2hhcnQuc3ZnLnNlbGVjdEFsbCgnLnhBeGlzTGFiZWxzJykuc3R5bGUoJ2Rpc3BsYXknLCAnYmxvY2snKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGRhdGFMZW5ndGggPiAxICYmIGNoYXJ0LmN1cnJlbnREYXRhLnhBeGlzRGF0YS5kYXRhVHlwZSA9PT0gJ05VTUJFUicpIHtcclxuICAgICAgICAgICAgLy9yZWN1cnNpdmVseSBrZWVwIGRlY3JlYXNpbmcgdG8gZmlndXJlIG91dCB0aWNrcyBsZW5ndGggdG8gcmVwYWludCB0aGUgeEF4aXMgaWYgaXRzIG51bWVyaWNcclxuICAgICAgICAgICAgY2hhcnQuZm9ybWF0WEF4aXNMYWJlbHMoKGRhdGFMZW5ndGggLSAxKSwgdHJ1ZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY2hhcnQuc3ZnLnNlbGVjdEFsbCgnLnhBeGlzJykuc2VsZWN0QWxsKCd0ZXh0Jykuc3R5bGUoJ2Rpc3BsYXknLCAnbm9uZScpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipnZW5lcmF0ZVlBeGlzXHJcbiAgICAgKiBjcmVhdGVzIHkgYXhpcyBvbiB0aGUgc3ZnXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtcyBnZW5lcmF0ZVlBeGlzXHJcbiAgICAgKi9cclxuICAgIGdlbmVyYXRlWUF4aXMoeUF4aXNEYXRhKSB7XHJcbiAgICAgICAgbGV0IGNoYXJ0ID0gdGhpcyxcclxuICAgICAgICAgICAgeUF4aXNTY2FsZSA9IGp2Q2hhcnRzLmdldEF4aXNTY2FsZSgneScsIHlBeGlzRGF0YSwgY2hhcnQuY29uZmlnLmNvbnRhaW5lciwgY2hhcnQuX3ZhcnMpLFxyXG4gICAgICAgICAgICB5QXhpc0NsYXNzID0gJ3lBeGlzTGFiZWxzIGVkaXRhYmxlIGVkaXRhYmxlLXlBeGlzIGVkaXRhYmxlLXRleHQnLFxyXG4gICAgICAgICAgICBtYXhZQXhpc0xhYmVsV2lkdGgsXHJcbiAgICAgICAgICAgIG51bWJlck9mVGlja3MgPSBNYXRoLmZsb29yKGNoYXJ0LmNvbmZpZy5jb250YWluZXIuaGVpZ2h0IC8gMTQpLFxyXG4gICAgICAgICAgICB5QXhpcyxcclxuICAgICAgICAgICAgeUNvbnRlbnQsXHJcbiAgICAgICAgICAgIHlBeGlzR3JvdXAsXHJcbiAgICAgICAgICAgIGZvcmNlRm9ybWF0VHlwZVRvID0gbnVsbCxcclxuICAgICAgICAgICAgeWxhYmVsID0gJyc7XHJcblxyXG4gICAgICAgIC8vYXNzaWduIGNzcyBjbGFzcyBmb3IgZWRpdCBtb2RlXHJcbiAgICAgICAgLy9pZiB0aGUgYXhpcyBpcyBudW1iZXJzIGFkZCBlZGl0YWJsZS1udW1cclxuICAgICAgICBpZiAoeUF4aXNEYXRhLmRhdGFUeXBlID09PSAnTlVNQkVSJykge1xyXG4gICAgICAgICAgICB5QXhpc0NsYXNzICs9ICcgZWRpdGFibGUtbnVtJztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vU2F2ZSB5IGF4aXMgc2NhbGUgdG8gY2hhcnQgb2JqZWN0XHJcbiAgICAgICAgY2hhcnQuY3VycmVudERhdGEueUF4aXNTY2FsZSA9IHlBeGlzU2NhbGU7XHJcblxyXG4gICAgICAgIC8vcmVtb3ZlIHByZXZpb3VzIHN2ZyBlbGVtZW50c1xyXG4gICAgICAgIGNoYXJ0LnN2Zy5zZWxlY3RBbGwoJy55QXhpc0NvbnRhaW5lcicpLnJlbW92ZSgpO1xyXG4gICAgICAgIGNoYXJ0LnN2Zy5zZWxlY3RBbGwoJ3RleHQueUxhYmVsJykucmVtb3ZlKCk7XHJcblxyXG4gICAgICAgIGlmIChudW1iZXJPZlRpY2tzID4gMTApIHtcclxuICAgICAgICAgICAgaWYgKG51bWJlck9mVGlja3MgPCAyMCkge1xyXG4gICAgICAgICAgICAgICAgbnVtYmVyT2ZUaWNrcyA9IDEwO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG51bWJlck9mVGlja3MgPCAzMCkge1xyXG4gICAgICAgICAgICAgICAgbnVtYmVyT2ZUaWNrcyAvPSAyO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbnVtYmVyT2ZUaWNrcyA9IDE1O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL0lmIGFsbCB5LWF4aXMgdmFsdWVzIGFyZSB0aGUgc2FtZSwgb25seSBzaG93IGEgdGljayBmb3IgdGhhdCB2YWx1ZS4gSWYgdmFsdWUgaXMgMSwgZG9uJ3Qgc2hvdyBhbnkgZGVjaW1hbCBwbGFjZXNcclxuICAgICAgICBpZiAoeUF4aXNEYXRhLnZhbHVlcy5sZW5ndGggPiAwICYmICEheUF4aXNEYXRhLnZhbHVlcy5yZWR1Y2UoKGEsIGIpID0+IGEgPT09IGIgPyBhIDogTmFOKSkge1xyXG4gICAgICAgICAgICBudW1iZXJPZlRpY2tzID0gMTtcclxuICAgICAgICAgICAgaWYgKHlBeGlzRGF0YS52YWx1ZXNbMF0gPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIGZvcmNlRm9ybWF0VHlwZVRvID0gJ25vZGVjaW1hbHMnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHlBeGlzID0gZDMuYXhpc0xlZnQoKVxyXG4gICAgICAgICAgICAudGlja3MobnVtYmVyT2ZUaWNrcykvL0xpbmsgdG8gRDMuc3ZnLmF4aXMgb3B0aW9uczogaHR0cHM6Ly9naXRodWIuY29tL21ib3N0b2NrL2QzL3dpa2kvU1ZHLUF4ZXNcclxuICAgICAgICAgICAgLnNjYWxlKHlBeGlzU2NhbGUpLy9TZXRzIHRoZSBzY2FsZSB0byB1c2UgaW4gdGhlIGF4aXNcclxuICAgICAgICAgICAgLnRpY2tTaXplKDUpLy9TZXRzIHRoZSB0aGlja25lc3Mgb2YgdGhlIGF4aXMgbGluZVxyXG4gICAgICAgICAgICAudGlja1BhZGRpbmcoNSk7XHJcblxyXG4gICAgICAgIC8vSGlkZSBBeGlzIHZhbHVlcyBpZiBuZWNlc3NhcnlcclxuICAgICAgICBpZiAoeUF4aXNEYXRhLmhpZGVWYWx1ZXMpIHtcclxuICAgICAgICAgICAgeUF4aXMudGlja0Zvcm1hdCgnJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjaGFydC5fdmFycy5kaXNwbGF5WUF4aXNMYWJlbCkge1xyXG4gICAgICAgICAgICB5bGFiZWwgPSB5QXhpc0RhdGEubGFiZWw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB5Q29udGVudCA9IGNoYXJ0LnN2Zy5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAneUF4aXNDb250YWluZXInKTtcclxuXHJcbiAgICAgICAgeUNvbnRlbnQuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3lMYWJlbCcpXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAneUxhYmVsIGVkaXRhYmxlIGVkaXRhYmxlLXRleHQgZWRpdGFibGUtY29udGVudCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdzdGFydCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdmb250LXNpemUnLCBjaGFydC5fdmFycy5mb250U2l6ZSlcclxuICAgICAgICAgICAgLmF0dHIoJ3gnLCAwKVxyXG4gICAgICAgICAgICAuYXR0cigneScsIDApXHJcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyAoLWNoYXJ0LmNvbmZpZy5tYXJnaW4ubGVmdCArIDEwKSArICcsIC0xMCknKVxyXG4gICAgICAgICAgICAudGV4dCh5bGFiZWwpXHJcbiAgICAgICAgICAgIC5hdHRyKCdmaWxsLW9wYWNpdHknLCAxKTtcclxuXHJcbiAgICAgICAgeUF4aXNHcm91cCA9IHlDb250ZW50LmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICd5QXhpcycpO1xyXG5cclxuXHJcbiAgICAgICAgeUF4aXNHcm91cFxyXG4gICAgICAgICAgICAuY2FsbCh5QXhpcyk7XHJcblxyXG4gICAgICAgIC8vU3R5bGluZyBmb3IgQXhpc1xyXG4gICAgICAgIHlBeGlzR3JvdXAuc2VsZWN0KCdwYXRoJylcclxuICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsIGNoYXJ0Ll92YXJzLmF4aXNDb2xvcilcclxuICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIGNoYXJ0Ll92YXJzLnN0cm9rZVdpZHRoKTtcclxuXHJcbiAgICAgICAgbWF4WUF4aXNMYWJlbFdpZHRoID0gMDtcclxuXHJcbiAgICAgICAgaWYgKHlBeGlzRGF0YS5oaWRlVmFsdWVzKSB7XHJcbiAgICAgICAgICAgIC8vU3R5bGluZyBmb3IgdGlja3NcclxuICAgICAgICAgICAgeUF4aXNHcm91cC5zZWxlY3RBbGwoJ2xpbmUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIDApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGxldCBmb3JtYXRWYWx1ZVR5cGUgPSBqdkNoYXJ0cy5qdkZvcm1hdFZhbHVlVHlwZSh5QXhpc0RhdGEudmFsdWVzKTtcclxuICAgICAgICAgICAgLy9TdHlsaW5nIGZvciB0aWNrc1xyXG4gICAgICAgICAgICB5QXhpc0dyb3VwLnNlbGVjdEFsbCgnbGluZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgY2hhcnQuX3ZhcnMuYXhpc0NvbG9yKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIGNoYXJ0Ll92YXJzLnN0cm9rZSk7XHJcbiAgICAgICAgICAgIC8vU3R5bGluZyBmb3IgZGF0YSBsYWJlbHMgb24gYXhpc1xyXG4gICAgICAgICAgICB5QXhpc0dyb3VwLnNlbGVjdEFsbCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZmlsbCcsIGNoYXJ0Ll92YXJzLmZvbnRDb2xvcikvL0N1c3RvbWl6ZSB0aGUgY29sb3Igb2YgYXhpcyBsYWJlbHNcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIHlBeGlzQ2xhc3MpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3JvdGF0ZSgwKScpLy9BZGQgbG9naWMgdG8gcm90YXRlIGF4aXMgYmFzZWQgb24gc2l6ZSBvZiB0aXRsZVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZvbnQtc2l6ZScsIGNoYXJ0Ll92YXJzLmZvbnRTaXplKVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgnc3ZnOnRpdGxlJyk7XHJcblxyXG4gICAgICAgICAgICB5QXhpc0dyb3VwLnNlbGVjdEFsbCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAudGV4dCgoZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFydC5fdmFycy5yb3RhdGVBeGlzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBsZXQgbWF4TGVuZ3RoID0gMTMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSAnJztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZC5sZW5ndGggPiBtYXhMZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGQuc3Vic3RyaW5nKDAsIG1heExlbmd0aCkgKyAnLi4uJztcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gZDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3JjZUZvcm1hdFR5cGVUbyAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXRWYWx1ZVR5cGUgPSBmb3JjZUZvcm1hdFR5cGVUbztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGp2Q2hhcnRzLmp2Rm9ybWF0VmFsdWUoY3VycmVudCwgZm9ybWF0VmFsdWVUeXBlKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuZWFjaCgoZCwgaSwgaikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChqWzBdLmdldEJCb3goKS53aWR0aCA+IG1heFlBeGlzTGFiZWxXaWR0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhZQXhpc0xhYmVsV2lkdGggPSBqWzBdLmdldEJCb3goKS53aWR0aDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKG1heFlBeGlzTGFiZWxXaWR0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGNoYXJ0Ll92YXJzLnlMYWJlbFdpZHRoID0gTWF0aC5jZWlsKG1heFlBeGlzTGFiZWxXaWR0aCkgKyAyMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogTGVnZW5kIGZ1bmN0aW9ucyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG4gICAgZ2VuZXJhdGVMZWdlbmQobGVnZW5kRGF0YSwgZHJhd0Z1bmMpIHtcclxuICAgICAgICBsZXQgY2hhcnQgPSB0aGlzLFxyXG4gICAgICAgICAgICBzdmcgPSBjaGFydC5zdmcsXHJcbiAgICAgICAgICAgIGxlZ2VuZEVsZW1lbnRzO1xyXG5cclxuICAgICAgICBpZiAoIWNoYXJ0Ll92YXJzLnRvZ2dsZUxlZ2VuZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN2Zy5zZWxlY3RBbGwoJy5sZWdlbmQnKS5yZW1vdmUoKTtcclxuXHJcbiAgICAgICAgbGVnZW5kRWxlbWVudHMgPSBqdkNoYXJ0cy5nZW5lcmF0ZUxlZ2VuZEVsZW1lbnRzKGNoYXJ0LCBsZWdlbmREYXRhLCBkcmF3RnVuYyk7XHJcblxyXG4gICAgICAgIC8vUmV0dXJucyB0aGUgbGVnZW5kIHJlY3RhbmdsZXMgdGhhdCBhcmUgdG9nZ2xlZCBvbi9vZmZcclxuICAgICAgICBpZiAoZHJhd0Z1bmMpIHtcclxuICAgICAgICAgICAganZDaGFydHMuYXR0YWNoQ2xpY2tFdmVudHNUb0xlZ2VuZChjaGFydCwgbGVnZW5kRWxlbWVudHMsIGRyYXdGdW5jLCBsZWdlbmREYXRhKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChjaGFydC5fdmFycy50aHJlc2hvbGRzICE9PSAnbm9uZScgJiYgY2hhcnQuX3ZhcnMudGhlc2hvbGRMZWdlbmQgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgaWYgKGNoYXJ0LmNvbmZpZy50eXBlID09PSAnYmFyJyB8fCBjaGFydC5jb25maWcudHlwZSA9PT0gJ2FyZWEnIHx8IGNoYXJ0LmNvbmZpZy50eXBlID09PSAnbGluZScpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjaGFydC5jb25maWcuY29udGFpbmVyLmhlaWdodCA+IDMwMCAmJiBjaGFydC5jb25maWcuY29udGFpbmVyLndpZHRoID4gMzAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAganZDaGFydHMuZ2VuZXJhdGVUaHJlc2hvbGRMZWdlbmQoY2hhcnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKmdlbmVyYXRlVmVydGljYWxMZWdlbmRcclxuICAgICAqXHJcbiAgICAgKiBjcmVhdGVzIGFuZCBkcmF3cyBhIHZlcnRpY2FsIGxlZ2VuZCBvbiB0aGUgc3ZnIGVsZW1lbnRcclxuICAgICAqIEBwYXJhbXMgc3ZnLCBsZWdlbmREYXRhLCBvcHRpb25zLCBjb250YWluZXIsIGNoYXJ0RGF0YSwgeEF4aXNEYXRhLCB5QXhpc0RhdGEsIGNoYXJ0VHlwZVxyXG4gICAgICogQHJldHVybnMge3t9fVxyXG4gICAgICovXHJcbiAgICBnZW5lcmF0ZVZlcnRpY2FsTGVnZW5kKHBhaW50RnVuYykge1xyXG4gICAgICAgIGxldCBjaGFydCA9IHRoaXMsXHJcbiAgICAgICAgICAgIHN2ZyA9IGNoYXJ0LnN2ZyxcclxuICAgICAgICAgICAgbGVnZW5kRGF0YSA9IGNoYXJ0LmN1cnJlbnREYXRhLmxlZ2VuZERhdGEsXHJcbiAgICAgICAgICAgIGxlZ2VuZEVsZW1lbnRzO1xyXG5cclxuICAgICAgICBpZiAoIWNoYXJ0Ll92YXJzLnRvZ2dsZUxlZ2VuZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdmcuc2VsZWN0QWxsKCcubGVnZW5kJykucmVtb3ZlKCk7XHJcbiAgICAgICAgbGVnZW5kRWxlbWVudHMgPSBqdkNoYXJ0cy5nZW5lcmF0ZVZlcnRpY2FsTGVnZW5kRWxlbWVudHMoY2hhcnQsIGxlZ2VuZERhdGEsIHBhaW50RnVuYyk7XHJcblxyXG4gICAgICAgIC8vUmV0dXJucyB0aGUgbGVnZW5kIHJlY3RhbmdsZXMgdGhhdCBhcmUgdG9nZ2xlZCBvbi9vZmZcclxuICAgICAgICBpZiAocGFpbnRGdW5jICE9PSAnZ2VuZXJhdGVQYWNrJykge1xyXG4gICAgICAgICAgICBqdkNoYXJ0cy5hdHRhY2hDbGlja0V2ZW50c1RvTGVnZW5kKGNoYXJ0LCBsZWdlbmRFbGVtZW50cywgcGFpbnRGdW5jLCBsZWdlbmREYXRhKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogR2VuZXJhdGVzIGEgY2xpcCBwYXRoIHRoYXQgY29udGFpbnMgdGhlIGNvbnRlbnRzIG9mIHRoZSBjaGFydCBhcmVhIHRvIHRoZSB2aWV3IG9mIHRoZSBjaGFydCBhcmVhIGNvbnRhaW5lclxyXG4gICAgICogaS5lIC0gZG9uJ3Qgd2FudCBiYXJzIGdvaW5nIGJlbG93IHRoZSB4IGF4aXNcclxuICAgICAqL1xyXG4gICAgZ2VuZXJhdGVDbGlwUGF0aCgpIHtcclxuICAgICAgICBsZXQgY2hhcnQgPSB0aGlzLFxyXG4gICAgICAgICAgICBzdmcgPSBjaGFydC5zdmcsXHJcbiAgICAgICAgICAgIHR5cGUgPSBjaGFydC5jb25maWcudHlwZSxcclxuICAgICAgICAgICAgY29udGFpbmVyTmFtZSA9ICcuJyArIHR5cGUgKyAnLWNvbnRhaW5lcic7XHJcblxyXG4gICAgICAgIHN2Z1xyXG4gICAgICAgICAgICAuYXBwZW5kKCdjbGlwUGF0aCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdpZCcsICdjbGlwJylcclxuICAgICAgICAgICAgLmFwcGVuZCgncmVjdCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4JywgMClcclxuICAgICAgICAgICAgLmF0dHIoJ3knLCAwKVxyXG4gICAgICAgICAgICAuYXR0cignd2lkdGgnLCBjaGFydC5jb25maWcuY29udGFpbmVyLndpZHRoKVxyXG4gICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgY2hhcnQuY29uZmlnLmNvbnRhaW5lci5oZWlnaHQpO1xyXG5cclxuICAgICAgICAvL0JyZWFrIHRoaXMgb3V0IGludG8gbG9naWMgZm9yIGFsbCBvdGhlciB2aXp6ZXMgdGhhdCBoYXZlIG92ZXJmbG93IGlzc3Vlc1xyXG4gICAgICAgIHN2Z1xyXG4gICAgICAgICAgICAuc2VsZWN0KGNvbnRhaW5lck5hbWUpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGlwLXBhdGgnLCAndXJsKCNjbGlwKScpO1xyXG4gICAgfVxyXG5cclxuICAgIHNldFRocmVzaG9sZChkYXRhKSB7XHJcbiAgICAgICAgbGV0IGNoYXJ0ID0gdGhpcyxcclxuICAgICAgICAgICAgdGhyZXNob2xkcyA9IGNoYXJ0Ll92YXJzLnRocmVzaG9sZHMsXHJcbiAgICAgICAgICAgIGxlbmd0aCA9IHRocmVzaG9sZHMgPyBPYmplY3Qua2V5cyh0aHJlc2hvbGRzKS5sZW5ndGggOiAwO1xyXG5cclxuICAgICAgICBpZiAodGhyZXNob2xkcyAhPT0gJ25vbmUnKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBsZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHRocmVzaG9sZCA9IHRocmVzaG9sZHNbaV07XHJcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKHR5cGVvZiBkYXRhID09IFwiZGF0ZVwiKTtcclxuICAgICAgICAgICAgICAgIGlmIChkYXRhID49IE51bWJlcih0aHJlc2hvbGQudGhyZXNob2xkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAncmVjdC0nICsgaTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gJyc7XHJcbiAgICB9XHJcblxyXG4gICAgZ2VuZXJhdGVMaW5lVGhyZXNob2xkKCkge1xyXG4gICAgICAgIGxldCBjaGFydCA9IHRoaXMsXHJcbiAgICAgICAgICAgIHN2ZyA9IGNoYXJ0LnN2ZyxcclxuICAgICAgICAgICAgd2lkdGggPSBjaGFydC5jb25maWcuY29udGFpbmVyLndpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQgPSBjaGFydC5jb25maWcuY29udGFpbmVyLmhlaWdodCxcclxuICAgICAgICAgICAgdGhyZXNob2xkcyA9IGNoYXJ0Ll92YXJzLnRocmVzaG9sZHMsXHJcbiAgICAgICAgICAgIGxlbmd0aCA9IE9iamVjdC5rZXlzKGNoYXJ0Ll92YXJzLnRocmVzaG9sZHMpLmxlbmd0aCxcclxuICAgICAgICAgICAgeCA9IGNoYXJ0LmN1cnJlbnREYXRhLnhBeGlzU2NhbGUsXHJcbiAgICAgICAgICAgIHkgPSBjaGFydC5jdXJyZW50RGF0YS55QXhpc1NjYWxlO1xyXG5cclxuICAgICAgICBpZiAodGhyZXNob2xkcyAhPT0gJ25vbmUnKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGxldCB0aHJlc2hvbGQgPSB0aHJlc2hvbGRzW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoYXJ0Ll92YXJzLnJvdGF0ZUF4aXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdmcuYXBwZW5kKCdsaW5lJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UnLCB0aHJlc2hvbGQudGhyZXNob2xkQ29sb3IpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsIHgodGhyZXNob2xkLnRocmVzaG9sZCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MicsIHgodGhyZXNob2xkLnRocmVzaG9sZCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIGhlaWdodClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZS1kYXNoYXJyYXknLCAoJzMsIDMnKSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHN2Zy5hcHBlbmQoJ2xpbmUnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsIHRocmVzaG9sZC50aHJlc2hvbGRDb2xvcilcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gxJywgMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgeSh0aHJlc2hvbGQudGhyZXNob2xkKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgd2lkdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIHkodGhyZXNob2xkLnRocmVzaG9sZCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2UtZGFzaGFycmF5JywgKCczLCAzJykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbG9yQmFja2dyb3VuZChjb2xvcikge1xyXG4gICAgICAgIGxldCBjaGFydCA9IHRoaXM7XHJcbiAgICAgICAgY2hhcnQuX3ZhcnMuYmFja2dyb3VuZENvbG9yID0gY29sb3I7XHJcbiAgICAgICAgY2hhcnQuY2hhcnREaXYuc3R5bGUoJ2JhY2tncm91bmQtY29sb3InLCAnJyArIGNvbG9yKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqZGlzcGxheVZhbHVlc1xyXG4gICAgICpcclxuICAgICAqIHRvZ2dsZXMgZGF0YSB2YWx1ZXMgdGhhdCBhcmUgZGlzcGxheWVkIG9uIHRoZSBzcGVjaWZpYyB0eXBlIG9mIGNoYXJ0IG9uIHRoZSBzdmdcclxuICAgICAqIEBwYXJhbXMgc3ZnLCBiYXJEYXRhLCBvcHRpb25zLCB4QXhpc0RhdGEsIHlBeGlzRGF0YSwgY29udGFpbmVyXHJcbiAgICAgKiBAcmV0dXJucyB7e319XHJcbiAgICAgKi9cclxuICAgIGRpc3BsYXlWYWx1ZXMoKSB7XHJcbiAgICAgICAgdmFyIGNoYXJ0ID0gdGhpcyxcclxuICAgICAgICAgICAgc3ZnID0gY2hhcnQuc3ZnLFxyXG4gICAgICAgICAgICBjb250YWluZXIgPSBjaGFydC5jb25maWcuY29udGFpbmVyLFxyXG4gICAgICAgICAgICBjaGFydERhdGEgPSBjaGFydC5kYXRhLmNoYXJ0RGF0YSxcclxuICAgICAgICAgICAgeEF4aXNEYXRhID0gY2hhcnQuY3VycmVudERhdGEueEF4aXNEYXRhLFxyXG4gICAgICAgICAgICB5QXhpc0RhdGEgPSBjaGFydC5jdXJyZW50RGF0YS55QXhpc0RhdGEsXHJcbiAgICAgICAgICAgIGxlZ2VuZE9wdGlvbnMgPSBjaGFydC5fdmFycy5sZWdlbmRPcHRpb25zLFxyXG4gICAgICAgICAgICBjbGVhbmVkQ2hhcnREYXRhID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShjaGFydERhdGEpKSxcclxuICAgICAgICAgICAgZGF0YSA9IFtdLCAvL09ubHkgc3RvcmVzIHZhbHVlc1xyXG4gICAgICAgICAgICBwb3NDYWxjLFxyXG4gICAgICAgICAgICB4LFxyXG4gICAgICAgICAgICB5LFxyXG4gICAgICAgICAgICBkaXNwbGF5VmFsdWVzR3JvdXA7XHJcblxyXG4gICAgICAgIC8vSWYgc2VyaWVzIGlzIGZsaXBwZWQsIHVzZSBmbGlwcGVkIGRhdGE7IGluaXRpYWxpemUgd2l0aCB0aGUgZnVsbCBkYXRhIHNldFxyXG4gICAgICAgIGlmIChjaGFydC5fdmFycy5zZXJpZXNGbGlwcGVkKSB7XHJcbiAgICAgICAgICAgIGNoYXJ0RGF0YSA9IGNoYXJ0LmZsaXBwZWREYXRhLmNoYXJ0RGF0YTtcclxuICAgICAgICAgICAgbGVnZW5kT3B0aW9ucyA9IGNoYXJ0Ll92YXJzLmZsaXBwZWRMZWdlbmRPcHRpb25zO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGNoYXJ0Ll92YXJzLmRpc3BsYXlWYWx1ZXMgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgc3ZnLnNlbGVjdEFsbCgnLmRpc3BsYXlWYWx1ZUNvbnRhaW5lcicpLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICBpZiAobGVnZW5kT3B0aW9ucykgey8vQ2hlY2tpbmcgd2hpY2ggbGVnZW5kIGVsZW1lbnRzIGFyZSB0b2dnbGVkIG9uIHJlc2l6ZVxyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY2hhcnRFbGUgb2YgY2xlYW5lZENoYXJ0RGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGxlZ2VuZEVsZSBvZiBsZWdlbmRPcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZWdlbmRFbGUudG9nZ2xlID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGNoYXJ0RWxlW2xlZ2VuZEVsZS5lbGVtZW50XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZm9yIChsZXQgY2hhcnRFbGUgb2YgY2xlYW5lZENoYXJ0RGF0YSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHZhbCA9IGp2Q2hhcnRzLmdldERpc3BsYXlWYWx1ZXNFbGVtZW50KGNoYXJ0RWxlLCBjaGFydC5jdXJyZW50RGF0YS5kYXRhVGFibGUsIGNoYXJ0LmNvbmZpZy50eXBlKTtcclxuICAgICAgICAgICAgICAgIGRhdGEucHVzaCh2YWwpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwb3NDYWxjID0ganZDaGFydHMuZ2V0UG9zQ2FsY3VsYXRpb25zKGNsZWFuZWRDaGFydERhdGEsIGNoYXJ0Ll92YXJzLCB4QXhpc0RhdGEsIHlBeGlzRGF0YSwgY29udGFpbmVyLCBjaGFydCk7XHJcbiAgICAgICAgICAgIHggPSBqdkNoYXJ0cy5nZXRBeGlzU2NhbGUoJ3gnLCB4QXhpc0RhdGEsIGNvbnRhaW5lciwgY2hhcnQuX3ZhcnMpO1xyXG4gICAgICAgICAgICB5ID0ganZDaGFydHMuZ2V0QXhpc1NjYWxlKCd5JywgeUF4aXNEYXRhLCBjb250YWluZXIsIGNoYXJ0Ll92YXJzKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChjaGFydC5fdmFycy5yb3RhdGVBeGlzKSB7XHJcbiAgICAgICAgICAgICAgICAvL0FkZCBhIGNvbnRhaW5lciBmb3IgZGlzcGxheSB2YWx1ZXMgb3ZlciBlYWNoIGJhciBncm91cFxyXG4gICAgICAgICAgICAgICAgZGlzcGxheVZhbHVlc0dyb3VwID1cclxuICAgICAgICAgICAgICAgICAgICBzdmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdkaXNwbGF5VmFsdWVzR3JvdXAnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKCdnJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmRhdGEoZGF0YSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmVudGVyKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdkaXNwbGF5VmFsdWVzR3JvdXAnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgKGQsIGkpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0cmFuc2xhdGUgPSAoeS5wYWRkaW5nT3V0ZXIoKSAqIHkuc3RlcCgpKSArICh5LnN0ZXAoKSAqIGkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoMCwnICsgdHJhbnNsYXRlICsgJyknO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICBkaXNwbGF5VmFsdWVzR3JvdXAuc2VsZWN0QWxsKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgICAgICAuZGF0YShkID0+IGQpXHJcbiAgICAgICAgICAgICAgICAgICAgLmVudGVyKClcclxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZGlzcGxheVZhbHVlJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIChkLCBpLCBqKSA9PiB7IC8vc2V0cyB0aGUgeCBwb3NpdGlvbiBvZiB0aGUgYmFyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9zQ2FsYy53aWR0aChkLCBpLCBqKSArIHBvc0NhbGMueChkLCBpLCBqKTtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgKGQsIGksIGopID0+IHsgLy9zZXRzIHRoZSB5IHBvc2l0aW9uIG9mIHRoZSBiYXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvc0NhbGMueShkLCBpLCBqKSArIChwb3NDYWxjLmhlaWdodChkLCBpLCBqKSAvIDIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2R5JywgJy4zNWVtJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigndGV4dC1hbmNob3InLCAnc3RhcnQnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgY2hhcnQuX3ZhcnMuZm9udENvbG9yKVxyXG4gICAgICAgICAgICAgICAgICAgIC50ZXh0KChkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXR1cm5UZXh0ID0gTWF0aC5yb3VuZChkICogMTAwKSAvIDEwMDsvL3JvdW5kIHRvIDIgZGVjaW1hbHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGp2Q2hhcnRzLmp2Rm9ybWF0VmFsdWUocmV0dXJuVGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignZm9udC1zaXplJywgY2hhcnQuX3ZhcnMuZm9udFNpemUpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy9BZGQgYSBkaXNwbGF5IHZhbHVlcyBjb250YWluZXIgb3ZlciBlYWNoIGJhciBncm91cFxyXG4gICAgICAgICAgICAgICAgZGlzcGxheVZhbHVlc0dyb3VwID0gc3ZnLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2Rpc3BsYXlWYWx1ZXNHcm91cCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgnZycpXHJcbiAgICAgICAgICAgICAgICAgICAgLmRhdGEoZGF0YSlcclxuICAgICAgICAgICAgICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdkaXNwbGF5VmFsdWVzR3JvdXAnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAoZCwgaSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdHJhbnNsYXRlID0gKHgucGFkZGluZ091dGVyKCkgKiB4LnN0ZXAoKSkgKyAoeC5zdGVwKCkgKiBpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIHRyYW5zbGF0ZSArICcsMCknO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgZGlzcGxheVZhbHVlc0dyb3VwLnNlbGVjdEFsbCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmRhdGEoZCA9PiBkKVxyXG4gICAgICAgICAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2Rpc3BsYXlWYWx1ZScpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCAoZCwgaSwgaikgPT4geyAvL3NldHMgdGhlIHggcG9zaXRpb24gb2YgdGhlIGJhcilcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoKHBvc0NhbGMueChkLCBpLCBqKSArIChwb3NDYWxjLndpZHRoKGQsIGksIGopIC8gMikpKTtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgKGQsIGksIGopID0+IHsgLy9zZXRzIHRoZSB5IHBvc2l0aW9uIG9mIHRoZSBiYXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQocG9zQ2FsYy55KGQsIGksIGopKSAtIDM7Ly8rIHBvc0NhbGMuaGVpZ2h0KGQsIGksIGopIC0gNSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigndGV4dC1hbmNob3InLCAnbWlkZGxlJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignZmlsbCcsIGNoYXJ0Ll92YXJzLmZvbnRDb2xvcilcclxuICAgICAgICAgICAgICAgICAgICAudGV4dCgoZCwgaSwgaikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhcnQuX3ZhcnMuc3RhY2tUb2dnbGUgJiYgY2hhcnQuX3ZhcnMuZGlzcGxheVZhbHVlc1N0YWNrQXNQZXJjZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdG90YWwgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGoubGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG90YWwgKz0galtpbmRleF0uX19kYXRhX187XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ganZDaGFydHMuanZGb3JtYXRWYWx1ZShkIC8gdG90YWwsICdwZXJjZW50Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBqdkNoYXJ0cy5qdkZvcm1hdFZhbHVlKGQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2ZvbnQtc2l6ZScsIGNoYXJ0Ll92YXJzLmZvbnRTaXplKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoY2hhcnQuX3ZhcnMuc3RhY2tUb2dnbGUgJiYgY2hhcnQuX3ZhcnMuZGlzcGxheVZhbHVlc1N0YWNrVG90YWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgc3RhY2tDb3VudGVyID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBzdmcuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2Rpc3BsYXlTdGFja1RvdGFsJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgnZycpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5kYXRhKGRhdGEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgKGQsIGkpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0cmFuc2xhdGUgPSAoeC5wYWRkaW5nT3V0ZXIoKSAqIHguc3RlcCgpKSArICh4LnN0ZXAoKSAqIGkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIHRyYW5zbGF0ZSArICcsMCknO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmRhdGEoZCA9PiBkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCAoZCwgaSwgaikgPT4geyAvL3NldHMgdGhlIHggcG9zaXRpb24gb2YgdGhlIGJhcilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKChwb3NDYWxjLngoZCwgaSwgaikgKyAocG9zQ2FsYy53aWR0aChkLCBpLCBqKSAvIDIpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgKGQsIGksIGopID0+IHsgLy9zZXRzIHRoZSB5IHBvc2l0aW9uIG9mIHRoZSBiYXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHBvc0NhbGMueShkLCBpLCBqKSkgLSAxODsvLysgcG9zQ2FsYy5oZWlnaHQoZCwgaSwgaikgLSA1KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgY2hhcnQuX3ZhcnMuZm9udENvbG9yKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAudGV4dCgoZCwgaSwgaikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHlMZW5ndGggPSBjaGFydC5jdXJyZW50RGF0YS55QXhpc0RhdGEudmFsdWVzLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4TGVuZ3RoID0gY2hhcnQuY3VycmVudERhdGEueEF4aXNEYXRhLnZhbHVlcy5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXhNYXggPSB5TGVuZ3RoIC8geExlbmd0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjayA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGkgKyAxKSA9PT0gaW5kZXhNYXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgaiA8IGluZGV4TWF4OyBrKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2sgKz0gY2hhcnQuY3VycmVudERhdGEueUF4aXNEYXRhLnZhbHVlc1tpbmRleE1heCAqIHN0YWNrQ291bnRlciArIGtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFja0NvdW50ZXIrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ganZDaGFydHMuanZGb3JtYXRWYWx1ZShzdGFjayk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdmb250LXNpemUnLCBjaGFydC5fdmFycy5mb250U2l6ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzdmcuc2VsZWN0QWxsKCcuZGlzcGxheVZhbHVlQ29udGFpbmVyJykucmVtb3ZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGRyYXdHcmlkbGluZXMoYXhpc0RhdGEpIHtcclxuICAgICAgICBsZXQgY2hhcnQgPSB0aGlzLFxyXG4gICAgICAgICAgICBzY2FsZURhdGE7XHJcblxyXG4gICAgICAgIGNoYXJ0LnN2Zy5zZWxlY3RBbGwoJ2cuZ3JpZExpbmVzJykucmVtb3ZlKCk7XHJcbiAgICAgICAgY2hhcnQuc3ZnLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdncmlkTGluZXMnKTtcclxuXHJcbiAgICAgICAgLy9EZXRlcm1pbmUgaWYgZ3JpZGxpbmVzIGFyZSBob3Jpem9udGFsIG9yIHZlcnRpY2FsIGJhc2VkIG9uIHJvdGF0ZUF4aXNcclxuICAgICAgICBpZiAoY2hhcnQuX3ZhcnMucm90YXRlQXhpcyA9PT0gdHJ1ZSB8fCBjaGFydC5jb25maWcudHlwZSA9PT0gJ2dhbnR0JyB8fCBjaGFydC5jb25maWcudHlwZSA9PT0gJ3NpbmdsZWF4aXMnKSB7XHJcbiAgICAgICAgICAgIGxldCBncmlkTGluZUhlaWdodCA9IGNoYXJ0LmNvbmZpZy5jb250YWluZXIuaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgeEF4aXNTY2FsZSA9IGp2Q2hhcnRzLmdldEF4aXNTY2FsZSgneCcsIGF4aXNEYXRhLCBjaGFydC5jb25maWcuY29udGFpbmVyLCBjaGFydC5fdmFycyk7XHJcblxyXG4gICAgICAgICAgICBpZiAoYXhpc0RhdGEuZGF0YVR5cGUgPT09ICdTVFJJTkcnKSB7XHJcbiAgICAgICAgICAgICAgICBzY2FsZURhdGEgPSBheGlzRGF0YS52YWx1ZXM7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXhpc0RhdGEuZGF0YVR5cGUgPT09ICdOVU1CRVInIHx8IGF4aXNEYXRhLmRhdGFUeXBlID09PSAnREFURScpIHtcclxuICAgICAgICAgICAgICAgIHNjYWxlRGF0YSA9IHhBeGlzU2NhbGUudGlja3MoMTApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjaGFydC5zdmcuc2VsZWN0KCcuZ3JpZExpbmVzJykuc2VsZWN0QWxsKCcuaG9yaXpvbnRhbEdyaWQnKVxyXG4gICAgICAgICAgICAgICAgLmRhdGEoc2NhbGVEYXRhKVxyXG4gICAgICAgICAgICAgICAgLmVudGVyKClcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2xpbmUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2hvcml6b250YWxHcmlkJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsIChkLCBpKSA9PiBpID4gMCA/IHhBeGlzU2NhbGUoZCkgOiAwKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgKGQsIGkpID0+IGkgPiAwID8geEF4aXNTY2FsZShkKSA6IDApXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneTEnLCAwKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3kyJywgKGQsIGkpID0+IGkgPiAwID8gZ3JpZExpbmVIZWlnaHQgOiAwKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCAnbm9uZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignc2hhcGUtcmVuZGVyaW5nJywgJ2NyaXNwRWRnZXMnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsIGNoYXJ0Ll92YXJzLmF4aXNDb2xvcilcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCBjaGFydC5fdmFycy5ncmlkTGluZVN0cm9rZVdpZHRoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgZ3JpZExpbmVXaWR0aCA9IGNoYXJ0LmNvbmZpZy5jb250YWluZXIud2lkdGgsXHJcbiAgICAgICAgICAgICAgICB5QXhpc1NjYWxlID0ganZDaGFydHMuZ2V0QXhpc1NjYWxlKCd5JywgYXhpc0RhdGEsIGNoYXJ0LmNvbmZpZy5jb250YWluZXIsIGNoYXJ0Ll92YXJzKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChheGlzRGF0YS5kYXRhVHlwZSA9PT0gJ1NUUklORycpIHtcclxuICAgICAgICAgICAgICAgIHNjYWxlRGF0YSA9IGF4aXNEYXRhLnZhbHVlcztcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChheGlzRGF0YS5kYXRhVHlwZSA9PT0gJ05VTUJFUicgfHwgYXhpc0RhdGEuZGF0YVR5cGUgPT09ICdEQVRFJykge1xyXG4gICAgICAgICAgICAgICAgc2NhbGVEYXRhID0geUF4aXNTY2FsZS50aWNrcygxMCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNoYXJ0LnN2Zy5zZWxlY3QoJy5ncmlkTGluZXMnKS5zZWxlY3RBbGwoJy5ob3Jpem9udGFsR3JpZCcpLmRhdGEoc2NhbGVEYXRhKS5lbnRlcigpXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdsaW5lJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdob3Jpem9udGFsR3JpZCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneDEnLCAwKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgKGQsIGkpID0+IGkgPiAwID8gZ3JpZExpbmVXaWR0aCA6IDApXHJcbiAgICAgICAgICAgICAgICAuYXR0cigneTEnLCAoZCwgaSkgPT4gaSA+IDAgPyB5QXhpc1NjYWxlKGQpIDogMClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIChkLCBpKSA9PiBpID4gMCA/IHlBeGlzU2NhbGUoZCkgOiAwKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCAnbm9uZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignc2hhcGUtcmVuZGVyaW5nJywgJ2NyaXNwRWRnZXMnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsIGNoYXJ0Ll92YXJzLmF4aXNDb2xvcilcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCBjaGFydC5fdmFycy5ncmlkTGluZVN0cm9rZVdpZHRoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqZ2V0QmFyRGF0YUZyb21PcHRpb25zXHJcbiAgICAqIF5eIG5vdCBqdXN0IGEgYmFyIGZ1bmN0aW9uLCBsaW5lIGFuZCBhcmVhIGFsc28gdXNlIGl0XHJcbiAgICAqXHJcbiAgICAqIEFzc2lnbnMgdGhlIGNvcnJlY3QgY2hhcnQgZGF0YSB0byBjdXJyZW50IGRhdGEgdXNpbmcgdGhlIGNoYXJ0Lm9wdGlvbnNcclxuICAgICovXHJcbiAgICBnZXRCYXJEYXRhRnJvbU9wdGlvbnMoKSB7XHJcbiAgICAgICAgbGV0IGNoYXJ0ID0gdGhpcyxcclxuICAgICAgICAgICAgZGF0YU9iaiA9IHt9LFxyXG4gICAgICAgICAgICBkYXRhID0gY2hhcnQuZGF0YTtcclxuXHJcbiAgICAgICAgLy9zZXQgZmxpcHBlZCBkYXRhIGlmIG5lY2Vzc2FyeVxyXG4gICAgICAgIGlmIChjaGFydC5fdmFycy5zZXJpZXNGbGlwcGVkKSB7XHJcbiAgICAgICAgICAgIGRhdGEgPSBjaGFydC5mbGlwcGVkRGF0YTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRhdGFPYmouY2hhcnREYXRhID0gZGF0YS5jaGFydERhdGE7XHJcbiAgICAgICAgZGF0YU9iai5sZWdlbmREYXRhID0gZGF0YS5sZWdlbmREYXRhO1xyXG4gICAgICAgIGRhdGFPYmouZGF0YVRhYmxlID0gZGF0YS5kYXRhVGFibGU7XHJcbiAgICAgICAgY2hhcnQuX3ZhcnMuY29sb3IgPSBkYXRhLmNvbG9yO1xyXG4gICAgICAgIGlmIChjaGFydC5fdmFycy5yb3RhdGVBeGlzID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIGRhdGFPYmoueEF4aXNEYXRhID0gZGF0YS55QXhpc0RhdGE7XHJcbiAgICAgICAgICAgIGRhdGFPYmoueUF4aXNEYXRhID0gZGF0YS54QXhpc0RhdGE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZGF0YU9iai54QXhpc0RhdGEgPSBkYXRhLnhBeGlzRGF0YTtcclxuICAgICAgICAgICAgZGF0YU9iai55QXhpc0RhdGEgPSBkYXRhLnlBeGlzRGF0YTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBkYXRhT2JqO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogVXRpbGl0eSBmdW5jdGlvbnMgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuICAgIC8qKmhpZ2hsaWdodEl0ZW1zXHJcbiAgICAgKlxyXG4gICAgICogaGlnaGxpZ2h0cyBpdGVtcyBvbiB0aGUgc3ZnIGVsZW1lbnRcclxuICAgICAqIEBwYXJhbXMgaXRlbXMsIHN2Z1xyXG4gICAgICogQHJldHVybnMge3t9fVxyXG4gICAgICovXHJcbiAgICBoaWdobGlnaHRJdGVtKGl0ZW1zLCB0YWcsIGhpZ2hsaWdodEluZGV4LCBoaWdobGlnaHRVcmkpIHtcclxuICAgICAgICBsZXQgY2hhcnQgPSB0aGlzLFxyXG4gICAgICAgICAgICBzdmcgPSBjaGFydC5zdmc7XHJcblxyXG4gICAgICAgIC8vVE9ETyByZW1vdmUgaWYgc3RhdGVtZW50c1xyXG4gICAgICAgIGlmIChoaWdobGlnaHRJbmRleCA+PSAwKSB7XHJcbiAgICAgICAgICAgIGlmIChjaGFydC5jb25maWcudHlwZSA9PT0gJ3BpZScpIHtcclxuICAgICAgICAgICAgICAgIC8vc2V0IGFsbCBjaXJjbGVzIHN0cm9rZSB3aWR0aCB0byAwXHJcbiAgICAgICAgICAgICAgICBzdmcuc2VsZWN0KCcucGllLWNvbnRhaW5lcicpLnNlbGVjdEFsbCh0YWcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsIGNoYXJ0Ll92YXJzLnBpZUJvcmRlcilcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgMSk7XHJcbiAgICAgICAgICAgICAgICAvL2hpZ2hsaWdodCBuZWNlc3NhcnkgcGllIHNsaWNlc1xyXG4gICAgICAgICAgICAgICAgc3ZnLnNlbGVjdCgnLnBpZS1jb250YWluZXInKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwodGFnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoJy5oaWdobGlnaHQtY2xhc3MtJyArIGhpZ2hsaWdodEluZGV4KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCBjaGFydC5fdmFycy5oaWdobGlnaHRCb3JkZXJDb2xvcilcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgY2hhcnQuX3ZhcnMuaGlnaGxpZ2h0Qm9yZGVyV2lkdGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjaGFydC5jb25maWcudHlwZSA9PT0gJ3NjYXR0ZXJwbG90Jykge1xyXG4gICAgICAgICAgICAgICAgLy9zZXQgYWxsIGNpcmNsZXMgc3Ryb2tlIHdpZHRoIHRvIDBcclxuICAgICAgICAgICAgICAgIHN2Zy5zZWxlY3QoJy5zY2F0dGVyLWNvbnRhaW5lcicpLnNlbGVjdEFsbCh0YWcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIDApO1xyXG4gICAgICAgICAgICAgICAgLy9oaWdobGlnaHQgbmVjZXNzYXJ5IHNjYXR0ZXIgZG90c1xyXG4gICAgICAgICAgICAgICAgc3ZnLnNlbGVjdCgnLnNjYXR0ZXItY29udGFpbmVyJykuc2VsZWN0QWxsKHRhZykuZmlsdGVyKCcuc2NhdHRlci1jaXJjbGUtJyArIGhpZ2hsaWdodEluZGV4KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCBjaGFydC5fdmFycy5oaWdobGlnaHRCb3JkZXJDb2xvcilcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgY2hhcnQuX3ZhcnMuaGlnaGxpZ2h0Qm9yZGVyV2lkdGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChoaWdobGlnaHRVcmkpIHtcclxuICAgICAgICAgICAgaWYgKGNoYXJ0LmNvbmZpZy50eXBlID09PSAnYmFyJykge1xyXG4gICAgICAgICAgICAgICAgLy9zZXQgYWxsIGJhcnMgc3Ryb2tlIHdpZHRoIHRvIDBcclxuICAgICAgICAgICAgICAgIHN2Zy5zZWxlY3QoJy5iYXItY29udGFpbmVyJykuc2VsZWN0QWxsKHRhZylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgMClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgMCk7XHJcbiAgICAgICAgICAgICAgICAvL2hpZ2hsaWdodCBuZWNlc3NhcnkgYmFyc1xyXG4gICAgICAgICAgICAgICAgc3ZnLnNlbGVjdCgnLmJhci1jb250YWluZXInKS5zZWxlY3RBbGwoJy5oaWdobGlnaHQtY2xhc3MtJyArIGhpZ2hsaWdodFVyaSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgY2hhcnQuX3ZhcnMuaGlnaGxpZ2h0Qm9yZGVyQ29sb3IpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIGNoYXJ0Ll92YXJzLmhpZ2hsaWdodEJvcmRlcldpZHRoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY2hhcnQuY29uZmlnLnR5cGUgPT09ICdsaW5lJyB8fCBjaGFydC5jb25maWcudHlwZSA9PT0gJ2FyZWEnKSB7XHJcbiAgICAgICAgICAgICAgICAvL3NldCBhbGwgY2lyY2xlcyBzdHJva2Ugd2lkdGggdG8gMFxyXG4gICAgICAgICAgICAgICAgc3ZnLnNlbGVjdCgnLmxpbmUtY29udGFpbmVyJykuc2VsZWN0QWxsKHRhZylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgMClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgMCk7XHJcbiAgICAgICAgICAgICAgICAvL2hpZ2hsaWdodCBuZWNlc3NhcnkgY2lybGNlc1xyXG4gICAgICAgICAgICAgICAgc3ZnLnNlbGVjdCgnLmxpbmUtY29udGFpbmVyJykuc2VsZWN0QWxsKHRhZykuZmlsdGVyKCcuaGlnaGxpZ2h0LWNsYXNzLScgKyBoaWdobGlnaHRVcmkpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsIGNoYXJ0Ll92YXJzLmhpZ2hsaWdodEJvcmRlckNvbG9yKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCBjaGFydC5fdmFycy5oaWdobGlnaHRCb3JkZXJXaWR0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnbmVlZCB0byBwYXNzIGhpZ2hsaWdodCBpbmRleCB0byBoaWdobGlnaHQgaXRlbScpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICpAZGVzYyBSZW1vdmVzIGhpZ2hsaWdodHMgdGhhdCB3ZXJlIGFwcGxpZWQgd2l0aCByZWxhdGVkIGluc2lnaHRzXHJcbiAgICAqXHJcbiAgICAqL1xyXG4gICAgcmVtb3ZlSGlnaGxpZ2h0KCkge1xyXG4gICAgICAgIGxldCBjaGFydCA9IHRoaXMsXHJcbiAgICAgICAgICAgIHN2ZyA9IGNoYXJ0LnN2ZztcclxuICAgICAgICBpZiAoY2hhcnQuY29uZmlnLnR5cGUgPT09ICdwaWUnKSB7XHJcbiAgICAgICAgICAgIC8vc2V0IGFsbCBjaXJjbGVzIHN0cm9rZSB3aWR0aCB0byAwXHJcbiAgICAgICAgICAgIHN2Zy5zZWxlY3QoJy5waWUtY29udGFpbmVyJykuc2VsZWN0QWxsKCdwYXRoJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCBjaGFydC5fdmFycy5waWVCb3JkZXIpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjaGFydC5jb25maWcudHlwZSA9PT0gJ3NjYXR0ZXJwbG90Jykge1xyXG4gICAgICAgICAgICBzdmcuc2VsZWN0KCcuc2NhdHRlci1jb250YWluZXInKS5zZWxlY3RBbGwoJ2NpcmNsZScpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjaGFydC5jb25maWcudHlwZSA9PT0gJ2JhcicpIHtcclxuICAgICAgICAgICAgc3ZnLnNlbGVjdCgnLmJhci1jb250YWluZXInKS5zZWxlY3RBbGwoJ3JlY3QnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsIDApXHJcbiAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjaGFydC5jb25maWcudHlwZSA9PT0gJ2xpbmUnIHx8IGNoYXJ0LmNvbmZpZy50eXBlID09PSAnYXJlYScpIHtcclxuICAgICAgICAgICAgc3ZnLnNlbGVjdCgnLmxpbmUtY29udGFpbmVyJykuc2VsZWN0QWxsKCdjaXJjbGUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsIDApXHJcbiAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBnZXRWaWV3Rm9yVmFsdWUoaW5wdXQpIHtcclxuICAgICAgICBsZXQgdmlld1N0cmluZyA9IGlucHV0LnJlcGxhY2UoL1xccy9nLCAnXycpXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXC4vZywgJ19kb3RfJyk7XHJcbiAgICAgICAgcmV0dXJuIHZpZXdTdHJpbmc7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGdldFJhd0ZvclZhbHVlKGlucHV0KSB7XHJcbiAgICAgICAgbGV0IHJhd1N0cmluZyA9IGlucHV0LnJlcGxhY2UoL18vZywgJyAnKVxyXG4gICAgICAgICAgICAucmVwbGFjZSgvX2RvdF8vZywgJy4nKTtcclxuICAgICAgICByZXR1cm4gcmF3U3RyaW5nO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBqdkZvcm1hdFZhbHVlKHZhbCwgZm9ybWF0VHlwZSkge1xyXG4gICAgICAgIGlmICghaXNOYU4odmFsKSkge1xyXG4gICAgICAgICAgICBsZXQgZm9ybWF0TnVtYmVyID0gZDMuZm9ybWF0KCcuMGYnKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChmb3JtYXRUeXBlID09PSAnYmlsbGlvbnMnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0TnVtYmVyKHZhbCAvIDFlOSkgKyAnQic7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0VHlwZSA9PT0gJ21pbGxpb25zJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE51bWJlcih2YWwgLyAxZTYpICsgJ00nO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdFR5cGUgPT09ICd0aG91c2FuZHMnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0TnVtYmVyKHZhbCAvIDFlMykgKyAnSyc7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0VHlwZSA9PT0gJ2RlY2ltYWxzJykge1xyXG4gICAgICAgICAgICAgICAgZm9ybWF0TnVtYmVyID0gZDMuZm9ybWF0KCcuMmYnKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXROdW1iZXIodmFsKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChmb3JtYXRUeXBlID09PSAnbm9kZWNpbWFscycpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXROdW1iZXIodmFsKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChmb3JtYXRUeXBlID09PSAncGVyY2VudCcpIHtcclxuICAgICAgICAgICAgICAgIGxldCBwID0gTWF0aC5tYXgoMCwgZDMucHJlY2lzaW9uRml4ZWQoMC4wNSkgLSAyKSxcclxuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uID0gZDMuZm9ybWF0KCcuJyArIHAgKyAnJScpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cHJlc3Npb24odmFsKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChmb3JtYXRUeXBlID09PSAnJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHZhbCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh2YWwpID49IDEwMDAwMDAwMDApIHtcclxuICAgICAgICAgICAgICAgIC8vQmlsbGlvbnNcclxuICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXROdW1iZXIodmFsIC8gMWU5KSArICdCJztcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyh2YWwpID49IDEwMDAwMDApIHtcclxuICAgICAgICAgICAgICAgIC8vTWlsbGlvbnNcclxuICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXROdW1iZXIodmFsIC8gMWU2KSArICdNJztcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyh2YWwpID49IDEwMDApIHtcclxuICAgICAgICAgICAgICAgIC8vVGhvdXNhbmRzXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0TnVtYmVyKHZhbCAvIDFlMykgKyAnSyc7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoTWF0aC5hYnModmFsKSA8PSAxMCkge1xyXG4gICAgICAgICAgICAgICAgLy8yIGRlY2ltYWxzXHJcbiAgICAgICAgICAgICAgICBmb3JtYXROdW1iZXIgPSBkMy5mb3JtYXQoJy4yZicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXROdW1iZXIodmFsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB0aGUgc2V0IG9mIHZhbHVlcyB0aGF0IHlvdSB3YW50IHRvIGZvcm1hdCB1bmlmb3JtbHlcclxuICAgICAqIEByZXR1cm4gJycgdGhlIGxldmVsIG9mIGZvcm1hdHRpbmcgZm9yIHRoZSBncm91cCBvZiBkYXRhXHJcbiAgICAgKiBQcm9ibGVtIHdpdGgganZGb3JtYXRWYWx1ZSBmdW5jdGlvbiBpcyB0aGF0IGlmIHlvdSBwYXNzIGluIHZhbHVlcyAxMCwgMjAuLi4gOTAsIDEwMCwgMTEyMCwgMTIwXHJcbiAgICAgKiB5b3Ugd2lsbCBnZXQgdGhlIGZvcm1hdHMgMTAuMDAsIDIwLjAwIC4uLi4gMTAwLCAxMTAsIDEyMCB3aGVuIHlvdSB3YW50IDEwLCAyMCwgLi4uIDEwMCwgMTEwXHJcbiAgICAgKiAtLUZvcm1hdCB0aGUgdmFsdWUgYmFzZWQgb2ZmIG9mIHRoZSBoaWdoZXN0IG51bWJlciBpbiB0aGUgZ3JvdXBcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGp2Rm9ybWF0VmFsdWVUeXBlKHZhbHVlQXJyYXksIGRhdGFUeXBlKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlQXJyYXkgIT0gbnVsbCAmJiBkYXRhVHlwZSAhPT0gJ1NUUklORycpIHtcclxuICAgICAgICAgICAgbGV0IG1heCA9IE1hdGgubWF4LmFwcGx5KG51bGwsIHZhbHVlQXJyYXkpLFxyXG4gICAgICAgICAgICAgICAgLy9BZnRlciBnZXR0aW5nIHRoZSBtYXgsIGNoZWNrIHRoZSBtaW5cclxuICAgICAgICAgICAgICAgIG1pbiA9IE1hdGgubWluLmFwcGx5KG51bGwsIHZhbHVlQXJyYXkpLFxyXG4gICAgICAgICAgICAgICAgcmFuZ2UgPSBtYXggLSBtaW4sXHJcbiAgICAgICAgICAgICAgICBpbmNyZW1lbW50ID0gTWF0aC5hYnMoTWF0aC5yb3VuZChyYW5nZSAvIDEwKSk7Ly8xMCBiZWluZyB0aGUgbnVtYmVyIG9mIGF4aXMgbGFiZWxzIHRvIHNob3dcclxuXHJcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhpbmNyZW1lbW50KSA+PSAxMDAwMDAwMDAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2JpbGxpb25zJztcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhpbmNyZW1lbW50KSA+PSAxMDAwMDAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ21pbGxpb25zJztcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhpbmNyZW1lbW50KSA+PSAxMDAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3Rob3VzYW5kcyc7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoTWF0aC5hYnMoaW5jcmVtZW1udCkgPD0gMTApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnZGVjaW1hbHMnO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKGluY3JlbWVtbnQpID49IDEwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ25vZGVjaW1hbHMnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAnJztcclxuICAgIH1cclxuXHJcbiAgICAvKipnZXRGb3JtYXRFeHByZXNzaW9uXHJcbiAgICAgKlxyXG4gICAgICogQGRlc2MgcmV0dXJucyB0aGUgZDMgZm9ybWF0IGV4cHJlc3Npb24gZm9yIGEgZ2l2ZW4gb3B0aW9uXHJcbiAgICAgKiBAcGFyYW1zIG9wdGlvblxyXG4gICAgICogQHJldHVybnMgc3RyaW5nIGV4cHJlc3Npb25cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldEZvcm1hdEV4cHJlc3Npb24ob3B0aW9uKSB7XHJcbiAgICAgICAgbGV0IGV4cHJlc3Npb24gPSAnJyxcclxuICAgICAgICAgICAgcDtcclxuICAgICAgICBpZiAob3B0aW9uID09PSAnY3VycmVuY3knKSB7XHJcbiAgICAgICAgICAgIGV4cHJlc3Npb24gPSBkMy5mb3JtYXQoJyQsJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcHRpb24gPT09ICdmaXhlZEN1cnJlbmN5Jykge1xyXG4gICAgICAgICAgICBleHByZXNzaW9uID0gZDMuZm9ybWF0KCcoJC4yZicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3B0aW9uID09PSAncGVyY2VudCcpIHtcclxuICAgICAgICAgICAgcCA9IE1hdGgubWF4KDAsIGQzLnByZWNpc2lvbkZpeGVkKDAuMDUpIC0gMik7XHJcbiAgICAgICAgICAgIGV4cHJlc3Npb24gPSBkMy5mb3JtYXQoJy4nICsgcCArICclJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcHRpb24gPT09ICdtaWxsaW9ucycpIHtcclxuICAgICAgICAgICAgcCA9IGQzLnByZWNpc2lvblByZWZpeCgxZTUsIDEuM2U2KTtcclxuICAgICAgICAgICAgZXhwcmVzc2lvbiA9IGQzLmZvcm1hdFByZWZpeCgnLicgKyBwLCAxLjNlNik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcHRpb24gPT09ICdjb21tYXMnKSB7XHJcbiAgICAgICAgICAgIGV4cHJlc3Npb24gPSBkMy5mb3JtYXQoJywuMGYnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9wdGlvbiA9PT0gJ25vbmUnIHx8IG9wdGlvbiA9PT0gJycpIHtcclxuICAgICAgICAgICAgZXhwcmVzc2lvbiA9IGQzLmZvcm1hdCgnJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcHRpb24gPT09ICdkaXNwbGF5VmFsdWVzJykge1xyXG4gICAgICAgICAgICBleHByZXNzaW9uID0gZDMuZm9ybWF0KCcsLjJmJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbjtcclxuICAgIH1cclxuXHJcbiAgICAvKipnZXRUb2dnbGVkRGF0YVxyXG4gICAgICpcclxuICAgICAqIEdldHMgdGhlIGhlYWRlcnMgb2YgdGhlIGRhdGEgdG8gYmUgZHJhd24gYW5kIGZpbHRlcnMgdGhlIGRhdGEgYmFzZWQgb24gdGhhdFxyXG4gICAgICogQHBhcmFtcyBjaGFydERhdGEsIGRhdGFIZWFkZXJzXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXRUb2dnbGVkRGF0YShkYXRhLCBkYXRhSGVhZGVycykge1xyXG4gICAgICAgIGxldCBsZWdlbmRUb2dnbGVBcnJheSA9IHRoaXMuZ2V0TGVnZW5kRWxlbWVudFRvZ2dsZUFycmF5KGRhdGFIZWFkZXJzLCBkYXRhLmxlZ2VuZERhdGEpLFxyXG4gICAgICAgICAgICBuZXdEYXRhID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShkYXRhLmNoYXJ0RGF0YSkpO1xyXG4gICAgICAgIGlmIChsZWdlbmRUb2dnbGVBcnJheSkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEuY2hhcnREYXRhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB0b2dnbGVLZXkgb2YgbGVnZW5kVG9nZ2xlQXJyYXkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodG9nZ2xlS2V5LnRvZ2dsZSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG5ld0RhdGFbaV1bdG9nZ2xlS2V5LmVsZW1lbnRdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3RGF0YTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIGdldExlZ2VuZEVsZW1lbnRUb2dnbGVBcnJheVxyXG4gICAgICogQGRlc2MgR2V0cyBhbiBhcnJheSBvZiBsZWdlbmQgZWxlbWVudHMgd2l0aCB0cnVlL2ZhbHNlIHRhZ3MgZm9yIGlmIHRvZ2dsZWRcclxuICAgICAqIEBwYXJhbSB7YW55fSBzZWxlY3RlZEhlYWRlcnMgLSBoZWFkZXJzIHNlbGVjdGVkIGJ5IHVzZXJcclxuICAgICAqIEBwYXJhbSB7YW55fSBhbGxIZWFkZXJzIC0gYWxsIGF2YWlsYWJsZSBoZWFkZXJzIGluIHRoZSB2aXN1YWxcclxuICAgICAqIEByZXR1cm5zIHthcnJheX0gLSBhcnJheSBvZiBsZWdlbmQgZWxlbWVudHNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldExlZ2VuZEVsZW1lbnRUb2dnbGVBcnJheShzZWxlY3RlZEhlYWRlcnMsIGFsbEhlYWRlcnMpIHtcclxuICAgICAgICBsZXQgbGVnZW5kVG9nZ2xlQXJyYXkgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBoZWFkZXIgb2YgYWxsSGVhZGVycykge1xyXG4gICAgICAgICAgICBsZWdlbmRUb2dnbGVBcnJheS5wdXNoKHsgZWxlbWVudDogaGVhZGVyIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yIChsZXQgdG9nZ2xlS2V5IG9mIGxlZ2VuZFRvZ2dsZUFycmF5KSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGhlYWRlciBvZiBzZWxlY3RlZEhlYWRlcnMpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0b2dnbGVLZXkuZWxlbWVudCA9PT0gaGVhZGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9nZ2xlS2V5LnRvZ2dsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRvZ2dsZUtleS50b2dnbGUgIT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIHRvZ2dsZUtleS50b2dnbGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbGVnZW5kVG9nZ2xlQXJyYXk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBnZW5lcmF0ZUxlZ2VuZEVsZW1lbnRzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHthbnl9IGNoYXJ0IC0gY2hhcnQgb2JqZWN0XHJcbiAgICAgKiBAcGFyYW0ge2FueX0gbGVnZW5kRGF0YSAtbGVnZW5kIGRhdGEgZm9yIHZpc3VhbFxyXG4gICAgICogQHBhcmFtIHthbnl9IGRyYXdGdW5jIC0gcmVkcmF3IGZ1bmN0aW9uIGZvciB2aXN1YWxcclxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IC0gbGVnZW5kIHJlY3RhbmdsZXNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdlbmVyYXRlTGVnZW5kRWxlbWVudHMoY2hhcnQsIGxlZ2VuZERhdGEsIGRyYXdGdW5jKSB7XHJcbiAgICAgICAgbGV0IHN2ZyA9IGNoYXJ0LnN2ZyxcclxuICAgICAgICAgICAgY29udGFpbmVyID0gY2hhcnQuY29uZmlnLmNvbnRhaW5lcixcclxuICAgICAgICAgICAgbGVnZW5kLFxyXG4gICAgICAgICAgICBsZWdlbmRSb3cgPSAwLFxyXG4gICAgICAgICAgICBsZWdlbmRDb2x1bW4gPSAwLFxyXG4gICAgICAgICAgICBsZWdlbmREYXRhTGVuZ3RoID0gbGVnZW5kRGF0YS5sZW5ndGgsXHJcbiAgICAgICAgICAgIGxlZ2VuZEVsZW1lbnRUb2dnbGVBcnJheSxcclxuICAgICAgICAgICAgbGVnZW5kUmVjdGFuZ2xlcyxcclxuICAgICAgICAgICAgbGVnZW5kVGV4dDtcclxuXHJcbiAgICAgICAgaWYgKCFjaGFydC5fdmFycy5sZWdlbmRJbmRleCkge1xyXG4gICAgICAgICAgICBjaGFydC5fdmFycy5sZWdlbmRJbmRleCA9IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWNoYXJ0Ll92YXJzLmxlZ2VuZEluZGV4TWF4KSB7XHJcbiAgICAgICAgICAgIGNoYXJ0Ll92YXJzLmxlZ2VuZEluZGV4TWF4ID0gTWF0aC5mbG9vcihsZWdlbmREYXRhTGVuZ3RoIC8gY2hhcnQuX3ZhcnMubGVnZW5kTWF4IC0gMC4wMSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2lmIGxlZ2VuZCBoZWFkZXJzIGRvbid0IGV4aXN0LCBzZXQgdGhlbSBlcXVhbCB0byBsZWdlbmQgZGF0YVxyXG4gICAgICAgIGlmICghY2hhcnQuX3ZhcnMubGVnZW5kSGVhZGVycyAmJiAhY2hhcnQuX3ZhcnMuc2VyaWVzRmxpcHBlZCkge1xyXG4gICAgICAgICAgICBjaGFydC5fdmFycy5sZWdlbmRIZWFkZXJzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShsZWdlbmREYXRhKSk7XHJcbiAgICAgICAgfSBlbHNlIGlmICghY2hhcnQuX3ZhcnMuZmxpcHBlZExlZ2VuZEhlYWRlcnMgJiYgY2hhcnQuX3ZhcnMuc2VyaWVzRmxpcHBlZCkge1xyXG4gICAgICAgICAgICBjaGFydC5fdmFycy5mbGlwcGVkTGVnZW5kSGVhZGVycyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobGVnZW5kRGF0YSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL1NldCBsZWdlbmQgZWxlbWVudCB0b2dnbGUgYXJyYXkgYmFzZWQgb24gaWYgc2VyaWVzIGlzIGZsaXBwZWRcclxuICAgICAgICBpZiAoIWNoYXJ0Ll92YXJzLnNlcmllc0ZsaXBwZWQpIHtcclxuICAgICAgICAgICAgbGVnZW5kRWxlbWVudFRvZ2dsZUFycmF5ID0gdGhpcy5nZXRMZWdlbmRFbGVtZW50VG9nZ2xlQXJyYXkoY2hhcnQuX3ZhcnMubGVnZW5kSGVhZGVycywgbGVnZW5kRGF0YSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbGVnZW5kRWxlbWVudFRvZ2dsZUFycmF5ID0gdGhpcy5nZXRMZWdlbmRFbGVtZW50VG9nZ2xlQXJyYXkoY2hhcnQuX3ZhcnMuZmxpcHBlZExlZ2VuZEhlYWRlcnMsIGxlZ2VuZERhdGEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGVnZW5kID0gc3ZnLmFwcGVuZCgnZycpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdsZWdlbmQnKTtcclxuXHJcbiAgICAgICAgLy9BZGRpbmcgY29sb3JlZCByZWN0YW5nbGVzIHRvIHRoZSBsZWdlbmRcclxuICAgICAgICBsZWdlbmRSZWN0YW5nbGVzID0gbGVnZW5kLnNlbGVjdEFsbCgncmVjdCcpXHJcbiAgICAgICAgICAgIC5kYXRhKGxlZ2VuZERhdGEpXHJcbiAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3JlY3QnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbGVnZW5kUmVjdCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4JywgKGQsIGkpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCBsZWdlbmRQb3M7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSAlIChjaGFydC5fdmFycy5sZWdlbmRNYXggLyAzKSA9PT0gMCAmJiBpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxlZ2VuZENvbHVtbiA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsZWdlbmRQb3MgPSAyMDAgKiBsZWdlbmRDb2x1bW47XHJcbiAgICAgICAgICAgICAgICBsZWdlbmRDb2x1bW4rKztcclxuICAgICAgICAgICAgICAgIHJldHVybiBsZWdlbmRQb3M7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5hdHRyKCd5JywgKGQsIGkpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChpICUgKGNoYXJ0Ll92YXJzLmxlZ2VuZE1heCAvIDMpID09PSAwICYmIGkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVnZW5kUm93Kys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaSAlIGNoYXJ0Ll92YXJzLmxlZ2VuZE1heCA9PT0gMCAmJiBpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxlZ2VuZFJvdyA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKGNvbnRhaW5lci5oZWlnaHQgKyAxMCkgKyAoMTUgKiAobGVnZW5kUm93ICsgMSkpIC0gNTsgLy9JbmNyZW1lbnQgcm93IHdoZW4gY29sdW1uIGxpbWl0IGlzIHJlYWNoZWRcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgY2hhcnQuX3ZhcnMuZ3JpZFNpemUpXHJcbiAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBjaGFydC5fdmFycy5ncmlkU2l6ZSlcclxuICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCAoZCwgaSkgPT4gdGhpcy5nZXRDb2xvcnMoY2hhcnQuX3ZhcnMuY29sb3IsIGksIGxlZ2VuZERhdGFbaV0pKVxyXG4gICAgICAgICAgICAuYXR0cignZGlzcGxheScsIChkLCBpKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA+PSAoY2hhcnQuX3ZhcnMubGVnZW5kSW5kZXggKiBjaGFydC5fdmFycy5sZWdlbmRNYXgpICYmIGkgPD0gKChjaGFydC5fdmFycy5sZWdlbmRJbmRleCAqIGNoYXJ0Ll92YXJzLmxlZ2VuZE1heCkgKyAoY2hhcnQuX3ZhcnMubGVnZW5kTWF4IC0gMSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdhbGwnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdub25lJztcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLmF0dHIoJ29wYWNpdHknLCAoZCwgaSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFsZWdlbmRFbGVtZW50VG9nZ2xlQXJyYXkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJzEnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGxlZ2VuZEVsZW1lbnRUb2dnbGVBcnJheVtpXS50b2dnbGUgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJzEnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICcwLjInO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgbGVnZW5kUm93ID0gMDtcclxuICAgICAgICBsZWdlbmRDb2x1bW4gPSAwO1xyXG5cclxuICAgICAgICAvL0FkZGluZyB0ZXh0IGxhYmVscyBmb3IgZWFjaCByZWN0YW5nbGUgaW4gbGVnZW5kXHJcbiAgICAgICAgbGVnZW5kVGV4dCA9IGxlZ2VuZC5zZWxlY3RBbGwoJ3RleHQnKVxyXG4gICAgICAgICAgICAuZGF0YShsZWdlbmREYXRhKVxyXG4gICAgICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgKGQsIGkpID0+ICdsZWdlbmRUZXh0IGVkaXRhYmxlIGVkaXRhYmxlLXRleHQgZWRpdGFibGUtY29udGVudCBlZGl0YWJsZS1sZWdlbmQtJyArIGkpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4JywgKGQsIGkpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChpICUgKGNoYXJ0Ll92YXJzLmxlZ2VuZE1heCAvIDMpID09PSAwICYmIGkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVnZW5kQ29sdW1uID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxldCBsZWdlbmRQb3MgPSAyMDAgKiBsZWdlbmRDb2x1bW47XHJcbiAgICAgICAgICAgICAgICBsZWdlbmRDb2x1bW4rKztcclxuICAgICAgICAgICAgICAgIHJldHVybiBsZWdlbmRQb3MgKyAxNztcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLmF0dHIoJ3knLCAoZCwgaSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgJSAoY2hhcnQuX3ZhcnMubGVnZW5kTWF4IC8gMykgPT09IDAgJiYgaSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBsZWdlbmRSb3crKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpICUgY2hhcnQuX3ZhcnMubGVnZW5kTWF4ID09PSAwICYmIGkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVnZW5kUm93ID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiAoY29udGFpbmVyLmhlaWdodCArIDEwKSArICgxNSAqIChsZWdlbmRSb3cgKyAxKSk7IC8vSW5jcmVtZW50IHJvdyB3aGVuIGNvbHVtbiBsaW1pdCBpcyByZWFjaGVkXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdzdGFydCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdkeScsICcwLjM1ZW0nKSAvL1ZlcnRpY2FsbHkgYWxpZ24gd2l0aCBub2RlXHJcbiAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgY2hhcnQuX3ZhcnMuZm9udENvbG9yKVxyXG4gICAgICAgICAgICAuYXR0cignZm9udC1zaXplJywgY2hhcnQuX3ZhcnMuZm9udFNpemUpXHJcbiAgICAgICAgICAgIC5hdHRyKCdkaXNwbGF5JywgKGQsIGkpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChpID49IChjaGFydC5fdmFycy5sZWdlbmRJbmRleCAqIGNoYXJ0Ll92YXJzLmxlZ2VuZE1heCkgJiYgaSA8PSAoKGNoYXJ0Ll92YXJzLmxlZ2VuZEluZGV4ICogY2hhcnQuX3ZhcnMubGVnZW5kTWF4KSArIChjaGFydC5fdmFycy5sZWdlbmRNYXggLSAxKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2FsbCc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ25vbmUnO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAudGV4dCgoZCwgaSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IGVsZW1lbnROYW1lID0gbGVnZW5kRGF0YVtpXTtcclxuICAgICAgICAgICAgICAgIGlmIChjaGFydC5jb25maWcudHlwZSA9PT0gJ2dhbnR0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnROYW1lID0gbGVnZW5kRGF0YVtpXS5zbGljZSgwLCAtNSk7Ly9SZW1vdmluZyBsYXN0IDUgY2hhcmFjdGVycyBvZiBsZWdlbmQgbGFiZWwtLS1pLmUgcGxhbm5lZFNUQVJUIC0+IHBsYW5uZWRcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50TmFtZS5sZW5ndGggPiAyMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50TmFtZS5zdWJzdHJpbmcoMCwgMTkpICsgJy4uLic7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudE5hbWU7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvL0FkZGluZyBpbmZvIGJveCB0byBsZWdlbmQgZWxlbWVudHMgd2hlbiBob3ZlcmluZyBvdmVyXHJcbiAgICAgICAgbGVnZW5kVGV4dFxyXG4gICAgICAgICAgICAuZGF0YShsZWdlbmREYXRhKVxyXG4gICAgICAgICAgICAuYXBwZW5kKCdzdmc6dGl0bGUnKVxyXG4gICAgICAgICAgICAudGV4dChkID0+IGQpO1xyXG5cclxuXHJcbiAgICAgICAgLy9Pbmx5IGNyZWF0ZSBjYXJvdXNlbCBpZiB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGV4Y2VlZHMgb25lIGxlZ2VuZCBcInBhZ2VcIlxyXG4gICAgICAgIGlmIChjaGFydC5fdmFycy5sZWdlbmRJbmRleE1heCA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy5jcmVhdGVDYXJvdXNlbChjaGFydCwgbGVnZW5kRGF0YSwgZHJhd0Z1bmMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL0NlbnRlcnMgdGhlIGxlZ2VuZCBpbiB0aGUgcGFuZWxcclxuICAgICAgICBpZiAobGVnZW5kKSB7XHJcbiAgICAgICAgICAgIGxldCBsZWdlbmRXaWR0aCA9IGxlZ2VuZC5ub2RlKCkuZ2V0QkJveCgpLndpZHRoO1xyXG4gICAgICAgICAgICBsZWdlbmQuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgKChjb250YWluZXIud2lkdGggLSBsZWdlbmRXaWR0aCkgLyAyKSArICcsIDMwKScpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGxlZ2VuZFJlY3RhbmdsZXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqdXBkYXRlRGF0YUZyb21MZWdlbmRcclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBkYXRhIGhlYWRlcnMgdGhhdCBzaG91bGQgYmUgZGlzcGxheWVkIGluIHZpelxyXG4gICAgICogYmFzZWQgb2ZmIHdoYXQgaXMgdG9nZ2xlZCBvbi9vZmYgaW4gbGVnZW5kXHJcbiAgICAgKiBAcGFyYW1zIGxlZ2VuZERhdGFcclxuICAgICAqL1xyXG4gICAgc3RhdGljIHVwZGF0ZURhdGFGcm9tTGVnZW5kKGxlZ2VuZERhdGEpIHtcclxuICAgICAgICBsZXQgZGF0YSA9IFtdLFxyXG4gICAgICAgICAgICBsZWdlbmRFbGVtZW50ID0gbGVnZW5kRGF0YVswXTtcclxuICAgICAgICBmb3IgKGxldCBlbGUgb2YgbGVnZW5kRWxlbWVudCkge1xyXG4gICAgICAgICAgICBpZiAoZWxlLmF0dHJpYnV0ZXMub3BhY2l0eS52YWx1ZSAhPT0gJzAuMicpIHtcclxuICAgICAgICAgICAgICAgIC8vSWYgbm90IHdoaXRlLCBhZGQgaXQgdG8gdGhlIHVwZGF0ZWQgZGF0YSBhcnJheVxyXG4gICAgICAgICAgICAgICAgZGF0YS5wdXNoKGVsZS5fX2RhdGFfXyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqY3JlYXRlQ2Fyb3VzZWxcclxuICAgICAqXHJcbiAgICAgKiBEcmF3cyB0aGUgaG9yaXpvbnRhbCBsZWdlbmQgY2Fyb3VzZWxcclxuICAgICAqIEBwYXJhbXMgY2hhcnQsIGxlZ2VuZERhdGEsIGRyYXdGdW5jXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjcmVhdGVDYXJvdXNlbChjaGFydCwgbGVnZW5kRGF0YSwgZHJhd0Z1bmMpIHtcclxuICAgICAgICBsZXQgc3ZnID0gY2hhcnQuc3ZnLFxyXG4gICAgICAgICAgICBjb250YWluZXIgPSBjaGFydC5jb25maWcuY29udGFpbmVyLFxyXG4gICAgICAgICAgICBsZWdlbmRQb2x5Z29uO1xyXG5cclxuICAgICAgICAvL0FkZGluZyBjYXJvdXNlbCB0byBsZWdlbmRcclxuICAgICAgICBzdmcuc2VsZWN0QWxsKCcubGVnZW5kLWNhcm91c2VsJykucmVtb3ZlKCk7XHJcbiAgICAgICAgc3ZnLnNlbGVjdEFsbCgnI2xlZ2VuZC10ZXh0LWluZGV4JykucmVtb3ZlKCk7XHJcblxyXG4gICAgICAgIGxlZ2VuZFBvbHlnb24gPSBzdmcuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2xlZ2VuZC1jYXJvdXNlbCcpO1xyXG5cclxuICAgICAgICAvL0NyZWF0ZXMgbGVmdCBuYXZpZ2F0aW9uIGFycm93IGZvciBjYXJvdXNlbFxyXG4gICAgICAgIGxlZ2VuZFBvbHlnb24uYXBwZW5kKCdwb2x5Z29uJylcclxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2xlZnRDaGV2cm9uJylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3BvaW50ZXItY3Vyc29yJylcclxuICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgY2hhcnQuX3ZhcnMubGVnZW5kQXJyb3dDb2xvcilcclxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwwKScpXHJcbiAgICAgICAgICAgIC5hdHRyKCdwb2ludHMnLCAnMCw3LjUsIDE1LDAsIDE1LDE1JylcclxuICAgICAgICAgICAgLm9uKCdjbGljaycsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChjaGFydC5fdmFycy5sZWdlbmRJbmRleCA+PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhcnQuX3ZhcnMubGVnZW5kSW5kZXgtLTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHN2Zy5zZWxlY3RBbGwoJy5sZWdlbmQnKS5yZW1vdmUoKTtcclxuICAgICAgICAgICAgICAgIGxldCBsZWdlbmRFbGVtZW50cyA9IHRoaXMuZ2VuZXJhdGVMZWdlbmRFbGVtZW50cyhjaGFydCwgbGVnZW5kRGF0YSwgZHJhd0Z1bmMpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hdHRhY2hDbGlja0V2ZW50c1RvTGVnZW5kKGNoYXJ0LCBsZWdlbmRFbGVtZW50cywgZHJhd0Z1bmMsIGxlZ2VuZERhdGEpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuYXR0cih7XHJcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJ0Ll92YXJzLmxlZ2VuZEluZGV4ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnbm9uZSc7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnYWxsJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vQ3JlYXRlcyBwYWdlIG51bWJlciBmb3IgY2Fyb3VzZWwgbmF2aWdhdGlvblxyXG4gICAgICAgIGxlZ2VuZFBvbHlnb24uYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2xlZ2VuZC10ZXh0LWluZGV4JylcclxuICAgICAgICAgICAgLmF0dHIoJ3gnLCAzNSlcclxuICAgICAgICAgICAgLmF0dHIoJ3knLCAxMi41KVxyXG4gICAgICAgICAgICAuc3R5bGUoJ3RleHQtYW5jaG9yJywgJ3N0YXJ0JylcclxuICAgICAgICAgICAgLnN0eWxlKCdmb250LXNpemUnLCBjaGFydC5fdmFycy5mb250U2l6ZSlcclxuICAgICAgICAgICAgLnRleHQoKCkgPT4gKGNoYXJ0Ll92YXJzLmxlZ2VuZEluZGV4ICsgMSkgKyAnIC8gJyArIChjaGFydC5fdmFycy5sZWdlbmRJbmRleE1heCArIDEpKVxyXG4gICAgICAgICAgICAuYXR0cih7XHJcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJ0Ll92YXJzLmxlZ2VuZEluZGV4TWF4ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnbm9uZSc7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnYWxsJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vQ3JlYXRlcyByaWdodCBuYXZpZ2F0aW9uIGFycm93IGZvciBjYXJvdXNlbFxyXG4gICAgICAgIGxlZ2VuZFBvbHlnb24uYXBwZW5kKCdwb2x5Z29uJylcclxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ3JpZ2h0Q2hldnJvbicpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdwb2ludGVyLWN1cnNvcicpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIGNoYXJ0Ll92YXJzLmxlZ2VuZEFycm93Q29sb3IpXHJcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDg1LDApJylcclxuICAgICAgICAgICAgLmF0dHIoJ3BvaW50cycsICcxNSw3LjUsIDAsMCwgMCwxNScpXHJcbiAgICAgICAgICAgIC5vbignY2xpY2snLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hhcnQuX3ZhcnMubGVnZW5kSW5kZXggPCBjaGFydC5fdmFycy5sZWdlbmRJbmRleE1heCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0Ll92YXJzLmxlZ2VuZEluZGV4Kys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzdmcuc2VsZWN0QWxsKCcubGVnZW5kJykucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgbGVnZW5kRWxlbWVudHMgPSB0aGlzLmdlbmVyYXRlTGVnZW5kRWxlbWVudHMoY2hhcnQsIGxlZ2VuZERhdGEsIGRyYXdGdW5jKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXR0YWNoQ2xpY2tFdmVudHNUb0xlZ2VuZChjaGFydCwgbGVnZW5kRWxlbWVudHMsIGRyYXdGdW5jLCBsZWdlbmREYXRhKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLmF0dHIoe1xyXG4gICAgICAgICAgICAgICAgZGlzcGxheTogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFydC5fdmFycy5sZWdlbmRJbmRleCA9PT0gY2hhcnQuX3ZhcnMubGVnZW5kSW5kZXhNYXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdub25lJztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdhbGwnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy9DZW50ZXJzIHRoZSBsZWdlbmQgcG9seWdvbnMgaW4gdGhlIHBhbmVsXHJcbiAgICAgICAgaWYgKGxlZ2VuZFBvbHlnb24pIHtcclxuICAgICAgICAgICAgbGV0IGxlZ2VuZFBvbHlnb25XaWR0aCA9IGxlZ2VuZFBvbHlnb24ubm9kZSgpLmdldEJCb3goKS53aWR0aDtcclxuICAgICAgICAgICAgbGVnZW5kUG9seWdvbi5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyAoKGNvbnRhaW5lci53aWR0aCAtIGxlZ2VuZFBvbHlnb25XaWR0aCkgLyAyKSArICcsJyArIChjb250YWluZXIuaGVpZ2h0ICsgMTA1KSArICcpJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipnZXRQbG90RGF0YVxyXG4gICAgICpcclxuICAgICAqIFJldHVybnMgb25seSBkYXRhIHZhbHVlcyB0byBiZSBwbG90dGVkOyBpbnB1dCBpcyB0aGUgZGF0YSBvYmplY3RcclxuICAgICAqIEBwYXJhbXMgb2JqZWN0RGF0YSwgY2hhcnRcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldFBsb3REYXRhKG9iamVjdERhdGEsIGNoYXJ0KSB7XHJcbiAgICAgICAgbGV0IGRhdGEgPSBbXSxcclxuICAgICAgICAgICAgb2JqRGF0YU5ldyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqZWN0RGF0YSkpOy8vQ29weSBvZiBiYXJEYXRhXHJcbiAgICAgICAgZm9yIChsZXQgb2JqRWxlIG9mIG9iakRhdGFOZXcpIHtcclxuICAgICAgICAgICAgbGV0IGdyb3VwID0gW107XHJcbiAgICAgICAgICAgIGZvciAobGV0IGxlZ2VuZEVsZSBvZiBjaGFydC5jdXJyZW50RGF0YS5sZWdlbmREYXRhKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iakVsZVtsZWdlbmRFbGVdICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwLnB1c2gob2JqRWxlW2xlZ2VuZEVsZV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRhdGEucHVzaChncm91cCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKmdldFBvc0NhbGN1bGF0aW9uc1xyXG4gICAgICpIb2xkcyB0aGUgbG9naWMgZm9yIHBvc2l0aW9uaW5nIGFsbCBiYXJzIG9uIGEgYmFyIGNoYXJ0IChkZXBlbmRzIG9uIHRvb2xEYXRhKVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbXMgc3ZnLCBjaGFydERhdGEsIG9wdGlvbnMsIHhBeGlzRGF0YSwgeUF4aXNEYXRhLCBjb250YWluZXJcclxuICAgICAqIEByZXR1cm5zIHt7fX1cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldFBvc0NhbGN1bGF0aW9ucyhjaGFydERhdGEsIF92YXJzLCB4QXhpc0RhdGEsIHlBeGlzRGF0YSwgY29udGFpbmVyLCBjaGFydCkge1xyXG4gICAgICAgIGxldCB4ID0ganZDaGFydHMuZ2V0QXhpc1NjYWxlKCd4JywgeEF4aXNEYXRhLCBjb250YWluZXIsIF92YXJzKSxcclxuICAgICAgICAgICAgeSA9IGp2Q2hhcnRzLmdldEF4aXNTY2FsZSgneScsIHlBeGlzRGF0YSwgY29udGFpbmVyLCBfdmFycyksXHJcbiAgICAgICAgICAgIHNjYWxlRmFjdG9yID0gMSxcclxuICAgICAgICAgICAgZGF0YSA9IFtdLFxyXG4gICAgICAgICAgICBzaXplID0gMCxcclxuICAgICAgICAgICAgcG9zaXRpb25GdW5jdGlvbnMgPSB7fTtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaXRlbSBpbiBjaGFydC5jdXJyZW50RGF0YS5kYXRhVGFibGUpIHtcclxuICAgICAgICAgICAgaWYgKGl0ZW0gIT09ICdsYWJlbCcgJiYgaXRlbS5pbmRleE9mKCd0b29sdGlwJykgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBzaXplKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAobGV0IGNoYXJ0RWxlIG9mIGNoYXJ0RGF0YSkge1xyXG4gICAgICAgICAgICBsZXQgdmFsID0gW107XHJcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBjaGFydEVsZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoYXJ0RWxlLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWwucHVzaChjaGFydEVsZVtrZXldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkYXRhLnB1c2godmFsLnNsaWNlKDEsIGNoYXJ0RWxlLmxlbmd0aCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKF92YXJzLnJvdGF0ZUF4aXMgPT09IHRydWUgJiYgX3ZhcnMuc3RhY2tUb2dnbGUgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgcG9zaXRpb25GdW5jdGlvbnMuc3RhcnR4ID0gKCkgPT4gMDtcclxuICAgICAgICAgICAgcG9zaXRpb25GdW5jdGlvbnMuc3RhcnR5ID0gKCkgPT4gMDtcclxuICAgICAgICAgICAgcG9zaXRpb25GdW5jdGlvbnMuc3RhcnR3aWR0aCA9ICgpID0+IDA7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uRnVuY3Rpb25zLnN0YXJ0aGVpZ2h0ID0gKCkgPT4geS5iYW5kd2lkdGgoKSAqIDAuOTU7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uRnVuY3Rpb25zLnggPSAoZCwgaSwgaikgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IGluY3JlbWVudCA9IDA7Ly9Nb3ZlIHRoZSB4IHVwIGJ5IHRoZSB2YWx1ZXMgdGhhdCBjb21lIGJlZm9yZSBpdFxyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgayA9IGkgLSAxOyBrID49IDA7IGstLSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNOYU4oaltrXS5fX2RhdGFfXykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jcmVtZW50ICs9IGpba10uX19kYXRhX187XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHgoaW5jcmVtZW50KSA9PT0gMCA/IDEgOiB4KGluY3JlbWVudCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHBvc2l0aW9uRnVuY3Rpb25zLnkgPSAoKSA9PiAwO1xyXG4gICAgICAgICAgICBwb3NpdGlvbkZ1bmN0aW9ucy53aWR0aCA9IGQgPT4gTWF0aC5hYnMoeCgwKSAtIHgoZCkpO1xyXG4gICAgICAgICAgICBwb3NpdGlvbkZ1bmN0aW9ucy5oZWlnaHQgPSAoKSA9PiB5LmJhbmR3aWR0aCgpICogMC45NTtcclxuICAgICAgICB9IGVsc2UgaWYgKF92YXJzLnJvdGF0ZUF4aXMgPT09IHRydWUgJiYgX3ZhcnMuc3RhY2tUb2dnbGUgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uRnVuY3Rpb25zLnN0YXJ0eCA9ICgpID0+IDA7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uRnVuY3Rpb25zLnN0YXJ0eSA9IChkLCBpKSA9PiB5LmJhbmR3aWR0aCgpIC8gc2l6ZSAqIGk7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uRnVuY3Rpb25zLnN0YXJ0d2lkdGggPSAoKSA9PiAwO1xyXG4gICAgICAgICAgICBwb3NpdGlvbkZ1bmN0aW9ucy5zdGFydGhlaWdodCA9ICgpID0+ICh5LmJhbmR3aWR0aCgpIC8gc2l6ZSAqIDAuOTUpICogc2NhbGVGYWN0b3I7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uRnVuY3Rpb25zLnggPSBkID0+IHgoMCkgLSB4KGQpID4gMCA/IHgoZCkgOiB4KDApO1xyXG4gICAgICAgICAgICBwb3NpdGlvbkZ1bmN0aW9ucy55ID0gKGQsIGkpID0+IHkuYmFuZHdpZHRoKCkgLyBzaXplICogaTtcclxuICAgICAgICAgICAgcG9zaXRpb25GdW5jdGlvbnMud2lkdGggPSBkID0+IE1hdGguYWJzKHgoMCkgLSB4KGQpKTtcclxuICAgICAgICAgICAgcG9zaXRpb25GdW5jdGlvbnMuaGVpZ2h0ID0gKCkgPT4gKHkuYmFuZHdpZHRoKCkgLyBzaXplICogMC45NSkgKiBzY2FsZUZhY3RvcjtcclxuICAgICAgICB9IGVsc2UgaWYgKF92YXJzLnJvdGF0ZUF4aXMgPT09IGZhbHNlICYmIF92YXJzLnN0YWNrVG9nZ2xlID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uRnVuY3Rpb25zLnN0YXJ0eCA9ICgpID0+IDA7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uRnVuY3Rpb25zLnN0YXJ0eSA9ICgpID0+IGNvbnRhaW5lci5oZWlnaHQ7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uRnVuY3Rpb25zLnN0YXJ0d2lkdGggPSAoKSA9PiAoeC5iYW5kd2lkdGgoKSAqIDAuOTUpICogc2NhbGVGYWN0b3I7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uRnVuY3Rpb25zLnN0YXJ0aGVpZ2h0ID0gKCkgPT4gMDtcclxuICAgICAgICAgICAgcG9zaXRpb25GdW5jdGlvbnMueCA9ICgpID0+IDA7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uRnVuY3Rpb25zLnkgPSAoZCwgaSwgaikgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IGluY3JlbWVudCA9IDA7Ly9Nb3ZlIHRoZSB5IHVwIGJ5IHRoZSB2YWx1ZXMgdGhhdCBjb21lIGJlZm9yZSBpdFxyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgayA9IGkgLSAxOyBrID49IDA7IGstLSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNOYU4oaltrXS5fX2RhdGFfXykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jcmVtZW50ICs9IGpba10uX19kYXRhX187XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHkocGFyc2VGbG9hdChkKSArIGluY3JlbWVudCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHBvc2l0aW9uRnVuY3Rpb25zLndpZHRoID0gKCkgPT4gKHguYmFuZHdpZHRoKCkgKiAwLjk1KSAqIHNjYWxlRmFjdG9yO1xyXG4gICAgICAgICAgICBwb3NpdGlvbkZ1bmN0aW9ucy5oZWlnaHQgPSBkID0+IGNvbnRhaW5lci5oZWlnaHQgLSB5KGQpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoX3ZhcnMucm90YXRlQXhpcyA9PT0gZmFsc2UgJiYgX3ZhcnMuc3RhY2tUb2dnbGUgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uRnVuY3Rpb25zLnN0YXJ0eCA9IChkLCBpKSA9PiB4LmJhbmR3aWR0aCgpIC8gc2l6ZSAqIGk7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uRnVuY3Rpb25zLnN0YXJ0eSA9ICgpID0+IGNvbnRhaW5lci5oZWlnaHQ7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uRnVuY3Rpb25zLnN0YXJ0d2lkdGggPSAoKSA9PiB4LmJhbmR3aWR0aCgpIC8gc2l6ZSAqIDAuOTU7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uRnVuY3Rpb25zLnN0YXJ0aGVpZ2h0ID0gKCkgPT4gMDtcclxuICAgICAgICAgICAgcG9zaXRpb25GdW5jdGlvbnMueCA9IChkLCBpKSA9PiB4LmJhbmR3aWR0aCgpIC8gc2l6ZSAqIGk7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uRnVuY3Rpb25zLnkgPSBkID0+IHkoMCkgLSB5KGQpID4gMCA/IHkoZCkgOiB5KDApO1xyXG4gICAgICAgICAgICBwb3NpdGlvbkZ1bmN0aW9ucy53aWR0aCA9ICgpID0+IHguYmFuZHdpZHRoKCkgLyBzaXplICogMC45NTtcclxuICAgICAgICAgICAgcG9zaXRpb25GdW5jdGlvbnMuaGVpZ2h0ID0gZCA9PiBNYXRoLmFicyh5KDApIC0geShkKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwb3NpdGlvbkZ1bmN0aW9ucztcclxuICAgIH1cclxuXHJcbiAgICAvKipnZXRDb2xvcnNcclxuICAgICAqXHJcbiAgICAgKiBnZXRzIHRoZSBjb2xvcnMgdG8gYXBwbHkgdG8gdGhlIHNwZWNpZmljIGNoYXJ0XHJcbiAgICAgKiBAcGFyYW1zIGNvbG9yT2JqLCBpbmRleCwgbGFiZWxcclxuICAgICAqIEByZXR1cm5zIHt7fX1cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldENvbG9ycyhjb2xvck9iaiwgcGFyYW1JbmRleCwgbGFiZWwpIHtcclxuICAgICAgICBsZXQgaW5kZXggPSBwYXJhbUluZGV4LFxyXG4gICAgICAgICAgICBjbGVhbmVkQ29sb3JzO1xyXG5cclxuICAgICAgICAvL2xvZ2ljIHRvIHJldHVybiB0aGUgY29sb3IgaWYgdGhlIGNvbG9yT2JqIHBhc3NlZCBpblxyXG4gICAgICAgIC8vaXMgYW4gb2JqZWN0IHdpdGggdGhlIGxhYmVsIGJlaW5nIHRoZSBrZXlcclxuICAgICAgICBpZiAodHlwZW9mIGxhYmVsICE9PSAndW5kZWZpbmVkJyAmJiBjb2xvck9iai5oYXNPd25Qcm9wZXJ0eShsYWJlbCkgJiYgY29sb3JPYmpbbGFiZWxdKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb2xvck9ialtsYWJlbF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoY29sb3JPYmopKSB7XHJcbiAgICAgICAgICAgIGNsZWFuZWRDb2xvcnMgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChsZXQgayBpbiBjb2xvck9iaikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbG9yT2JqLmhhc093blByb3BlcnR5KGspKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbG9yT2JqW2tdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFuZWRDb2xvcnMucHVzaChjb2xvck9ialtrXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY2xlYW5lZENvbG9ycyA9IGNvbG9yT2JqO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9sb2dpYyB0byByZXR1cm4gYSByZXBlYXRpbmcgc2V0IG9mIGNvbG9ycyBhc3N1bWluZyB0aGF0XHJcbiAgICAgICAgLy90aGUgdXNlciBjaGFuZ2VkIGRhdGEgKGV4OiBmbGlwIHNlcmllcyBvbiBiYXIgY2hhcnQpXHJcbiAgICAgICAgaWYgKCFjbGVhbmVkQ29sb3JzW2luZGV4XSkge1xyXG4gICAgICAgICAgICB3aGlsZSAoaW5kZXggPiBjbGVhbmVkQ29sb3JzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICAgIGluZGV4ID0gaW5kZXggLSBjbGVhbmVkQ29sb3JzLmxlbmd0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY2xlYW5lZENvbG9yc1tpbmRleF07XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHN0YXRpYyBnZXRBeGlzU2NhbGUod2hpY2hBeGlzLCBheGlzRGF0YSwgY29udGFpbmVyLCBfdmFycywgcGFkZGluZ1R5cGUpIHtcclxuICAgICAgICBsZXQgbGVmdFBhZGRpbmcgPSAwLjQsXHJcbiAgICAgICAgICAgIHJpZ2h0UGFkZGluZyA9IDAuMixcclxuICAgICAgICAgICAgYXhpc1NjYWxlLFxyXG4gICAgICAgICAgICBheGlzLFxyXG4gICAgICAgICAgICBtaW5EYXRlLFxyXG4gICAgICAgICAgICBtYXhEYXRlO1xyXG5cclxuICAgICAgICBpZiAocGFkZGluZ1R5cGUgPT09ICduby1wYWRkaW5nJykge1xyXG4gICAgICAgICAgICBsZWZ0UGFkZGluZyA9IDA7XHJcbiAgICAgICAgICAgIHJpZ2h0UGFkZGluZyA9IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB3aGljaEF4aXMgPT09ICd4JyA/IGF4aXMgPSBjb250YWluZXIud2lkdGggOiBheGlzID0gY29udGFpbmVyLmhlaWdodDtcclxuXHJcbiAgICAgICAgaWYgKGF4aXNEYXRhLmRhdGFUeXBlID09PSAnREFURScpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBheGlzRGF0YS52YWx1ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGF4aXNEYXRhLnZhbHVlc1tpXSA9IG5ldyBEYXRlKGF4aXNEYXRhLnZhbHVlc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIG1heERhdGUgPSBNYXRoLm1heC5hcHBseShudWxsLCBheGlzRGF0YS52YWx1ZXMpO1xyXG4gICAgICAgICAgICBtaW5EYXRlID0gTWF0aC5taW4uYXBwbHkobnVsbCwgYXhpc0RhdGEudmFsdWVzKTtcclxuXHJcbiAgICAgICAgICAgIGF4aXNTY2FsZSA9IGQzLnNjYWxlVGltZSgpLmRvbWFpbihbbmV3IERhdGUobWluRGF0ZSksIG5ldyBEYXRlKG1heERhdGUpXSkucmFuZ2VSb3VuZChbMCwgYXhpc10pO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoYXhpc0RhdGEuZGF0YVR5cGUgPT09ICdTVFJJTkcnKSB7XHJcbiAgICAgICAgICAgIGF4aXNTY2FsZSA9IGQzLnNjYWxlQmFuZCgpXHJcbiAgICAgICAgICAgICAgICAuZG9tYWluKGF4aXNEYXRhLnZhbHVlcylcclxuICAgICAgICAgICAgICAgIC5yYW5nZShbMCwgYXhpc10pXHJcbiAgICAgICAgICAgICAgICAucGFkZGluZ0lubmVyKGxlZnRQYWRkaW5nKVxyXG4gICAgICAgICAgICAgICAgLnBhZGRpbmdPdXRlcihyaWdodFBhZGRpbmcpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoYXhpc0RhdGEuZGF0YVR5cGUgPT09ICdOVU1CRVInKSB7XHJcbiAgICAgICAgICAgIGxldCBkb21haW47XHJcbiAgICAgICAgICAgIGlmIChfdmFycy54UmV2ZXJzZWQgfHwgX3ZhcnMueVJldmVyc2VkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKF92YXJzLnhSZXZlcnNlZCAmJiB3aGljaEF4aXMgPT09ICd4JykgfHwgKHdoaWNoQXhpcyA9PT0gJ3knICYmICFfdmFycy55UmV2ZXJzZWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9tYWluID0gW2F4aXNEYXRhLm1heCwgYXhpc0RhdGEubWluXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICgoX3ZhcnMueVJldmVyc2VkICYmIHdoaWNoQXhpcyA9PT0gJ3knKSB8fCAod2hpY2hBeGlzID09PSAneCcgJiYgIV92YXJzLnhSZXZlcnNlZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBkb21haW4gPSBbYXhpc0RhdGEubWluLCBheGlzRGF0YS5tYXhdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgd2hpY2hBeGlzID09PSAneCcgPyBkb21haW4gPSBbYXhpc0RhdGEubWluLCBheGlzRGF0YS5tYXhdIDogZG9tYWluID0gW2F4aXNEYXRhLm1heCwgYXhpc0RhdGEubWluXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKF92YXJzLmhhc093blByb3BlcnR5KCdheGlzVHlwZScpICYmIF92YXJzLmF4aXNUeXBlID09PSAnTG9nYXJpdGhtaWMnKSB7XHJcbiAgICAgICAgICAgICAgICBkb21haW5bMV0gPSAwLjE7XHJcbiAgICAgICAgICAgICAgICBheGlzU2NhbGUgPSBkMy5zY2FsZUxvZygpLmJhc2UoMTApLmRvbWFpbihkb21haW4pLnJhbmdlUm91bmQoWzAsIGF4aXNdKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGF4aXNTY2FsZSA9IGQzLnNjYWxlTGluZWFyKCkuZG9tYWluKGRvbWFpbikucmFuZ2VSb3VuZChbMCwgYXhpc10pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignQXhpcyBpcyBub3QgYSB2YWxpZCBkYXRhIHR5cGUnKTtcclxuICAgICAgICAgICAgLy90aHJvdyBuZXcgRXJyb3IoJ0F4aXMgaXMgbm90IGEgdmFsaWQgZGF0YSB0eXBlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBheGlzU2NhbGU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBEYXRhIGZ1bmN0aW9ucyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYWJlbCAtIFRoZSBmaWVsZCB0aGF0IGlzIGNoZWNrZWQgZm9yIHR5cGVcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhVGFibGVLZXlzIC0gT2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIGRhdGEgdHlwZSBmb3IgZWFjaCBjb2x1bW4gb2YgZGF0YVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0RGF0YVR5cGVGcm9tS2V5cyhsYWJlbCwgZGF0YVRhYmxlS2V5cywgZGVmYXVsdFR5cGUgPSAnU1RSSU5HJykge1xyXG4gICAgICAgIGxldCB0eXBlID0gZGVmYXVsdFR5cGU7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGtleSBvZiBkYXRhVGFibGVLZXlzKSB7XHJcbiAgICAgICAgICAgIC8vUmVwbGFjZSB1bmRlcnNjb3JlcyB3aXRoIHNwYWNlc1xyXG4gICAgICAgICAgICBpZiAoa2V5Lm5hbWUucmVwbGFjZSgvXy9nLCAnICcpID09PSBsYWJlbC5yZXBsYWNlKC9fL2csICcgJykpIHtcclxuICAgICAgICAgICAgICAgIGlmIChrZXkuaGFzT3duUHJvcGVydHkoJ3R5cGUnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSAoa2V5LnR5cGUgKyAnJykudG9VcHBlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ1NUUklORycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9ICdTVFJJTkcnO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ0RBVEUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSAnREFURSc7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnTlVNQkVSJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gJ05VTUJFUic7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9ICdOVU1CRVInO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHlwZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipzZXRCYXJMaW5lTGVnZW5kRGF0YVxyXG4gICAgICogIGdldHMgbGVnZW5kIGluZm8gZnJvbSBjaGFydCBEYXRhXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtcyBkYXRhLCB0eXBlXHJcbiAgICAgKiBAcmV0dXJucyBbXSBvZiBsZWdlbmQgdGV4dFxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgc2V0QmFyTGluZUxlZ2VuZERhdGEoZGF0YSkge1xyXG4gICAgICAgIGxldCBsZWdlbmRBcnJheSA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGl0ZW0gaW4gZGF0YS5kYXRhVGFibGUpIHtcclxuICAgICAgICAgICAgaWYgKGRhdGEuZGF0YVRhYmxlLmhhc093blByb3BlcnR5KGl0ZW0pKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXRlbSAhPT0gJ2xhYmVsJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxlZ2VuZEFycmF5LnB1c2goZGF0YS5kYXRhVGFibGVbaXRlbV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBsZWdlbmRBcnJheTtcclxuICAgIH1cclxuXHJcbiAgICAvKipzZXRDaGFydENvbG9yc1xyXG4gICAgICogIGNsZWFucyBpbmNvbWluZyBjb2xvcnMgZm9yIGNvbnNpc3RlbmN5XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtcyBjb2xvckFycmF5LCBsZWdlbmREYXRhXHJcbiAgICAgKiBAcmV0dXJucyBvYmplY3Qgd2l0aCBjb2xvcnNcclxuICAgICAqL1xyXG5cclxuICAgIHN0YXRpYyBzZXRDaGFydENvbG9ycyh0b29sRGF0YSwgbGVnZW5kRGF0YSwgZGVmYXVsdENvbG9yQXJyYXkpIHtcclxuICAgICAgICAvL2Z1bmN0aW9uIGhhbmRsZXMgMyBjb2xvciBpbnB1dHNcclxuICAgICAgICAvL3Rvb2xEYXRhIGFzIGFuIGFycmF5IGluIHRvb2xEYXRhXHJcbiAgICAgICAgLy90b29sRGF0YSBhcyBhbiBvYmplY3RcclxuICAgICAgICAvL3Rvb2xEYXRhIGFzICdub25lJ1xyXG4gICAgICAgIC8vYW55IG90aGVyIGNhc2Ugd2lsbCByZXN1bHQgaW4gdXNpbmcgZGVmYXVsdENvbG9yQXJyYXlcclxuXHJcbiAgICAgICAgbGV0IGNvbG9ycyA9IHt9LFxyXG4gICAgICAgICAgICB1c2VkQ29sb3JzID0gW10sXHJcbiAgICAgICAgICAgIHVuYWNjb3VudGVkTGVnZW5kRWxlbWVudHMgPSBbXSxcclxuICAgICAgICAgICAgdG9vbERhdGFBc0FycmF5O1xyXG5cclxuICAgICAgICAvL3Rvb2xEYXRhIGlzIGFycmF5XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodG9vbERhdGEpKSB7XHJcbiAgICAgICAgICAgIGlmICh0b29sRGF0YS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb2xvcnMgPSB0aGlzLmNyZWF0ZUNvbG9yc1dpdGhEZWZhdWx0KGxlZ2VuZERhdGEsIHRvb2xEYXRhKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbG9ycyA9IHRoaXMuY3JlYXRlQ29sb3JzV2l0aERlZmF1bHQobGVnZW5kRGF0YSwgZGVmYXVsdENvbG9yQXJyYXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmICh0b29sRGF0YSA9PT0gT2JqZWN0KHRvb2xEYXRhKSkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBsZWdlbmRFbGUgb2YgbGVnZW5kRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRvb2xEYXRhLmhhc093blByb3BlcnR5KGxlZ2VuZEVsZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB1c2VkQ29sb3JzLnB1c2godG9vbERhdGFbbGVnZW5kRWxlXSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHVuYWNjb3VudGVkTGVnZW5kRWxlbWVudHMucHVzaChsZWdlbmRFbGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vY2hlY2sgaWYgb2JqZWN0IGhhcyBkZXNpcmVkIGtleXNcclxuICAgICAgICAgICAgaWYgKHVzZWRDb2xvcnMubGVuZ3RoID09PSBsZWdlbmREYXRhLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgY29sb3JzID0gdG9vbERhdGE7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodXNlZENvbG9ycy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICB0b29sRGF0YUFzQXJyYXkgPSBPYmplY3QudmFsdWVzKHRvb2xEYXRhKTtcclxuICAgICAgICAgICAgICAgIGlmICh0b29sRGF0YUFzQXJyYXkubGVuZ3RoID4gbGVnZW5kRGF0YS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2xvcnMgPSB0aGlzLmNyZWF0ZUNvbG9yc1dpdGhEZWZhdWx0KGxlZ2VuZERhdGEsIHRvb2xEYXRhQXNBcnJheSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbG9ycyA9IHRoaXMuY3JlYXRlQ29sb3JzV2l0aERlZmF1bHQobGVnZW5kRGF0YSwgZGVmYXVsdENvbG9yQXJyYXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdG9vbERhdGFBc0FycmF5ID0gT2JqZWN0LnZhbHVlcyh0b29sRGF0YSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodG9vbERhdGFBc0FycmF5Lmxlbmd0aCA+IGxlZ2VuZERhdGEubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sb3JzID0gdGhpcy5jcmVhdGVDb2xvcnNXaXRoRGVmYXVsdChsZWdlbmREYXRhLCB0b29sRGF0YUFzQXJyYXkpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2xvcnMgPSB0aGlzLmNyZWF0ZUNvbG9yc1dpdGhEZWZhdWx0KGxlZ2VuZERhdGEsIGRlZmF1bHRDb2xvckFycmF5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbG9ycyA9IHRoaXMuY3JlYXRlQ29sb3JzV2l0aERlZmF1bHQobGVnZW5kRGF0YSwgZGVmYXVsdENvbG9yQXJyYXkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGNvbG9ycztcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgY3JlYXRlQ29sb3JzV2l0aERlZmF1bHQobGVnZW5kRGF0YSwgY29sb3JzKSB7XHJcbiAgICAgICAgbGV0IG1hcHBlZENvbG9ycyA9IHt9LFxyXG4gICAgICAgICAgICBjb3VudCA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgbGVnZW5kRWxlIG9mIGxlZ2VuZERhdGEpIHtcclxuICAgICAgICAgICAgaWYgKGNvdW50ID4gY29sb3JzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICAgIGNvdW50ID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBtYXBwZWRDb2xvcnNbbGVnZW5kRWxlXSA9IGNvbG9yc1tjb3VudF07XHJcbiAgICAgICAgICAgIGNvdW50Kys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtYXBwZWRDb2xvcnM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqY2xlYW5Ub29sRGF0YVxyXG4gICAgICogIGNsZWFucyBpbmNvbWluZyB0b29sRGF0YSBmb3IgY29uc2lzdGVuY3lcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdG9vbERhdGFcclxuICAgICAqIEByZXR1cm5zIG9iamVjdCB3aXRoIHRvb2xkYXRhXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjbGVhblRvb2xEYXRhKG9wdGlvbnMgPSB7fSwgZWRpdE9wdGlvbnMgPSB7fSkge1xyXG4gICAgICAgIGxldCBkYXRhID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcbiAgICAgICAgaWYgKCFkYXRhLmhhc093blByb3BlcnR5KCdyb3RhdGVBeGlzJykpIHtcclxuICAgICAgICAgICAgZGF0YS5yb3RhdGVBeGlzID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KCdzdGFja1RvZ2dsZScpKSB7XHJcbiAgICAgICAgICAgIGlmIChkYXRhLnN0YWNrVG9nZ2xlID09PSAnc3RhY2stZGF0YScgfHwgZGF0YS5zdGFja1RvZ2dsZSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgZGF0YS5zdGFja1RvZ2dsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkYXRhLnN0YWNrVG9nZ2xlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBkYXRhLnN0YWNrVG9nZ2xlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KCdjb2xvcnMnKSkge1xyXG4gICAgICAgICAgICBkYXRhLmNvbG9yID0gZGF0YS5jb2xvcnM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghZGF0YS5oYXNPd25Qcm9wZXJ0eSgndGhyZXNob2xkcycpKSB7XHJcbiAgICAgICAgICAgIGRhdGEudGhyZXNob2xkcyA9IFtdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9UaGVzZSBhcmUgdXNlZCBpbiBzZXR0aW5nIGR5bmFtaWMgbWFyZ2lucyBvbiB0aGUgeSBBeGlzIGluIGp2Q2hhcnRzXHJcbiAgICAgICAgaWYgKGVkaXRPcHRpb25zICYmIGVkaXRPcHRpb25zLmhhc093blByb3BlcnR5KCd5QXhpcycpICYmIGVkaXRPcHRpb25zLnlBeGlzLmhhc093blByb3BlcnR5KCdlZGl0YWJsZS10ZXh0LXNpemUnKSkge1xyXG4gICAgICAgICAgICBkYXRhLnlMYWJlbEZvbnRTaXplID0gZWRpdE9wdGlvbnMueUF4aXNbJ2VkaXRhYmxlLXRleHQtc2l6ZSddO1xyXG4gICAgICAgICAgICBkYXRhLnlMYWJlbEZvcm1hdCA9IGVkaXRPcHRpb25zLnlBeGlzWydlZGl0YWJsZS1udW0tZm9ybWF0J107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBnZXRNYXhXaWR0aEZvckF4aXNEYXRhKGF4aXMsIGF4aXNEYXRhLCBfdmFycywgZGltZW5zaW9ucywgbWFyZ2luLCBjaGFydERpdikge1xyXG4gICAgICAgIGxldCBtYXhBeGlzVGV4dCA9ICcnLFxyXG4gICAgICAgICAgICBmb3JtYXRUeXBlLFxyXG4gICAgICAgICAgICBkdW1teVNWRyxcclxuICAgICAgICAgICAgYXhpc0R1bW15LFxyXG4gICAgICAgICAgICB3aWR0aDtcclxuICAgICAgICAvL0R5bmFtaWMgbGVmdCBtYXJnaW4gZm9yIGNoYXJ0cyB3aXRoIHkgYXhpc1xyXG4gICAgICAgIGlmIChfdmFycy5yb3RhdGVBeGlzKSB7XHJcbiAgICAgICAgICAgIC8vZ2V0IGxlbmd0aCBvZiBsb25nZXN0IHRleHQgbGFiZWwgYW5kIG1ha2UgdGhlIGF4aXMgYmFzZWQgb2ZmIHRoYXRcclxuICAgICAgICAgICAgbGV0IG1heFN0cmluZyA9ICcnLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gcGFyc2VJbnQoZGltZW5zaW9ucy5oZWlnaHQsIDEwKSAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tO1xyXG5cclxuICAgICAgICAgICAgLy9jaGVjayBpZiBsYWJlbHMgc2hvdWxkIGJlIHNob3duXHJcbiAgICAgICAgICAgIGlmIChoZWlnaHQgIT09IDAgJiYgaGVpZ2h0IC8gYXhpc0RhdGEudmFsdWVzLmxlbmd0aCA8IHBhcnNlSW50KF92YXJzLmZvbnRTaXplLCAxMCkpIHtcclxuICAgICAgICAgICAgICAgIGF4aXNEYXRhLmhpZGVWYWx1ZXMgPSB0cnVlO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYXhpc1ZhbHVlIG9mIGF4aXNEYXRhLnZhbHVlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBjdXJyZW50U3RyID0gYXhpc1ZhbHVlLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTdHIubGVuZ3RoID4gbWF4U3RyaW5nLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhTdHJpbmcgPSBjdXJyZW50U3RyO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG1heEF4aXNUZXh0ID0gbWF4U3RyaW5nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmICghIV92YXJzLnlMYWJlbEZvcm1hdCB8fCAhIV92YXJzLnhMYWJlbEZvcm1hdCkge1xyXG4gICAgICAgICAgICBsZXQgbGFiZWxGb3JtYXQgPSBfdmFycy55TGFiZWxGb3JtYXQsXHJcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uO1xyXG4gICAgICAgICAgICBpZiAoYXhpcyA9PT0gJ3gnKSB7XHJcbiAgICAgICAgICAgICAgICBsYWJlbEZvcm1hdCA9IF92YXJzLnhMYWJlbEZvcm1hdDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZm9ybWF0VHlwZSA9IHRoaXMuanZGb3JtYXRWYWx1ZVR5cGUoYXhpc0RhdGEudmFsdWVzKTtcclxuICAgICAgICAgICAgZXhwcmVzc2lvbiA9IHRoaXMuZ2V0Rm9ybWF0RXhwcmVzc2lvbihsYWJlbEZvcm1hdCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoZXhwcmVzc2lvbiAhPT0gJycpIHtcclxuICAgICAgICAgICAgICAgIG1heEF4aXNUZXh0ID0gZXhwcmVzc2lvbihheGlzRGF0YS5tYXgpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbWF4QXhpc1RleHQgPSB0aGlzLmp2Rm9ybWF0VmFsdWUoYXhpc0RhdGEubWF4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGZvcm1hdFR5cGUgPSB0aGlzLmp2Rm9ybWF0VmFsdWVUeXBlKGF4aXNEYXRhLnZhbHVlcyk7XHJcbiAgICAgICAgICAgIGlmICghYXhpc0RhdGEuaGFzT3duUHJvcGVydHkoJ21heCcpKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbWF4TGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGF4aXNWYWx1ZSBvZiBheGlzRGF0YS52YWx1ZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYXhpc1ZhbHVlICYmIGF4aXNWYWx1ZS5sZW5ndGggPiBtYXhMZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4TGVuZ3RoID0gYXhpc1ZhbHVlLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4QXhpc1RleHQgPSBheGlzVmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbWF4QXhpc1RleHQgPSB0aGlzLmp2Rm9ybWF0VmFsdWUoYXhpc0RhdGEubWF4LCBmb3JtYXRUeXBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9pZiAodHlwZSA9PT0gJ2hlYXRtYXAnKSB7XHJcbiAgICAgICAgLy8vL2Fsc28gbmVlZCB0byBjaGVjayB3aWR0aCBvZiBsYWJlbFxyXG4gICAgICAgIC8vaWYgKG1heEF4aXNUZXh0Lmxlbmd0aCA8IGF4aXNEYXRhLmxhYmVsLmxlbmd0aCArIDUpIHtcclxuICAgICAgICAvLy8vbmVlZCBhZGRlZCBzcGFjZVxyXG4gICAgICAgIC8vaWYgKGF4aXMgPT09ICd4Jykge1xyXG4gICAgICAgIC8vbWF4QXhpc1RleHQgPSBheGlzRGF0YS5sYWJlbDtcclxuICAgICAgICAvL30gZWxzZSB7XHJcbiAgICAgICAgLy9tYXhBeGlzVGV4dCA9IGF4aXNEYXRhLmxhYmVsICsgJ0V4dHJhJztcclxuICAgICAgICAvL31cclxuICAgICAgICAvL31cclxuICAgICAgICAvL31cclxuXHJcbiAgICAgICAgLy9DcmVhdGUgZHVtbXkgc3ZnIHRvIHBsYWNlIG1heCBzaXplZCB0ZXh0IGVsZW1lbnQgb25cclxuICAgICAgICBkdW1teVNWRyA9IGNoYXJ0RGl2LmFwcGVuZCgnc3ZnJykuYXR0cignY2xhc3MnLCAnZHVtbXktc3ZnJyk7XHJcblxyXG4gICAgICAgIC8vQ3JlYXRlIGR1bW15IHRleHQgZWxlbWVudFxyXG4gICAgICAgIGF4aXNEdW1teSA9IGR1bW15U1ZHXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAuYXR0cignZm9udC1zaXplJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGF4aXMgPT09ICd5JyAmJiBfdmFycy55TGFiZWxGb250U2l6ZSAhPT0gJ25vbmUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF92YXJzLnlMYWJlbEZvbnRTaXplO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGF4aXMgPT09ICd4JyAmJiBfdmFycy54TGFiZWxGb250U2l6ZSAhPT0gJ25vbmUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF92YXJzLnhMYWJlbEZvbnRTaXplO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF92YXJzLmZvbnRTaXplO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuYXR0cigneCcsIDApXHJcbiAgICAgICAgICAgIC5hdHRyKCd5JywgMClcclxuICAgICAgICAgICAgLnRleHQobWF4QXhpc1RleHQpO1xyXG5cclxuICAgICAgICAvL0NhbGN1bGF0ZSB0aGUgd2lkdGggb2YgdGhlIGR1bW15IHRleHRcclxuICAgICAgICB3aWR0aCA9IGF4aXNEdW1teS5ub2RlKCkuZ2V0QkJveCgpLndpZHRoO1xyXG4gICAgICAgIC8vUmVtb3ZlIHRoZSBzdmcgYW5kIHRleHQgZWxlbWVudFxyXG4gICAgICAgIGNoYXJ0RGl2LnNlbGVjdCgnLmR1bW15LXN2ZycpLnJlbW92ZSgpO1xyXG4gICAgICAgIHJldHVybiB3aWR0aDtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZ2V0RGlzcGxheVZhbHVlc0VsZW1lbnQob2JqZWN0LCBkYXRhVGFibGVBbGlnbiwgdHlwZSkge1xyXG4gICAgICAgIGxldCB2YWx1ZXNBcnJheSA9IFtdO1xyXG5cclxuICAgICAgICBpZiAodHlwZSA9PT0gJ2JhcicgfHwgdHlwZSA9PT0gJ3BpZScgfHwgdHlwZSA9PT0gJ2xpbmUnIHx8IHR5cGUgPT09ICdhcmVhJykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gZGF0YVRhYmxlQWxpZ24pIHtcclxuICAgICAgICAgICAgICAgIGlmIChkYXRhVGFibGVBbGlnbi5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleS5pbmRleE9mKCd2YWx1ZScpID4gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzQXJyYXkucHVzaChvYmplY3RbZGF0YVRhYmxlQWxpZ25ba2V5XV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBvYmplY3QpIHtcclxuICAgICAgICAgICAgICAgIGlmIChvYmplY3QuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlc0FycmF5LnB1c2gob2JqZWN0W2tleV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWx1ZXNBcnJheTtcclxuICAgIH1cclxuXHJcbiAgICAvKipnZXRaU2NhbGVcclxuICAgICAqXHJcbiAgICAgKiBnZXRzIHRoZSBzY2FsZSBmb3IgdGhlIHogYXhpc1xyXG4gICAgICogQHBhcmFtcyB6QXhpc0RhdGEsIGNvbnRhaW5lciwgcGFkZGluZ1xyXG4gICAgICogQHJldHVybnMge3t9fVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0WlNjYWxlKHpBeGlzRGF0YSwgY29udGFpbmVyLCBfdmFycykge1xyXG4gICAgICAgIGxldCB6QXhpc1NjYWxlID0gZDMuc2NhbGVMaW5lYXIoKVxyXG4gICAgICAgICAgICAuZG9tYWluKFtkMy5taW4oekF4aXNEYXRhLnZhbHVlcyksIGQzLm1heCh6QXhpc0RhdGEudmFsdWVzKV0pXHJcbiAgICAgICAgICAgIC5yYW5nZVJvdW5kKFtfdmFycy5OT0RFX01JTl9TSVpFLCBfdmFycy5OT0RFX01BWF9TSVpFXSlcclxuICAgICAgICAgICAgLm5pY2UoKTtcclxuICAgICAgICByZXR1cm4gekF4aXNTY2FsZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipnZW5lcmF0ZUV2ZW50R3JvdXBzXHJcbiAgICAgKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbXMgY2hhcnRDb250YWluZXIsIGJhckRhdGEsIGNoYXJ0XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZW5lcmF0ZUV2ZW50R3JvdXBzKGNoYXJ0Q29udGFpbmVyLCBiYXJEYXRhLCBjaGFydCkge1xyXG4gICAgICAgIGxldCBjb250YWluZXIgPSBjaGFydC5jb25maWcuY29udGFpbmVyLFxyXG4gICAgICAgICAgICBkYXRhVG9QbG90ID0ganZDaGFydHMuZ2V0UGxvdERhdGEoYmFyRGF0YSwgY2hhcnQpLFxyXG4gICAgICAgICAgICBldmVudEdyb3VwcztcclxuXHJcbiAgICAgICAgLy9JbnZpc2libGUgcmVjdGFuZ2xlcyBvbiBzY3JlZW4gdGhhdCByZXByZXNlbnQgYmFyIGdyb3Vwcy4gVXNlZCB0byBzaG93L2hpZGUgdG9vbCB0aXBzIG9uIGhvdmVyXHJcbiAgICAgICAgZXZlbnRHcm91cHMgPSBjaGFydENvbnRhaW5lclxyXG4gICAgICAgICAgICAuZGF0YShkYXRhVG9QbG90KVxyXG4gICAgICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgICAgICAuYXBwZW5kKCdyZWN0JylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2V2ZW50LXJlY3QnKVxyXG4gICAgICAgICAgICAvL3NldHMgdGhlIHggcG9zaXRpb24gb2YgdGhlIGJhclxyXG4gICAgICAgICAgICAuYXR0cigneCcsIChkLCBpKSA9PiBjaGFydC5fdmFycy5yb3RhdGVBeGlzID8gMCA6IChjb250YWluZXIud2lkdGggLyBiYXJEYXRhLmxlbmd0aCAqIGkpKVxyXG4gICAgICAgICAgICAvL3NldHMgdGhlIHkgcG9zaXRpb24gb2YgdGhlIGJhclxyXG4gICAgICAgICAgICAuYXR0cigneScsIChkLCBpKSA9PiBjaGFydC5fdmFycy5yb3RhdGVBeGlzID8gKGNvbnRhaW5lci5oZWlnaHQgLyBiYXJEYXRhLmxlbmd0aCAqIGkpIDogMClcclxuICAgICAgICAgICAgLy9zZXRzIHRoZSB3aWR0aCBwb3NpdGlvbiBvZiB0aGUgYmFyXHJcbiAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsICgpID0+IGNoYXJ0Ll92YXJzLnJvdGF0ZUF4aXMgPyBjb250YWluZXIud2lkdGggOiAoY29udGFpbmVyLndpZHRoIC8gYmFyRGF0YS5sZW5ndGgpKVxyXG4gICAgICAgICAgICAvL3NldHMgdGhlIGhlaWdodCBwb3NpdGlvbiBvZiB0aGUgYmFyXHJcbiAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCAoKSA9PiBjaGFydC5fdmFycy5yb3RhdGVBeGlzID8gKGNvbnRhaW5lci5oZWlnaHQgLyBiYXJEYXRhLmxlbmd0aCkgOiBjb250YWluZXIuaGVpZ2h0KVxyXG4gICAgICAgICAgICAuYXR0cignZmlsbCcsICd0cmFuc3BhcmVudCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIChkLCBpKSA9PiAnZXZlbnQtcmVjdCBlZGl0YWJsZS1iYXIgYmFyLWNvbC0nICsgU3RyaW5nKGJhckRhdGFbaV1bY2hhcnQuY3VycmVudERhdGEuZGF0YVRhYmxlLmxhYmVsXSkucmVwbGFjZSgvXFxzL2csICdfJykucmVwbGFjZSgvOi9nLCAnX2NvbG9uXycpLnJlcGxhY2UoL1xcLi9nLCAnX2RvdF8nKSk7XHJcblxyXG4gICAgICAgIHJldHVybiBldmVudEdyb3VwcztcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZ2VuZXJhdGVUaHJlc2hvbGRMZWdlbmQoY2hhcnQpIHtcclxuICAgICAgICBsZXQgc3ZnID0gY2hhcnQuc3ZnLFxyXG4gICAgICAgICAgICBjb2xvckxlZ2VuZERhdGEgPSBbXSxcclxuICAgICAgICAgICAgZ0xlZ2VuZCxcclxuICAgICAgICAgICAgbGVnZW5kO1xyXG4gICAgICAgIGlmIChjaGFydC5fdmFycy50aHJlc2hvbGRzICE9PSAnbm9uZScpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBPYmplY3Qua2V5cyhjaGFydC5fdmFycy50aHJlc2hvbGRzKS5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgY29sb3JMZWdlbmREYXRhLnB1c2goY2hhcnQuX3ZhcnMudGhyZXNob2xkc1tqXS50aHJlc2hvbGROYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZ0xlZ2VuZCA9IHN2Zy5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAndGhyZXNob2xkTGVnZW5kQ29udGFpbmVyJyk7XHJcblxyXG4gICAgICAgIGxlZ2VuZCA9IGdMZWdlbmQuc2VsZWN0QWxsKCcudGhyZXNob2xkTGVnZW5kJylcclxuICAgICAgICAgICAgLmRhdGEoY29sb3JMZWdlbmREYXRhKVxyXG4gICAgICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3RocmVzaG9sZExlZ2VuZCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAoZCwgaSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IGhlaWdodCA9IDE5LFxyXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IDE5ICogY29sb3JMZWdlbmREYXRhLmxlbmd0aCAvIDIsXHJcbiAgICAgICAgICAgICAgICAgICAgaG9yeiA9IC0yICogMTIsXHJcbiAgICAgICAgICAgICAgICAgICAgdmVydCA9IGkgKiBoZWlnaHQgLSBvZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgaG9yeiArICcsJyArIHZlcnQgKyAnKSc7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICBsZWdlbmQuYXBwZW5kKCdyZWN0JylcclxuICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgMTIpXHJcbiAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCAxMilcclxuICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgKGQsIGkpID0+IGNoYXJ0Ll92YXJzLnRocmVzaG9sZHNbaV0udGhyZXNob2xkQ29sb3IpO1xyXG5cclxuICAgICAgICBsZWdlbmQuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgLmF0dHIoJ3gnLCAyNClcclxuICAgICAgICAgICAgLmF0dHIoJ3knLCA4KVxyXG4gICAgICAgICAgICAuYXR0cignZm9udC1zaXplJywgJy43NWVtJylcclxuICAgICAgICAgICAgLnRleHQoZCA9PiBkKTtcclxuXHJcbiAgICAgICAgLy9DZW50ZXJzIHRoZSBsZWdlbmQgaW4gdGhlIHBhbmVsXHJcbiAgICAgICAgaWYgKGdMZWdlbmQpIHtcclxuICAgICAgICAgICAgbGV0IGxlZ2VuZFdpZHRoID0gZ0xlZ2VuZC5ub2RlKCkuZ2V0QkJveCgpLndpZHRoO1xyXG4gICAgICAgICAgICBnTGVnZW5kLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIChjaGFydC5jb25maWcuY29udGFpbmVyLndpZHRoIC0gbGVnZW5kV2lkdGgpICsgJywnICsgKDEwICogY29sb3JMZWdlbmREYXRhLmxlbmd0aCkgKyAnKScpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgYXR0YWNoQ2xpY2tFdmVudHNUb0xlZ2VuZChjaGFydCwgbGVnZW5kRWxlbWVudHMsIGRyYXdGdW5jKSB7XHJcbiAgICAgICAgLy9BZGRpbmcgdGhlIGNsaWNrIGV2ZW50IHRvIGxlZ2VuZCByZWN0YW5nbGVzIGZvciB0b2dnbGluZyBvbi9vZmZcclxuICAgICAgICBsZWdlbmRFbGVtZW50c1xyXG4gICAgICAgICAgICAub24oJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHNlbGVjdGVkUmVjdCA9IGQzLnNlbGVjdCh0aGlzKSxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhSGVhZGVycztcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWRSZWN0Ll9ncm91cHNbMF1bMF0uYXR0cmlidXRlcy5vcGFjaXR5LnZhbHVlICE9PSAnMC4yJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkUmVjdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignb3BhY2l0eScsICcwLjInKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRSZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdvcGFjaXR5JywgJzEnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvL0dldHMgdGhlIGhlYWRlcnMgb2YgdGhlIGRhdGEgdG8gYmUgZHJhd25cclxuICAgICAgICAgICAgICAgIGRhdGFIZWFkZXJzID0gdGhpcy51cGRhdGVEYXRhRnJvbUxlZ2VuZChsZWdlbmRFbGVtZW50cy5fZ3JvdXBzKTtcclxuICAgICAgICAgICAgICAgIC8vU2V0cyB0aGUgbGVnZW5kRGF0YSB0byB0aGUgdXBkYXRlZCBoZWFkZXJzXHJcbiAgICAgICAgICAgICAgICBpZiAoY2hhcnQuX3ZhcnMuc2VyaWVzRmxpcHBlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0Ll92YXJzLmZsaXBwZWRMZWdlbmRIZWFkZXJzID0gZGF0YUhlYWRlcnM7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0Ll92YXJzLmxlZ2VuZEhlYWRlcnMgPSBkYXRhSGVhZGVycztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvL1Bsb3RzIHRoZSBkYXRhXHJcbiAgICAgICAgICAgICAgICBjaGFydC5fdmFycy50cmFuc2l0aW9uVGltZSA9IDgwMDsvL0tlZXAgdHJhbnNpdGlvbiBmb3IgdG9nZ2xpbmcgbGVnZW5kIGVsZW1lbnRzXHJcbiAgICAgICAgICAgICAgICBpZiAoY2hhcnQuX3ZhcnMuc2VyaWVzRmxpcHBlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0W2RyYXdGdW5jXShjaGFydC5mbGlwcGVkRGF0YSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0W2RyYXdGdW5jXShjaGFydC5kYXRhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChjaGFydC5hcHBseUVkaXRNb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhcnQuYXBwbHlFZGl0TW9kZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipnZW5lcmF0ZVZlcnRpY2FsTGVnZW5kRWxlbWVudHNcclxuICAgICAqXHJcbiAgICAgKiBDcmVhdGVzIHRoZSBsZWdlbmQgZWxlbWVudHMtLXJlY3RhbmdsZXMgYW5kIGxhYmVsc1xyXG4gICAgICogQHBhcmFtcyBjaGFydCwgbGVnZW5kRGF0YSwgZHJhd0Z1bmNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdlbmVyYXRlVmVydGljYWxMZWdlbmRFbGVtZW50cyhjaGFydCwgbGVnZW5kRGF0YSwgZHJhd0Z1bmMpIHtcclxuICAgICAgICBsZXQgc3ZnID0gY2hhcnQuc3ZnLFxyXG4gICAgICAgICAgICBsZWdlbmQsXHJcbiAgICAgICAgICAgIGxlZ2VuZERhdGFMZW5ndGggPSBsZWdlbmREYXRhLmxlbmd0aCxcclxuICAgICAgICAgICAgbGVnZW5kRWxlbWVudFRvZ2dsZUFycmF5LFxyXG4gICAgICAgICAgICBsZWdlbmRSZWN0YW5nbGVzLFxyXG4gICAgICAgICAgICBsZWdlbmRUZXh0O1xyXG5cclxuICAgICAgICBjaGFydC5fdmFycy5ncmlkU2l6ZSA9IDIwO1xyXG5cclxuICAgICAgICBpZiAoIWNoYXJ0Ll92YXJzLmxlZ2VuZEluZGV4KSB7XHJcbiAgICAgICAgICAgIGNoYXJ0Ll92YXJzLmxlZ2VuZEluZGV4ID0gMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghY2hhcnQuX3ZhcnMubGVnZW5kSW5kZXhNYXgpIHtcclxuICAgICAgICAgICAgY2hhcnQuX3ZhcnMubGVnZW5kSW5kZXhNYXggPSBNYXRoLmZsb29yKGxlZ2VuZERhdGFMZW5ndGggLyBjaGFydC5fdmFycy5sZWdlbmRNYXggLSAwLjAxKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vQ2hlY2sgdG8gc2VlIGlmIGxlZ2VuZCBlbGVtZW50IHRvZ2dsZSBhcnJheSBuZWVkcyB0byBiZSBzZXRcclxuICAgICAgICBpZiAoY2hhcnQuX3ZhcnMubGVnZW5kSW5kZXhNYXggPj0gMCkge1xyXG4gICAgICAgICAgICBpZiAoIWNoYXJ0Ll92YXJzLmxlZ2VuZEhlYWRlcnMpIHtcclxuICAgICAgICAgICAgICAgIGNoYXJ0Ll92YXJzLmxlZ2VuZEhlYWRlcnMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGxlZ2VuZERhdGEpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbGVnZW5kRWxlbWVudFRvZ2dsZUFycmF5ID0gdGhpcy5nZXRMZWdlbmRFbGVtZW50VG9nZ2xlQXJyYXkoY2hhcnQuX3ZhcnMubGVnZW5kSGVhZGVycywgbGVnZW5kRGF0YSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZWdlbmQgPSBzdmcuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2xlZ2VuZCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyAxOCArICcsJyArIDIwICsgJyknKTtcclxuXHJcbiAgICAgICAgLy9BZGRpbmcgY29sb3JlZCByZWN0YW5nbGVzIHRvIHRoZSBsZWdlbmRcclxuICAgICAgICBsZWdlbmRSZWN0YW5nbGVzID0gbGVnZW5kLnNlbGVjdEFsbCgncmVjdCcpXHJcbiAgICAgICAgICAgIC5kYXRhKGxlZ2VuZERhdGEpXHJcbiAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3JlY3QnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbGVnZW5kUmVjdCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4JywgJzMnKVxyXG4gICAgICAgICAgICAuYXR0cigneScsIChkLCBpKSA9PiAoY2hhcnQuX3ZhcnMuZ3JpZFNpemUpICogKGkgJSBjaGFydC5fdmFycy5sZWdlbmRNYXgpICogMS4xKVxyXG4gICAgICAgICAgICAuYXR0cignd2lkdGgnLCBjaGFydC5fdmFycy5ncmlkU2l6ZSlcclxuICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGNoYXJ0Ll92YXJzLmdyaWRTaXplKVxyXG4gICAgICAgICAgICAuYXR0cignZmlsbCcsIChkLCBpKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKCFsZWdlbmRFbGVtZW50VG9nZ2xlQXJyYXkgJiYgIWNoYXJ0Ll92YXJzLnNlcmllc0ZsaXBwZWQpIHx8IChjaGFydC5fdmFycy5zZXJpZXNGbGlwcGVkICYmICFsZWdlbmRFbGVtZW50VG9nZ2xlQXJyYXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29sb3JzKGNoYXJ0Ll92YXJzLmNvbG9yLCBpLCBsZWdlbmREYXRhW2ldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICgoIWNoYXJ0Ll92YXJzLnNlcmllc0ZsaXBwZWQgJiYgbGVnZW5kRWxlbWVudFRvZ2dsZUFycmF5W2ldLnRvZ2dsZSA9PT0gdHJ1ZSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAoY2hhcnQuX3ZhcnMuc2VyaWVzRmxpcHBlZCAmJiBsZWdlbmRFbGVtZW50VG9nZ2xlQXJyYXlbaV0udG9nZ2xlID09PSB0cnVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENvbG9ycyhjaGFydC5fdmFycy5jb2xvciwgaSwgbGVnZW5kRGF0YVtpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hhcnQuX3ZhcnMuZW1wdHlMZWdlbmRTcXVhcmU7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5hdHRyKCdkaXNwbGF5JywgKGQsIGkpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChpID49IChjaGFydC5fdmFycy5sZWdlbmRJbmRleCAqIGNoYXJ0Ll92YXJzLmxlZ2VuZE1heCkgJiYgaSA8PSAoKGNoYXJ0Ll92YXJzLmxlZ2VuZEluZGV4ICogY2hhcnQuX3ZhcnMubGVnZW5kTWF4KSArIChjaGFydC5fdmFycy5sZWdlbmRNYXggLSAxKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2FsbCc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ25vbmUnO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuYXR0cignb3BhY2l0eScsICcxJyk7XHJcblxyXG4gICAgICAgIC8vQWRkaW5nIHRleHQgbGFiZWxzIGZvciBlYWNoIHJlY3RhbmdsZSBpbiBsZWdlbmRcclxuICAgICAgICBsZWdlbmRUZXh0ID0gbGVnZW5kLnNlbGVjdEFsbCgndGV4dCcpXHJcbiAgICAgICAgICAgIC5kYXRhKGxlZ2VuZERhdGEpXHJcbiAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAoZCwgaSkgPT4gJ2xlZ2VuZFRleHQgZWRpdGFibGUgZWRpdGFibGUtdGV4dCBlZGl0YWJsZS1jb250ZW50IGVkaXRhYmxlLWxlZ2VuZC0nICsgaSlcclxuICAgICAgICAgICAgLmF0dHIoJ3gnLCBjaGFydC5fdmFycy5ncmlkU2l6ZSArIDcpXHJcbiAgICAgICAgICAgIC5hdHRyKCd5JywgKGQsIGkpID0+IChjaGFydC5fdmFycy5ncmlkU2l6ZSkgKiAoaSAlIGNoYXJ0Ll92YXJzLmxlZ2VuZE1heCkgKiAxLjEgKyAxMClcclxuICAgICAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ3N0YXJ0JylcclxuICAgICAgICAgICAgLmF0dHIoJ2R5JywgJzAuMzVlbScpIC8vVmVydGljYWxseSBhbGlnbiB3aXRoIG5vZGVcclxuICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCBjaGFydC5fdmFycy5mb250Q29sb3IpXHJcbiAgICAgICAgICAgIC5hdHRyKCdmb250LXNpemUnLCBjaGFydC5fdmFycy5mb250U2l6ZSlcclxuICAgICAgICAgICAgLmF0dHIoJ2Rpc3BsYXknLCAoZCwgaSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgPj0gKGNoYXJ0Ll92YXJzLmxlZ2VuZEluZGV4ICogY2hhcnQuX3ZhcnMubGVnZW5kTWF4KSAmJiBpIDw9ICgoY2hhcnQuX3ZhcnMubGVnZW5kSW5kZXggKiBjaGFydC5fdmFycy5sZWdlbmRNYXgpICsgKGNoYXJ0Ll92YXJzLmxlZ2VuZE1heCAtIDEpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnYWxsJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiAnbm9uZSc7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC50ZXh0KChkLCBpKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgZWxlbWVudE5hbWUgPSBsZWdlbmREYXRhW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnROYW1lLmxlbmd0aCA+IDIwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnROYW1lLnN1YnN0cmluZygwLCAxOSkgKyAnLi4uJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50TmFtZTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vQWRkaW5nIGluZm8gYm94IHRvIGxlZ2VuZCBlbGVtZW50cyB3aGVuIGhvdmVyaW5nIG92ZXJcclxuICAgICAgICBsZWdlbmRUZXh0XHJcbiAgICAgICAgICAgIC5kYXRhKGxlZ2VuZERhdGEpXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3N2Zzp0aXRsZScpXHJcbiAgICAgICAgICAgIC50ZXh0KGQgPT4gZCk7XHJcblxyXG4gICAgICAgIC8vT25seSBjcmVhdGUgY2Fyb3VzZWwgaWYgdGhlIG51bWJlciBvZiBlbGVtZW50cyBleGNlZWRzIG9uZSBsZWdlbmQgXCJwYWdlXCJcclxuICAgICAgICBpZiAoY2hhcnQuX3ZhcnMubGVnZW5kSW5kZXhNYXggPiAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlVmVydGljYWxDYXJvdXNlbChjaGFydCwgbGVnZW5kRGF0YSwgZHJhd0Z1bmMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGxlZ2VuZFJlY3RhbmdsZXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqY3JlYXRlVmVydGljYWxDYXJvdXNlbFxyXG4gICAgICpcclxuICAgICAqIERyYXdzIHRoZSB2ZXJ0aWNhbCBsZWdlbmQgY2Fyb3VzZWxcclxuICAgICAqIEBwYXJhbXMgY2hhcnQsIGxlZ2VuZERhdGEsIGRyYXdGdW5jXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjcmVhdGVWZXJ0aWNhbENhcm91c2VsKGNoYXJ0LCBsZWdlbmREYXRhLCBkcmF3RnVuYykge1xyXG4gICAgICAgIGxldCBzdmcgPSBjaGFydC5zdmcsXHJcbiAgICAgICAgICAgIGxlZ2VuZFBvbHlnb247XHJcblxyXG4gICAgICAgIC8vQWRkaW5nIGNhcm91c2VsIHRvIGxlZ2VuZFxyXG4gICAgICAgIHN2Zy5zZWxlY3RBbGwoJy5sZWdlbmQtY2Fyb3VzZWwnKS5yZW1vdmUoKTtcclxuICAgICAgICBzdmcuc2VsZWN0QWxsKCcjbGVnZW5kLXRleHQtaW5kZXgnKS5yZW1vdmUoKTtcclxuXHJcbiAgICAgICAgbGVnZW5kUG9seWdvbiA9IHN2Zy5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbGVnZW5kLWNhcm91c2VsJyk7XHJcblxyXG4gICAgICAgIC8vQ3JlYXRlcyBsZWZ0IG5hdmlnYXRpb24gYXJyb3cgZm9yIGNhcm91c2VsXHJcbiAgICAgICAgbGVnZW5kUG9seWdvbi5hcHBlbmQoJ3BvbHlnb24nKVxyXG4gICAgICAgICAgICAuYXR0cignaWQnLCAnbGVmdENoZXZyb24nKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAncG9pbnRlci1jdXJzb3InKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBjaGFydC5fdmFycy5sZWdlbmRBcnJvd0NvbG9yKVxyXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLCcgKyAoKGNoYXJ0Ll92YXJzLmxlZ2VuZE1heCAqIGNoYXJ0Ll92YXJzLmdyaWRTaXplKSArIDUwKSArICcpJylcclxuICAgICAgICAgICAgLmF0dHIoJ3BvaW50cycsICcwLDcuNSwgMTUsMCwgMTUsMTUnKVxyXG4gICAgICAgICAgICAub24oJ2NsaWNrJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoYXJ0Ll92YXJzLmxlZ2VuZEluZGV4ID49IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGFydC5fdmFycy5sZWdlbmRJbmRleC0tO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc3ZnLnNlbGVjdEFsbCgnLmxlZ2VuZCcpLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGxlZ2VuZEVsZW1lbnRzID0gdGhpcy5nZW5lcmF0ZVZlcnRpY2FsTGVnZW5kRWxlbWVudHMoY2hhcnQsIGxlZ2VuZERhdGEsIGRyYXdGdW5jKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXR0YWNoQ2xpY2tFdmVudHNUb0xlZ2VuZChjaGFydCwgbGVnZW5kRWxlbWVudHMsIGRyYXdGdW5jLCBsZWdlbmREYXRhKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLmF0dHIoe1xyXG4gICAgICAgICAgICAgICAgZGlzcGxheTogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFydC5fdmFycy5sZWdlbmRJbmRleCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ25vbmUnO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2FsbCc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvL0NyZWF0ZXMgcGFnZSBudW1iZXIgZm9yIGNhcm91c2VsIG5hdmlnYXRpb25cclxuICAgICAgICBsZWdlbmRQb2x5Z29uLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdpZCcsICdsZWdlbmQtdGV4dC1pbmRleCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4JywgMzUpXHJcbiAgICAgICAgICAgIC5hdHRyKCd5JywgMjQyLjUpXHJcbiAgICAgICAgICAgIC5zdHlsZSgndGV4dC1hbmNob3InLCAnc3RhcnQnKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ2ZvbnQtc2l6ZScsIGNoYXJ0Ll92YXJzLmZvbnRTaXplKVxyXG4gICAgICAgICAgICAudGV4dCgoKSA9PiAoY2hhcnQuX3ZhcnMubGVnZW5kSW5kZXggKyAxKSArICcgLyAnICsgKGNoYXJ0Ll92YXJzLmxlZ2VuZEluZGV4TWF4ICsgMSkpXHJcbiAgICAgICAgICAgIC5hdHRyKHtcclxuICAgICAgICAgICAgICAgIGRpc3BsYXk6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhcnQuX3ZhcnMubGVnZW5kSW5kZXhNYXggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdub25lJztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdhbGwnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy9DcmVhdGVzIHJpZ2h0IG5hdmlnYXRpb24gYXJyb3cgZm9yIGNhcm91c2VsXHJcbiAgICAgICAgbGVnZW5kUG9seWdvbi5hcHBlbmQoJ3BvbHlnb24nKVxyXG4gICAgICAgICAgICAuYXR0cignaWQnLCAncmlnaHRDaGV2cm9uJylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3BvaW50ZXItY3Vyc29yJylcclxuICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgY2hhcnQuX3ZhcnMubGVnZW5kQXJyb3dDb2xvcilcclxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoODUsJyArICgoY2hhcnQuX3ZhcnMubGVnZW5kTWF4ICogY2hhcnQuX3ZhcnMuZ3JpZFNpemUpICsgNTApICsgJyknKVxyXG4gICAgICAgICAgICAuYXR0cigncG9pbnRzJywgJzE1LDcuNSwgMCwwLCAwLDE1JylcclxuICAgICAgICAgICAgLm9uKCdjbGljaycsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChjaGFydC5fdmFycy5sZWdlbmRJbmRleCA8IGNoYXJ0Ll92YXJzLmxlZ2VuZEluZGV4TWF4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhcnQuX3ZhcnMubGVnZW5kSW5kZXgrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHN2Zy5zZWxlY3RBbGwoJy5sZWdlbmQnKS5yZW1vdmUoKTtcclxuICAgICAgICAgICAgICAgIGxldCBsZWdlbmRFbGVtZW50cyA9IHRoaXMuZ2VuZXJhdGVWZXJ0aWNhbExlZ2VuZEVsZW1lbnRzKGNoYXJ0LCBsZWdlbmREYXRhLCBkcmF3RnVuYyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmF0dGFjaENsaWNrRXZlbnRzVG9MZWdlbmQoY2hhcnQsIGxlZ2VuZEVsZW1lbnRzLCBkcmF3RnVuYywgbGVnZW5kRGF0YSk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5hdHRyKHtcclxuICAgICAgICAgICAgICAgIGRpc3BsYXk6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhcnQuX3ZhcnMubGVnZW5kSW5kZXggPT09IGNoYXJ0Ll92YXJzLmxlZ2VuZEluZGV4TWF4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnbm9uZSc7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnYWxsJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqY29udmVydFRhYmxlVG9UcmVlXHJcbiAgICAgKlxyXG4gICAgICogQ29udmVydHMgdGFibGUgZGF0YSB0byB0cmVlIHN0cnVjdHVyZVxyXG4gICAgICogQHBhcmFtcyBkYXRhLCBkYXRhVGFibGUsIG51bWVyaWNDaGVja1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY29udmVydFRhYmxlVG9UcmVlKGRhdGEsIGRhdGFUYWJsZSwgbGFzdE5vZGVBc1ZhbHVlKSB7XHJcbiAgICAgICAgdmFyIGFsbEhhc2ggPSB7fSxcclxuICAgICAgICAgICAgbGlzdCA9IFtdLFxyXG4gICAgICAgICAgICByb290TWFwID0ge30sXHJcbiAgICAgICAgICAgIGN1cnJlbnRNYXAgPSB7fSxcclxuICAgICAgICAgICAgdGFibGVIZWFkZXJzID0gW10sXHJcbiAgICAgICAgICAgIGNvdW50O1xyXG4gICAgICAgIGlmIChkYXRhVGFibGUpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaGVhZGVyIGluIGRhdGFUYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGhlYWRlciAhPT0gJ3ZhbHVlJyAmJiBoZWFkZXIuaW5kZXhPZigndG9vbHRpcCcpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhYmxlSGVhZGVycy5wdXNoKGRhdGFUYWJsZVtoZWFkZXJdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZGF0YVRhYmxlLnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB0YWJsZUhlYWRlcnMucHVzaChkYXRhVGFibGUudmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKGxldCBkYXRhRWxlIG9mIGRhdGEpIHsgLy9hbGwgb2YgdGhpcyBpcyB0byBjaGFuZ2UgaXQgdG8gYSB0cmVlIHN0cnVjdHVyZSBhbmQgdGhlbiBjYWxsIG1ha2VUcmVlIHRvIHN0cnVjdHVyZSB0aGUgZGF0YSBhcHByb3ByaWF0ZWx5IGZvciB0aGlzIHZpelxyXG4gICAgICAgICAgICBjb3VudCA9IDA7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGhlYWRlciBvZiB0YWJsZUhlYWRlcnMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChoZWFkZXIgIT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkYXRhRWxlW2hlYWRlci5yZXBsYWNlKC9bX10vZywgJyAnKV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUVsZVtoZWFkZXIucmVwbGFjZSgvW19dL2csICcgJyldID0gJ05VTExfVkFMVUUnO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBsZXQgY3VycmVudFZhbHVlID0gZGF0YUVsZVtoZWFkZXIucmVwbGFjZSgvW19dL2csICcgJyldLnRvU3RyaW5nKCkucmVwbGFjZSgvW1wiXS9nLCAnJyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRNYXAgPSB7fTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50ID09PSAwKSB7IC8vd2lsbCB0YWtlIGNhcmUgb2YgdGhlIGZpcnN0IGxldmVsIGFuZCBwdXQgaW50byByb290bWFwIGlmIGl0IGRvZXNudCBhbHJlYWR5IGV4aXN0IGluIHJvb3RtYXBcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudE1hcCA9IHJvb3RNYXBbY3VycmVudFZhbHVlXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50TWFwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50TWFwID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb290TWFwW2N1cnJlbnRWYWx1ZV0gPSBjdXJyZW50TWFwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRNYXAgPSBjdXJyZW50TWFwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRNYXAgPSBjdXJyZW50TWFwW2N1cnJlbnRWYWx1ZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbmV4dE1hcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dE1hcCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudE1hcFtjdXJyZW50VmFsdWVdID0gbmV4dE1hcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50TWFwID0gbmV4dE1hcDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5tYWtlVHJlZShyb290TWFwLCBsaXN0LCBsYXN0Tm9kZUFzVmFsdWUpO1xyXG4gICAgICAgIGFsbEhhc2gubmFtZSA9ICdyb290JztcclxuICAgICAgICBhbGxIYXNoLmNoaWxkcmVuID0gbGlzdDtcclxuICAgICAgICByZXR1cm4gYWxsSGFzaDtcclxuICAgIH1cclxuXHJcbiAgICAvKiptYWtlVHJlZVxyXG4gICAgICpcclxuICAgICAqIFJlY3VyaXZlIGZ1bmN0aW9uIHRvIGJ1aWxkIHRyZWVcclxuICAgICAqIEBwYXJhbXMgbWFwLCBsaXN0LCBpc051bWVyaWNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIG1ha2VUcmVlKG1hcCwgbGlzdCwgbGFzdE5vZGVBc1ZhbHVlKSB7XHJcbiAgICAgICAgdmFyIGNoaWxkU2V0ID0gW107XHJcbiAgICAgICAgZm9yIChsZXQga2V5IGluIG1hcCkge1xyXG4gICAgICAgICAgICBpZiAobWFwLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICAgICAgICAgIGxldCBjaGlsZE1hcCA9IG1hcFtrZXldLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFNYXAgPSB7fSxcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZEV4aXN0cyA9IGNoaWxkTWFwICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGNoaWxkTWFwKS5sZW5ndGggPiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIG51bWVyaWNDaGVjayA9IGxhc3ROb2RlQXNWYWx1ZSAmJiBPYmplY3Qua2V5cyhjaGlsZE1hcCkubGVuZ3RoID09PSAxICYmICFpc05hTihPYmplY3Qua2V5cyhjaGlsZE1hcClbMF0pO1xyXG4gICAgICAgICAgICAgICAgZGF0YU1hcC5uYW1lID0ga2V5O1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjaGlsZEV4aXN0cyB8fCBudW1lcmljQ2hlY2spIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhTWFwLnZhbHVlID0gT2JqZWN0LmtleXMoY2hpbGRNYXApWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGxpc3QucHVzaChkYXRhTWFwKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YU1hcC5jaGlsZHJlbiA9IGNoaWxkU2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIGxpc3QucHVzaChkYXRhTWFwKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1ha2VUcmVlKGNoaWxkTWFwLCBjaGlsZFNldCwgbGFzdE5vZGVBc1ZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZFNldCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipjb252ZXJ0VGFibGVUb1RyZWVtYXBcclxuICAgICAqXHJcbiAgICAgKiBMb29wIHRocm91Z2ggZGF0YSB0byBvcmdhbml6ZSBpbnRvIHRyZWVtYXAgZm9ybVxyXG4gICAgICogQHBhcmFtcyBkYXRhLCBkYXRhVGFibGVBbGdpblxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY29udmVydFRhYmxlVG9UcmVlbWFwKGRhdGEsIGRhdGFUYWJsZUFsaWduKSB7XHJcbiAgICAgICAgdmFyIGFkZGVkSGVhZGVyTWFwID0ge30sXHJcbiAgICAgICAgICAgIGNoaWxkcmVuQXJyYXkgPSBbXSxcclxuICAgICAgICAgICAgc2VyaWVzSW5kZXg7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGRhdGFFbGUgb2YgZGF0YSkge1xyXG4gICAgICAgICAgICBsZXQgc2VyaWVzID0gZGF0YUVsZVtkYXRhVGFibGVBbGlnbi5zZXJpZXNdO1xyXG4gICAgICAgICAgICBzZXJpZXNJbmRleCA9IGFkZGVkSGVhZGVyTWFwW3Nlcmllc107XHJcbiAgICAgICAgICAgIGRhdGFFbGUuUGFyZW50ID0gc2VyaWVzO1xyXG4gICAgICAgICAgICBpZiAoc2VyaWVzSW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIGNoaWxkcmVuQXJyYXlbc2VyaWVzSW5kZXhdLmNoaWxkcmVuLnB1c2goZGF0YUVsZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBhZGRlZEhlYWRlck1hcFtzZXJpZXNdID0gY2hpbGRyZW5BcnJheS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBjaGlsZHJlbkFycmF5LnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIFtkYXRhVGFibGVBbGlnbi5zZXJpZXNdOiBzZXJpZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgUGFyZW50OiAnVG9wIExldmVsJyxcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogW2RhdGFFbGVdXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgW2RhdGFUYWJsZUFsaWduLnNlcmllc106ICdUb3AgTGV2ZWwnLFxyXG4gICAgICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW5BcnJheVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ganZDaGFydHM7XHJcbiIsIi8qKiogIGp2Q29tbWVudCAqKiovXHJcbid1c2Utc3RyaWN0JztcclxuLyoqXHJcbiogQG5hbWUganZDb21tZW50XHJcbiogQGRlc2MgQ29uc3RydWN0b3IgZm9yIEpWIENvbW1lbnQgLSBjcmVhdGVzIGNvbW1lbnRzIGZvciBhIGp2IHZpc3VhbGl6YXRpb24gYW5kIGV4ZWN1dGVzIGEgY2FsbGJhY2sgZm9yIHRoZSBjb21tZW50cyB0byBiZSBzYXZlZFxyXG4qIEBwYXJhbSB7b2JqZWN0fSBjb25maWdPYmogLSBjb25zdHJ1Y3RvciBvYmplY3QgY29udGFpbmluZyB0aGUganZDaGFydCBhbmQgb3RoZXIgb3B0aW9uc1xyXG4qIEByZXR1cm4ge3VuZGVmaW5lZH0gLSBubyByZXR1cm5cclxuKi9cclxuZnVuY3Rpb24ganZDb21tZW50KGNvbmZpZ09iaikge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgdmFyIGNvbW1lbnRPYmogPSB0aGlzO1xyXG4gICAgY29tbWVudE9iai5jaGFydERpdiA9IGNvbmZpZ09iai5jaGFydERpdjtcclxuICAgIGNvbW1lbnRPYmouc2hvd0NvbW1lbnRzID0gZmFsc2U7XHJcbiAgICBjb21tZW50T2JqLmNvbW1lbnRzID0gc2V0Q29tbWVudHNMaXN0KGNvbmZpZ09iai5jb21tZW50cyk7XHJcbiAgICBjb21tZW50T2JqLmRpc2FibGVkID0gZmFsc2U7XHJcbiAgICBjb21tZW50T2JqLmRyYXdDb21tZW50Tm9kZXMoKTtcclxuICAgIGNvbW1lbnRPYmoub25TYXZlQ2FsbGJhY2sgPSBjb25maWdPYmoub25TYXZlQ2FsbGJhY2s7XHJcbiAgICBjb21tZW50T2JqLmdldE1vZGUgPSBjb25maWdPYmouZ2V0TW9kZTtcclxufVxyXG5cclxuanZDb21tZW50LnByb3RvdHlwZS5jcmVhdGVNb3ZlTGlzdGVuZXIgPSBjcmVhdGVNb3ZlTGlzdGVuZXI7XHJcbmp2Q29tbWVudC5wcm90b3R5cGUudXBkYXRlUG9zaXRpb24gPSB1cGRhdGVQb3NpdGlvbjtcclxuanZDb21tZW50LnByb3RvdHlwZS5tYWtlQ29tbWVudCA9IG1ha2VDb21tZW50O1xyXG5qdkNvbW1lbnQucHJvdG90eXBlLnJlbW92ZUNvbW1lbnQgPSByZW1vdmVDb21tZW50O1xyXG5qdkNvbW1lbnQucHJvdG90eXBlLmRyYXdDb21tZW50Tm9kZXMgPSBkcmF3Q29tbWVudE5vZGVzO1xyXG5qdkNvbW1lbnQucHJvdG90eXBlLmRyYXdDb21tZW50ID0gZHJhd0NvbW1lbnQ7XHJcbmp2Q29tbWVudC5wcm90b3R5cGUuZG91YmxlQ2xpY2sgPSBkb3VibGVDbGljaztcclxuanZDb21tZW50LnByb3RvdHlwZS5vdmVybGF5RGl2UG9zaXRpb24gPSBvdmVybGF5RGl2UG9zaXRpb247XHJcblxyXG5cclxuLyoqXHJcbiogQG5hbWUgc2V0Q29tbWVudHNMaXN0XHJcbiogQGRlc2Mgc2V0cyB0aGUgYXBwcm9wcmlhdGUgY29tbWVudHMgb2JqZWN0IGZvciBhIGNvbW1lbnRzIG9iamVjdFxyXG4qIEBwYXJhbSB7b2JqZWN0fSBjb21tZW50cyAtIGxpc3Qgb2YgY29tbWVudHMgdG8gcGFpbnRcclxuKiBAcmV0dXJuIHtjb21tZW50c30gLSBvYmplY3Qgd2l0aCBjb21tZW50cyBsaXN0IGFuZCBtYXggaWRcclxuKi9cclxuZnVuY3Rpb24gc2V0Q29tbWVudHNMaXN0KGNvbW1lbnRzKSB7XHJcbiAgICBsZXQgbmV3Q29tbWVudHMgPSB7fTtcclxuICAgIGlmICh0eXBlb2YgY29tbWVudHMgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgaWYgKCFjb21tZW50cy5saXN0KSB7XHJcbiAgICAgICAgICAgIG5ld0NvbW1lbnRzLmxpc3QgPSBjb21tZW50cztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKG5ld0NvbW1lbnRzLmxpc3QpLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgbGV0IG1heElkID0gMDtcclxuICAgICAgICAgICAgZm9yIChsZXQgaWQgaW4gbmV3Q29tbWVudHMubGlzdCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKE51bWJlcihpZCkgPiBtYXhJZCkgbWF4SWQgPSBOdW1iZXIoaWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG5ld0NvbW1lbnRzLm1heElkID0gbWF4SWQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbmV3Q29tbWVudHMubWF4SWQgPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbmV3Q29tbWVudHMubGlzdCA9IHt9O1xyXG4gICAgICAgIG5ld0NvbW1lbnRzLm1heElkID0gMDtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXdDb21tZW50cztcclxufVxyXG5cclxuLyoqXHJcbiogQG5hbWUgY3JlYXRlTW92ZUxpc3RlbmVyXHJcbiogQGRlc2MgY3JlYXRlcyB0aGUgbW91c2Vtb3ZlIGxpc3RlbmVyIHRvIGRldGVybWluZSBpZiB0aGUgdXNlciBtb3ZlcyBvciByZXNpemVzIGEgY29tbWVudFxyXG4qIEBwYXJhbSB7b2JqZWN0fSBjb21tZW50Tm9kZSAtIGNvbW1lbnQgdGhhdCB0aGUgdXNlciBjbGlja2VkIG9uXHJcbiogQHJldHVybiB7dW5kZWZpbmVkfSAtIG5vIHJldHVyblxyXG4qL1xyXG5mdW5jdGlvbiBjcmVhdGVNb3ZlTGlzdGVuZXIoY29tbWVudE5vZGUpIHtcclxuICAgIHZhciBjb21tZW50T2JqID0gdGhpcyxcclxuICAgICAgICB0aW1lTW91c2VEb3duID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgICBjb21tZW50T2JqLmNoYXJ0RGl2Lm9uKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy9tb3VzZSBtb3ZlIGhhcHBlbmQgdG9vIHF1aWNrbHksIGNocm9tZSBidWdcclxuICAgICAgICB2YXIgdGltZU1vdXNlTW92ZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpLFxyXG4gICAgICAgICAgICBub2RlID0gY29tbWVudE5vZGUubm9kZSgpLFxyXG4gICAgICAgICAgICBtb3VzZSA9IGQzLm1vdXNlKG5vZGUpLFxyXG4gICAgICAgICAgICBtb3VzZU9uQ2hhcnREaXYgPSBkMy5tb3VzZShjb21tZW50T2JqLmNoYXJ0RGl2Lm5vZGUoKSksXHJcbiAgICAgICAgICAgIHJlc2l6ZU5vZGU7XHJcbiAgICAgICAgaWYgKHRpbWVNb3VzZURvd24gKyAxMCA+IHRpbWVNb3VzZU1vdmUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL3NldCB0aGUgbW92ZWQgbm9kZSwgc28gd2Uga25vdyB0byBkbyBhIG1vdXNlIHVwIGV2ZW50XHJcbiAgICAgICAgY29tbWVudE9iai5tb3ZlZCA9IGNvbW1lbnROb2RlO1xyXG5cclxuICAgICAgICAvL3Jlc2l6ZSBpbiB0aGUgcmlnaHQgY29ybmVyIG9mIHRoZSBjb21tZW50XHJcbiAgICAgICAgaWYgKGNvbW1lbnROb2RlLnNlbGVjdCgnLmNvbW1lbnQtcGFkZGluZycpLl9ncm91cHNbMF1bMF0gJiYgKChtb3VzZVswXSArIDE1ID4gbm9kZS5jbGllbnRXaWR0aCAmJiBtb3VzZVsxXSArIDE1ID4gbm9kZS5jbGllbnRIZWlnaHQpIHx8IGNvbW1lbnRPYmoubW92ZWQubW91c2UpKSB7XHJcbiAgICAgICAgICAgIGlmICghY29tbWVudE9iai5tb3ZlZC5tb3VzZSkge1xyXG4gICAgICAgICAgICAgICAgcmVzaXplTm9kZSA9IGNvbW1lbnROb2RlLnNlbGVjdCgnLmNvbW1lbnQtcGFkZGluZycpO1xyXG4gICAgICAgICAgICAgICAgcmVzaXplTm9kZS5zdHlsZSgnd2lkdGgnLCAnYXV0bycpO1xyXG4gICAgICAgICAgICAgICAgcmVzaXplTm9kZS5zdHlsZSgnaGVpZ2h0JywgJ2F1dG8nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL3NldCB0aGUgbW91c2UgZXZlbnQgc28gd2UgY2FuIHVwZGF0ZSB0aGUgbG9jYXRpb24gb24gbW91c2UgdXBcclxuICAgICAgICAgICAgY29tbWVudE9iai5tb3ZlZC5tb3VzZSA9IG1vdXNlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vbW92ZSB0aGUgY29tbWVudCBub2RlIGFyb3VuZCB0aGUgdmlzdWFsXHJcbiAgICAgICAgICAgIGlmIChjb21tZW50Tm9kZS5fZ3JvdXBzWzBdWzBdLm5vZGVOYW1lID09PSAndGV4dCcpIHtcclxuICAgICAgICAgICAgICAgIGNvbW1lbnRPYmouY2hhcnREaXYuc2VsZWN0KCcuY29tbWVudGJveC1yZWFkb25seScpLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbW1lbnROb2RlXHJcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2xlZnQnLCBtb3VzZU9uQ2hhcnREaXZbMF0gKyAncHgnKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCd0b3AnLCBtb3VzZU9uQ2hhcnREaXZbMV0gKyAncHgnKTtcclxuICAgICAgICAgICAgY29tbWVudE5vZGVcclxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgbW91c2VPbkNoYXJ0RGl2WzBdKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBtb3VzZU9uQ2hhcnREaXZbMV0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcblxyXG4vKipcclxuKiBAbmFtZSB1cGRhdGVQb3NpdGlvblxyXG4qIEBkZXNjIGRldGVybWluZXMgd2hldGhlciB0aGUgdXNlciBkcmFnZ2VkIGEgY29tbWVudCBvbiB0aGUgc2NyZWVuIG9yIHVwZGF0ZWQgaXRzIHNpemUgYW5kIHRoZW4gY3JlYXRlcyB0aGUgYXBwcm9wcmlhdGUgc2F2ZSBmdW5jdGlvblxyXG4qIEByZXR1cm4ge3VuZGVmaW5lZH0gLSBubyByZXR1cm5cclxuKi9cclxuZnVuY3Rpb24gdXBkYXRlUG9zaXRpb24oKSB7XHJcbiAgICBsZXQgY29tbWVudE9iaiA9IHRoaXMsXHJcbiAgICAgICAgbm9kZVRvVXBkYXRlID0gY29tbWVudE9iai5tb3ZlZC5fZ3JvdXBzWzBdWzBdLFxyXG4gICAgICAgIG5vZGVJZCA9IG5vZGVUb1VwZGF0ZS5pZC5zcGxpdCgnbm9kZScpWzFdLFxyXG4gICAgICAgIGNvbW1lbnQgPSBjb21tZW50T2JqLmNvbW1lbnRzLmxpc3Rbbm9kZUlkXSxcclxuICAgICAgICB4LFxyXG4gICAgICAgIHk7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjb21tZW50T2JqLm1vdmVkLm1vdXNlKSkge1xyXG4gICAgICAgIGNvbW1lbnQuYmluZGluZy53aWR0aCA9IGNvbW1lbnRPYmoubW92ZWQubW91c2VbMF07XHJcbiAgICAgICAgY29tbWVudC5iaW5kaW5nLmhlaWdodCA9IGNvbW1lbnRPYmoubW92ZWQubW91c2VbMV07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHggPSBNYXRoLnJvdW5kKG5vZGVUb1VwZGF0ZS5nZXRBdHRyaWJ1dGUoJ3gnKSk7XHJcbiAgICAgICAgeSA9IE1hdGgucm91bmQobm9kZVRvVXBkYXRlLmdldEF0dHJpYnV0ZSgneScpKTtcclxuICAgICAgICBjb21tZW50LmJpbmRpbmcgPSB7XHJcbiAgICAgICAgICAgICd4JzogeCxcclxuICAgICAgICAgICAgJ3knOiB5LFxyXG4gICAgICAgICAgICAneENoYXJ0QXJlYSc6IGNvbW1lbnRPYmouY2hhcnREaXYuX2dyb3Vwc1swXVswXS5jbGllbnRXaWR0aCxcclxuICAgICAgICAgICAgJ3lDaGFydEFyZWEnOiBjb21tZW50T2JqLmNoYXJ0RGl2Ll9ncm91cHNbMF1bMF0uY2xpZW50SGVpZ2h0LFxyXG4gICAgICAgICAgICAnY3VycmVudFgnOiB4LFxyXG4gICAgICAgICAgICAnY3VycmVudFknOiB5LFxyXG4gICAgICAgICAgICAnc2hvd0FzTWFya2VyJzogY29tbWVudC5iaW5kaW5nLnNob3dBc01hcmtlcixcclxuICAgICAgICAgICAgJ2hlaWdodCc6IGNvbW1lbnQuYmluZGluZy5oZWlnaHQsXHJcbiAgICAgICAgICAgICd3aWR0aCc6IGNvbW1lbnQuYmluZGluZy53aWR0aFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgY29tbWVudE9iai5vblNhdmVDYWxsYmFjayhjb21tZW50LCBub2RlSWQsICdlZGl0Jyk7XHJcbn1cclxuXHJcbi8qKlxyXG4qIEBuYW1lIG1ha2VDb21tZW50XHJcbiogQGRlc2MgY3JlYXRlcyB0aGUgY29tbWVudCBlbnRyeSBib3ggb24gdGhlIHNjcmVlbiBhbmQgYXR0YWNoZXMgbGlzdGVuZXJzIHRvIHRoZSBzYXZlIGRlbGV0ZSBhbmQgY2FuY2VsIG9wdGlvbnNcclxuKiBAcGFyYW0ge29iamVjdH0gZXZlbnQgLSBldmVudCB0aGF0IGhvbGRzIHRoZSBtb3VzZSBwb3NpdGlvbiBmb3Igd2hlcmUgdGhlIHVzZXIgd2FudHMgdG8gcGxhY2UgdGhlIGNvbW1lbnRcclxuKiBAcmV0dXJuIHt1bmRlZmluZWR9IC0gbm8gcmV0dXJuXHJcbiovXHJcbmZ1bmN0aW9uIG1ha2VDb21tZW50KGV2ZW50KSB7XHJcbiAgICBpZiAodGhpcy5jaGFydERpdi5zZWxlY3QoJy5jb21tZW50Ym94JykuX2dyb3Vwc1swXVswXSB8fCB0aGlzLmNoYXJ0RGl2LnNlbGVjdCgnLmNvbW1lbnRib3gtZWRpdCcpLl9ncm91cHNbMF1bMF0pIHtcclxuICAgICAgICAvL2RvbnQgY3JlYXRlIG5ldyBjb21tZW50XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBjb21tZW50T2JqID0gdGhpcyxcclxuICAgICAgICB4ID0gcGFyc2VJbnQoZDMubW91c2UoZXZlbnQpWzBdLCAxMCksXHJcbiAgICAgICAgeSA9IHBhcnNlSW50KGQzLm1vdXNlKGV2ZW50KVsxXSwgMTApLFxyXG4gICAgICAgIGNvbW1lbnRIZWlnaHQgPSAxNDUsXHJcbiAgICAgICAgY29tbWVudFdpZHRoID0gMjAwLFxyXG4gICAgICAgIC8vY2FsY3VsYXRlIHBvc2l0aW9uIG9mIG92ZXJsYXkgZGl2XHJcbiAgICAgICAgcG9zaXRpb24gPSBjb21tZW50T2JqLm92ZXJsYXlEaXZQb3NpdGlvbihjb21tZW50V2lkdGgsIGNvbW1lbnRIZWlnaHQsIHgsIHkpLFxyXG4gICAgICAgIGNvbW1lbnRUeXBlID0gJ3N2Z01haW4nO1xyXG5cclxuICAgIGNvbW1lbnRPYmouY2hhcnREaXYuc2VsZWN0QWxsKCcuY29tbWVudGJveC1yZWFkb25seScpLnJlbW92ZSgpO1xyXG5cclxuICAgIGNvbW1lbnRPYmouc2hvd0NvbW1lbnRzID0gZmFsc2U7XHJcbiAgICBjb21tZW50T2JqLmNoYXJ0RGl2LmFwcGVuZCgnZGl2JylcclxuICAgICAgICAuYXR0cignY2xhc3MnLCAnY29tbWVudGJveCcpXHJcbiAgICAgICAgLmF0dHIoJ2lkJywgJ2NvbW1lbnRib3gnKVxyXG4gICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDEpXHJcbiAgICAgICAgLmh0bWwoXCI8ZGl2IGNsYXNzPSd0aXRsZSc+PGI+QWRkIE5ldyBDb21tZW50PC9iPjwvZGl2PlwiICtcclxuICAgICAgICBcIjx0ZXh0YXJlYSBwbGFjZWhvbGRlcj0nRW50ZXIgY29tbWVudC4uLicgZm9ybT0nY29tbWVudGZvcm0nIGNsYXNzPSdjb21tZW50LXRleHRhcmVhJyBzdHlsZT0nd2lkdGg6MTU1cHg7IGhlaWdodDogOTBweDsnIG5hbWU9J2NvbW1lbnQnIGlkID0gJ3RleHRhcmVhMSc+PC90ZXh0YXJlYT5cIiArXHJcbiAgICAgICAgXCI8YnI+PGlucHV0IHR5cGU9J2NoZWNrQm94JyBjbGFzcz0nY29tbWVudGJveC1kaXNwbGF5JyBpZCA9J2Rpc3BsYXknPiBEaXNwbGF5IGFzIG1hcmtlclwiICtcclxuICAgICAgICBcIjxicj48YnV0dG9uIGNsYXNzPSdjb21tZW50Ym94LWNsb3NlJyBpZCA9J2NhbmNlbCc+PGkgY2xhc3M9J2ZhIGZhLWNsb3NlJz48L2k+PC9idXR0b24+XCIgK1xyXG4gICAgICAgIFwiPGJ1dHRvbiBjbGFzcz0nc21zcy1idG4gY29tbWVudGJveC1zdWJtaXQnIGlkID0gJ3N1Ym1pdCc+U3VibWl0IENvbW1lbnQ8L2J1dHRvbj5cIilcclxuICAgICAgICAuc3R5bGUoJ3Bvc2l0aW9uJywgJ2Fic29sdXRlJylcclxuICAgICAgICAuc3R5bGUoJ2xlZnQnLCBwb3NpdGlvbi54ICsgJ3B4JylcclxuICAgICAgICAuc3R5bGUoJ3RvcCcsIHBvc2l0aW9uLnkgKyAncHgnKTtcclxuXHJcbiAgICAvL0F1dG9mb2N1cyBvbiB0aGUgdGV4dCBhcmVhXHJcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndGV4dGFyZWExJykuZm9jdXMoKTtcclxuXHJcbiAgICBjb21tZW50T2JqLmNoYXJ0RGl2LnNlbGVjdEFsbCgnLmNvbW1lbnRib3gnKS5zZWxlY3QoJyNjYW5jZWwnKVxyXG4gICAgICAgIC5vbignY2xpY2suZGVsZXRlJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBjb21tZW50T2JqLnJlbW92ZUNvbW1lbnQoKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICBjb21tZW50T2JqLmNoYXJ0RGl2LnNlbGVjdEFsbCgnLmNvbW1lbnRib3gnKS5zZWxlY3QoJyNzdWJtaXQnKVxyXG4gICAgICAgIC5vbignY2xpY2suc2F2ZScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgbGV0IGNvbW1lbnRUZXh0ID0gY29tbWVudE9iai5jaGFydERpdi5zZWxlY3QoJyNjb21tZW50Ym94Jykuc2VsZWN0KCcjdGV4dGFyZWExJykuX2dyb3Vwc1swXVswXS52YWx1ZSxcclxuICAgICAgICAgICAgICAgIHNob3dBc01hcmtlciA9IGNvbW1lbnRPYmouY2hhcnREaXYuc2VsZWN0KCcjY29tbWVudGJveCcpLnNlbGVjdCgnI2Rpc3BsYXknKS5fZ3JvdXBzWzBdWzBdLmNoZWNrZWQsXHJcbiAgICAgICAgICAgICAgICBuZXdDb21tZW50T2JqO1xyXG5cclxuICAgICAgICAgICAgbmV3Q29tbWVudE9iaiA9IHtcclxuICAgICAgICAgICAgICAgICdjb21tZW50VGV4dCc6IGNvbW1lbnRUZXh0LFxyXG4gICAgICAgICAgICAgICAgJ2dyb3VwSUQnOiAnZ3JvdXAwJyxcclxuICAgICAgICAgICAgICAgICd0eXBlJzogY29tbWVudFR5cGUsXHJcbiAgICAgICAgICAgICAgICAnYmluZGluZyc6IHtcclxuICAgICAgICAgICAgICAgICAgICAneCc6IHgsXHJcbiAgICAgICAgICAgICAgICAgICAgJ3knOiB5LFxyXG4gICAgICAgICAgICAgICAgICAgICd4Q2hhcnRBcmVhJzogY29tbWVudE9iai5jaGFydERpdi5fZ3JvdXBzWzBdWzBdLmNsaWVudFdpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgICd5Q2hhcnRBcmVhJzogY29tbWVudE9iai5jaGFydERpdi5fZ3JvdXBzWzBdWzBdLmNsaWVudEhlaWdodCxcclxuICAgICAgICAgICAgICAgICAgICAnY3VycmVudFgnOiB4LFxyXG4gICAgICAgICAgICAgICAgICAgICdjdXJyZW50WSc6IHksXHJcbiAgICAgICAgICAgICAgICAgICAgJ3Nob3dBc01hcmtlcic6IHNob3dBc01hcmtlciA/ICd0cnVlJyA6ICdmYWxzZScsXHJcbiAgICAgICAgICAgICAgICAgICAgJ2hlaWdodCc6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgICd3aWR0aCc6IGZhbHNlXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvbW1lbnRPYmouY2hhcnREaXYuc2VsZWN0KCcuY29tbWVudGJveCcpLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICBpZiAoaXNOYU4oY29tbWVudE9iai5jb21tZW50cy5tYXhJZCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbW1lbnRPYmouY29tbWVudHMubWF4SWQgPSAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb21tZW50T2JqLm9uU2F2ZUNhbGxiYWNrKG5ld0NvbW1lbnRPYmosICsrY29tbWVudE9iai5jb21tZW50cy5tYXhJZCwgJ2FkZCcpO1xyXG4gICAgICAgIH0pO1xyXG59XHJcblxyXG4vKipcclxuKiBAbmFtZSByZW1vdmVDb21tZW50XHJcbiogQGRlc2MgZnVuY3Rpb24gdG8gcmVtb3ZlIGNvbW1lbnQgZW50cnkgYm94XHJcbiogQHJldHVybiB7dW5kZWZpbmVkfSAtIG5vIHJldHVyblxyXG4qL1xyXG5mdW5jdGlvbiByZW1vdmVDb21tZW50KCkge1xyXG4gICAgdmFyIGNvbW1lbnRPYmogPSB0aGlzO1xyXG4gICAgY29tbWVudE9iai5jaGFydERpdi5zZWxlY3RBbGwoJy5jb21tZW50Ym94JykucmVtb3ZlKCk7XHJcbn1cclxuXHJcbi8qKlxyXG4qIEBuYW1lIGRyYXdDb21tZW50Tm9kZXNcclxuKiBAZGVzYyBmdW5jdGlvbiB0byBkcmF3IGEgYWxsIGNvbW1lbnRzIG9uIHRoZSB2aXN1YWxcclxuKiBAcmV0dXJuIHt1bmRlZmluZWR9IC0gbm8gcmV0dXJuXHJcbiovXHJcbmZ1bmN0aW9uIGRyYXdDb21tZW50Tm9kZXMoKSB7XHJcbiAgICB2YXIgY29tbWVudE9iaiA9IHRoaXMsXHJcbiAgICAgICAgY29tbWVudHMgPSBjb21tZW50T2JqLmNvbW1lbnRzLmxpc3Q7XHJcblxyXG4gICAgY29tbWVudE9iai5jaGFydERpdi5zZWxlY3RBbGwoJy5taW4tY29tbWVudCcpLnJlbW92ZSgpO1xyXG5cclxuICAgIGZvciAobGV0IGlkIGluIGNvbW1lbnRzKSB7XHJcbiAgICAgICAgaWYgKGNvbW1lbnRzLmhhc093blByb3BlcnR5KGlkKSkge1xyXG4gICAgICAgICAgICBjb21tZW50T2JqLmRyYXdDb21tZW50KGNvbW1lbnRzW2lkXSwgaWQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiogQG5hbWUgZHJhd0NvbW1lbnRcclxuKiBAZGVzYyBmdW5jdGlvbiB0byBkcmF3IGEgc2luZ2xlIGNvbW1lbnQgb24gdGhlIHZpc3VhbFxyXG4qIEBwYXJhbSB7b2JqZWN0fSBjb21tZW50IC0gZGF0YSB1c2VkIHRvIHBhaW4gdGhlIGNvbW1lbnRcclxuKiBAcGFyYW0ge251bWJlcn0gaWQgLSBpZCBvZiB0aGUgc3BlY2lmaWMgY29tbWVudFxyXG4qIEByZXR1cm4ge3VuZGVmaW5lZH0gLSBubyByZXR1cm5cclxuKi9cclxuZnVuY3Rpb24gZHJhd0NvbW1lbnQoY29tbWVudCwgaWQpIHtcclxuICAgIGlmICh0eXBlb2YgdGhpcy5jaGFydERpdi5fZ3JvdXBzID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdDb21tZW50IGRhdGEgaXMgaW4gb2xkIGZvcm1hdCwgd2lsbCBub3QgZGlzcGxheSBvciBjaGFydCBkaXYgZG9lc250IGV4aXN0Jyk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghY29tbWVudC5iaW5kaW5nIHx8ICF0aGlzLmNoYXJ0RGl2Ll9ncm91cHNbMF1bMF0pIHtcclxuICAgICAgICBjb25zb2xlLmxvZygnQ29tbWVudCBkYXRhIGlzIGluIG9sZCBmb3JtYXQsIHdpbGwgbm90IGRpc3BsYXkgb3IgY2hhcnQgZGl2IGRvZXNudCBleGlzdCcpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgY29tbWVudE9iaiA9IHRoaXMsXHJcbiAgICAgICAgY2hhcnREaXYgPSBjb21tZW50T2JqLmNoYXJ0RGl2LFxyXG4gICAgICAgIGJpbmRpbmcgPSBjb21tZW50LmJpbmRpbmcsXHJcbiAgICAgICAgY2hhcnRBcmVhV2lkdGggPSBjaGFydERpdi5fZ3JvdXBzWzBdWzBdLmNsaWVudFdpZHRoLFxyXG4gICAgICAgIGNoYXJ0QXJlYUhlaWdodCA9IGNoYXJ0RGl2Ll9ncm91cHNbMF1bMF0uY2xpZW50SGVpZ2h0LFxyXG4gICAgICAgIHggPSAoYmluZGluZy54IC8gYmluZGluZy54Q2hhcnRBcmVhICogY2hhcnRBcmVhV2lkdGgpLFxyXG4gICAgICAgIHkgPSAoYmluZGluZy55IC8gYmluZGluZy55Q2hhcnRBcmVhICogY2hhcnRBcmVhSGVpZ2h0KSxcclxuICAgICAgICBzdHlsZVN0cmluZyA9ICcnLFxyXG4gICAgICAgIHRleHQgPSAnJyxcclxuICAgICAgICByZXNpemUgPSBmYWxzZTtcclxuXHJcbiAgICBiaW5kaW5nLmN1cnJlbnRYID0gKGJpbmRpbmcueCAvIGJpbmRpbmcueENoYXJ0QXJlYSAqIGNoYXJ0QXJlYVdpZHRoKTtcclxuICAgIGJpbmRpbmcuY3VycmVudFkgPSAoYmluZGluZy55IC8gYmluZGluZy55Q2hhcnRBcmVhICogY2hhcnRBcmVhSGVpZ2h0KTtcclxuXHJcbiAgICBpZiAoY29tbWVudC5iaW5kaW5nLnNob3dBc01hcmtlciA9PT0gJ2ZhbHNlJykge1xyXG4gICAgICAgIGlmIChjb21tZW50LmJpbmRpbmcud2lkdGggJiYgY29tbWVudC5iaW5kaW5nLmhlaWdodCkge1xyXG4gICAgICAgICAgICBzdHlsZVN0cmluZyA9IFwic3R5bGU9J3dpZHRoOiBcIiArIGNvbW1lbnQuYmluZGluZy53aWR0aCArICdweDsgaGVpZ2h0OiAnICsgY29tbWVudC5iaW5kaW5nLmhlaWdodCArIFwicHgnXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb21tZW50LmNvbW1lbnRUZXh0LmluZGV4T2YoJzxpZnJhbWUnKSA+IC0xIHx8IGNvbW1lbnQuY29tbWVudFRleHQuaW5kZXhPZignPGltZycpID4gLTEgfHwgY29tbWVudC5jb21tZW50VGV4dC5pbmRleE9mKCc8c3ZnJykgPiAtMSkge1xyXG4gICAgICAgICAgICAvL2NvbnRhaW5zIGVsZW50cyB0aGF0IHNob3VsZCByZXNpemVcclxuICAgICAgICAgICAgdGV4dCA9IFwiPGRpdiBjbGFzcz0nY29tbWVudC1wYWRkaW5nIHRleHQnXCIgKyBzdHlsZVN0cmluZyArIFwiPjxkaXYgY2xhc3M9J3VzZXItY29tbWVudCc+XCIgKyBjb21tZW50LmNvbW1lbnRUZXh0ICsgJzwvZGl2PjwvZGl2Pic7XHJcbiAgICAgICAgICAgIHJlc2l6ZSA9IHRydWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGV4dCA9ICc8ZGl2IGNsYXNzPVwidGV4dCBlZGl0YWJsZSBlZGl0YWJsZS10ZXh0IGVkaXRhYmxlLWNvbW1lbnQtJyArIGlkICsgJ1wiPicgKyBjb21tZW50LmNvbW1lbnRUZXh0ICsgJzxkaXYvPic7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNoYXJ0RGl2LmFwcGVuZCgnZGl2JylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ21pbi1jb21tZW50JylcclxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ25vZGUnICsgaWQpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDEpXHJcbiAgICAgICAgICAgIC5zdHlsZSgncG9zaXRpb24nLCAnYWJzb2x1dGUnKVxyXG4gICAgICAgICAgICAvLy5zdHlsZShcImJvcmRlclwiLCBcIjFweCBzb2xpZCBibGFja1wiKVxyXG4gICAgICAgICAgICAuaHRtbCh0ZXh0KVxyXG4gICAgICAgICAgICAuc3R5bGUoJ2xlZnQnLCB4ICsgJ3B4JylcclxuICAgICAgICAgICAgLnN0eWxlKCd0b3AnLCB5ICsgJ3B4JylcclxuICAgICAgICAgICAgLm9uKCdkYmxjbGljay5jb21tZW50JywgZnVuY3Rpb24gKCkgey8vRWRpdCB0ZXh0IG9yIGRlbGV0ZSB0aGUgY29tbWVudFxyXG4gICAgICAgICAgICAgICAgY29tbWVudE9iai5kb3VibGVDbGljayh0aGlzLCB4LCB5KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHJlc2l6ZSkge1xyXG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gZDMuc2VsZWN0KCcudXNlci1jb21tZW50Jyk7XHJcbiAgICAgICAgICAgIHJlc2NhbGUocGFyZW50LCBwYXJlbnQubm9kZSgpKTtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNoYXJ0RGl2LnNlbGVjdCgnc3ZnJykuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ21pbi1jb21tZW50JylcclxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ25vZGUnICsgaWQpXHJcbiAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgJyNlNmU2ZTYnKVxyXG4gICAgICAgICAgICAuYXR0cigneCcsIHgpXHJcbiAgICAgICAgICAgIC5hdHRyKCd5JywgeSlcclxuICAgICAgICAgICAgLmF0dHIoJ2ZvbnQtZmFtaWx5JywgJ0ZvbnRBd2Vzb21lJylcclxuICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsICdkYXJrZ3JheScpXHJcbiAgICAgICAgICAgIC5hdHRyKCdmb250LXNpemUnLCAnMTVweCcpXHJcbiAgICAgICAgICAgIC50ZXh0KCdcXHVmMGU1JylcclxuICAgICAgICAgICAgLmF0dHIoJ29wYWNpdHknLCAxKVxyXG4gICAgICAgICAgICAub24oJ2RibGNsaWNrLmNvbW1lbnQnLCBmdW5jdGlvbiAoKSB7Ly9FZGl0IHRleHQgb3IgZGVsZXRlIHRoZSBjb21tZW50XHJcbiAgICAgICAgICAgICAgICBjb21tZW50T2JqLmRvdWJsZUNsaWNrKHRoaXMsIHgsIHkpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAub24oJ21vdXNlZW50ZXIuY29tbWVudCcsIGZ1bmN0aW9uICgpIHsvL1Nob3cgaG92ZXIgb3ZlciBib3ggd2hlbiBtb3VzZSBlbnRlcnMgbm9kZVxyXG4gICAgICAgICAgICAgICAgaWYgKGNvbW1lbnRPYmouc2hvd0NvbW1lbnRzID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBjb21tZW50VGV4dCA9ICcnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50SGVpZ2h0ID0gODAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnRXaWR0aCA9IDE4NSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb247XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogaW4gY29tbWVudE9iai5jb21tZW50cy5saXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLnJvdW5kKGNvbW1lbnRPYmouY29tbWVudHMubGlzdFtqXS5iaW5kaW5nLmN1cnJlbnRYKSA9PT0gTWF0aC5yb3VuZCh0aGlzLnguYmFzZVZhbFswXS52YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLnJvdW5kKGNvbW1lbnRPYmouY29tbWVudHMubGlzdFtqXS5iaW5kaW5nLmN1cnJlbnRZKSA9PT0gTWF0aC5yb3VuZCh0aGlzLnkuYmFzZVZhbFswXS52YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50VGV4dCA9IGNvbW1lbnRPYmouY29tbWVudHMubGlzdFtqXS5jb21tZW50VGV4dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ID0gY29tbWVudE9iai5jb21tZW50cy5saXN0W2pdLmJpbmRpbmcuY3VycmVudFg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGNvbW1lbnRPYmouY29tbWVudHMubGlzdFtqXS5iaW5kaW5nLmN1cnJlbnRZO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gY29tbWVudE9iai5vdmVybGF5RGl2UG9zaXRpb24oY29tbWVudFdpZHRoLCBjb21tZW50SGVpZ2h0LCB4LCB5KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY2hhcnREaXYuYXBwZW5kKCdkaXYnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnY29tbWVudGJveC1yZWFkb25seScpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgncG9zaXRpb24nLCAnYWJzb2x1dGUnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuaHRtbChcIjx0ZXh0YXJlYSByZWFkb25seSByb3dzPSc0JyBjb2xzPScyNycgY2xhc3M9J3RleHRhcmVhJyBuYW1lPSdjb21tZW50Jz5cIiArIGNvbW1lbnRUZXh0ICsgJzwvdGV4dGFyZWE+JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdsZWZ0JywgcG9zaXRpb24ueCArICdweCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgndG9wJywgcG9zaXRpb24ueSArICdweCcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAub24oJ21vdXNlb3V0LmNvbW1lbnQnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvL1JlbW92ZSBob3ZlciBvdmVyIGJveCB3aGVuIG1vdXNlIG1vdmVzIGF3YXlcclxuICAgICAgICAgICAgICAgIGlmIChjb21tZW50T2JqLnNob3dDb21tZW50cyA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGFydERpdi5zZWxlY3QoJy5jb21tZW50Ym94LXJlYWRvbmx5JykucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuKiBAbmFtZSByZXNjYWxlXHJcbiogQGRlc2Mgc2V0cyB0aGUgY2hpbGRyZW4gb2YgdGhlIGVsZSBwYXJhbSB0byAxMDAgcGVyY2VudCBoZWlnaHQgYW5kIHdpZHRoXHJcbiogQHBhcmFtIHtkM25vZGV9IGVsZSAtIG5vZGUgdG8gc3RhcnQgcmVjdXJzaXZlIGZ1bmN0aW9uXHJcbiogQHBhcmFtIHtodG1sTm9kZX0gY29tbWVudE5vZGUgLSB1bnVzZWQgcGFyZW50IG5vZGUgdGhhdCBjYW4gYmUgdXNlZCB0byBjYWxjdWFsdGUgcGVyY2VudCBoZWlnaHQgYW5kIHdpZHRoc1xyXG4qIEByZXR1cm4ge3VuZGVmaW5lZH0gLSBubyByZXR1cm5cclxuKi9cclxuZnVuY3Rpb24gcmVzY2FsZShlbGUsIGNvbW1lbnROb2RlKSB7XHJcbiAgICB2YXIgbm9kZSA9IGVsZS5ub2RlKCksXHJcbiAgICAgICAgd2lkdGggPSAxMDAsXHJcbiAgICAgICAgaGVpZ2h0ID0gMTAwO1xyXG4gICAgLy93aWR0aCA9IG5vZGUuY2xpZW50V2lkdGggLyBjb21tZW50Tm9kZS5jbGllbnRXaWR0aCAqIDEwMDtcclxuICAgIC8vaGVpZ2h0ID0gbm9kZS5jbGllbnRIZWlnaHQgLyBjb21tZW50Tm9kZS5jbGllbnRIZWlnaHQgKiAxMDA7XHJcbiAgICAvL2lmICh3aWR0aCA+IDEwMCkge1xyXG4gICAgLy93aWR0aCA9IDEwMDtcclxuICAgIC8vfVxyXG5cclxuICAgIC8vaWYgKGhlaWdodCA+IDEwMCkge1xyXG4gICAgLy9oZWlnaHQgPSAxMDA7XHJcbiAgICAvL31cclxuXHJcbiAgICBlbGUuc3R5bGUoJ3dpZHRoJywgd2lkdGggKyAnJScpO1xyXG4gICAgZWxlLnN0eWxlKCdoZWlnaHQnLCBoZWlnaHQgKyAnJScpO1xyXG4gICAgZm9yIChsZXQgY2hpbGQgb2Ygbm9kZS5jaGlsZE5vZGVzKSB7XHJcbiAgICAgICAgcmVzY2FsZShkMy5zZWxlY3QoY2hpbGQpLCBjb21tZW50Tm9kZSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4qIEBuYW1lIGRvdWJsZUNsaWNrXHJcbiogQGRlc2MgY2xpY2sgZnVuY3Rpb24gYWZ0ZXIgdGhlIHVzZXIgY2xpY2tzIG9uIGFuIGV4aXN0aW5nIGNvbW1lbnRcclxuKiBAcGFyYW0ge29iamVjdH0gY29tbWVudE5vZGUgLSBjdXJyZW50IGNvbW1lbnQgdGhhdCB0aGUgdXNlciBjbGlja2VkXHJcbiogQHBhcmFtIHtudW1iZXJ9IHggLSB4IHBvc2l0aW9uIG9mIHRoZSBjbGljayBldmVudFxyXG4qIEBwYXJhbSB7bnVtYmVyfSB5IC0geSBwb3NpdGlvbiBvZiB0aGUgY2xpY2sgZXZlbnRcclxuKiBAcmV0dXJuIHt1bmRlZmluZWR9IC0gbm8gcmV0dXJuXHJcbiovXHJcbmZ1bmN0aW9uIGRvdWJsZUNsaWNrKGNvbW1lbnROb2RlLCB4LCB5KSB7XHJcbiAgICBpZiAodGhpcy5jaGFydERpdi5zZWxlY3QoJy5jb21tZW50Ym94LWVkaXQnKS5fZ3JvdXBzWzBdWzBdIHx8IHRoaXMuZ2V0TW9kZSgpICE9PSAnY29tbWVudC1tb2RlJykge1xyXG4gICAgICAgIC8vZG9udCBjcmVhdGUgbmV3IGNvbW1lbnRcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBsZXQgY29tbWVudE9iaiA9IHRoaXMsXHJcbiAgICAgICAgY2hhcnREaXYgPSBjb21tZW50T2JqLmNoYXJ0RGl2LFxyXG4gICAgICAgIGN1cnJlbnRDb21tZW50ID0gY29tbWVudE5vZGUuaWQuc3BsaXQoJ25vZGUnKVsxXSxcclxuICAgICAgICBjb21tZW50VGV4dCA9IGNvbW1lbnRPYmouY29tbWVudHMubGlzdFtjdXJyZW50Q29tbWVudF0uY29tbWVudFRleHQsXHJcbiAgICAgICAgY29tbWVudEhlaWdodCA9IDE0NSxcclxuICAgICAgICBjb21tZW50V2lkdGggPSAyMDAsXHJcbiAgICAgICAgcG9zaXRpb24gPSBjb21tZW50T2JqLm92ZXJsYXlEaXZQb3NpdGlvbihjb21tZW50V2lkdGgsIGNvbW1lbnRIZWlnaHQsIHgsIHkpO1xyXG5cclxuICAgIGNvbW1lbnRPYmouc2hvd0NvbW1lbnRzID0gZmFsc2U7XHJcbiAgICBjaGFydERpdi5zZWxlY3RBbGwoJy5jb21tZW50Ym94LXJlYWRvbmx5JykucmVtb3ZlKCk7XHJcbiAgICBjaGFydERpdi5zZWxlY3RBbGwoJy5jb21tZW50Ym94LWVkaXQnKS5yZW1vdmUoKTtcclxuICAgIGNoYXJ0RGl2LnNlbGVjdEFsbCgnLmNvbW1lbnRib3gnKS5yZW1vdmUoKTtcclxuXHJcbiAgICBjaGFydERpdi5hcHBlbmQoJ2RpdicpXHJcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2NvbW1lbnRib3gtZWRpdCcpXHJcbiAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMSlcclxuICAgICAgICAuc3R5bGUoJ2xlZnQnLCBwb3NpdGlvbi54ICsgJ3B4JylcclxuICAgICAgICAuc3R5bGUoJ3RvcCcsIHBvc2l0aW9uLnkgKyAncHgnKVxyXG4gICAgICAgIC5zdHlsZSgncG9zaXRpb24nLCAnYWJzb2x1dGUnKVxyXG4gICAgICAgIC5odG1sKFwiPGRpdiBjbGFzcz0ndGl0bGUnPjxiPkVkaXQgQ29tbWVudDwvYj48L2Rpdj5cIiArXHJcbiAgICAgICAgXCI8dGV4dGFyZWEgaWQ9J2VkaXQnIGNsYXNzPSdjb21tZW50LXRleHRhcmVhJyBzdHlsZT0nd2lkdGg6MTU1cHg7IGhlaWdodDogOTBweDsnIG5hbWU9J2NvbW1lbnQnPlwiICsgY29tbWVudFRleHQgKyAnPC90ZXh0YXJlYT4nICtcclxuICAgICAgICBcIjxicj48aW5wdXQgdHlwZT0nY2hlY2tCb3gnIGNsYXNzPSdjb21tZW50Ym94LWRpc3BsYXknIGlkID0nZGlzcGxheSc+IERpc3BsYXkgYXMgbWFya2VyXCIgK1xyXG4gICAgICAgIFwiPGJyPjxidXR0b24gY2xhc3M9J2NvbW1lbnRib3gtY2xvc2UnIGlkID0nY2FuY2VsLWVkaXQnPjxpIGNsYXNzPSdmYSBmYS1jbG9zZSc+PC9pPjwvYnV0dG9uPlwiICtcclxuICAgICAgICBcIjxidXR0b24gY2xhc3M9J3Ntc3MtYnRuJyBpZCA9J2RlbGV0ZSc+RGVsZXRlPC9idXR0b24+XCIgK1xyXG4gICAgICAgIFwiPGJ1dHRvbiBjbGFzcz0nc21zcy1idG4nIGlkID0gJ3NhdmUnPlNhdmU8L2J1dHRvbj5cIik7XHJcblxyXG4gICAgY2hhcnREaXYuc2VsZWN0KCcuY29tbWVudGJveC1lZGl0Jykuc2VsZWN0KCcjZGlzcGxheScpLl9ncm91cHNbMF1bMF0uY2hlY2tlZCA9IGNvbW1lbnRPYmouY29tbWVudHMubGlzdFtjdXJyZW50Q29tbWVudF0uYmluZGluZy5zaG93QXNNYXJrZXIgPT09ICd0cnVlJztcclxuXHJcbiAgICBjaGFydERpdi5zZWxlY3RBbGwoJy5jb21tZW50Ym94LWVkaXQnKS5zZWxlY3QoJyNkZWxldGUnKVxyXG4gICAgICAgIC5vbignY2xpY2suZGVsZXRlJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBjaGFydERpdi5zZWxlY3QoJy5jb21tZW50Ym94LWVkaXQnKS5yZW1vdmUoKTtcclxuICAgICAgICAgICAgY2hhcnREaXYuc2VsZWN0KCcuY29tbWVudGJveC1yZWFkb25seScpLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICBjaGFydERpdi5zZWxlY3QoJyNub2RlJyArIGN1cnJlbnRDb21tZW50KS5hdHRyKCdkaXNwbGF5JywgJ25vbmUnKTtcclxuICAgICAgICAgICAgLy9yZWRyYXcgY29tbWVudCBub2RlcyB3aXRoIG5ldyBpbmRleGVzXHJcbiAgICAgICAgICAgIGNvbW1lbnRPYmoub25TYXZlQ2FsbGJhY2soY29tbWVudE9iai5jb21tZW50cy5saXN0W2N1cnJlbnRDb21tZW50XSwgY3VycmVudENvbW1lbnQsICdyZW1vdmUnKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICBjaGFydERpdi5zZWxlY3RBbGwoJy5jb21tZW50Ym94LWVkaXQnKS5zZWxlY3QoJyNzYXZlJylcclxuICAgICAgICAub24oJ2NsaWNrLnNhdmUnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGxldCB0ZXh0ID0gY2hhcnREaXYuc2VsZWN0KCcuY29tbWVudGJveC1lZGl0Jykuc2VsZWN0KCcjZWRpdCcpLl9ncm91cHNbMF1bMF0udmFsdWUsXHJcbiAgICAgICAgICAgICAgICBzaG93QXNNYXJrZXIgPSBjaGFydERpdi5zZWxlY3QoJy5jb21tZW50Ym94LWVkaXQnKS5zZWxlY3QoJyNkaXNwbGF5JykuX2dyb3Vwc1swXVswXS5jaGVja2VkO1xyXG4gICAgICAgICAgICBjb21tZW50T2JqLmNvbW1lbnRzLmxpc3RbY3VycmVudENvbW1lbnRdLmNvbW1lbnRUZXh0ID0gdGV4dDtcclxuICAgICAgICAgICAgY29tbWVudE9iai5jb21tZW50cy5saXN0W2N1cnJlbnRDb21tZW50XS5iaW5kaW5nLnNob3dBc01hcmtlciA9IHNob3dBc01hcmtlciA/ICd0cnVlJyA6ICdmYWxzZSc7XHJcbiAgICAgICAgICAgIGNoYXJ0RGl2LnNlbGVjdCgnLmNvbW1lbnRib3gtcmVhZG9ubHknKS5yZW1vdmUoKTtcclxuICAgICAgICAgICAgY2hhcnREaXYuc2VsZWN0KCcuY29tbWVudGJveC1lZGl0JykucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIGNvbW1lbnRPYmoub25TYXZlQ2FsbGJhY2soY29tbWVudE9iai5jb21tZW50cy5saXN0W2N1cnJlbnRDb21tZW50XSwgY3VycmVudENvbW1lbnQsICdlZGl0Jyk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgY2hhcnREaXYuc2VsZWN0QWxsKCcuY29tbWVudGJveC1lZGl0Jykuc2VsZWN0KCcjY2FuY2VsLWVkaXQnKVxyXG4gICAgICAgIC5vbignY2xpY2suY2FuY2VsLWVkaXQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGNoYXJ0RGl2LnNlbGVjdCgnLmNvbW1lbnRib3gtcmVhZG9ubHknKS5yZW1vdmUoKTtcclxuICAgICAgICAgICAgY2hhcnREaXYuc2VsZWN0KCcuY29tbWVudGJveC1lZGl0JykucmVtb3ZlKCk7XHJcbiAgICAgICAgfSk7XHJcbn1cclxuXHJcblxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBVdGlsaXR5IGZ1bmN0aW9ucyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG4vKipcclxuKiBAbmFtZSBvdmVybGF5RGl2UG9zaXRpb25cclxuKiBAZGVzYyBmdW5jdGlvbiB0byBkZXRlcm1pbmUgdGhlIHBsYWNlbWVudCBvZiB0aGUgZGl2IG9uIHRoZSB2aXN1YWxcclxuKiBAcGFyYW0ge251bWJlcn0gZGl2V2lkdGggLSB3aWR0aCBvZiB0aGUgY29tbWVudCBlbnRyeSBib3hcclxuKiBAcGFyYW0ge251bWJlcn0gZGl2SGVpZ2h0IC0gaGVpZ2h0IG9mIHRoZSBjb21tZW50IGVudHJ5IGJveFxyXG4qIEBwYXJhbSB7bnVtYmVyfSBtb3VzZVggLSB4IHBvc2l0aW9uIG9mIHRoZSBjbGljayBldmVudFxyXG4qIEBwYXJhbSB7bnVtYmVyfSBtb3VzZVkgLSB5IHBvc2l0aW9uIG9mIHRoZSBjbGljayBldmVudFxyXG4qIEByZXR1cm4ge29iamVjdH0gLSBwb3NpdGlvbiBvZiBkaXZcclxuKi9cclxuZnVuY3Rpb24gb3ZlcmxheURpdlBvc2l0aW9uKGRpdldpZHRoLCBkaXZIZWlnaHQsIG1vdXNlWCwgbW91c2VZKSB7XHJcbiAgICBsZXQgZWRpdE9iaiA9IHRoaXMsXHJcbiAgICAgICAgcG9zaXRpb24gPSB7XHJcbiAgICAgICAgICAgIHg6IG1vdXNlWCxcclxuICAgICAgICAgICAgeTogbW91c2VZICsgMTBcclxuICAgICAgICB9O1xyXG4gICAgaWYgKG1vdXNlWCA+IHBhcnNlSW50KGVkaXRPYmouY2hhcnREaXYuc3R5bGUoJ3dpZHRoJyksIDEwKSAvIDIpIHtcclxuICAgICAgICBwb3NpdGlvbi54ID0gbW91c2VYIC0gZGl2V2lkdGg7XHJcbiAgICB9XHJcbiAgICBpZiAobW91c2VZIC0gZGl2SGVpZ2h0IC0gMTAgPiAwKSB7XHJcbiAgICAgICAgcG9zaXRpb24ueSA9IG1vdXNlWSAtIGRpdkhlaWdodCAtIDEwO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBvc2l0aW9uO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGp2Q29tbWVudDtcclxuIiwiLyoqKiAganZFZGl0ICoqKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG52YXIgZWRpdFRlbXBsYXRlID0gcmVxdWlyZSgnLi9lZGl0T3B0aW9uc1RlbXBsYXRlLmpzJyk7XHJcblxyXG4vKipcclxuKiBAbmFtZSBqdkVkaXRcclxuKiBAZGVzYyBDb25zdHJ1Y3RvciBmb3IgSlYgRWRpdCAtIGNyZWF0ZXMgZWRpdHMgdG8gYSBqdiB2aXN1YWxpemF0aW9uIGFuZCBleGVjdXRlcyBhIGNhbGxiYWNrIGZvciB0aGUgZWRpdCBvcHRpb25zIHRvIGJlIHNhdmVkXHJcbiogQHBhcmFtIHtvYmplY3R9IGNvbmZpZ09iaiAtIGNvbnN0cnVjdG9yIG9iamVjdCBjb250YWluaW5nIHRoZSBqdkNoYXJ0IGFuZCBvdGhlciBvcHRpb25zXHJcbiogQHJldHVybiB7dW5kZWZpbmVkfSAtIG5vIHJldHVyblxyXG4qL1xyXG5mdW5jdGlvbiBqdkVkaXQoY29uZmlnT2JqKSB7XHJcbiAgICB2YXIgZWRpdE9iaiA9IHRoaXM7XHJcbiAgICBlZGl0T2JqLmNoYXJ0RGl2ID0gY29uZmlnT2JqLmNoYXJ0RGl2O1xyXG4gICAgZWRpdE9iai52aXpPcHRpb25zID0gY29uZmlnT2JqLnZpek9wdGlvbnMgPyBjb25maWdPYmoudml6T3B0aW9ucyA6IHt9O1xyXG4gICAgZWRpdE9iai5jaGFydERpdi5zZWxlY3RBbGwoJy5lZGl0LWRpdicpLnJlbW92ZSgpO1xyXG4gICAgZWRpdE9iai5lZGl0RGl2ID0gZWRpdE9iai5jaGFydERpdi5hcHBlbmQoJ2RpdicpLmF0dHIoJ2NsYXNzJywgJ2VkaXQtZGl2Jyk7XHJcbiAgICBlZGl0T2JqLm9uU2F2ZUNhbGxiYWNrID0gY29uZmlnT2JqLm9uU2F2ZUNhbGxiYWNrO1xyXG59XHJcblxyXG5qdkVkaXQucHJvdG90eXBlLmRpc3BsYXlFZGl0ID0gZGlzcGxheUVkaXQ7XHJcbmp2RWRpdC5wcm90b3R5cGUuY2hhbmdlRm9udFNpemUgPSBjaGFuZ2VGb250U2l6ZTtcclxuanZFZGl0LnByb3RvdHlwZS5zdWJtaXRFZGl0TW9kZSA9IHN1Ym1pdEVkaXRNb2RlO1xyXG5qdkVkaXQucHJvdG90eXBlLmFwcGx5RWRpdE1vZGUgPSBhcHBseUVkaXRNb2RlO1xyXG5qdkVkaXQucHJvdG90eXBlLmFwcGx5QWxsRWRpdHMgPSBhcHBseUFsbEVkaXRzO1xyXG5qdkVkaXQucHJvdG90eXBlLnJlbW92ZUVkaXQgPSByZW1vdmVFZGl0O1xyXG5qdkVkaXQucHJvdG90eXBlLm92ZXJsYXlEaXZQb3NpdGlvbiA9IG92ZXJsYXlEaXZQb3NpdGlvbjtcclxuXHJcbi8qKlxyXG4qIEBuYW1lIGRpc3BsYXlFZGl0XHJcbiogQGRlc2MgRGlzcGxheXMgdGhlIGVkaXQgZGl2LCBncmFiYmluZyBpdCBmcm9tIHRoZSB0ZW1wbGF0ZVxyXG4qIEBwYXJhbSB7YXJyYXl9IG1vdXNlIC0gbW91c2UgbG9jYXRpb24gb2YgdGhlIGNsaWNrIGV2ZW50LCB1c2VkIHRvIHBsYWNlIHRoZSBlZGl0IG1vZGUgZGl2IG9uIHRoZSB2aXN1YWxcclxuKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucyAtIGNzcyBjbGFzcyBvZiBjbGlja2VkIGVsZW1lbnQsIHByb3ZpZGVzIHRoZSBvcHRpb25zIHRoYXQgYXJlIGVkaXRhYmxlIGJ5IGVkaXQgbW9kZVxyXG4qIEByZXR1cm4ge3VuZGVmaW5lZH0gLSBubyByZXR1cm5cclxuKi9cclxuZnVuY3Rpb24gZGlzcGxheUVkaXQobW91c2UsIG9wdGlvbnMpIHtcclxuICAgIHZhciBlZGl0T2JqID0gdGhpcyxcclxuICAgICAgICBtb3VzZVggPSBtb3VzZVswXSxcclxuICAgICAgICBtb3VzZVkgPSBtb3VzZVsxXSxcclxuICAgICAgICBvcHRpb25WYWx1ZXMgPSBbXSxcclxuICAgICAgICBpdGVtVG9DaGFuZ2UgPSAnJyxcclxuICAgICAgICBlZGl0T3B0aW9uRWxlbWVudCxcclxuICAgICAgICBlZGl0SGVpZ2h0ID0gcGFyc2VGbG9hdChlZGl0T2JqLmVkaXREaXYuc3R5bGUoJ2hlaWdodCcpKSxcclxuICAgICAgICBlZGl0V2lkdGggPSBwYXJzZUZsb2F0KGVkaXRPYmouZWRpdERpdi5zdHlsZSgnd2lkdGgnKSksXHJcbiAgICAgICAgcG9zaXRpb247XHJcblxyXG4gICAgLy9yZXR1cm4gaWYgeW91IGNsaWNrIG9uIHRoZSBzYW1lIGVsZW1lbnQgdHdpY2UsIG5vIG5lZWQgdG8gZGlzcGxheSBhIHNlY29uZCBlZGl0IGRpdiBpZiB0aGUgY3VycmVudCBvbmUgaXMgc3RpbGwgb3BlblxyXG4gICAgaWYgKGVkaXRPYmouZWRpdE9wdGlvbnMgPT09IG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBlZGl0T2JqLmVkaXREaXYuaHRtbCgnJyk7XHJcbiAgICBlZGl0T2JqLmVkaXRPcHRpb25zID0gb3B0aW9ucztcclxuXHJcbiAgICAvL2Fzc2lnbiBodG1sIHRvIGVkaXREaXYgKGJhc2ljYWxseSBkaXNwbGF5cyB0aGUgZGl2KVxyXG4gICAgZWRpdE9iai5lZGl0RGl2Lmh0bWwoZWRpdFRlbXBsYXRlKTtcclxuXHJcbiAgICAvL29wdGlvblZhbHVlcyAtIGFuIGFycmF5IG9mIHN0cmluZ3MuXHJcbiAgICAvL1N0cmluZyBpcyB0aGUgaWQgdG8gdGhlIGVsZW1lbnQgaW4gdGhlIGVkaXREaXYgZm9ybS5cclxuICAgIC8vVGhpcyBzdHJpbmcgY29udGFpbnMgdGhlIHNwZWNpZmljIG9wdGlvbiB0aGF0IGlzIGJlaW5nIGNoYW5nZWRcclxuXHJcbiAgICAvL2l0ZW1Ub0NoYW5nZVxyXG4gICAgLy9TdHJpbmcgdGhhdCBpcyB0aGUgY2xhc3Mgb2YgdGhlIHN2ZyBlbGVtZW50IHRvIGJlIGNoYW5nZWQgb24gdGhlIHZpeiBpdHNlbGZcclxuICAgIGVkaXRPcHRpb25FbGVtZW50ID0gZWRpdE9iai5lZGl0RGl2LnNlbGVjdCgnI2VkaXQtb3B0aW9uLWVsZW1lbnQnKTtcclxuXHJcbiAgICAvL2lmIHN0YXRlbWVudHMgdG8gZGV0ZXJtaW5lIHdoaWNoIGVkaXQgb3B0aW9ucyB0byBkaXNwbGF5XHJcbiAgICBpZiAob3B0aW9ucy5pbmRleE9mKCdlZGl0YWJsZS15QXhpcycpID49IDApIHtcclxuICAgICAgICBlZGl0T3B0aW9uRWxlbWVudC5odG1sKCcmbmJzcDtmb3IgWSBBeGlzJyk7XHJcbiAgICAgICAgZWRpdE9wdGlvbkVsZW1lbnQuc3R5bGUoJ3Zpc2liaWxpdHknLCAndmlzaWJsZScpO1xyXG4gICAgICAgIGl0ZW1Ub0NoYW5nZSA9ICd5QXhpcyc7XHJcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuaW5kZXhPZignZWRpdGFibGUteEF4aXMnKSA+PSAwKSB7XHJcbiAgICAgICAgZWRpdE9wdGlvbkVsZW1lbnQuaHRtbCgnJm5ic3A7Zm9yIFggQXhpcycpO1xyXG4gICAgICAgIGVkaXRPcHRpb25FbGVtZW50LnN0eWxlKCd2aXNpYmlsaXR5JywgJ3Zpc2libGUnKTtcclxuICAgICAgICBpdGVtVG9DaGFuZ2UgPSAneEF4aXMnO1xyXG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmluZGV4T2YoJ3lMYWJlbCcpID49IDApIHtcclxuICAgICAgICBlZGl0T3B0aW9uRWxlbWVudC5odG1sKCcmbmJzcDtmb3IgWSBMYWJlbCcpO1xyXG4gICAgICAgIGVkaXRPcHRpb25FbGVtZW50LnN0eWxlKCd2aXNpYmlsaXR5JywgJ3Zpc2libGUnKTtcclxuICAgICAgICBpdGVtVG9DaGFuZ2UgPSAneUxhYmVsJztcclxuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5pbmRleE9mKCd4TGFiZWwnKSA+PSAwKSB7XHJcbiAgICAgICAgZWRpdE9wdGlvbkVsZW1lbnQuaHRtbCgnJm5ic3A7Zm9yIFggTGFiZWwnKTtcclxuICAgICAgICBlZGl0T3B0aW9uRWxlbWVudC5zdHlsZSgndmlzaWJpbGl0eScsICd2aXNpYmxlJyk7XHJcbiAgICAgICAgaXRlbVRvQ2hhbmdlID0gJ3hMYWJlbCc7XHJcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuaW5kZXhPZignbGVnZW5kVGV4dCcpID49IDApIHtcclxuICAgICAgICBlZGl0T3B0aW9uRWxlbWVudC5odG1sKCcmbmJzcDtmb3IgTGVnZW5kIEl0ZW0nKTtcclxuICAgICAgICBlZGl0T3B0aW9uRWxlbWVudC5zdHlsZSgndmlzaWJpbGl0eScsICd2aXNpYmxlJyk7XHJcbiAgICAgICAgaXRlbVRvQ2hhbmdlID0gb3B0aW9ucy5zdWJzdHJpbmcob3B0aW9ucy5pbmRleE9mKCdlZGl0YWJsZS1sZWdlbmQtJykpLnNwbGl0KCcgJylbMF07XHJcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuaW5kZXhPZignZWRpdGFibGUtYmFyJykgPj0gMCkge1xyXG4gICAgICAgIGVkaXRPcHRpb25FbGVtZW50Lmh0bWwoJyZuYnNwO2ZvciBCYXIgQ2hhcnQnKTtcclxuICAgICAgICBlZGl0T3B0aW9uRWxlbWVudC5zdHlsZSgndmlzaWJpbGl0eScsICd2aXNpYmxlJyk7XHJcbiAgICAgICAgZWRpdE9iai5lZGl0RGl2LnNlbGVjdCgnLmVkaXRhYmxlLWJhcicpLnN0eWxlKCdkaXNwbGF5JywgJ2Jsb2NrJyk7XHJcbiAgICAgICAgb3B0aW9uVmFsdWVzLnB1c2goJ2VkaXRhYmxlLWJhcicpO1xyXG4gICAgICAgIGl0ZW1Ub0NoYW5nZSA9IG9wdGlvbnMuc3Vic3RyaW5nKG9wdGlvbnMuaW5kZXhPZignYmFyLWNvbC0nKSkuc3BsaXQoJyAnKVswXTtcclxuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5pbmRleE9mKCdlZGl0YWJsZS1waWUnKSA+PSAwKSB7XHJcbiAgICAgICAgZWRpdE9wdGlvbkVsZW1lbnQuaHRtbCgnJm5ic3A7Zm9yIFBpZSBTbGljZScpO1xyXG4gICAgICAgIGVkaXRPcHRpb25FbGVtZW50LnN0eWxlKCd2aXNpYmlsaXR5JywgJ3Zpc2libGUnKTtcclxuICAgICAgICBlZGl0T2JqLmVkaXREaXYuc2VsZWN0KCcuZWRpdGFibGUtcGllJykuc3R5bGUoJ2Rpc3BsYXknLCAnYmxvY2snKTtcclxuICAgICAgICBvcHRpb25WYWx1ZXMucHVzaCgnZWRpdGFibGUtcGllJyk7XHJcbiAgICAgICAgaXRlbVRvQ2hhbmdlID0gb3B0aW9ucy5zdWJzdHJpbmcob3B0aW9ucy5pbmRleE9mKCdwaWUtc2xpY2UtJykpLnNwbGl0KCcgJylbMF07XHJcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuaW5kZXhPZignZWRpdGFibGUtc2NhdHRlcicpID49IDApIHtcclxuICAgICAgICBlZGl0T3B0aW9uRWxlbWVudC5odG1sKCcmbmJzcDtmb3IgU2NhdHRlciBQbG90Jyk7XHJcbiAgICAgICAgZWRpdE9wdGlvbkVsZW1lbnQuc3R5bGUoJ3Zpc2liaWxpdHknLCAndmlzaWJsZScpO1xyXG4gICAgICAgIGVkaXRPYmouZWRpdERpdi5zZWxlY3QoJy5lZGl0YWJsZS1zY2F0dGVyJykuc3R5bGUoJ2Rpc3BsYXknLCAnYmxvY2snKTtcclxuICAgICAgICBvcHRpb25WYWx1ZXMucHVzaCgnZWRpdGFibGUtc2NhdHRlcicpO1xyXG4gICAgICAgIGl0ZW1Ub0NoYW5nZSA9IG9wdGlvbnMuc3Vic3RyaW5nKG9wdGlvbnMuaW5kZXhPZignc2NhdHRlci1jaXJjbGUtJykpLnNwbGl0KCcgJylbMF07XHJcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuaW5kZXhPZignZWRpdGFibGUtYnViYmxlJykgPj0gMCkge1xyXG4gICAgICAgIGVkaXRPcHRpb25FbGVtZW50Lmh0bWwoJyZuYnNwO2ZvciBCdWJibGUgQ2hhcnQnKTtcclxuICAgICAgICBlZGl0T3B0aW9uRWxlbWVudC5zdHlsZSgndmlzaWJpbGl0eScsICd2aXNpYmxlJyk7XHJcbiAgICAgICAgZWRpdE9iai5lZGl0RGl2LnNlbGVjdCgnLmVkaXRhYmxlLWJ1YmJsZScpLnN0eWxlKCdkaXNwbGF5JywgJ2Jsb2NrJyk7XHJcbiAgICAgICAgb3B0aW9uVmFsdWVzLnB1c2goJ2VkaXRhYmxlLWJ1YmJsZScpO1xyXG4gICAgICAgIGl0ZW1Ub0NoYW5nZSA9IG9wdGlvbnMuc3Vic3RyaW5nKG9wdGlvbnMuaW5kZXhPZignYnViYmxlLScpKS5zcGxpdCgnICcpWzBdO1xyXG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmluZGV4T2YoJ2VkaXRhYmxlLWJveCcpID49IDApIHtcclxuICAgICAgICBlZGl0T3B0aW9uRWxlbWVudC5odG1sKCcmbmJzcDtmb3IgQm94IGFuZCBXaGlza2VyIFBsb3QnKTtcclxuICAgICAgICBlZGl0T3B0aW9uRWxlbWVudC5zdHlsZSgndmlzaWJpbGl0eScsICd2aXNpYmxlJyk7XHJcbiAgICAgICAgZWRpdE9iai5lZGl0RGl2LnNlbGVjdCgnLmVkaXRhYmxlLWJveCcpLnN0eWxlKCdkaXNwbGF5JywgJ2Jsb2NrJyk7XHJcbiAgICAgICAgb3B0aW9uVmFsdWVzLnB1c2goJ2VkaXRhYmxlLWJveCcpO1xyXG4gICAgICAgIGl0ZW1Ub0NoYW5nZSA9IG9wdGlvbnMuc3Vic3RyaW5nKG9wdGlvbnMuaW5kZXhPZignYm94LScpKS5zcGxpdCgnICcpWzBdO1xyXG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmluZGV4T2YoJ2VkaXRhYmxlLWNvbW1lbnQnKSA+PSAwKSB7XHJcbiAgICAgICAgZWRpdE9wdGlvbkVsZW1lbnQuaHRtbCgnJm5ic3A7Zm9yIENvbW1lbnQnKTtcclxuICAgICAgICBlZGl0T3B0aW9uRWxlbWVudC5zdHlsZSgndmlzaWJpbGl0eScsICd2aXNpYmxlJyk7XHJcbiAgICAgICAgaXRlbVRvQ2hhbmdlID0gb3B0aW9ucy5zdWJzdHJpbmcob3B0aW9ucy5pbmRleE9mKCdlZGl0YWJsZS1jb21tZW50LScpKS5zcGxpdCgnICcpWzBdO1xyXG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmluZGV4T2YoJ2VkaXRhYmxlLXN2ZycpID49IDApIHtcclxuICAgICAgICBlZGl0T3B0aW9uRWxlbWVudC5odG1sKCcmbmJzcDtmb3IgQWxsIFRleHQnKTtcclxuICAgICAgICBlZGl0T3B0aW9uRWxlbWVudC5zdHlsZSgndmlzaWJpbGl0eScsICd2aXNpYmxlJyk7XHJcbiAgICAgICAgZWRpdE9iai5lZGl0RGl2LnNlbGVjdCgnLmVkaXRhYmxlLXRleHQtc2l6ZS1idXR0b25zJykuc3R5bGUoJ2Rpc3BsYXknLCAnYmxvY2snKTtcclxuICAgICAgICBvcHRpb25WYWx1ZXMucHVzaCgnZWRpdGFibGUtdGV4dC1zaXplJyk7XHJcbiAgICAgICAgaXRlbVRvQ2hhbmdlID0gJ3N2Zyc7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdTdGlsbCBuZWVkIHRvIGFkZCBvcHRpb24gdG8gZGlzcGxheSBlZGl0Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG9wdGlvbnMuaW5kZXhPZignZWRpdGFibGUtbnVtJykgPj0gMCkge1xyXG4gICAgICAgIGVkaXRPYmouZWRpdERpdi5zZWxlY3QoJy5lZGl0YWJsZS1udW0tZm9ybWF0Jykuc3R5bGUoJ2Rpc3BsYXknLCAnYmxvY2snKTtcclxuICAgICAgICBvcHRpb25WYWx1ZXMucHVzaCgnZWRpdGFibGUtbnVtLWZvcm1hdCcpO1xyXG4gICAgfVxyXG4gICAgaWYgKG9wdGlvbnMuaW5kZXhPZignZWRpdGFibGUtdGV4dCcpID49IDApIHtcclxuICAgICAgICBlZGl0T2JqLmVkaXREaXYuc2VsZWN0KCcuZWRpdGFibGUtdGV4dC1jb2xvcicpLnN0eWxlKCdkaXNwbGF5JywgJ2Jsb2NrJyk7XHJcbiAgICAgICAgb3B0aW9uVmFsdWVzLnB1c2goJ2VkaXRhYmxlLXRleHQtY29sb3InKTtcclxuICAgICAgICBlZGl0T2JqLmVkaXREaXYuc2VsZWN0KCcuZWRpdGFibGUtdGV4dC1zaXplJykuc3R5bGUoJ2Rpc3BsYXknLCAnYmxvY2snKTtcclxuICAgICAgICBvcHRpb25WYWx1ZXMucHVzaCgnZWRpdGFibGUtdGV4dC1zaXplJyk7XHJcbiAgICB9XHJcbiAgICBpZiAob3B0aW9ucy5pbmRleE9mKCdlZGl0YWJsZS1jb250ZW50JykgPj0gMCkge1xyXG4gICAgICAgIGVkaXRPYmouZWRpdERpdi5zZWxlY3QoJy5lZGl0YWJsZS1jb250ZW50Jykuc3R5bGUoJ2Rpc3BsYXknLCAnYmxvY2snKTtcclxuICAgICAgICBvcHRpb25WYWx1ZXMucHVzaCgnZWRpdGFibGUtY29udGVudCcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vcG9wdWxhdGUgZWRpdCBkaXYgd2l0aCBpbml0aWFsIHZhbHVlc1xyXG4gICAgaWYgKGVkaXRPYmoudml6T3B0aW9uc1tpdGVtVG9DaGFuZ2VdKSB7XHJcbiAgICAgICAgcG9wdWxhdGVTZWxlY3Rpb25zRWRpdE1vZGUoZWRpdE9iai5lZGl0RGl2LCBlZGl0T2JqLnZpek9wdGlvbnNbaXRlbVRvQ2hhbmdlXSk7XHJcbiAgICB9XHJcbiAgICBlZGl0T2JqLmVkaXREaXZcclxuICAgICAgICAuc3R5bGUoJ2Rpc3BsYXknLCAnYmxvY2snKVxyXG4gICAgICAgIC5zdHlsZSgnbGVmdCcsIDAgKyAncHgnKVxyXG4gICAgICAgIC5zdHlsZSgndG9wJywgMCArICdweCcpO1xyXG5cclxuICAgIC8vY2FsY3VsYXRlIHBvc2l0aW9uIG9mIG92ZXJsYXkgZGl2XHJcbiAgICBlZGl0SGVpZ2h0ID0gcGFyc2VGbG9hdChlZGl0T2JqLmVkaXREaXYuc3R5bGUoJ2hlaWdodCcpKTtcclxuICAgIGVkaXRXaWR0aCA9IHBhcnNlRmxvYXQoZWRpdE9iai5lZGl0RGl2LnN0eWxlKCd3aWR0aCcpKTtcclxuICAgIHBvc2l0aW9uID0gZWRpdE9iai5vdmVybGF5RGl2UG9zaXRpb24oZWRpdFdpZHRoLCBlZGl0SGVpZ2h0LCBtb3VzZVgsIG1vdXNlWSk7XHJcblxyXG4gICAgLy9zaG93IHRoZSBuZXcgZWRpdCBkaXZcclxuICAgIGVkaXRPYmouZWRpdERpdlxyXG4gICAgICAgIC5zdHlsZSgnbGVmdCcsIHBvc2l0aW9uLnggKyAncHgnKVxyXG4gICAgICAgIC5zdHlsZSgndG9wJywgcG9zaXRpb24ueSArICdweCcpO1xyXG5cclxuICAgIC8vYWRkIHN1Ym1pdCwgZGVmYXVsdCwgYW5kIGV4aXQgbGlzdGVuZXJzIHRvIHRoZSBkaXZcclxuICAgIGVkaXRPYmouZWRpdERpdi5zZWxlY3QoJyNzdWJtaXRFZGl0TW9kZScpLm9uKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBlZGl0T2JqLnN1Ym1pdEVkaXRNb2RlKG9wdGlvblZhbHVlcywgaXRlbVRvQ2hhbmdlKTtcclxuICAgICAgICBlZGl0T2JqLnJlbW92ZUVkaXQoKTtcclxuICAgIH0pO1xyXG4gICAgZWRpdE9iai5lZGl0RGl2LnNlbGVjdCgnI3N1Ym1pdEVkaXRNb2RlRGVmYXVsdCcpLm9uKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBlZGl0T2JqLnN1Ym1pdEVkaXRNb2RlKG9wdGlvblZhbHVlcywgaXRlbVRvQ2hhbmdlLCB0cnVlKTtcclxuICAgICAgICBlZGl0T2JqLnJlbW92ZUVkaXQoKTtcclxuICAgIH0pO1xyXG4gICAgZWRpdE9iai5lZGl0RGl2LnNlbGVjdCgnI2V4aXRFZGl0TW9kZScpLm9uKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBlZGl0T2JqLnJlbW92ZUVkaXQoKTtcclxuICAgIH0pO1xyXG4gICAgZWRpdE9iai5mb250U2l6ZUluY3JlbWVudCA9IDA7XHJcblxyXG4gICAgLy9DbGljayBldmVudHMgZm9yIGluY3JlYXNlL2RlY3JlYXNlIGZvbnQgc2l6ZSBidXR0b25zXHJcbiAgICBlZGl0T2JqLmVkaXREaXYuc2VsZWN0KCcjaW5jcmVhc2VGb250U2l6ZScpLm9uKCdjbGljaycsIGluY3JlYXNlRm9udFNpemUuYmluZChlZGl0T2JqKSk7XHJcbiAgICBlZGl0T2JqLmVkaXREaXYuc2VsZWN0KCcjZGVjcmVhc2VGb250U2l6ZScpLm9uKCdjbGljaycsIGRlY3JlYXNlRm9udFNpemUuYmluZChlZGl0T2JqKSk7XHJcbn1cclxuXHJcbi8qKlxyXG4qIEBuYW1lIGluY3JlYXNlRm9udFNpemVcclxuKiBAZGVzYyBJbmNyZWFzZXMgZm9udCBzaXplIGJ5IGFuIGluY3JlbWVudFxyXG4qIEByZXR1cm4ge3VuZGVmaW5lZH0gLSBubyByZXR1cm5cclxuKi9cclxuZnVuY3Rpb24gaW5jcmVhc2VGb250U2l6ZSgpIHtcclxuICAgIHZhciBlZGl0T2JqID0gdGhpcyxcclxuICAgICAgICBmb250SW5jcmVtZW50ID0gMSxcclxuICAgICAgICBtYXhTaXplID0gMjg7XHJcbiAgICBpZiAoZWRpdE9iai5mb250U2l6ZUluY3JlbWVudCA8IG1heFNpemUpIHtcclxuICAgICAgICBlZGl0T2JqLmNoYW5nZUZvbnRTaXplKGZvbnRJbmNyZW1lbnQpO1xyXG4gICAgICAgIGVkaXRPYmouZm9udFNpemVJbmNyZW1lbnQrKztcclxuICAgICAgICBlZGl0T2JqLnZpek9wdGlvbnMudGV4dCA9IHsgJ2VkaXRhYmxlLXRleHQtaW5jcmVtZW50JzogZWRpdE9iai5mb250U2l6ZUluY3JlbWVudCB9O1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuKiBAbmFtZSBkZWNyZWFzZUZvbnRTaXplXHJcbiogQGRlc2MgRGVjcmVhc2VzIGZvbnQgc2l6ZSBieSBhbiBpbmNyZW1lbnRcclxuKiBAcmV0dXJuIHt1bmRlZmluZWR9IC0gbm8gcmV0dXJuXHJcbiovXHJcbmZ1bmN0aW9uIGRlY3JlYXNlRm9udFNpemUoKSB7XHJcbiAgICB2YXIgZWRpdE9iaiA9IHRoaXMsXHJcbiAgICAgICAgZm9udERlY3JlbWVudCA9IC0xLFxyXG4gICAgICAgIG1pblNpemUgPSAtMTI7XHJcbiAgICAvL21pbiBzaXplIGlzIG5lZyAxMiBiZWNhdXNlIGRlZmF1bHQgc2l6ZSBpcyAxMnB4IG9uIG91ciBjaGFydHNcclxuICAgIGlmIChlZGl0T2JqLmZvbnRTaXplSW5jcmVtZW50ID4gbWluU2l6ZSkge1xyXG4gICAgICAgIGVkaXRPYmouY2hhbmdlRm9udFNpemUoZm9udERlY3JlbWVudCk7XHJcbiAgICAgICAgZWRpdE9iai5mb250U2l6ZUluY3JlbWVudC0tO1xyXG4gICAgICAgIGVkaXRPYmoudml6T3B0aW9ucy50ZXh0ID0geyAnZWRpdGFibGUtdGV4dC1pbmNyZW1lbnQnOiBlZGl0T2JqLmZvbnRTaXplSW5jcmVtZW50IH07XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4qIEBuYW1lIGNoYW5nZUZvbnRTaXplXHJcbiogQGRlc2MgSW5jcmVhc2VzIG9yIGRlY3JlYXNlcyBmb250IHNpemUgYnkgYSBjZXJ0YWluIGluY3JlbWVudFxyXG4qIEBwYXJhbSB7aW50ZWdlcn0gaW5jcmVtZW50IC0gbnVtYmVyIG9mIGluY3JlbWVudFxyXG4qIEByZXR1cm4ge3VuZGVmaW5lZH0gLSBubyByZXR1cm5cclxuKi9cclxuZnVuY3Rpb24gY2hhbmdlRm9udFNpemUoaW5jcmVtZW50KSB7XHJcbiAgICB2YXIgZWRpdE9iaiA9IHRoaXM7XHJcbiAgICBlZGl0T2JqLmNoYXJ0RGl2LnNlbGVjdEFsbCgndGV4dCcpLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHVwZGF0ZUZvbnQodGhpcywgaW5jcmVtZW50KTtcclxuICAgIH0pO1xyXG4gICAgZWRpdE9iai5jaGFydERpdi5zZWxlY3RBbGwoJy50ZXh0JykuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdXBkYXRlRm9udCh0aGlzLCBpbmNyZW1lbnQpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4qIEBuYW1lIHVwZGF0ZUZvbnRcclxuKiBAZGVzYyBjaGFuZ2VzIHRoZSBzaXplIG9mIHRoZSBmb250IGJ5IGEgZ2l2ZW4gaW5jcmVtZW50XHJcbiogQHBhcmFtIHtodG1sTm9kZX0gdGhpc0RpdiAtIG5vZGUgdG8gY2hhbmdlIGZvbnQgc2l6ZVxyXG4qIEBwYXJhbSB7aW50ZWdlcn0gaW5jcmVtZW50IC0gbnVtYmVyIG9mIGluY3JlbWVudFxyXG4qIEByZXR1cm4ge3VuZGVmaW5lZH0gLSBubyByZXR1cm5cclxuKi9cclxuZnVuY3Rpb24gdXBkYXRlRm9udCh0aGlzRGl2LCBpbmNyZW1lbnQpIHtcclxuICAgIHZhciBuZXdTaXplLFxyXG4gICAgICAgIHRleHRTaXplID0gMTI7XHJcbiAgICBpZiAodGhpc0RpdiAmJiB0aGlzRGl2LmdldEF0dHJpYnV0ZSgnZm9udC1zaXplJykpIHtcclxuICAgICAgICB0ZXh0U2l6ZSA9IHRoaXNEaXYuZ2V0QXR0cmlidXRlKCdmb250LXNpemUnKTtcclxuICAgICAgICBuZXdTaXplID0gcGFyc2VJbnQodGV4dFNpemUsIDEwKSArIGluY3JlbWVudDtcclxuICAgICAgICB0aGlzRGl2LnNldEF0dHJpYnV0ZSgnZm9udC1zaXplJywgbmV3U2l6ZSArICdweCcpO1xyXG4gICAgfSBlbHNlIGlmICh0aGlzRGl2KSB7XHJcbiAgICAgICAgdGV4dFNpemUgPSBwYXJzZUludCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzRGl2LCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKCdmb250LXNpemUnKSwgMTApICsgaW5jcmVtZW50O1xyXG4gICAgICAgIHRoaXNEaXYuc3R5bGUuZm9udFNpemUgPSAgdGV4dFNpemUgKyAncHgnO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuKiBAbmFtZSBwb3B1bGF0ZVNlbGVjdGlvbnNFZGl0TW9kZVxyXG4qIEBkZXNjIEluaXRpYWxseSBwb3B1bGF0ZXMgdGhlIGVkaXREaXYgaWYgdGhlcmUgYXJlIHZpek9wdGlvbnNcclxuKiBAcGFyYW0ge2h0bWxOb2RlfSBlZGl0RGl2IC0gZWRpdCBtb2RlIG9wdGlvbnMgZGl2XHJcbiogQHBhcmFtIHtvYmplY3R9IHZpek9wdGlvbnMgLSBjdXJyZW50IHVzZXIgb3B0aW9ucyB0byBhcHBseSB0byB0aGUgZWRpdCBkaXZcclxuKiBAcmV0dXJuIHt1bmRlZmluZWR9IC0gbm8gcmV0dXJuXHJcbiovXHJcbmZ1bmN0aW9uIHBvcHVsYXRlU2VsZWN0aW9uc0VkaXRNb2RlKGVkaXREaXYsIHZpek9wdGlvbnMpIHtcclxuICAgIGZvciAobGV0IG9wdGlvbiBpbiB2aXpPcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKHZpek9wdGlvbnMuaGFzT3duUHJvcGVydHkob3B0aW9uKSkge1xyXG4gICAgICAgICAgICBsZXQgc2VsZWN0ZWRPYmplY3QgPSBlZGl0RGl2LnNlbGVjdCgnIycgKyBvcHRpb24pLl9ncm91cHNbMF1bMF07XHJcbiAgICAgICAgICAgIC8vZGVmYXVsdCBjb2xvciBpbnB1dHMgdG8gZ3JheVxyXG4gICAgICAgICAgICBpZiAodml6T3B0aW9uc1tvcHRpb25dID09PSAnZGVmYXVsdCcpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RlZE9iamVjdC50eXBlID09PSAnY29sb3InKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkT2JqZWN0LmlkLmluZGV4T2YoJ3RleHQnKSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRPYmplY3QudmFsdWUgPSAnIzAwMDAwMCc7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRPYmplY3QudmFsdWUgPSAnI2FhYWFhYSc7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRPYmplY3QudmFsdWUgPSB2aXpPcHRpb25zW29wdGlvbl07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4qIEBuYW1lIHN1Ym1pdEVkaXRNb2RlXHJcbiogQGRlc2MgY2FsbHMgc2F2ZSBjYWxsYmFjayBvbiBlZGl0IG1vZGUgd2l0aCBlZGl0IG9wdGlvbnNcclxuKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uVmFsdWVzIC0gbmV3IHVzZXIgb3B0aW9ucyB0byBzYXZlXHJcbiogQHBhcmFtIHtvYmplY3R9IHBvc3NpYmxlSXRlbVRvQ2hhbmdlIC0gaXRlbSB0aGF0IHRoZSB1c2VyIGNsaWNrZWQgKG1pZ2h0IG5vdCBiZSB0aGUgYWN0dWFsIGl0ZW0gdG8gdXBkYXRlKVxyXG4qIEBwYXJhbSB7b2JqZWN0fSBkZWZhdWx0QnRuQ2xpY2tlZCAtIHJlc2V0IHZpeiBvcHRpb24gdG8gZGVmYXVsdFxyXG4qIEByZXR1cm4ge3VuZGVmaW5lZH0gLSBubyByZXR1cm5cclxuKi9cclxuZnVuY3Rpb24gc3VibWl0RWRpdE1vZGUob3B0aW9uVmFsdWVzLCBwb3NzaWJsZUl0ZW1Ub0NoYW5nZSwgZGVmYXVsdEJ0bkNsaWNrZWQpIHtcclxuICAgIGxldCBlZGl0T2JqID0gdGhpcyxcclxuICAgICAgICBvcHRpb25BcnJheSA9IG9wdGlvblZhbHVlcyxcclxuICAgICAgICBzZWxlY3RlZEVkaXRPcHRpb25zID0ge30sXHJcbiAgICAgICAgZWRpdFZhbHVlLFxyXG4gICAgICAgIHNlbGVjdGVkT2JqLFxyXG4gICAgICAgIGl0ZW1Ub0NoYW5nZSA9IHBvc3NpYmxlSXRlbVRvQ2hhbmdlO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3B0aW9uQXJyYXkubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAob3B0aW9uQXJyYXlbaV0uaW5kZXhPZignZWRpdGFibGUtbGVnZW5kJykgPiAwKSB7XHJcbiAgICAgICAgICAgIC8vY2hhbmdlIGl0ZW0gdG8gY2hhbmdlIGZvciBsZWdlbmQgZWxlbWVudHNcclxuICAgICAgICAgICAgaXRlbVRvQ2hhbmdlID0gb3B0aW9uQXJyYXlbaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNlbGVjdGVkT2JqID0gZWRpdE9iai5lZGl0RGl2LnNlbGVjdCgnIycgKyBvcHRpb25BcnJheVtpXSk7XHJcbiAgICAgICAgLy9zZWUgaWYgc2VsZWN0ZWQgb2JqZWN0IGV4aXN0c1xyXG4gICAgICAgIGlmIChzZWxlY3RlZE9iaiAmJiBzZWxlY3RlZE9iai5fZ3JvdXBzWzBdICYmIHNlbGVjdGVkT2JqLl9ncm91cHNbMF1bMF0pIHtcclxuICAgICAgICAgICAgZWRpdFZhbHVlID0gc2VsZWN0ZWRPYmouX2dyb3Vwc1swXVswXS52YWx1ZTtcclxuICAgICAgICAgICAgLy9nZXQgc2VsZWN0ZWQgb3B0aW9uIGZyb20gZWRpdCBkaXZcclxuICAgICAgICAgICAgaWYgKG9wdGlvbkFycmF5W2ldID09PSAnZWRpdGFibGUtY29udGVudCcgJiYgZWRpdFZhbHVlID09PSAnJykge1xyXG4gICAgICAgICAgICAgICAgLy9kb250IGFkZCBhbiBlbXB0eSBzdHJpbmcgdG8gdGhlIHZpeiBvcHRpb25zIGZvciBlZGl0YWJsZSBjb250ZW50XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZWxlY3RlZEVkaXRPcHRpb25zW29wdGlvbkFycmF5W2ldXSA9IGVkaXRWYWx1ZTtcclxuICAgICAgICAgICAgaWYgKCghc2VsZWN0ZWRFZGl0T3B0aW9uc1tvcHRpb25BcnJheVtpXV0pICYmIG9wdGlvbkFycmF5W2ldLmluZGV4T2YoJ2NvbnRlbnQnKSA8IDApIHtcclxuICAgICAgICAgICAgICAgIHNlbGVjdGVkRWRpdE9wdGlvbnNbb3B0aW9uQXJyYXlbaV1dID0gJ2RlZmF1bHQnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChkZWZhdWx0QnRuQ2xpY2tlZCkge1xyXG4gICAgICAgIGlmIChpdGVtVG9DaGFuZ2UgPT09ICdzdmcnKSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBlZGl0T2JqLnZpek9wdGlvbnMudGV4dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVsZXRlIGVkaXRPYmoudml6T3B0aW9uc1tpdGVtVG9DaGFuZ2VdO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBlZGl0T2JqLnZpek9wdGlvbnNbaXRlbVRvQ2hhbmdlXSA9IHNlbGVjdGVkRWRpdE9wdGlvbnM7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGl0ZW1Ub0NoYW5nZSA9PT0gJ3N2ZycpIHtcclxuICAgICAgICBkZWxldGUgZWRpdE9iai52aXpPcHRpb25zLnN2ZztcclxuICAgIH1cclxuXHJcbiAgICAvL3NhdmUgdml6T3B0aW9uc1xyXG4gICAgZWRpdE9iai5vblNhdmVDYWxsYmFjayhlZGl0T2JqLnZpek9wdGlvbnMpO1xyXG59XHJcblxyXG4vKipcclxuKiBAbmFtZSBhcHBseUVkaXRNb2RlXHJcbiogQGRlc2MgYXBwbGllcyBpbmRpdmlkdWFsIHZpeiBvcHRpb24gb24gdGhlIHZpc3VhbFxyXG4qIEBwYXJhbSB7c3RyaW5nfSBpdGVtVG9DaGFuZ2UgLSB2aXogb3B0aW9uIHRvIHVwZGF0ZVxyXG4qIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gdml6IG9wdGlvbiBwcm9wZXJ0aWVzXHJcbiogQHJldHVybiB7dW5kZWZpbmVkfSAtIG5vIHJldHVyblxyXG4qL1xyXG5mdW5jdGlvbiBhcHBseUVkaXRNb2RlKGl0ZW1Ub0NoYW5nZSwgb3B0aW9ucykge1xyXG4gICAgdmFyIGVkaXRPYmogPSB0aGlzLFxyXG4gICAgICAgIG9iamVjdCA9IGVkaXRPYmouY2hhcnREaXYuc2VsZWN0KCcuJyArIGl0ZW1Ub0NoYW5nZSksXHJcbiAgICAgICAgb2JqZWN0R3JvdXBzID0gb2JqZWN0Ll9ncm91cHMsXHJcbiAgICAgICAgb2JqZWN0VGFnTmFtZSA9IG9iamVjdEdyb3Vwc1swXVswXSA/IG9iamVjdEdyb3Vwc1swXVswXS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgOiBudWxsO1xyXG5cclxuICAgIGlmIChpdGVtVG9DaGFuZ2UgPT09ICd0ZXh0Jykge1xyXG4gICAgICAgIC8vZG8gc29tZXRoaW5nIGlmIGl0IGlzIGFsbCB0aGUgdGV4dCB0aGF0IGlzIGJlaW5nIGNoYW5nZWRcclxuICAgICAgICBvYmplY3QgPSBlZGl0T2JqLmNoYXJ0RGl2LnNlbGVjdEFsbCgndGV4dCcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vb3B0aW9ucyBieSB0YWdOYW1lXHJcbiAgICBpZiAob2JqZWN0VGFnTmFtZSA9PT0gJ2cnKSB7XHJcbiAgICAgICAgb2JqZWN0ID0gZWRpdE9iai5jaGFydERpdi5zZWxlY3QoJy4nICsgaXRlbVRvQ2hhbmdlKS5zZWxlY3RBbGwoJ3RleHQnKTtcclxuICAgIH0gZWxzZSBpZiAob2JqZWN0VGFnTmFtZSA9PT0gJ3JlY3QnKSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnNbJ2VkaXRhYmxlLWJhciddKSB7XHJcbiAgICAgICAgICAgIG9iamVjdC5hdHRyKCdmaWxsJywgb3B0aW9uc1snZWRpdGFibGUtYmFyJ10pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3B0aW9uc1snZWRpdGFibGUtYm94J10pIHtcclxuICAgICAgICAgICAgb2JqZWN0LmF0dHIoJ2ZpbGwnLCBvcHRpb25zWydlZGl0YWJsZS1ib3gnXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChvYmplY3RUYWdOYW1lID09PSAnY2lyY2xlJykge1xyXG4gICAgICAgIGlmIChvcHRpb25zWydlZGl0YWJsZS1zY2F0dGVyJ10pIHtcclxuICAgICAgICAgICAgb2JqZWN0LmF0dHIoJ2ZpbGwnLCBvcHRpb25zWydlZGl0YWJsZS1zY2F0dGVyJ10pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3B0aW9uc1snZWRpdGFibGUtYnViYmxlJ10pIHtcclxuICAgICAgICAgICAgb2JqZWN0LmF0dHIoJ2ZpbGwnLCBvcHRpb25zWydlZGl0YWJsZS1idWJibGUnXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChvYmplY3RUYWdOYW1lID09PSAncGF0aCcpIHtcclxuICAgICAgICBpZiAob3B0aW9uc1snZWRpdGFibGUtcGllJ10pIHtcclxuICAgICAgICAgICAgb2JqZWN0LmF0dHIoJ2ZpbGwnLCBvcHRpb25zWydlZGl0YWJsZS1waWUnXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vc3RhbmRhcmQgb3B0aW9uc1xyXG4gICAgLy9JZiBhIHRleHQgaW5jcmVtZW50IGV4aXN0cywgYXBwbHkgaXQgYmFzZWQgb24gdGhlIHNpZ24gb2YgdGhlIHZhcmlhYmxlXHJcbiAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnZWRpdGFibGUtdGV4dC1pbmNyZW1lbnQnKSkge1xyXG4gICAgICAgIGVkaXRPYmouY2hhbmdlRm9udFNpemUob3B0aW9uc1snZWRpdGFibGUtdGV4dC1pbmNyZW1lbnQnXSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2VkaXRhYmxlLXRleHQtc2l6ZScpKSB7XHJcbiAgICAgICAgb2JqZWN0LnN0eWxlKCdmb250LXNpemUnLCBvcHRpb25zWydlZGl0YWJsZS10ZXh0LXNpemUnXSArICdweCcpO1xyXG4gICAgfVxyXG4gICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2VkaXRhYmxlLXRleHQtY29sb3InKSkge1xyXG4gICAgICAgIG9iamVjdC5zdHlsZSgnZmlsbCcsIG9wdGlvbnNbJ2VkaXRhYmxlLXRleHQtY29sb3InXSk7XHJcbiAgICAgICAgb2JqZWN0LnN0eWxlKCdjb2xvcicsIG9wdGlvbnNbJ2VkaXRhYmxlLXRleHQtY29sb3InXSk7XHJcbiAgICB9XHJcbiAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnZWRpdGFibGUtbnVtLWZvcm1hdCcpKSB7XHJcbiAgICAgICAgbGV0IGV4cHJlc3Npb24gPSBnZXRGb3JtYXRFeHByZXNzaW9uKG9wdGlvbnNbJ2VkaXRhYmxlLW51bS1mb3JtYXQnXSk7XHJcbiAgICAgICAgb2JqZWN0XHJcbiAgICAgICAgICAgIC50cmFuc2l0aW9uKClcclxuICAgICAgICAgICAgLnRleHQoKGQpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghaXNOYU4oZCkgJiYgdHlwZW9mIGV4cHJlc3Npb24gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGV4cHJlc3Npb24oZCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGQ7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2VkaXRhYmxlLWNvbnRlbnQnKSkge1xyXG4gICAgICAgIGlmIChvcHRpb25zWydlZGl0YWJsZS1jb250ZW50J10ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBvYmplY3QuaHRtbChvcHRpb25zWydlZGl0YWJsZS1jb250ZW50J10pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVkaXRPYmoucmVtb3ZlRWRpdCgpO1xyXG59XHJcblxyXG4vKipcclxuKiBAbmFtZSBhcHBseUFsbEVkaXRzXHJcbiogQGRlc2MgYXBwbGllcyBhbGwgdml6IG9wdGlvbnMgaW4gdGhlIGVkaXQgbW9kZSBvYmplY3RcclxuKiBAcmV0dXJuIHt1bmRlZmluZWR9IC0gbm8gcmV0dXJuXHJcbiovXHJcbmZ1bmN0aW9uIGFwcGx5QWxsRWRpdHMoKSB7XHJcbiAgICBsZXQgZWRpdE9iaiA9IHRoaXM7XHJcbiAgICBmb3IgKGxldCBvcHRpb24gaW4gZWRpdE9iai52aXpPcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKGVkaXRPYmoudml6T3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShvcHRpb24pICYmIGVkaXRPYmouY2hhcnREaXYuc2VsZWN0KG9wdGlvbikpIHtcclxuICAgICAgICAgICAgZWRpdE9iai5hcHBseUVkaXRNb2RlKG9wdGlvbiwgZWRpdE9iai52aXpPcHRpb25zW29wdGlvbl0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiogQG5hbWUgcmVtb3ZlRWRpdFxyXG4qIEBkZXNjIHJlbW92ZXMgZWRpdCBkaXYgZnJvbSB0aGUgdmlzdWFsXHJcbiogQHJldHVybiB7dW5kZWZpbmVkfSAtIG5vIHJldHVyblxyXG4qL1xyXG5mdW5jdGlvbiByZW1vdmVFZGl0KCkge1xyXG4gICAgbGV0IGVkaXRPYmogPSB0aGlzO1xyXG4gICAgaWYgKGVkaXRPYmouZWRpdERpdikge1xyXG4gICAgICAgIGVkaXRPYmouZWRpdERpdi5odG1sKCcnKTtcclxuICAgICAgICBlZGl0T2JqLmVkaXREaXZcclxuICAgICAgICAgICAgLnN0eWxlKCdkaXNwbGF5JywgJ25vbmUnKTtcclxuICAgIH1cclxuICAgIGVkaXRPYmouZWRpdE9wdGlvbnMgPSAnJztcclxufVxyXG5cclxuLyoqXHJcbiogQG5hbWUgb3ZlcmxheURpdlBvc2l0aW9uXHJcbiogQGRlc2MgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIHRoZSBwbGFjZW1lbnQgb2YgdGhlIGRpdiBvbiB0aGUgdmlzdWFsXHJcbiogQHBhcmFtIHtudW1iZXJ9IGRpdldpZHRoIC0gd2lkdGggb2YgdGhlIGNvbW1lbnQgZW50cnkgYm94XHJcbiogQHBhcmFtIHtudW1iZXJ9IGRpdkhlaWdodCAtIGhlaWdodCBvZiB0aGUgY29tbWVudCBlbnRyeSBib3hcclxuKiBAcGFyYW0ge251bWJlcn0gbW91c2VYIC0geCBwb3NpdGlvbiBvZiB0aGUgY2xpY2sgZXZlbnRcclxuKiBAcGFyYW0ge251bWJlcn0gbW91c2VZIC0geSBwb3NpdGlvbiBvZiB0aGUgY2xpY2sgZXZlbnRcclxuKiBAcmV0dXJuIHtvYmplY3R9IC0gcG9zaXRpb24gb2YgZGl2XHJcbiovXHJcbmZ1bmN0aW9uIG92ZXJsYXlEaXZQb3NpdGlvbihkaXZXaWR0aCwgZGl2SGVpZ2h0LCBtb3VzZVgsIG1vdXNlWSkge1xyXG4gICAgbGV0IGVkaXRPYmogPSB0aGlzLFxyXG4gICAgICAgIHBvc2l0aW9uID0ge1xyXG4gICAgICAgICAgICB4OiBtb3VzZVgsXHJcbiAgICAgICAgICAgIHk6IG1vdXNlWSArIDEwXHJcbiAgICAgICAgfTtcclxuICAgIGlmIChtb3VzZVggPiBwYXJzZUludChlZGl0T2JqLmNoYXJ0RGl2LnN0eWxlKCd3aWR0aCcpLCAxMCkgLyAyKSB7XHJcbiAgICAgICAgcG9zaXRpb24ueCA9IG1vdXNlWCAtIGRpdldpZHRoO1xyXG4gICAgfVxyXG4gICAgaWYgKG1vdXNlWSAtIGRpdkhlaWdodCAtIDEwID4gMCkge1xyXG4gICAgICAgIHBvc2l0aW9uLnkgPSBtb3VzZVkgLSBkaXZIZWlnaHQgLSAxMDtcclxuICAgIH1cclxuICAgIHJldHVybiBwb3NpdGlvbjtcclxufVxyXG5cclxuLyoqXHJcbiogQG5hbWUgZ2V0Rm9ybWF0RXhwcmVzc2lvblxyXG4qIEBkZXNjIHJldHVybnMgdGhlIGQzIGZvcm1hdCBleHByZXNzaW9uIGZvciBhIGdpdmVuIG9wdGlvblxyXG4qIEBwYXJhbSB7c3RyaW5nfSBvcHRpb24gLSB0eXBlIG9mIGRhdGEgZm9ybWF0XHJcbiogQHJldHVybiB7ZnVuY3Rpb259IC0gZXhwcmVzc2lvblxyXG4qL1xyXG5mdW5jdGlvbiBnZXRGb3JtYXRFeHByZXNzaW9uKG9wdGlvbikge1xyXG4gICAgbGV0IGV4cHJlc3Npb24gPSAnJyxcclxuICAgICAgICBwO1xyXG4gICAgaWYgKG9wdGlvbiA9PT0gJ2N1cnJlbmN5Jykge1xyXG4gICAgICAgIGV4cHJlc3Npb24gPSBkMy5mb3JtYXQoJyQsJyk7XHJcbiAgICB9IGVsc2UgaWYgKG9wdGlvbiA9PT0gJ2ZpeGVkQ3VycmVuY3knKSB7XHJcbiAgICAgICAgZXhwcmVzc2lvbiA9IGQzLmZvcm1hdCgnKCQuMmYnKTtcclxuICAgIH0gZWxzZSBpZiAob3B0aW9uID09PSAncGVyY2VudCcpIHtcclxuICAgICAgICBwID0gTWF0aC5tYXgoMCwgZDMucHJlY2lzaW9uRml4ZWQoMC4wNSkgLSAyKTtcclxuICAgICAgICBleHByZXNzaW9uID0gZDMuZm9ybWF0KCcuJyArIHAgKyAnJScpO1xyXG4gICAgfSBlbHNlIGlmIChvcHRpb24gPT09ICdtaWxsaW9ucycpIHtcclxuICAgICAgICBwID0gZDMucHJlY2lzaW9uUHJlZml4KDFlNSwgMS4zZTYpO1xyXG4gICAgICAgIGV4cHJlc3Npb24gPSBkMy5mb3JtYXRQcmVmaXgoJy4nICsgcCwgMS4zZTYpO1xyXG4gICAgfSBlbHNlIGlmIChvcHRpb24gPT09ICdjb21tYXMnKSB7XHJcbiAgICAgICAgZXhwcmVzc2lvbiA9IGQzLmZvcm1hdCgnLC4wZicpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBleHByZXNzaW9uID0gZDMuZm9ybWF0KCcnKTtcclxuICAgIH1cclxuICAgIHJldHVybiBleHByZXNzaW9uO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGp2RWRpdDtcclxuIiwiLyoqKmp2RXZlbnRzXHJcbiAqIEV2ZW50aW5nIGxheWVyIG9uIHRvcCBvZiBKViBDaGFydHMgdG8gYWxsb3cgY3VzdG9tIGNhbGxiYWNrcyB0byBiZSBhdHRhY2hlZCB0byBtb3VzZSBldmVudHNcclxuICovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBqdkNoYXJ0cyA9IHJlcXVpcmUoJy4vanZDaGFydHMuanMnKSxcclxuICAgIGp2Q29tbWVudCA9IHJlcXVpcmUoJy4vanZDb21tZW50LmpzJyksXHJcbiAgICBqdkVkaXQgPSByZXF1aXJlKCcuL2p2RWRpdC5qcycpLFxyXG4gICAganZCcnVzaCA9IHJlcXVpcmUoJy4vanZCcnVzaC5qcycpO1xyXG5cclxuanZDaGFydHMucHJvdG90eXBlLmluaXRpYWxpemVNb2RlcyA9IGluaXRpYWxpemVNb2RlcztcclxuanZDaGFydHMucHJvdG90eXBlLmNyZWF0ZURlZmF1bHRNb2RlID0gY3JlYXRlRGVmYXVsdE1vZGU7XHJcbmp2Q2hhcnRzLnByb3RvdHlwZS5jcmVhdGVDb21tZW50TW9kZSA9IGNyZWF0ZUNvbW1lbnRNb2RlO1xyXG5qdkNoYXJ0cy5wcm90b3R5cGUuY3JlYXRlRWRpdE1vZGUgPSBjcmVhdGVFZGl0TW9kZTtcclxuanZDaGFydHMucHJvdG90eXBlLmNyZWF0ZUJydXNoTW9kZSA9IGNyZWF0ZUJydXNoTW9kZTtcclxuanZDaGFydHMucHJvdG90eXBlLmNyZWF0ZVNlbGVjdE1vZGUgPSBjcmVhdGVTZWxlY3RNb2RlO1xyXG5qdkNoYXJ0cy5wcm90b3R5cGUudG9nZ2xlTW9kZXMgPSB0b2dnbGVNb2RlcztcclxuanZDaGFydHMucHJvdG90eXBlLnRvZ2dsZURlZmF1bHRNb2RlID0gdG9nZ2xlRGVmYXVsdE1vZGU7XHJcbmp2Q2hhcnRzLnByb3RvdHlwZS50b2dnbGVDb21tZW50TW9kZSA9IHRvZ2dsZUNvbW1lbnRNb2RlO1xyXG5qdkNoYXJ0cy5wcm90b3R5cGUudG9nZ2xlRWRpdE1vZGUgPSB0b2dnbGVFZGl0TW9kZTtcclxuanZDaGFydHMucHJvdG90eXBlLnRvZ2dsZUJydXNoTW9kZSA9IHRvZ2dsZUJydXNoTW9kZTtcclxuanZDaGFydHMucHJvdG90eXBlLnRvZ2dsZVNlbGVjdE1vZGUgPSB0b2dnbGVTZWxlY3RNb2RlO1xyXG5qdkNoYXJ0cy5wcm90b3R5cGUuYWRkQnJ1c2hFdmVudHMgPSBhZGRCcnVzaEV2ZW50cztcclxuXHJcbi8qKlxyXG4qIEBuYW1lIGluaXRpYWxpemVNb2Rlc1xyXG4qIEBkZXNjIGZ1bmN0aW9uIHRoYXQgaW5pdGlhbGl6ZXMgYW5kIGNyZWF0ZXMgdGhlIGNoYXJ0IHRvb2xiYXJcclxuKiBAcmV0dXJuIHt1bmRlZmluZWR9IC0gbm8gcmV0dXJuXHJcbiovXHJcbmZ1bmN0aW9uIGluaXRpYWxpemVNb2RlcygpIHtcclxuICAgIGxldCBjaGFydCA9IHRoaXMsXHJcbiAgICAgICAgY2FsbGJhY2tzID0gY2hhcnQuY29uZmlnLmNhbGxiYWNrcztcclxuXHJcbiAgICAvL2NoZWNrIGlmIGNhbGxiYWNrcyBhcmUgbmVlZGVkXHJcbiAgICBpZiAoY2FsbGJhY2tzKSB7XHJcbiAgICAgICAgZm9yIChsZXQgbW9kZSBpbiBjYWxsYmFja3MpIHtcclxuICAgICAgICAgICAgLy9sb29wIHRocm91Z2ggYWxsIHRoZSB0eXBlcyBvZiBtb2RlcyB0byBpbml0aWFsaXplIHRoZSBtb2RlIGFuZCByZWdpc3RlciB0aGUgYXBwcm9wcmlhdGUgZXZlbnRzXHJcbiAgICAgICAgICAgIGlmIChjYWxsYmFja3MuaGFzT3duUHJvcGVydHkobW9kZSkgJiYgY2FsbGJhY2tzW21vZGVdKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgY2FtZWxDYXNlTW9kZSA9IG1vZGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBtb2RlLnNsaWNlKDEpO1xyXG4gICAgICAgICAgICAgICAgY2hhcnRbbW9kZV0gPSBjaGFydFsnY3JlYXRlJyArIGNhbWVsQ2FzZU1vZGVdKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNoYXJ0LmVkaXRNb2RlKSB7XHJcbiAgICAgICAgICAgIGNoYXJ0LmVkaXRNb2RlLmFwcGx5QWxsRWRpdHMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2hhcnQudG9nZ2xlTW9kZXMoY2hhcnQubW9kZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNoYXJ0LmNyZWF0ZURlZmF1bHRNb2RlKCk7XHJcbiAgICAgICAgLy91c2VyIGhhcyBub3QgZGVmaW5lZCBhbnkgb3RoZXIgbW9kZXMsIHNvIGp1c3QgdXNlIGRlZmF1bHQgbW9kZVxyXG4gICAgICAgIGNoYXJ0LnRvZ2dsZURlZmF1bHRNb2RlKCdkZWZhdWx0LW1vZGUnKTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiogQG5hbWUgY3JlYXRlRGVmYXVsdE1vZGVcclxuKiBAZGVzYyBmdW5jdGlvbiB0aGF0IGluaXRpYWxpemVzIGFuZCBjcmVhdGVzIHRoZSBkZWZhdWx0IG1vZGVcclxuKiBAcmV0dXJuIHt1bmRlZmluZWR9IC0gbm8gcmV0dXJuXHJcbiovXHJcbmZ1bmN0aW9uIGNyZWF0ZURlZmF1bHRNb2RlKCkge1xyXG4gICAgbGV0IGNoYXJ0ID0gdGhpcztcclxuICAgIGlmIChjaGFydC5jb25maWcuY2FsbGJhY2tzICYmIGNoYXJ0LmNvbmZpZy5jYWxsYmFja3MuZGVmYXVsdE1vZGUub25CcnVzaCkge1xyXG4gICAgICAgIGNoYXJ0LmJydXNoTW9kZSA9IGNoYXJ0LmNyZWF0ZUJydXNoTW9kZShjaGFydC5jb25maWcuY2FsbGJhY2tzLmRlZmF1bHRNb2RlLm9uQnJ1c2gpO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuKiBAbmFtZSBjcmVhdGVDb21tZW50TW9kZVxyXG4qIEBkZXNjIGZ1bmN0aW9uIHRoYXQgaW5pdGlhbGl6ZXMgYW5kIGNyZWF0ZXMgdGhlIGNvbW1lbnQgbW9kZVxyXG4qIEByZXR1cm4ge2p2Q29tbWVudH0gLSBjcmVhdGVkIGNvbW1lbnQgbW9kZVxyXG4qL1xyXG5mdW5jdGlvbiBjcmVhdGVDb21tZW50TW9kZSgpIHtcclxuICAgIGxldCBjaGFydCA9IHRoaXM7XHJcbiAgICByZXR1cm4gbmV3IGp2Q29tbWVudCh7XHJcbiAgICAgICAgY2hhcnREaXY6IGNoYXJ0LmNoYXJ0RGl2LFxyXG4gICAgICAgIGNvbW1lbnRzOiBjaGFydC5jb25maWcuY29tbWVudHMgfHwge30sXHJcbiAgICAgICAgb25TYXZlQ2FsbGJhY2s6IGNoYXJ0LmNvbmZpZy5jYWxsYmFja3MuY29tbWVudE1vZGUub25TYXZlLFxyXG4gICAgICAgIGdldE1vZGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNoYXJ0Lm1vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4qIEBuYW1lIGNyZWF0ZUVkaXRNb2RlXHJcbiogQGRlc2MgZnVuY3Rpb24gdGhhdCBpbml0aWFsaXplcyBhbmQgY3JlYXRlcyB0aGUgZWRpdCBtb2RlXHJcbiogQHJldHVybiB7anZFZGl0fSAtIGNyZWF0ZWQgZWRpdCBtb2RlIG9iamVjdFxyXG4qL1xyXG5mdW5jdGlvbiBjcmVhdGVFZGl0TW9kZSgpIHtcclxuICAgIGxldCBjaGFydCA9IHRoaXM7XHJcbiAgICByZXR1cm4gbmV3IGp2RWRpdCh7XHJcbiAgICAgICAgY2hhcnREaXY6IGNoYXJ0LmNoYXJ0RGl2LFxyXG4gICAgICAgIHZpek9wdGlvbnM6IGNoYXJ0LmNvbmZpZy5lZGl0T3B0aW9ucyB8fCB7fSxcclxuICAgICAgICBvblNhdmVDYWxsYmFjazogY2hhcnQuY29uZmlnLmNhbGxiYWNrcy5lZGl0TW9kZS5vblNhdmVcclxuICAgIH0pO1xyXG59XHJcblxyXG4vKipcclxuKiBAbmFtZSBjcmVhdGVCcnVzaE1vZGVcclxuKiBAZGVzYyBmdW5jdGlvbiB0aGF0IGluaXRpYWxpemVzIGFuZCBjcmVhdGVzIHRoZSBicnVzaCBtb2RlXHJcbiogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tQYXJhbSAtIGZ1bmN0aW9uIHRoYXQgaXMgYW4gb3B0aW9uYWwgY2FsbGJhY2sgZm9yIGJydXNoIG1vZGVcclxuKiBAcmV0dXJuIHtqdkJydXNofSAtIGNyZWF0ZWQgYnJ1c2ggbW9kZSBvYmplY3RcclxuKi9cclxuZnVuY3Rpb24gY3JlYXRlQnJ1c2hNb2RlKGNhbGxiYWNrUGFyYW0pIHtcclxuICAgIGxldCBjaGFydCA9IHRoaXMsXHJcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFja1BhcmFtO1xyXG4gICAgaWYgKCFjYWxsYmFjaykge1xyXG4gICAgICAgIGlmIChjaGFydC5jb25maWcuY2FsbGJhY2tzLmJydXNoTW9kZSAmJiB0eXBlb2YgY2hhcnQuY29uZmlnLmNhbGxiYWNrcy5icnVzaE1vZGUub25CcnVzaCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICBjYWxsYmFjayA9IGNoYXJ0LmNvbmZpZy5jYWxsYmFja3MuYnJ1c2hNb2RlLm9uQnJ1c2g7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ25vIGJydXNoIGNhbGxiYWNrLCBwYXNzIGl0IGludG8gdGhlIGNhbGxiYWNrcyBvcHRpb24nKTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBqdkJydXNoKHtcclxuICAgICAgICBjaGFydERpdjogY2hhcnQuY2hhcnREaXYsXHJcbiAgICAgICAganZDaGFydDogY2hhcnQsXHJcbiAgICAgICAgb25CcnVzaENhbGxiYWNrOiBjYWxsYmFja1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4qIEBuYW1lIGNyZWF0ZVNlbGVjdE1vZGVcclxuKiBAZGVzYyBmdW5jdGlvbiB0aGF0IGluaXRpYWxpemVzIGFuZCBjcmVhdGVzIHRoZSBzZWxlY3QgbW9kZVxyXG4qIEByZXR1cm4ge2Jvb2xlYW59IC0gdHJ1ZSBzaW5jZSB0aGUgY3JlYXRpb24gb2YgYSBtb2RlIGlzIG9ubHkgY2FsbGVkIHdoZW4gY2FsbGJhY2tzIGZvciB0aGUgbW9kZSBleGlzdFxyXG4qL1xyXG5mdW5jdGlvbiBjcmVhdGVTZWxlY3RNb2RlKCkge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuXHJcbi8qKlxyXG4qIEBuYW1lIHRvZ2dsZU1vZGVzXHJcbiogQGRlc2Mgc2V0cyB0aGUgY29ycmVjdCBldmVudHMgZm9yIHRoZSBzcGVjaWZpYyBtb2RlIHBhcmFtXHJcbiogQHBhcmFtIHtzdHJpbmd9IG1vZGUgLSBzcGVjaWZpZWQgbW9kZSB0byB0b2dnbGUgdG9cclxuKiBAcmV0dXJuIHt1bmRlZmluZWR9IC0gbm8gcmV0dXJuXHJcbiovXHJcbmZ1bmN0aW9uIHRvZ2dsZU1vZGVzKG1vZGUpIHtcclxuICAgIGxldCBjaGFydCA9IHRoaXM7XHJcbiAgICBjaGFydC50b2dnbGVEZWZhdWx0TW9kZShtb2RlKTtcclxuICAgIGNoYXJ0LmNvbW1lbnRNb2RlICYmIGNoYXJ0LnRvZ2dsZUNvbW1lbnRNb2RlKG1vZGUpO1xyXG4gICAgY2hhcnQuZWRpdE1vZGUgJiYgY2hhcnQudG9nZ2xlRWRpdE1vZGUobW9kZSk7XHJcbiAgICBjaGFydC5icnVzaE1vZGUgJiYgY2hhcnQudG9nZ2xlQnJ1c2hNb2RlKG1vZGUpO1xyXG4gICAgY2hhcnQuc2VsZWN0TW9kZSAmJiBjaGFydC50b2dnbGVTZWxlY3RNb2RlKG1vZGUpO1xyXG59XHJcblxyXG4vKipcclxuKiBAbmFtZSB0b2dnbGVEZWZhdWx0TW9kZVxyXG4qIEBkZXNjIHVwZGF0ZXMgZXZlbnQgbGlzdGVuZXJzIGZvciBkZWZhdWx0IG1vZGVcclxuKiBAcGFyYW0ge3N0cmluZ30gbW9kZSAtIHNwZWNpZmllZCBtb2RlIHRvIHRvZ2dsZSB0b1xyXG4qIEByZXR1cm4ge3VuZGVmaW5lZH0gLSBubyByZXR1cm5cclxuKi9cclxuZnVuY3Rpb24gdG9nZ2xlRGVmYXVsdE1vZGUobW9kZSkge1xyXG4gICAgbGV0IGNoYXJ0ID0gdGhpcztcclxuICAgIGlmIChtb2RlID09PSAnZGVmYXVsdC1tb2RlJykge1xyXG4gICAgICAgIGxldCBkZWZhdWx0TW9kZSA9IGNoYXJ0LmNvbmZpZy5jYWxsYmFja3MgPyBjaGFydC5jb25maWcuY2FsbGJhY2tzLmRlZmF1bHRNb2RlIDogZmFsc2UsXHJcbiAgICAgICAgICAgIGVudGlyZVN2ZyA9IGNoYXJ0LmNoYXJ0RGl2LnNlbGVjdCgnc3ZnJyksXHJcbiAgICAgICAgICAgIGNhbGxiYWNrcztcclxuICAgICAgICAvL2NoYW5nZSBjdXJzb3IgYW5kIHNob3cgdG9vbHRpcHNcclxuICAgICAgICBjaGFydC5jaGFydERpdi5zdHlsZSgnY3Vyc29yJywgJ2RlZmF1bHQnKTtcclxuICAgICAgICBjaGFydC5zaG93VG9vbFRpcCA9IHRydWU7XHJcblxyXG4gICAgICAgIC8vcmV0dXJuIGlmIG5vIGNhbGxiYWNrcyBleGlzdFxyXG4gICAgICAgIGlmICghZGVmYXVsdE1vZGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYWxsYmFja3MgPSB7XHJcbiAgICAgICAgICAgIG9uRG91YmxlQ2xpY2s6IChldmVudCwgbW91c2UpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGVmYXVsdE1vZGUub25Eb3VibGVDbGljayA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRNb2RlLm9uRG91YmxlQ2xpY2soZ2V0RXZlbnRPYmooZXZlbnQsIG1vdXNlLCBjaGFydCwgJ2RvdWJsZUNsaWNrJykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBvbkNsaWNrOiAoZXZlbnQsIG1vdXNlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRlZmF1bHRNb2RlLm9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0TW9kZS5vbkNsaWNrKGdldEV2ZW50T2JqKGV2ZW50LCBtb3VzZSwgY2hhcnQsICdjbGljaycpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgb25Ib3ZlcjogKGV2ZW50LCBtb3VzZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWZhdWx0TW9kZS5vbkhvdmVyID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdE1vZGUub25Ib3ZlcihnZXRFdmVudE9iaihldmVudCwgbW91c2UsIGNoYXJ0LCAnb25Ib3ZlcicpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgb2ZmSG92ZXI6IChldmVudCwgbW91c2UsIHByZXZFdmVudERhdGEpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGVmYXVsdE1vZGUub2ZmSG92ZXIgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbmV3RXZlbnREYXRhID0gZXZlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZFdmVudERhdGEgJiYgcHJldkV2ZW50RGF0YS5ldmVudFR5cGUgPT09ICdvbkhvdmVyJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdFdmVudERhdGEgPSBwcmV2RXZlbnREYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0TW9kZS5vZmZIb3ZlcihnZXRFdmVudE9iaihuZXdFdmVudERhdGEsIG1vdXNlLCBjaGFydCwgJ29mZkhvdmVyJykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBvbktleVVwOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRlZmF1bHRNb2RlLm9uS2V5VXAgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZSA9IGQzLmV2ZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRNb2RlLm9uS2V5VXAoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudFR5cGU6ICdvbktleVVwJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBlLmtleSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleUNvZGU6IGUua2V5Q29kZVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBvbktleURvd246ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGVmYXVsdE1vZGUub25LZXlEb3duID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGUgPSBkMy5ldmVudDtcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0TW9kZS5vbktleURvd24oe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudFR5cGU6ICdvbktleURvd24nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IGUua2V5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudDogZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5Q29kZTogZS5rZXlDb2RlXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBpZiAoZGVmYXVsdE1vZGUub25CcnVzaCAmJiBjaGFydC5icnVzaE1vZGUpIHtcclxuICAgICAgICAgICAgY2FsbGJhY2tzLm1vdXNlZG93biA9IGFkZEJydXNoTW91c2Vkb3duLmJpbmQoY2hhcnQpO1xyXG4gICAgICAgICAgICBjYWxsYmFja3MubW91c2V1cCA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNoYXJ0LmNoYXJ0RGl2LnNlbGVjdCgnc3ZnJykub24oJ21vdXNlbW92ZScsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIGNoYXJ0LmNoYXJ0RGl2LnNlbGVjdCgnc3ZnJykuc3R5bGUoJ2N1cnNvcicsICdkZWZhdWx0Jyk7XHJcbiAgICAgICAgICAgICAgICBjaGFydC5icnVzaE1vZGUucmVtb3ZlQnJ1c2goKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVnaXN0ZXJDbGlja0V2ZW50cyhlbnRpcmVTdmcsIGNhbGxiYWNrcywgY2hhcnQuY29uZmlnLmN1cnJlbnRFdmVudCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vcmVtb3ZlIHRvb2x0aXBzIGFuZCBhbnkgaGlnaGxpZ2h0c1xyXG4gICAgICAgIGNoYXJ0LnNob3dUb29sVGlwID0gZmFsc2U7XHJcbiAgICAgICAgY2hhcnQucmVtb3ZlSGlnaGxpZ2h0KCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEV2ZW50T2JqKGV2ZW50LCBtb3VzZSwgY2hhcnQsIGV2ZW50VHlwZSkge1xyXG4gICAgbGV0IHJldHVybk9iaiA9IHt9O1xyXG4gICAgaWYgKGV2ZW50Lmhhc093blByb3BlcnR5KCdldmVudFR5cGUnKSkge1xyXG4gICAgICAgIHJldHVybk9iaiA9IGV2ZW50O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm5PYmogPSBjaGFydFtjaGFydC5jb25maWcudHlwZV0uZ2V0RXZlbnREYXRhLmNhbGwoY2hhcnQsIGV2ZW50LCBtb3VzZSk7XHJcbiAgICAgICAgcmV0dXJuT2JqLm1vdXNlID0gbW91c2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm5PYmouZXZlbnRUeXBlID0gZXZlbnRUeXBlO1xyXG4gICAgcmV0dXJuIHJldHVybk9iajtcclxufVxyXG5cclxuLyoqXHJcbiogQG5hbWUgdG9nZ2xlQ29tbWVudE1vZGVcclxuKiBAZGVzYyB1cGRhdGVzIGV2ZW50IGxpc3RlbmVycyBmb3IgY29tbWVudCBtb2RlXHJcbiogQHBhcmFtIHtzdHJpbmd9IG1vZGUgLSBzcGVjaWZpZWQgbW9kZSB0byB0b2dnbGUgdG9cclxuKiBAcmV0dXJuIHt1bmRlZmluZWR9IC0gbm8gcmV0dXJuXHJcbiovXHJcbmZ1bmN0aW9uIHRvZ2dsZUNvbW1lbnRNb2RlKG1vZGUpIHtcclxuICAgIGxldCBjaGFydCA9IHRoaXMsXHJcbiAgICAgICAgY29tbWVudE9iaiA9IGNoYXJ0LmNvbW1lbnRNb2RlO1xyXG4gICAgaWYgKG1vZGUgPT09ICdjb21tZW50LW1vZGUnKSB7XHJcbiAgICAgICAgbGV0IGVudGlyZVN2ZyA9IGNoYXJ0LmNoYXJ0RGl2LnNlbGVjdCgnc3ZnJyksXHJcbiAgICAgICAgICAgIGNhbGxiYWNrcyA9IHtcclxuICAgICAgICAgICAgICAgIG9uRG91YmxlQ2xpY2s6IChldmVudCwgbW91c2UpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb21tZW50T2JqLm1ha2VDb21tZW50KGV2ZW50LnRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGFydC5jb25maWcuY2FsbGJhY2tzLmNvbW1lbnRNb2RlLm9uRG91YmxlQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJldHVybk9iaiA9IGNoYXJ0W2NoYXJ0LmNvbmZpZy50eXBlXS5nZXRFdmVudERhdGEuY2FsbChjaGFydCwgZXZlbnQsIG1vdXNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuT2JqLmV2ZW50VHlwZSA9ICdkb3VibGVDbGljayc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJ0LmNvbmZpZy5jYWxsYmFja3MuY29tbWVudE1vZGUub25Eb3VibGVDbGljayhyZXR1cm5PYmopO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBvbkNsaWNrOiAoZXZlbnQsIG1vdXNlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGFydC5jb25maWcuY2FsbGJhY2tzLmNvbW1lbnRNb2RlLm9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJldHVybk9iaiA9IGNoYXJ0W2NoYXJ0LmNvbmZpZy50eXBlXS5nZXRFdmVudERhdGEuY2FsbChjaGFydCwgZXZlbnQsIG1vdXNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuT2JqLmV2ZW50VHlwZSA9ICdjbGljayc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJ0LmNvbmZpZy5jYWxsYmFja3MuY29tbWVudE1vZGUub25DbGljayhyZXR1cm5PYmopO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICByZWdpc3RlckNsaWNrRXZlbnRzKGVudGlyZVN2ZywgY2FsbGJhY2tzLCBjaGFydC5jb25maWcuY3VycmVudEV2ZW50KTtcclxuICAgICAgICAvL3NldCBjdXJzb3IgZm9yIGNvbW1lbnQgbW9kZVxyXG4gICAgICAgIGNoYXJ0LmNoYXJ0RGl2LnN0eWxlKCdjdXJzb3InLCAncG9pbnRlcicpO1xyXG4gICAgICAgIC8vYWRkIG1vdmVtZW50bGlzdGVuZXJzXHJcbiAgICAgICAgY2hhcnQuY2hhcnREaXYuc2VsZWN0QWxsKCcubWluLWNvbW1lbnQnKVxyXG4gICAgICAgICAgICAub24oJ21vdXNlZG93bicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIC8vbG9naWMgdG8gbW92ZSBjb21tZW50c1xyXG4gICAgICAgICAgICAgICAgY29tbWVudE9iai5jcmVhdGVNb3ZlTGlzdGVuZXIoZDMuc2VsZWN0KHRoaXMpKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLm9uKCdtb3VzZXVwJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbW1lbnRPYmoubW92ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb21tZW50T2JqLnVwZGF0ZVBvc2l0aW9uKGNvbW1lbnRPYmopO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29tbWVudE9iai5tb3ZlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgY2hhcnQuY2hhcnREaXYub24oJ21vdXNlbW92ZScsIGZhbHNlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbW1lbnRPYmoucmVtb3ZlQ29tbWVudCgpO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuKiBAbmFtZSB0b2dnbGVFZGl0TW9kZVxyXG4qIEBkZXNjIHVwZGF0ZXMgZXZlbnQgbGlzdGVuZXJzIGZvciBlZGl0IG1vZGVcclxuKiBAcGFyYW0ge3N0cmluZ30gbW9kZSAtIHNwZWNpZmllZCBtb2RlIHRvIHRvZ2dsZSB0b1xyXG4qIEByZXR1cm4ge3VuZGVmaW5lZH0gLSBubyByZXR1cm5cclxuKi9cclxuZnVuY3Rpb24gdG9nZ2xlRWRpdE1vZGUobW9kZSkge1xyXG4gICAgbGV0IGNoYXJ0ID0gdGhpcyxcclxuICAgICAgICBlZGl0T2JqID0gY2hhcnQuZWRpdE1vZGUsXHJcbiAgICAgICAgZW50aXJlU3ZnID0gZWRpdE9iai5jaGFydERpdi5zZWxlY3QoJ3N2ZycpO1xyXG4gICAgaWYgKG1vZGUgPT09ICdlZGl0LW1vZGUnKSB7XHJcbiAgICAgICAgZWRpdE9iai5jaGFydERpdi5zdHlsZSgnY3Vyc29yJywgJ2RlZmF1bHQnKTtcclxuICAgICAgICBlbnRpcmVTdmcuc2VsZWN0QWxsKCcuZXZlbnQtcmVjdCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdkaXNwbGF5JywgJ25vbmUnKTtcclxuXHJcbiAgICAgICAgbGV0IGNhbGxiYWNrcyA9IHtcclxuICAgICAgICAgICAgb25Eb3VibGVDbGljazogKGV2ZW50LCBtb3VzZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGFydC5jb25maWcuY2FsbGJhY2tzLmVkaXRNb2RlLm9uRG91YmxlQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcmV0dXJuT2JqID0gY2hhcnRbY2hhcnQuY29uZmlnLnR5cGVdLmdldEV2ZW50RGF0YS5jYWxsKGNoYXJ0LCBldmVudCwgbW91c2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybk9iai5ldmVudFR5cGUgPSAnZG91YmxlQ2xpY2snO1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0LmNvbmZpZy5jYWxsYmFja3MuZWRpdE1vZGUub25Eb3VibGVDbGljayhyZXR1cm5PYmopO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBvbkNsaWNrOiAoZXZlbnQsIG1vdXNlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvL2VkaXQgbW9kZSBldmVudHNcclxuICAgICAgICAgICAgICAgIC8vZ29pbmcgdG8gYmUgbW91c2VvdmVyIHRvIGhpZ2hsaWdodCBvcHRpb25zIGZvciB3aGF0ZXZlciBwaWVjZSB5b3UgaG92ZXIgb3ZlclxyXG4gICAgICAgICAgICAgICAgbGV0IGNsYXNzVGV4dCA9IGQzLnNlbGVjdChldmVudC50YXJnZXQpLmF0dHIoJ2NsYXNzJyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2xhc3NUZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNsYXNzVGV4dC5pbmRleE9mKCdlZGl0YWJsZScpID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdE9iai5kaXNwbGF5RWRpdChtb3VzZSwgY2xhc3NUZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGFydC5jb25maWcuY2FsbGJhY2tzLmVkaXRNb2RlLm9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcmV0dXJuT2JqID0gY2hhcnRbY2hhcnQuY29uZmlnLnR5cGVdLmdldEV2ZW50RGF0YS5jYWxsKGNoYXJ0LCBldmVudCwgbW91c2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybk9iai5ldmVudFR5cGUgPSAnY2xpY2snO1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0LmNvbmZpZy5jYWxsYmFja3MuZWRpdE1vZGUub25DbGljayhyZXR1cm5PYmopO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvL2NsZWFyIHN2ZyBsaXN0ZW5lcnNcclxuICAgICAgICByZWdpc3RlckNsaWNrRXZlbnRzKGVudGlyZVN2Zywge30sIGNoYXJ0LmNvbmZpZy5jdXJyZW50RXZlbnQpO1xyXG4gICAgICAgIC8vYWRkIGNoYXJ0IGRpdiBsZXZlbCBsaXN0ZW5lcnNcclxuICAgICAgICByZWdpc3RlckNsaWNrRXZlbnRzKGVkaXRPYmouY2hhcnREaXYsIGNhbGxiYWNrcywgY2hhcnQuY29uZmlnLmN1cnJlbnRFdmVudCk7XHJcblxyXG4gICAgICAgIGVkaXRPYmouY2hhcnREaXYuc2VsZWN0QWxsKCcuZWRpdGFibGUnKS5jbGFzc2VkKCdwb2ludGVyJywgdHJ1ZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vY2xlYXIgY2hhcnQgZGl2IGxldmVsIGxpc3RlbmVyc1xyXG4gICAgICAgIGVkaXRPYmoucmVtb3ZlRWRpdCgpO1xyXG4gICAgICAgIGVudGlyZVN2Zy5zZWxlY3RBbGwoJy5lZGl0YWJsZScpLmNsYXNzZWQoJ3BvaW50ZXInLCBmYWxzZSk7XHJcbiAgICAgICAgZW50aXJlU3ZnLnNlbGVjdEFsbCgnLmV2ZW50LXJlY3QnKVxyXG4gICAgICAgICAgICAuYXR0cignZGlzcGxheScsICdibG9jaycpO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuKiBAbmFtZSB0b2dnbGVCcnVzaE1vZGVcclxuKiBAZGVzYyB1cGRhdGVzIGV2ZW50IGxpc3RlbmVycyBmb3IgYnJ1c2ggbW9kZVxyXG4qIEBwYXJhbSB7c3RyaW5nfSBtb2RlIC0gc3BlY2lmaWVkIG1vZGUgdG8gdG9nZ2xlIHRvXHJcbiogQHJldHVybiB7dW5kZWZpbmVkfSAtIG5vIHJldHVyblxyXG4qL1xyXG5mdW5jdGlvbiB0b2dnbGVCcnVzaE1vZGUobW9kZSkge1xyXG4gICAgdmFyIGNoYXJ0ID0gdGhpcztcclxuICAgIGlmIChtb2RlID09PSAnYnJ1c2gtbW9kZScgJiYgY2hhcnQuY29uZmlnLmNhbGxiYWNrcy5icnVzaE1vZGUpIHtcclxuICAgICAgICBjaGFydC5hZGRCcnVzaEV2ZW50cygpO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuKiBAbmFtZSB0b2dnbGVTZWxlY3RNb2RlXHJcbiogQGRlc2MgdXBkYXRlcyBldmVudCBsaXN0ZW5lcnMgZm9yIHNlbGVjdCBtb2RlXHJcbiogQHBhcmFtIHtzdHJpbmd9IG1vZGUgLSBzcGVjaWZpZWQgbW9kZSB0byB0b2dnbGUgdG9cclxuKiBAcmV0dXJuIHt1bmRlZmluZWR9IC0gbm8gcmV0dXJuXHJcbiovXHJcbmZ1bmN0aW9uIHRvZ2dsZVNlbGVjdE1vZGUobW9kZSkge1xyXG4gICAgdmFyIGNoYXJ0ID0gdGhpcztcclxuICAgIGlmIChtb2RlID09PSAnc2VsZWN0LW1vZGUnKSB7XHJcbiAgICAgICAgbGV0IGNhbGxiYWNrcyA9IHtcclxuICAgICAgICAgICAgb25Eb3VibGVDbGljazogKGV2ZW50LCBtb3VzZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGFydC5jb25maWcuY2FsbGJhY2tzLnNlbGVjdE1vZGUub25Eb3VibGVDbGljayA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCByZXR1cm5PYmogPSBjaGFydFtjaGFydC5jb25maWcudHlwZV0uZ2V0RXZlbnREYXRhLmNhbGwoY2hhcnQsIGV2ZW50LCBtb3VzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuT2JqLmV2ZW50VHlwZSA9ICdkb3VibGVDbGljayc7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhcnQuY29uZmlnLmNhbGxiYWNrcy5zZWxlY3RNb2RlLm9uRG91YmxlQ2xpY2socmV0dXJuT2JqKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgb25DbGljazogKGV2ZW50LCBtb3VzZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGFydC5jb25maWcuY2FsbGJhY2tzLnNlbGVjdE1vZGUub25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCByZXR1cm5PYmogPSBjaGFydFtjaGFydC5jb25maWcudHlwZV0uZ2V0RXZlbnREYXRhLmNhbGwoY2hhcnQsIGV2ZW50LCBtb3VzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuT2JqLmV2ZW50VHlwZSA9ICdjbGljayc7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhcnQuY29uZmlnLmNhbGxiYWNrcy5zZWxlY3RNb2RlLm9uQ2xpY2socmV0dXJuT2JqKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmVnaXN0ZXJDbGlja0V2ZW50cyhjaGFydC5jaGFydERpdi5zZWxlY3QoJ3N2ZycpLCBjYWxsYmFja3MsIGNoYXJ0LmNvbmZpZy5jdXJyZW50RXZlbnQpO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuKiBAbmFtZSBhZGRCcnVzaEV2ZW50c1xyXG4qIEBkZXNjIHJlZ2lzdGVycyBldmVudHMgZm9yIGJydXNoIG1vZGVcclxuKiBAcmV0dXJuIHt1bmRlZmluZWR9IC0gbm8gcmV0dXJuXHJcbiovXHJcbmZ1bmN0aW9uIGFkZEJydXNoRXZlbnRzKCkge1xyXG4gICAgbGV0IGNoYXJ0ID0gdGhpcyxcclxuICAgICAgICBlbnRpcmVTdmcgPSBjaGFydC5jaGFydERpdi5zZWxlY3QoJ3N2ZycpLFxyXG4gICAgICAgIGNhbGxiYWNrcyA9IHtcclxuICAgICAgICAgICAgbW91c2Vkb3duOiBhZGRCcnVzaE1vdXNlZG93bi5iaW5kKGNoYXJ0KSxcclxuICAgICAgICAgICAgbW91c2V1cDogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY2hhcnQuY2hhcnREaXYuc2VsZWN0KCdzdmcnKS5vbignbW91c2Vtb3ZlJywgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgY2hhcnQuYnJ1c2hNb2RlLnJlbW92ZUJydXNoKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgcmVnaXN0ZXJDbGlja0V2ZW50cyhlbnRpcmVTdmcsIGNhbGxiYWNrcywgY2hhcnQuY29uZmlnLmN1cnJlbnRFdmVudCk7XHJcbn1cclxuXHJcbi8qKlxyXG4qIEBuYW1lIGFkZEJydXNoTW91c2Vkb3duXHJcbiogQGRlc2MgY3JlYXRlcyBtb3VzZWRvd24gZXZlbnQgZm9yIGJydXNoIG1vZGVcclxuKiBAcmV0dXJuIHt1bmRlZmluZWR9IC0gbm8gcmV0dXJuXHJcbiovXHJcbmZ1bmN0aW9uIGFkZEJydXNoTW91c2Vkb3duKCkge1xyXG4gICAgdmFyIGNoYXJ0ID0gdGhpcyxcclxuICAgICAgICBicnVzaFN0YXJ0ZWQgPSBmYWxzZSxcclxuICAgICAgICBicnVzaENvbnRhaW5lciA9IGNoYXJ0LmNoYXJ0RGl2LnNlbGVjdCgnLicgKyBjaGFydC5jb25maWcudHlwZSArICctY29udGFpbmVyJykubm9kZSgpLFxyXG4gICAgICAgIGVudGlyZVN2ZyA9IGNoYXJ0LmNoYXJ0RGl2LnNlbGVjdCgnc3ZnJyksXHJcbiAgICAgICAgdGltZU1vdXNlRG93biA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgZW50aXJlU3ZnLm9uKCdtb3VzZW1vdmUnLCAoKSA9PiB7XHJcbiAgICAgICAgdmFyIHRpbWVNb3VzZU1vdmUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgICAgICBpZiAodGltZU1vdXNlRG93biA+IHRpbWVNb3VzZU1vdmUgLSAxMCkge1xyXG4gICAgICAgICAgICAvL21vdXNlIG1vdmUgaGFwcGVuZCB0b28gcXVpY2tseSwgY2hyb21lIGJ1Z1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChicnVzaFN0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgY29udGFpbmVyQm94LFxyXG4gICAgICAgICAgICB4LFxyXG4gICAgICAgICAgICB5LFxyXG4gICAgICAgICAgICBtb3VzZTtcclxuICAgICAgICBpZiAoYnJ1c2hDb250YWluZXIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBjaGFydC5icnVzaE1vZGUuc3RhcnRCcnVzaChkMy5ldmVudCk7XHJcbiAgICAgICAgICAgIGJydXNoU3RhcnRlZCA9IHRydWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29udGFpbmVyQm94ID0gYnJ1c2hDb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgICAgIG1vdXNlID0gZDMubW91c2UoZW50aXJlU3ZnLm5vZGUoKSk7XHJcbiAgICAgICAgICAgIHggPSBtb3VzZVswXTtcclxuICAgICAgICAgICAgeSA9IG1vdXNlWzFdO1xyXG5cclxuICAgICAgICAgICAgaWYgKHggPCBjb250YWluZXJCb3gucmlnaHQgJiYgeSA8IGNvbnRhaW5lckJveC5ib3R0b20gJiYgeCA+IGNvbnRhaW5lckJveC5sZWZ0ICYmIHkgPiBjb250YWluZXJCb3gudG9wKSB7XHJcbiAgICAgICAgICAgICAgICBjaGFydC5icnVzaE1vZGUuc3RhcnRCcnVzaChkMy5ldmVudCk7XHJcbiAgICAgICAgICAgICAgICBicnVzaFN0YXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4qIEBuYW1lIHJlZ2lzdGVyQ2xpY2tFdmVudHNcclxuKiBAZGVzYyByZWdpc3RlciBoYW5kbGVyIGZvciBqdiBldmVudHNcclxuKiBAcGFyYW0ge2QzZWxlbWVudH0gc3ZnIC0gZDMgc2VsZWN0ZWQgZWxlbWVudCB0byBiaW5kIGV2ZW50cyBvblxyXG4qIEBwYXJhbSB7b2JqZWN0fSBjYWxsYmFja3MgLSBjYWxsYmFja3MgdG8gcnVuIGZvciBlYWNoIHR5cGUgb2YgY2xpY2sgZXZlbnRcclxuKiBAcmV0dXJuIHt1bmRlZmluZWR9IC0gbm8gcmV0dXJuXHJcbiovXHJcbmZ1bmN0aW9uIHJlZ2lzdGVyQ2xpY2tFdmVudHMoc3ZnLCBjYWxsYmFja3MgPSB7fSwgY3VycmVudEV2ZW50ID0ge30pIHtcclxuICAgIC8vdXNpbmcgZGVmYXVsdCBwYXJhbWV0ZXJzIHRvIHNob3cgYXZhaWxhYmxlIHBhcnRzIG9mIHRoZSBjYWxsYmFja3Mgb2JqZWN0XHJcbiAgICB2YXIgZG93bixcclxuICAgICAgICBjbGlja2VkU3BvdCxcclxuICAgICAgICB0b2xlcmFuY2UgPSA1LFxyXG4gICAgICAgIGNsaWNrVGltZXIgPSBudWxsLFxyXG4gICAgICAgIENMSUNLX1RJTUVSID0gMjUwLFxyXG4gICAgICAgIGNsaWNrVGltZXJTdGFydGVkID0gZmFsc2U7XHJcblxyXG4gICAgc3ZnLm9uKCdtb3VzZWRvd24nLCBmYWxzZSk7XHJcbiAgICBzdmcub24oJ21vdXNldXAnLCBmYWxzZSk7XHJcbiAgICBzdmcub24oJ21vdXNlbW92ZScsIGZhbHNlKTtcclxuICAgIHN2Zy5vbignbW91c2VvdXQnLCBmYWxzZSk7XHJcbiAgICBzdmcub24oJ2tleXVwJywgZmFsc2UpO1xyXG4gICAgc3ZnLm9uKCdmb2N1cycsIGZhbHNlKTtcclxuXHJcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrcy5vbkhvdmVyID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBjYWxsYmFja3Mub2ZmSG92ZXIgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICByZWdpc3RlckhvdmVyRXZlbnRzKHN2ZywgY2FsbGJhY2tzLCBjdXJyZW50RXZlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2tzLm9uS2V5VXAgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICBzdmcub24oJ2tleXVwJywgY2FsbGJhY2tzLm9uS2V5VXApO1xyXG4gICAgICAgIHN2Zy5vbignZm9jdXMnLCAoKSA9PiB7IH0pO1xyXG4gICAgICAgIHN2Zy5ub2RlKCkuZm9jdXMoKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrcy5vbktleURvd24gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICBzdmcub24oJ2tleWRvd24nLCBjYWxsYmFja3Mub25LZXlEb3duKTtcclxuICAgICAgICBzdmcub24oJ2ZvY3VzJywgKCkgPT4geyB9KTtcclxuICAgICAgICBzdmcubm9kZSgpLmZvY3VzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHR5cGVvZiBjYWxsYmFja3MubW91c2Vkb3duID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgc3ZnLm9uKCdtb3VzZWRvd24nLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGRvd24gPSBkMy5tb3VzZShzdmcubm9kZSgpKTtcclxuICAgICAgICAgICAgY2FsbGJhY2tzLm1vdXNlZG93bigpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHN2Zy5vbignbW91c2V1cCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrcy5tb3VzZXVwID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrcy5tb3VzZXVwKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2tzLm9uRG91YmxlQ2xpY2sgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgLy9ydW4gc2luZ2xlIGNsaWNrIGlmIGRvdWJsZSBjbGljayBkb2VzbnQgZXhpc3RcclxuICAgICAgICAgICAgb25DbGlja0V2ZW50KGQzLmV2ZW50LCBkMy5tb3VzZSh0aGlzKSwgY2FsbGJhY2tzLm9uQ2xpY2spO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChkaXN0KGRvd24sIGQzLm1vdXNlKHN2Zy5ub2RlKCkpKSA+IHRvbGVyYW5jZSkge1xyXG4gICAgICAgICAgICAgICAgLy9kcmFnIG5vdCBjbGljayBzbyByZXR1cm5cclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL25lZWQgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgc2luZ2xlIG9yIGRvdWJsZSBjbGlja1xyXG4gICAgICAgICAgICBpZiAoY2xpY2tlZFNwb3QgJiYgZGlzdChjbGlja2VkU3BvdCwgZDMubW91c2Uoc3ZnLm5vZGUoKSkpIDwgdG9sZXJhbmNlICYmIGNsaWNrVGltZXJTdGFydGVkKSB7XHJcbiAgICAgICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KGNsaWNrVGltZXIpO1xyXG4gICAgICAgICAgICAgICAgY2xpY2tUaW1lciA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBjbGlja1RpbWVyU3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzLm9uRG91YmxlQ2xpY2soZDMuZXZlbnQsIGQzLm1vdXNlKHRoaXMpLCB0aGlzKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vZDMuZXZlbnQgYW5kIGQzLm1vdXNlIGJvdGggbG9zZSB0aGVpciBzY29wZSBpbiBhIHRpbWVvdXQgYW5kIG5vIGxvbmdlciByZXR1cm4gdGhlIGV4cGVjdGVkIHZhbHVlLCBzbyBiaW5kaW5nIGlzIG5lY2Vzc2FyeVxyXG4gICAgICAgICAgICAgICAgY2xpY2tUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KG9uQ2xpY2tFdmVudC5iaW5kKHRoaXMsIGQzLmV2ZW50LCBkMy5tb3VzZSh0aGlzKSwgY2FsbGJhY2tzLm9uQ2xpY2spLCBDTElDS19USU1FUik7XHJcbiAgICAgICAgICAgICAgICBjbGlja1RpbWVyU3RhcnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBjbGlja2VkU3BvdCA9IGQzLm1vdXNlKHN2Zy5ub2RlKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgZnVuY3Rpb24gb25DbGlja0V2ZW50KGUsIG1vdXNlLCBvbkNsaWNrKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBvbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIG9uQ2xpY2soZSwgbW91c2UsIHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gcmVnaXN0ZXJIb3ZlckV2ZW50cyhzdmcsIGNhbGxiYWNrcywgY3VycmVudEV2ZW50LCBfdmFycykge1xyXG4gICAgbGV0IGhvdmVyRGF0YSA9IHt9LFxyXG4gICAgICAgIGhvdmVyVGltZXIgPSBudWxsLFxyXG4gICAgICAgIGhvdmVyVGltZXJTdGFydGVkID0gZmFsc2UsXHJcbiAgICAgICAgSE9WRVJfVElNRVIgPSAyMDAwLFxyXG4gICAgICAgIHByZXZFdmVudCA9IGN1cnJlbnRFdmVudCxcclxuICAgICAgICBmYWtlSG92ZXJUaW1lciA9IGZhbHNlO1xyXG5cclxuICAgIHN2Zy5vbignbW91c2VvdXQnLCAoKSA9PiB7XHJcbiAgICAgICAgaWYgKHByZXZFdmVudC50eXBlID09PSAnb25Ib3ZlcicpIHtcclxuICAgICAgICAgICAgb2ZmSG92ZXJFdmVudChjYWxsYmFja3Mub2ZmSG92ZXIsIHByZXZFdmVudC5kYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaG92ZXJUaW1lciA9IHdpbmRvdy5jbGVhclRpbWVvdXQoaG92ZXJUaW1lcik7XHJcbiAgICAgICAgaG92ZXJUaW1lclN0YXJ0ZWQgPSBmYWxzZTtcclxuICAgIH0pO1xyXG5cclxuICAgIHN2Zy5vbignbW91c2Vtb3ZlJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChob3ZlclRpbWVyU3RhcnRlZCB8fCBmYWtlSG92ZXJUaW1lcikge1xyXG4gICAgICAgICAgICAvL2RldGVybWluZSB0byBjbGVhciB0aW1lclxyXG4gICAgICAgICAgICBpZiAoIXNhbWVOb2RlKGhvdmVyRGF0YS5lbGUsIGQzLmV2ZW50LnRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgIC8vY3JlYXRlIG5ldyB0aW1lciBhbmQgYXNzaWduIHRvIGhvdmVyIHRhcmdldCBlbGVcclxuICAgICAgICAgICAgICAgIGhvdmVyVGltZXIgPSB3aW5kb3cuY2xlYXJUaW1lb3V0KGhvdmVyVGltZXIpO1xyXG4gICAgICAgICAgICAgICAgaG92ZXJUaW1lclN0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGZha2VIb3ZlclRpbWVyID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaG92ZXJEYXRhLmVsZSA9IGQzLmV2ZW50LnRhcmdldDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvL2FkZCB0aW1lclxyXG4gICAgICAgICAgICAvL3NhbWUgZWxlbWVudCwgd2Ugd2FudCB0byBmaXJlIHRoZSBob3ZlciBpZiBtb3JlIHRoYW4geCBzZWNvbmRzXHJcbiAgICAgICAgICAgIGlmIChwcmV2RXZlbnQudHlwZSA9PT0gJ29uSG92ZXInKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaG92ZXJEYXRhLmVsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9mZkhvdmVyRXZlbnQoY2FsbGJhY2tzLm9mZkhvdmVyLCBwcmV2RXZlbnQuZGF0YSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGZha2VIb3ZlclRpbWVyID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBob3ZlckRhdGEuZWxlID0gZDMuZXZlbnQudGFyZ2V0O1xyXG5cclxuICAgICAgICAgICAgLy9jbGVhciBiZWZvcmUgc2V0dGluZ1xyXG4gICAgICAgICAgICBob3ZlclRpbWVyID0gd2luZG93LmNsZWFyVGltZW91dChob3ZlclRpbWVyKTtcclxuICAgICAgICAgICAgaG92ZXJEYXRhLmVsZSA9IGQzLmV2ZW50LnRhcmdldDtcclxuICAgICAgICAgICAgaG92ZXJUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KG9uSG92ZXJFdmVudC5iaW5kKHRoaXMsIGNhbGxiYWNrcy5vbkhvdmVyLCBkMy5ldmVudCwgZDMubW91c2UodGhpcykpLCBIT1ZFUl9USU1FUik7XHJcbiAgICAgICAgICAgIGhvdmVyVGltZXJTdGFydGVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBmdW5jdGlvbiBvZmZIb3ZlckV2ZW50KG9mZkhvdmVyLCBwcmV2RXZlbnREYXRhKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBvZmZIb3ZlciA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICBwcmV2RXZlbnQudHlwZSA9ICdvZmZIb3Zlcic7XHJcbiAgICAgICAgICAgIC8vcmVseSBvbiByZWZyZXNoIHRvIHJlYnVpbGQgZXZlbnRcclxuICAgICAgICAgICAgaWYgKHRydWUgfHwgX3ZhcnMuZXZlbnRSZWZyZXNoKSB7XHJcbiAgICAgICAgICAgICAgICBzdmcub24oJ21vdXNlbW92ZScsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIHN2Zy5vbignbW91c2VvdXQnLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIG9mZkhvdmVyKGhvdmVyRGF0YS5ldmVudCwgaG92ZXJEYXRhLm1vdXNlLCBwcmV2RXZlbnREYXRhKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gb25Ib3ZlckV2ZW50KG9uSG92ZXIsIGUsIG0pIHtcclxuICAgICAgICBpZiAodHlwZW9mIG9uSG92ZXIgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgaG92ZXJEYXRhID0ge1xyXG4gICAgICAgICAgICAgICAgbW91c2U6IG0sXHJcbiAgICAgICAgICAgICAgICBldmVudDogZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvL3JlbHkgb24gcmVmcmVzaCB0byByZWJ1aWxkIGV2ZW50XHJcbiAgICAgICAgICAgIGlmICh0cnVlIHx8IF92YXJzLmV2ZW50UmVmcmVzaCkge1xyXG4gICAgICAgICAgICAgICAgc3ZnLm9uKCdtb3VzZW1vdmUnLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICBzdmcub24oJ21vdXNlb3V0JywgZmFsc2UpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBvbkhvdmVyKGhvdmVyRGF0YS5ldmVudCwgaG92ZXJEYXRhLm1vdXNlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc2FtZU5vZGUobm9kZTEsIG5vZGUyKSB7XHJcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xyXG4gICAgICAgIGlmIChub2RlMSAmJiBub2RlMikge1xyXG4gICAgICAgICAgICAvL2JvdGggZXhpc3QsIGNoZWNrIGZvciBlcXVhbGl0eVxyXG4gICAgICAgICAgICBpZiAobm9kZTEuY2xhc3NMaXN0LnZhbHVlID09PSBub2RlMi5jbGFzc0xpc3QudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKG5vZGUxIHx8IG5vZGUyKSB7XHJcbiAgICAgICAgICAgIC8vb25lIGVtcHR5IGFuZCBvbmUgbm90XHJcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdHJ1ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvL2JvdGggbnVsbFxyXG4gICAgICAgICAgICByZXNwb25zZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXNwb25zZTtcclxuICAgIH1cclxufVxyXG5cclxuXHJcbi8qKlxyXG4qIEBuYW1lIGRpc3RcclxuKiBAZGVzYyBldWNsaWRlYW4gZGlzdGFuY2UgdG8gZGV0ZXJtaW5lIGlmIHRoZSBtb3VzZSBtb3ZlZCBpbiBiZXR3ZWVuIGNsaWNrcyBmb3IgZG91YmxlIGNsaWNrXHJcbiogQHBhcmFtIHthcnJheX0gYSAtIHBvaW50IGFcclxuKiBAcGFyYW0ge2FycmF5fSBiIC0gcG9pbnQgYlxyXG4qIEByZXR1cm4ge251bWJlcn0gLSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcclxuKi9cclxuZnVuY3Rpb24gZGlzdChhLCBiKSB7XHJcbiAgICBpZiAoYSAmJiBiICYmIEFycmF5LmlzQXJyYXkoYSkgJiYgQXJyYXkuaXNBcnJheShiKSkge1xyXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coYVswXSAtIGJbMF0sIDIpLCBNYXRoLnBvdyhhWzFdIC0gYlsxXSwgMikpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIDA7XHJcbn1cclxuIiwiLyoqKiAganZFZGl0ICoqKi9cclxuZnVuY3Rpb24ganZTZWxlY3QoY29uZmlnT2JqKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICB2YXIgc2VsZWN0T2JqID0gdGhpcztcclxuICAgIHNlbGVjdE9iai5jaGFydERpdiA9IGNvbmZpZ09iai5jaGFydERpdjtcclxuICAgIHNlbGVjdE9iai5qdkNoYXJ0ID0gY29uZmlnT2JqLmp2Q2hhcnQ7XHJcbiAgICBzZWxlY3RPYmouc2luZ2xlQ2xpY2tDYWxsYmFjayA9IGNvbmZpZ09iai5zaW5nbGVDbGlja0NhbGxiYWNrO1xyXG4gICAgc2VsZWN0T2JqLmRvdWJsZUNsaWNrQ2FsbGJhY2sgPSBjb25maWdPYmouZG91YmxlQ2xpY2tDYWxsYmFjaztcclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNpbmdsZUNsaWNrKHNlbGVjdE9iaiwgZXZlbnQpIHtcclxuICAgIGlmICh0eXBlb2Ygc2VsZWN0T2JqLnNpbmdsZUNsaWNrQ2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICBzZWxlY3RPYmouc2luZ2xlQ2xpY2tDYWxsYmFjayhldmVudCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZGJsY2xpY2soc2VsZWN0T2JqLCBldmVudCkge1xyXG4gICAgaWYgKHR5cGVvZiBzZWxlY3RPYmouZG91YmxlQ2xpY2tDYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIHNlbGVjdE9iai5kb3VibGVDbGlja0NhbGxiYWNrKGV2ZW50KTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBTZWxlY3QgTW9kZSBGdW5jdGlvbnMgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBqdlNlbGVjdDtcclxuIiwiLyoqKiAganZUaXAgKioqL1xyXG5cclxuZnVuY3Rpb24ganZUaXAoY29uZmlnT2JqKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICBsZXQgdGlwID0gdGhpcyxcclxuICAgICAgICBkZWZhdWx0Q29uZmlnID0ge1xyXG4gICAgICAgICAgICB0eXBlOiAnc2ltcGxlJ1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgdGlwLnRpcENvbmZpZyA9IGNvbmZpZ09iai50aXBDb25maWcgfHwgZGVmYXVsdENvbmZpZztcclxuICAgIHRpcC5jaGFydERpdiA9IGNvbmZpZ09iai5jaGFydERpdjtcclxuXHJcbiAgICAvL0NyZWF0ZSBpbml0aWFsIGRpdlxyXG4gICAgdGlwLmNoYXJ0RGl2LnNlbGVjdCgnLmp2LXRvb2x0aXAnKS5yZW1vdmUoKTtcclxuXHJcbiAgICB0aXAuY2hhcnREaXYuYXBwZW5kKCdkaXYnKVxyXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICd0b29sdGlwIGp2LXRvb2x0aXAnKVxyXG4gICAgICAgIC5zdHlsZSgncG9pbnRlci1ldmVudHMnLCAnbm9uZScpO1xyXG59XHJcblxyXG5qdlRpcC5wcm90b3R5cGUuc2hvd1RpcCA9IHNob3dUaXA7XHJcbmp2VGlwLnByb3RvdHlwZS5oaWRlVGlwID0gaGlkZVRpcDtcclxuanZUaXAucHJvdG90eXBlLmdlbmVyYXRlU2ltcGxlVGlwID0gZ2VuZXJhdGVTaW1wbGVUaXA7XHJcblxyXG5mdW5jdGlvbiBzaG93VGlwKHRyYW5zaXRpb25EdXJhdGlvbiA9IDUwKSB7XHJcbiAgICBsZXQgdGlwID0gdGhpcyxcclxuICAgICAgICBsZWZ0ID0gJ2F1dG8nLFxyXG4gICAgICAgIHRvcCA9ICdhdXRvJyxcclxuICAgICAgICBtb3VzZSA9IGQzLm1vdXNlKHRpcC5jaGFydERpdi5zZWxlY3QoJ3N2ZycpLm5vZGUoKSksXHJcbiAgICAgICAgLy9Mb2dpYyB0byBkZXRlcm1pbmUgd2hlcmUgdG9vbHRpcCB3aWxsIGJlIHBsYWNlZCBvbiBwYWdlXHJcbiAgICAgICAgbGVmdE9mTW91c2UgPSBtb3VzZVswXSA+ICh0aXAuY2hhcnREaXYuX2dyb3Vwc1swXVswXS5jbGllbnRXaWR0aCAvIDIpLFxyXG4gICAgICAgIHRvcE9mTW91c2UgPSBtb3VzZVsxXSA8ICh0aXAuY2hhcnREaXYuX2dyb3Vwc1swXVswXS5jbGllbnRIZWlnaHQgLyAyKSxcclxuICAgICAgICB0b29sdGlwSGVpZ2h0ID0gdGlwLnRvb2xUaXAuX2dyb3Vwc1swXVswXS5jbGllbnRIZWlnaHQgPT09IDAgPyA3NSA6IHRpcC50b29sVGlwLl9ncm91cHNbMF1bMF0uY2xpZW50SGVpZ2h0LFxyXG4gICAgICAgIHRvb2x0aXBXaWR0aCA9IHRpcC50b29sVGlwLl9ncm91cHNbMF1bMF0uY2xpZW50V2lkdGgsXHJcbiAgICAgICAgdDtcclxuXHJcbiAgICBpZiAobGVmdE9mTW91c2UpIHtcclxuICAgICAgICBpZiAodG9vbHRpcFdpZHRoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRvb2x0aXBXaWR0aCA9IDI1MDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGVmdCA9IG1vdXNlWzBdIC0gdG9vbHRpcFdpZHRoO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBsZWZ0ID0gbW91c2VbMF07XHJcbiAgICB9XHJcbiAgICBpZiAodG9wT2ZNb3VzZSkge1xyXG4gICAgICAgIHRvcCA9IG1vdXNlWzFdO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAodG9vbHRpcEhlaWdodCA9PT0gMCkge1xyXG4gICAgICAgICAgICB0b29sdGlwSGVpZ2h0ID0gNzU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRvcCA9IG1vdXNlWzFdIC0gdG9vbHRpcEhlaWdodDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWxlZnRPZk1vdXNlICYmIHRvcE9mTW91c2UpIHtcclxuICAgICAgICBsZWZ0ID0gbW91c2VbMF0gKyAxMztcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy9DT09MIENVUlNPUiwgYSBmdW5jdGlvbiBvZiB0aGUgaGVpZ2h0IGFuZCB3aWR0aCBvZiB0aGUgY29udGFpbmVyXHJcbiAgICAvL3ZhciBjb250YWluZXIgPSB0aXAuY2hhcnREaXYuc2VsZWN0KCcuYmFyLWNvbnRhaW5lcicpLm5vZGUoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgIC8vc3ZnTW91c2UgPSBkMy5tb3VzZSh0aXAuY2hhcnREaXYuc2VsZWN0KCcuYmFyLWNvbnRhaW5lcicpLm5vZGUoKSk7XHJcblxyXG4gICAgLy92YXIgdG9vbHRpcEhlaWdodCA9IHRpcC50b29sVGlwLl9ncm91cHNbMF1bMF0uY2xpZW50SGVpZ2h0ID09PSAwID8gNzUgOiB0aXAudG9vbFRpcC5fZ3JvdXBzWzBdWzBdLmNsaWVudEhlaWdodDtcclxuICAgIC8vdG9wID0gbW91c2VbMV0gLSAodG9vbHRpcEhlaWdodCAqIHN2Z01vdXNlWzFdIC8gY29udGFpbmVyLmhlaWdodCk7XHJcblxyXG4gICAgLy92YXIgdG9vbHRpcFdpZHRoID0gdGlwLnRvb2xUaXAuX2dyb3Vwc1swXVswXS5jbGllbnRXaWR0aDtcclxuICAgIC8vbGVmdCA9IG1vdXNlWzBdIC0gKHRvb2x0aXBXaWR0aCAqIHN2Z01vdXNlWzBdIC8gY29udGFpbmVyLndpZHRoKTtcclxuXHJcbiAgICAvL1NUSUNLWSBDVVJTT1IgSU4gVEhFIEJPVFRPTSBSSUdIVFxyXG4gICAgLy90b3AgPSBtb3VzZVsxXTtcclxuICAgIC8vbGVmdCA9IG1vdXNlWzBdO1xyXG4gICAgLy9zZXQgbWF4IGxlZnRcclxuICAgIC8vaWYobGVmdCA+IGNvbnRhaW5lci53aWR0aCAtIHRvb2x0aXBXaWR0aCArIGNvbnRhaW5lci5sZWZ0KSB7XHJcbiAgICAvL2xlZnQgPSBjb250YWluZXIud2lkdGggLSB0b29sdGlwV2lkdGggKyBjb250YWluZXIubGVmdDtcclxuICAgIC8vfVxyXG5cclxuICAgIC8vLy9zZXQgbWF4IHRvcFxyXG4gICAgLy9pZiAodG9wID4gY29udGFpbmVyLmhlaWdodCAtIHRvb2x0aXBIZWlnaHQgKyBjb250YWluZXIudG9wKSB7XHJcbiAgICAvL3RvcCA9IGNvbnRhaW5lci5oZWlnaHQgLSB0b29sdGlwSGVpZ2h0ICsgY29udGFpbmVyLnRvcDtcclxuICAgIC8vfVxyXG5cclxuICAgIHQgPSBkMy50cmFuc2l0aW9uKClcclxuICAgICAgICAuZHVyYXRpb24odHJhbnNpdGlvbkR1cmF0aW9uKVxyXG4gICAgICAgIC5lYXNlKGQzLmVhc2VMaW5lYXIpO1xyXG5cclxuICAgIHRpcC50b29sVGlwXHJcbiAgICAgICAgLnRyYW5zaXRpb24odClcclxuICAgICAgICAuc3R5bGUoJ2xlZnQnLCBsZWZ0ICsgJ3B4JylcclxuICAgICAgICAuc3R5bGUoJ3RvcCcsIHRvcCArICdweCcpXHJcbiAgICAgICAgLnN0eWxlKCdkaXNwbGF5JywgJ2Jsb2NrJylcclxuICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAxKTtcclxufVxyXG5cclxuZnVuY3Rpb24gaGlkZVRpcCgpIHtcclxuICAgIGxldCB0aXAgPSB0aGlzLFxyXG4gICAgICAgIHQgPSBkMy50cmFuc2l0aW9uKClcclxuICAgICAgICAgICAgLmR1cmF0aW9uKCcxMDAnKVxyXG4gICAgICAgICAgICAuZWFzZShkMy5lYXNlTGluZWFyKTtcclxuICAgIGlmICh0aXAudG9vbFRpcCkge1xyXG4gICAgICAgIC8vIHRpcC50b29sVGlwLnRyYW5zaXRpb24odCkuc3R5bGUoJ2Rpc3BsYXknLCAnbm9uZScpO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICBEZWNsYXJlIGp2IHRpcCBjb21wb25lbnRzICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcbnZhciBqdkhyID0gJzxociBzdHlsZT1cXCdtYXJnaW46M3B4IDAgM3B4IDA7XFwnLz4nO1xyXG5cclxuZnVuY3Rpb24gZ2V0VmFsdWVDb250ZW50KGl0ZW0sIHZhbHVlLCBjb2xvclRpbGUpIHtcclxuICAgIGxldCB2YWx1ZVN0cmluZyA9IHZhbHVlID8gYDogJHt2YWx1ZX1gIDogJycsXHJcbiAgICAgICAgY29sb3JUaWxlU3RyaW5nID0gY29sb3JUaWxlID8gY29sb3JUaWxlIDogJyc7XHJcbiAgICByZXR1cm4gYDxzcGFuIGNsYXNzPSdqdi10aXAtY29udGVudCBqdi10aXAtc2lkZS1wYWRkaW5nJz4ke2NvbG9yVGlsZVN0cmluZ30ke2l0ZW19JHt2YWx1ZVN0cmluZ308L3NwYW4+PGJyLz5gO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRUaXRsZVRlbXBsYXRlKGRhdGFPYmopIHtcclxuICAgIHJldHVybiBgPGRpdiBjbGFzcz0ndGl0bGUganYtdG9wLW1hcmdpbiBqdi1pbmxpbmUganYtZnVsbC13aWR0aCc+PGI+JHtkYXRhT2JqLnRpdGxlfTwvYj48L2Rpdj4ke2p2SHJ9YDtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0Q29sb3JUaWxlKGNvbG9yKSB7XHJcbiAgICBpZiAoY29sb3IpIHtcclxuICAgICAgICByZXR1cm4gYDxkaXYgY2xhc3M9J2QzLXRvb2x0aXAtY2lyY2xlIGp2LWlubGluZSBqdi1mdWxsLXdpZHRoIGp2LXRpcC1zaWRlLXBhZGRpbmcnIHN0eWxlPSdiYWNrZ3JvdW5kOiR7Y29sb3J9Jz48L2Rpdj5gO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFwiPGRpdiBjbGFzcz0nanYtaW5saW5lIGp2LWZ1bGwtd2lkdGgganYtdGlwLXNpZGUtcGFkZGluZyc+XCI7XHJcbn1cclxuXHJcblxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBWaXogU3BlY2lmaWMgRnVuY3Rpb25zICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcbmZ1bmN0aW9uIGdlbmVyYXRlU2ltcGxlVGlwKGRhdGFPYmosIGRhdGFUYWJsZSkge1xyXG4gICAgbGV0IHRpcCA9IHRoaXMsXHJcbiAgICAgICAgdG9vbHRpcEh0bWwgPSAnJztcclxuXHJcbiAgICBpZiAoZGF0YU9iai5oYXNPd25Qcm9wZXJ0eSgndGl0bGUnKSAmJiBkYXRhT2JqLnRpdGxlID09PSAnJykge1xyXG4gICAgICAgIGRhdGFPYmoudGl0bGUgPSAnRW1wdHknO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChkYXRhT2JqLnZpeiA9PT0gJ2NsdXN0ZXJzJyB8fCBkYXRhT2JqLnZpeiA9PT0gJ2NpcmNsZXZpZXdwbG90JyB8fCBkYXRhT2JqLnZpeiA9PT0gJ3NjYXR0ZXJwbG90JyB8fCBkYXRhT2JqLnZpeiA9PT0gJ3RyZWVtYXAnIHx8IGRhdGFPYmoudml6ID09PSAnc2luZ2xlYXhpcycpIHtcclxuICAgICAgICB0b29sdGlwSHRtbCA9IGdlbmVyYXRlU2luZ2xlQ29sb3JIVE1MKGRhdGFPYmosIGRhdGFUYWJsZSk7XHJcbiAgICB9IGVsc2UgaWYgKGRhdGFPYmoudml6ID09PSAncmFkaWFsJyB8fCBkYXRhT2JqLnZpeiA9PT0gJ3BpZScpIHtcclxuICAgICAgICB0b29sdGlwSHRtbCA9IGdlbmVyYXRlUGllSFRNTChkYXRhT2JqLCBkYXRhVGFibGUpO1xyXG4gICAgfSBlbHNlIGlmIChkYXRhT2JqLnZpeiA9PT0gJ2NpcmNsZXBhY2snIHx8IGRhdGFPYmoudml6ID09PSAnc3VuYnVyc3QnKSB7XHJcbiAgICAgICAgdG9vbHRpcEh0bWwgPSBnZW5lcmF0ZVBhY2tIVE1MKGRhdGFPYmosIGRhdGFUYWJsZSk7XHJcbiAgICB9IGVsc2UgaWYgKGRhdGFPYmoudml6ID09PSAnaGVhdG1hcCcgfHwgZGF0YU9iai52aXogPT09ICdjbG91ZCcpIHtcclxuICAgICAgICB0b29sdGlwSHRtbCA9IGdlbmVyYXRlSGVhdG1hcEhUTUwoZGF0YU9iaiwgZGF0YVRhYmxlKTtcclxuICAgIH0gZWxzZSBpZiAoZGF0YU9iai52aXogPT09ICdzYW5rZXknKSB7XHJcbiAgICAgICAgdG9vbHRpcEh0bWwgPSBnZW5lcmF0ZVNhbmtleUhUTUwoZGF0YU9iaiwgZGF0YVRhYmxlKTtcclxuICAgIH0gZWxzZSBpZiAoZGF0YU9iai52aXogPT09ICdidWJibGUnKSB7XHJcbiAgICAgICAgdG9vbHRpcEh0bWwgPSBnZW5lcmF0ZUJ1YmJsZUhUTUwoZGF0YU9iaik7XHJcbiAgICB9IGVsc2UgaWYgKGRhdGFPYmoudml6ID09PSAnYm94d2hpc2tlcicpIHtcclxuICAgICAgICB0b29sdGlwSHRtbCA9IGdlbmVyYXRlQm94SFRNTChkYXRhT2JqKTtcclxuICAgIH0gZWxzZSBpZiAoZGF0YU9iai52aXogPT09ICdjbHVzdGVyZ3JhbScpIHtcclxuICAgICAgICB0b29sdGlwSHRtbCA9IGdlbmVyYXRlQ2x1c3RlcmdyYW1IVE1MKGRhdGFPYmopO1xyXG4gICAgfSAgZWxzZSBpZiAoZGF0YU9iai52aXogPT09ICdnYW50dCcpIHtcclxuICAgICAgICB0b29sdGlwSHRtbCA9IGdlbmVyYXRlR2FudHRIVE1MKGRhdGFPYmosIGRhdGFUYWJsZSk7XHJcbiAgICB9ZWxzZSB7XHJcbiAgICAgICAgdG9vbHRpcEh0bWwgPSBnZW5lcmF0ZVNpbXBsZUhUTUwoZGF0YU9iaiwgZGF0YVRhYmxlKTtcclxuICAgIH1cclxuXHJcbiAgICAvL2FkZCBjb250ZW50IHRvIHRvb2x0aXBcclxuICAgIHRpcC50b29sVGlwID0gdGlwLmNoYXJ0RGl2LnNlbGVjdCgnLnRvb2x0aXAnKVxyXG4gICAgICAgIC5odG1sKHRvb2x0aXBIdG1sKTtcclxuXHJcbiAgICAvL3BhaW50IHRoZSB0b29sdGlwXHJcbiAgICB0aXAuc2hvd1RpcCgwKTtcclxuXHJcbiAgICByZXR1cm4gdGlwLnRvb2x0aXA7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdlbmVyYXRlU2ltcGxlSFRNTChkYXRhT2JqKSB7XHJcbiAgICBsZXQgdG9vbHRpcFRleHQ7XHJcbiAgICB0b29sdGlwVGV4dCA9IGA8ZGl2PjxkaXYgY2xhc3M9J3RpdGxlIGp2LXRpcC1jb250YWluZXIganYtdGlwLXNpZGUtcGFkZGluZyBqdi10b3AtbWFyZ2luJz48Yj4ke2RhdGFPYmoudGl0bGV9PC9iPjwvZGl2PiR7anZIcn1gO1xyXG5cclxuICAgIGZvciAobGV0IGl0ZW0gaW4gZGF0YU9iai50aXBEYXRhKSB7XHJcbiAgICAgICAgdG9vbHRpcFRleHQgKz0gZ2V0VmFsdWVDb250ZW50KGl0ZW0sIGZvcm1hdFZhbHVlKGRhdGFPYmoudGlwRGF0YVtpdGVtXSksIGdldENvbG9yVGlsZShkYXRhT2JqLmNvbG9yW2l0ZW1dKSk7XHJcbiAgICB9XHJcbiAgICB0b29sdGlwVGV4dCArPSAnPC9kaXY+JztcclxuICAgIHJldHVybiB0b29sdGlwVGV4dDtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2VuZXJhdGVTaW5nbGVDb2xvckhUTUwoZGF0YU9iaiwgZGF0YVRhYmxlKSB7XHJcbiAgICBsZXQgdG9vbHRpcFRleHQsXHJcbiAgICAgICAgdG9vbHRpcENvbG9yLFxyXG4gICAgICAgIHNob3dDb2xvckNpcmNsZSA9IHRydWUsXHJcbiAgICAgICAgY29sb3JDaXJjbGUgPSAnJztcclxuXHJcbiAgICBpZiAoISFkYXRhT2JqLmNvbG9yW2RhdGFPYmouZGF0YVtkYXRhVGFibGUuc2VyaWVzXV0pIHtcclxuICAgICAgICB0b29sdGlwQ29sb3IgPSBkYXRhT2JqLmNvbG9yW2RhdGFPYmouZGF0YVtkYXRhVGFibGUuc2VyaWVzXV07XHJcbiAgICB9IGVsc2UgaWYgKCEhZGF0YU9iai5jb2xvcltkYXRhVGFibGUubGFiZWxdICYmIGRhdGFPYmoudml6ICE9PSAnc2luZ2xlYXhpcycpIHtcclxuICAgICAgICB0b29sdGlwQ29sb3IgPSBkYXRhT2JqLmNvbG9yW2RhdGFUYWJsZS5sYWJlbF07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHNob3dDb2xvckNpcmNsZSA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzaG93Q29sb3JDaXJjbGUpIHtcclxuICAgICAgICBjb2xvckNpcmNsZSA9IGdldENvbG9yVGlsZSh0b29sdGlwQ29sb3IpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBjb2xvckNpcmNsZSA9IGdldENvbG9yVGlsZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHRvb2x0aXBUZXh0ID0gYDxkaXYgY2xhc3M9J2p2LWlubGluZSBqdi1mdWxsLXdpZHRoJz4ke2NvbG9yQ2lyY2xlfTxkaXYgY2xhc3M9J3RpdGxlIGp2LXRpcC1zaWRlLXBhZGRpbmcganYtaW5saW5lIGp2LWZ1bGwtd2lkdGgganYtdG9wLW1hcmdpbic+PGI+JHtkYXRhT2JqLnRpdGxlfTwvYj48L2Rpdj4ke2p2SHJ9YDtcclxuXHJcbiAgICBmb3IgKGxldCBpdGVtIGluIGRhdGFPYmoudGlwRGF0YSkge1xyXG4gICAgICAgIHRvb2x0aXBUZXh0ICs9IGdldFZhbHVlQ29udGVudChpdGVtLCBmb3JtYXRWYWx1ZShkYXRhT2JqLnRpcERhdGFbaXRlbV0pKTtcclxuICAgIH1cclxuICAgIHRvb2x0aXBUZXh0ICs9ICc8L2Rpdj4nO1xyXG4gICAgcmV0dXJuIHRvb2x0aXBUZXh0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZW5lcmF0ZVBhY2tIVE1MKGRhdGFPYmopIHtcclxuICAgIGxldCB0b29sdGlwVGV4dDtcclxuICAgIHRvb2x0aXBUZXh0ID0gYDxkaXYgY2xhc3M9J2p2LWlubGluZSBqdi1mdWxsLXdpZHRoJz5cclxuICAgICAgICAke2dldENvbG9yVGlsZShkYXRhT2JqLmRhdGEuY29sb3IpfVxyXG4gICAgICAgICR7Z2V0VGl0bGVUZW1wbGF0ZShkYXRhT2JqKX1gO1xyXG5cclxuICAgIGZvciAobGV0IGl0ZW0gaW4gZGF0YU9iai50aXBEYXRhKSB7XHJcbiAgICAgICAgdG9vbHRpcFRleHQgKz0gZ2V0VmFsdWVDb250ZW50KGl0ZW0sIGZvcm1hdFZhbHVlKGRhdGFPYmoudGlwRGF0YVtpdGVtXSkpO1xyXG4gICAgfVxyXG4gICAgdG9vbHRpcFRleHQgKz0gJzwvZGl2Pic7XHJcbiAgICByZXR1cm4gdG9vbHRpcFRleHQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdlbmVyYXRlQnViYmxlSFRNTChkYXRhT2JqKSB7XHJcbiAgICBsZXQgdG9vbHRpcFRleHQ7XHJcbiAgICB0b29sdGlwVGV4dCA9IGA8ZGl2IGNsYXNzPSdqdi1pbmxpbmUganYtZnVsbC13aWR0aCc+XHJcbiAgICAgICAgJHtnZXRDb2xvclRpbGUoZGF0YU9iai5kYXRhLmNvbG9yKX1cclxuICAgICAgICAke2dldFRpdGxlVGVtcGxhdGUoZGF0YU9iail9YDtcclxuXHJcbiAgICBmb3IgKGxldCBpdGVtIGluIGRhdGFPYmoudGlwRGF0YSkge1xyXG4gICAgICAgIGlmIChpdGVtID09PSAnY29sb3InKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0b29sdGlwVGV4dCArPSBnZXRWYWx1ZUNvbnRlbnQoaXRlbSwgZm9ybWF0VmFsdWUoZGF0YU9iai50aXBEYXRhW2l0ZW1dKSk7XHJcbiAgICB9XHJcbiAgICB0b29sdGlwVGV4dCArPSAnPC9kaXY+JztcclxuICAgIHJldHVybiB0b29sdGlwVGV4dDtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2VuZXJhdGVCb3hIVE1MKGRhdGFPYmopIHtcclxuICAgIGxldCB0b29sdGlwVGV4dDtcclxuICAgIHRvb2x0aXBUZXh0ID0gJzxkaXYgY2xhc3M9XCJqdi1pbmxpbmUganYtZnVsbC13aWR0aFwiPic7XHJcblxyXG4gICAgZm9yIChsZXQgaXRlbSBpbiBkYXRhT2JqLnRpcERhdGEpIHtcclxuICAgICAgICBpZiAoZGF0YU9iai50aXBEYXRhLmhhc093blByb3BlcnR5KGl0ZW0pKSB7XHJcbiAgICAgICAgICAgIHRvb2x0aXBUZXh0ICs9IGdldFZhbHVlQ29udGVudChpdGVtLCBmb3JtYXRWYWx1ZShkYXRhT2JqLnRpcERhdGFbaXRlbV0pKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB0b29sdGlwVGV4dCArPSAnPC9kaXY+JztcclxuICAgIHJldHVybiB0b29sdGlwVGV4dDtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2VuZXJhdGVIZWF0bWFwSFRNTChkYXRhT2JqKSB7XHJcbiAgICBsZXQgdG9vbHRpcFRleHQ7XHJcbiAgICBpZiAoZGF0YU9iai54QXhpc0NhdCkge1xyXG4gICAgICAgIHRvb2x0aXBUZXh0ID0gYDxkaXYgY2xhc3M9J2p2LWlubGluZSBqdi1mdWxsLXdpZHRoJz5cclxuICAgICAgICAgICAgJHtnZXRDb2xvclRpbGUoZGF0YU9iai5jb2xvcil9YCArXHJcbiAgICAgICAgICAgIFwiPGRpdiBjbGFzcz0ndGl0bGUganYtdG9wLW1hcmdpbiBqdi1pbmxpbmUganYtZnVsbC13aWR0aCc+PGI+XCIgKyBkYXRhT2JqLmRhdGEueEF4aXNOYW1lICsgXCI8L2I+PC9kaXY+PGhyIHN0eWxlPSdtYXJnaW46M3B4IDAgM3B4IDA7Jy8+XCI7XHJcblxyXG4gICAgICAgIHRvb2x0aXBUZXh0ICs9IFwiPHNwYW4gY2xhc3M9J2p2LXRpcC1jb250ZW50IGp2LXRpcC1zaWRlLXBhZGRpbmcnPlwiICsgZGF0YU9iai54QXhpc0NhdCArICc8L3NwYW4+PGJyLz4nO1xyXG4gICAgICAgIHRvb2x0aXBUZXh0ICs9ICc8L2Rpdj4nO1xyXG4gICAgICAgIHJldHVybiB0b29sdGlwVGV4dDtcclxuICAgIH0gZWxzZSBpZiAoZGF0YU9iai55QXhpc0NhdCkge1xyXG4gICAgICAgIHRvb2x0aXBUZXh0ID0gYDxkaXYgY2xhc3M9J2p2LWlubGluZSBqdi1mdWxsLXdpZHRoJz5cclxuICAgICAgICAgICAgJHtnZXRDb2xvclRpbGUoZGF0YU9iai5jb2xvcil9YCArXHJcbiAgICAgICAgICAgIFwiPGRpdiBjbGFzcz0ndGl0bGUganYtdG9wLW1hcmdpbiBqdi1pbmxpbmUganYtZnVsbC13aWR0aCc+PGI+XCIgKyBkYXRhT2JqLmRhdGEueUF4aXNOYW1lICsgXCI8L2I+PC9kaXY+PGhyIHN0eWxlPSdtYXJnaW46M3B4IDAgM3B4IDA7Jy8+XCI7XHJcblxyXG4gICAgICAgIHRvb2x0aXBUZXh0ICs9IFwiPHNwYW4gY2xhc3M9J2p2LXRpcC1jb250ZW50IGp2LXRpcC1zaWRlLXBhZGRpbmcnPlwiICsgZGF0YU9iai55QXhpc0NhdCArICc8L3NwYW4+PGJyLz4nO1xyXG4gICAgICAgIHRvb2x0aXBUZXh0ICs9ICc8L2Rpdj4nO1xyXG4gICAgICAgIHJldHVybiB0b29sdGlwVGV4dDtcclxuICAgIH1cclxuICAgIHRvb2x0aXBUZXh0ID0gYDxkaXYgY2xhc3M9J2p2LWlubGluZSBqdi1mdWxsLXdpZHRoJz5cclxuICAgICAgICAgICAgJHtnZXRDb2xvclRpbGUoZGF0YU9iai5jb2xvcil9XHJcbiAgICAgICAgICAgICR7Z2V0VGl0bGVUZW1wbGF0ZShkYXRhT2JqKX1gO1xyXG5cclxuICAgIGZvciAobGV0IGl0ZW0gaW4gZGF0YU9iai50aXBEYXRhKSB7XHJcbiAgICAgICAgdG9vbHRpcFRleHQgKz0gZ2V0VmFsdWVDb250ZW50KGl0ZW0sIGZvcm1hdFZhbHVlKGRhdGFPYmoudGlwRGF0YVtpdGVtXSkpO1xyXG4gICAgfVxyXG4gICAgdG9vbHRpcFRleHQgKz0gJzwvZGl2Pic7XHJcbiAgICByZXR1cm4gdG9vbHRpcFRleHQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdlbmVyYXRlQ2x1c3RlcmdyYW1IVE1MKGRhdGFPYmopIHtcclxuICAgIGxldCB0b29sdGlwVGV4dDtcclxuICAgIGRhdGFPYmoudGl0bGUgPSBkYXRhT2JqLnRpdGxlLnJlcGxhY2UoL18vZywgJyAnKTtcclxuICAgIHRvb2x0aXBUZXh0ID0gYDxkaXYgY2xhc3M9J2p2LWlubGluZSBqdi1mdWxsLXdpZHRoJz5cclxuICAgICR7Z2V0Q29sb3JUaWxlKGRhdGFPYmouY29sb3IpfVxyXG4gICAgJHtnZXRUaXRsZVRlbXBsYXRlKGRhdGFPYmopfWA7XHJcblxyXG4gICAgZm9yIChsZXQgaXRlbSBpbiBkYXRhT2JqLnRpcERhdGEpIHtcclxuICAgICAgICB0b29sdGlwVGV4dCArPSBnZXRWYWx1ZUNvbnRlbnQoaXRlbSwgZm9ybWF0VmFsdWUoZGF0YU9iai50aXBEYXRhW2l0ZW1dKSk7XHJcbiAgICB9XHJcbiAgICB0b29sdGlwVGV4dCArPSAnPC9kaXY+JztcclxuXHJcbiAgICByZXR1cm4gdG9vbHRpcFRleHQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdlbmVyYXRlR2FudHRIVE1MKGRhdGFPYmosIGRhdGFUYWJsZSkge1xyXG4gICAgdmFyIHRvb2x0aXBUZXh0O1xyXG5cclxuICAgIGRhdGFPYmoudGl0bGUgPSBkYXRhT2JqLnRpdGxlLnJlcGxhY2UoL18vZyxcIiBcIik7XHJcblxyXG4gICAgdG9vbHRpcFRleHQgPSBgPGRpdiBjbGFzcz0nanYtaW5saW5lIGp2LWZ1bGwtd2lkdGgnPlxyXG4gICAgJHtnZXRUaXRsZVRlbXBsYXRlKGRhdGFPYmopfWA7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDE7IGk8PWRhdGFPYmouZGF0YS5sZW5ndGg7IGkrKykgeyAgICAgICAgXHJcbiAgICAgICAgdmFyIHN0YXJ0VmFsdWUgPSBkYXRhT2JqLnRpcERhdGFbZGF0YVRhYmxlW1wic3RhcnQgXCIgKyBpXV07XHJcbiAgICAgICAgdmFyIGVuZFZhbHVlID0gZGF0YU9iai50aXBEYXRhW2RhdGFUYWJsZVtcImVuZCBcIiArIGldXTtcclxuICAgICAgICB2YXIgZHVyYXRpb25WYWx1ZSA9IGRhdGFPYmoudGlwRGF0YVtcIkR1cmF0aW9uIFwiICsgaV07XHJcbiAgICAgICAgaWYgKGR1cmF0aW9uVmFsdWUgIT09IFwiMCBkYXlzXCIgJiYgZHVyYXRpb25WYWx1ZSAhPSBudWxsICYmIHN0YXJ0VmFsdWUgIT0gbnVsbCAmJiBlbmRWYWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGVuZFZhbHVlID0gZW5kVmFsdWUuc3Vic3RyaW5nKDAsMTApO1xyXG4gICAgICAgICAgICBzdGFydFZhbHVlID0gc3RhcnRWYWx1ZS5zdWJzdHJpbmcoMCwxMCk7XHJcbiAgICAgICAgICAgIHZhciBpdGVtID0gZGF0YVRhYmxlW1wic3RhcnQgXCIgKyBpXTtcclxuICAgICAgICAgICAgLy8gaWYgKGl0ZW0uc3Vic3RyaW5nKDAsNikgPT09IFwiU3RhcnQgXCIpIHtcclxuICAgICAgICAgICAgLy8gICAgIGl0ZW0gPSBpdGVtLnN1YnN0cmluZyg2KTtcclxuICAgICAgICAgICAgLy8gfVxyXG5cclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gc3RhcnRWYWx1ZSArIFwiIHRvIFwiICsgZW5kVmFsdWU7XHJcbiAgICAgICAgICAgIHRvb2x0aXBUZXh0ICs9IGdldFZhbHVlQ29udGVudChpdGVtLCB2YWx1ZSwgZ2V0Q29sb3JUaWxlKGRhdGFPYmouY29sb3JbZGF0YVRhYmxlW1wic3RhcnQgXCIraV1dKSk7XHJcbiAgICAgICAgICAgIHRvb2x0aXBUZXh0ICs9IGdldFZhbHVlQ29udGVudChcIiZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwO0R1cmF0aW9uXCIsIGR1cmF0aW9uVmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHRvb2x0aXBUZXh0ICs9IFwiPC9kaXY+XCI7XHJcbiAgICAgICAgXHJcbiAgICByZXR1cm4gdG9vbHRpcFRleHQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdlbmVyYXRlUGllSFRNTChkYXRhT2JqLCBkYXRhVGFibGUpIHtcclxuICAgIGxldCB0b29sdGlwVGV4dDtcclxuICAgIHRvb2x0aXBUZXh0ID0gYDxkaXYgY2xhc3M9J2p2LWlubGluZSBqdi1mdWxsLXdpZHRoJz5cclxuICAgICR7Z2V0Q29sb3JUaWxlKGRhdGFPYmouY29sb3JbZGF0YU9iai5kYXRhLmxhYmVsXSl9XHJcbiAgICAke2dldFRpdGxlVGVtcGxhdGUoZGF0YU9iail9YDtcclxuXHJcbiAgICBmb3IgKGxldCBpdGVtIGluIGRhdGFPYmoudGlwRGF0YSkge1xyXG4gICAgICAgIHRvb2x0aXBUZXh0ICs9IGdldFZhbHVlQ29udGVudChkYXRhVGFibGVbaXRlbV0sIGZvcm1hdFZhbHVlKGRhdGFPYmoudGlwRGF0YVtpdGVtXSkpO1xyXG4gICAgfVxyXG4gICAgdG9vbHRpcFRleHQgKz0gJzwvZGl2Pic7XHJcbiAgICByZXR1cm4gdG9vbHRpcFRleHQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdlbmVyYXRlU2Fua2V5SFRNTChkYXRhT2JqKSB7XHJcbiAgICBsZXQgdG9vbHRpcFRleHQ7XHJcbiAgICB0b29sdGlwVGV4dCA9IGA8ZGl2IGNsYXNzPSdqdi1pbmxpbmUganYtZnVsbC13aWR0aCc+JHtnZXRUaXRsZVRlbXBsYXRlKGRhdGFPYmopfWA7XHJcblxyXG4gICAgZm9yIChsZXQgaXRlbSBpbiBkYXRhT2JqLnRpcERhdGEpIHtcclxuICAgICAgICB0b29sdGlwVGV4dCArPSBnZXRWYWx1ZUNvbnRlbnQoZGF0YU9iai52YWx1ZU5hbWUsIGZvcm1hdFZhbHVlKGRhdGFPYmoudGlwRGF0YVtpdGVtXSkpO1xyXG4gICAgfVxyXG4gICAgdG9vbHRpcFRleHQgKz0gJzwvZGl2Pic7XHJcbiAgICByZXR1cm4gdG9vbHRpcFRleHQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKHZhbCkge1xyXG4gICAgaWYgKCFpc05hTih2YWwpKSB7XHJcbiAgICAgICAgbGV0IGZvcm1hdE51bWJlciA9IGQzLmZvcm1hdCgnLC4wZicpO1xyXG4gICAgICAgIGlmICh2YWwgPj0gMTAwMDAwMCkge1xyXG4gICAgICAgICAgICAvL21pbGxpb25zXHJcbiAgICAgICAgICAgIC8vdmFyIHAgPSBkMy5wcmVjaXNpb25QcmVmaXgoMWU1LCAxLjNlNik7XHJcbiAgICAgICAgICAgIC8vZm9ybWF0TnVtYmVyID0gZDMuZm9ybWF0UHJlZml4KFwiLlwiICsgcCwgMS4zZTYpO1xyXG4gICAgICAgICAgICBmb3JtYXROdW1iZXIgPSBkMy5mb3JtYXQoJywuMmYnKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHZhbCA8PSAxMDApIHtcclxuICAgICAgICAgICAgLy8yIGRlY2ltYWxzXHJcbiAgICAgICAgICAgIGZvcm1hdE51bWJlciA9IGQzLmZvcm1hdCgnLC4yZicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZm9ybWF0TnVtYmVyKHZhbCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGp2VGlwO1xyXG4iLCIndXNlIHN0cmljdCc7XHJcbnZhciBqdkNoYXJ0cyA9IHJlcXVpcmUoJy4vanZDaGFydHMuanMnKTtcclxuXHJcbmp2Q2hhcnRzLnByb3RvdHlwZS5nZXREZWZhdWx0T3B0aW9ucyA9IGdldERlZmF1bHRPcHRpb25zO1xyXG5cclxuZnVuY3Rpb24gZ2V0RGVmYXVsdE9wdGlvbnModXNlck9wdGlvbnMgPSB7fSkge1xyXG4gICAgdmFyIF92YXJzID0ge307XHJcblxyXG4gICAgLy9HZW5lcmFsIFN0eWxlcy9BdHRyaWJ1dGVzXHJcbiAgICAvL0NPTlNUIHZhcmlhYmxlcyAtIHRyeSB0byBub3QgdXNlIGluIGp2Q2hhcnRzIGFzIHRoZXkgZG8gbm90IGhhdmUgbXVjaCBjb250ZXh0XHJcbiAgICBfdmFycy5HUkFZID0gJyNjY2NjY2MnO1xyXG4gICAgX3ZhcnMuV0hJVEUgPSAnI0ZGRkZGRic7XHJcbiAgICBfdmFycy5CTEFDSyA9ICcjMDAwMDAwJztcclxuICAgIF92YXJzLlNNQUxMX1NUUk9LRV9XSURUSCA9ICcxcHgnO1xyXG4gICAgX3ZhcnMubGlnaHQgPSAnI0JCQkJCQic7XHJcbiAgICBfdmFycy5zdHJva2VXaWR0aCA9ICcycHgnO1xyXG5cclxuICAgIC8vQWN0aW9uIEF0dHJpYnV0ZXNcclxuICAgIF92YXJzLmhpZ2hsaWdodEJvcmRlckNvbG9yID0gX3ZhcnMuQkxBQ0s7XHJcbiAgICBfdmFycy5oaWdobGlnaHRCb3JkZXJXaWR0aCA9ICcycHgnO1xyXG5cclxuICAgIC8vQ29tcG9uZW50IFNwZWNpZmljIFN0eWxlcy9BdHRyaWJ1dGVzXHJcbiAgICBfdmFycy50aHJlc2hvbGRzID0gJ25vbmUnOyAvL2lmIG5vdCBub25lLCBleHBlY3RlZCB0byBiZSBhbiBhcnJheVxyXG4gICAgX3ZhcnMudGhyZXNob2xkTGVnZW5kID0gZmFsc2U7XHJcbiAgICBfdmFycy5iYWNrZ3JvdW5kQ29sb3IgPSAnbm9uZSc7XHJcbiAgICBfdmFycy5heGlzQ29sb3IgPSBfdmFycy5HUkFZO1xyXG4gICAgX3ZhcnMuZ3JpZExpbmVDb2xvciA9IF92YXJzLldISVRFO1xyXG4gICAgX3ZhcnMuYXhpc1dpZHRoID0gX3ZhcnMuc3Ryb2tlV2lkdGg7XHJcbiAgICBfdmFycy5ncmlkTGluZVN0cm9rZVdpZHRoID0gX3ZhcnMuU01BTExfU1RST0tFX1dJRFRIO1xyXG4gICAgX3ZhcnMuZGlzcGxheVZhbHVlcyA9IGZhbHNlO1xyXG4gICAgX3ZhcnMudG9nZ2xlTGVnZW5kID0gZmFsc2U7XHJcblxyXG4gICAgLy9fdmFycy5sZWdlbmRBcnJvd0NvbG9yID0gJ2MyYzJkNic7XHJcbiAgICAvL192YXJzLmxlZ2VuZEFycm93Q29sb3IgPSAnMDAwMDAwJztcclxuICAgIF92YXJzLmxlZ2VuZEFycm93Q29sb3IgPSAnZTdlN2U3JztcclxuXHJcbiAgICBfdmFycy5sZWdlbmRNYXggPSA5O1xyXG4gICAgX3ZhcnMuZ3JpZFNpemUgPSAxMjtcclxuICAgIF92YXJzLnhSZXZlcnNlZCA9IGZhbHNlO1xyXG4gICAgX3ZhcnMueVJldmVyc2VkID0gZmFsc2U7XHJcblxyXG4gICAgLy9mb250IHN0eWxlc1xyXG4gICAgX3ZhcnMuZm9udFNpemUgPSAnMTJweCc7XHJcbiAgICBfdmFycy5mb250Q29sb3IgPSBfdmFycy5CTEFDSztcclxuICAgIF92YXJzLnhMYWJlbEZvbnRTaXplID0gJ25vbmUnO1xyXG4gICAgX3ZhcnMueUxhYmVsRm9udFNpemUgPSAnbm9uZSc7XHJcblxyXG4gICAgLy9IZWF0bWFwIFNwZWNpZmljIFN0eWxlcy9BdHRyaWJ1dGVzXHJcbiAgICBfdmFycy5jb2xvciA9ICcjZmYwMDAwJztcclxuICAgIF92YXJzLnRvZ2dsZUxlZ2VuZCA9IGZhbHNlO1xyXG4gICAgX3ZhcnMuYnVja2V0cyA9ICcxMCc7XHJcbiAgICBfdmFycy5vcGFjaXR5ID0gJzEwJztcclxuICAgIF92YXJzLmNvbG9yTGFiZWwgPSAnbm9uZSc7XHJcbiAgICBfdmFycy5taW4gPSAnMCc7XHJcbiAgICBfdmFycy5tYXggPSAnMTAnO1xyXG4gICAgX3ZhcnMuZG9tYWluQXJyYXkgPSAnJztcclxuICAgIF92YXJzLnN0ZXAgPSAnMSc7XHJcbiAgICBfdmFycy5xdWFudGlsZXMgPSB0cnVlO1xyXG4gICAgX3ZhcnMuaGVhdExlZ2VuZFNwYWNpbmcgPSAyO1xyXG4gICAgX3ZhcnMuaGVhdEdyaWRTaXplID0gMjA7XHJcbiAgICBfdmFycy5jb2xvcnMgPSBbXHJcbiAgICAgICAgJyNmYmYyZDInLFxyXG4gICAgICAgICcjZmRlZGI1JyxcclxuICAgICAgICAnI2ZlZTdhMCcsXHJcbiAgICAgICAgJyNmZmRhODQnLFxyXG4gICAgICAgICcjZmZjNjY1JyxcclxuICAgICAgICAnI2ZlYjQ0ZScsXHJcbiAgICAgICAgJyNmZWE3NDMnLFxyXG4gICAgICAgICcjZmQ5YjNmJyxcclxuICAgICAgICAnI2ZkOGMzYycsXHJcbiAgICAgICAgJyNmZDc3MzUnLFxyXG4gICAgICAgICcjZmQ2MDJmJyxcclxuICAgICAgICAnI2ZiNGIyOScsXHJcbiAgICAgICAgJyNmNDM3MjMnLFxyXG4gICAgICAgICcjZWEyNDFlJyxcclxuICAgICAgICAnI2UwMTYxYycsXHJcbiAgICAgICAgJyNkNjBiMjAnLFxyXG4gICAgICAgICcjYzgwMzI0JyxcclxuICAgICAgICAnI2IxMDAyNicsXHJcbiAgICAgICAgJyM4NzAwMjUnLFxyXG4gICAgICAgICcjNjIwMDIzJ1xyXG4gICAgXTtcclxuICAgIF92YXJzLmNsdXN0ZXJDb2xvcnMgPSBbXHJcbiAgICAgICAgJyMwMDAwOUMnLFxyXG4gICAgICAgICcjMDAzMzk5JyxcclxuICAgICAgICAnIzAwMkZBNycsXHJcbiAgICAgICAgJyMyQTUyQkUnLFxyXG4gICAgICAgICcjMDAwMEZGJyxcclxuICAgICAgICAnIzhDOTJBQycsXHJcbiAgICAgICAgJyM5MkExQ0YnLFxyXG4gICAgICAgICcjQzRDM0QwJyxcclxuICAgICAgICAnI0NDQ0NGRicsXHJcbiAgICAgICAgJyNGOEY4RkYnLFxyXG4gICAgICAgICcjRkZGQUZBJyxcclxuICAgICAgICAnI0Y0QzJDMicsXHJcbiAgICAgICAgJyNGRjY5NjEnLFxyXG4gICAgICAgICcjRkY1QzVDJyxcclxuICAgICAgICAnI0ZGMUMwMCcsXHJcbiAgICAgICAgJyNGRjA4MDAnLFxyXG4gICAgICAgICcjRkYwMDAwJyxcclxuICAgICAgICAnI0NENUM1QycsXHJcbiAgICAgICAgJyNFMzQyMzQnLFxyXG4gICAgICAgICcjRDczQjNFJ1xyXG4gICAgXTtcclxuXHJcbiAgICAvL3BpZSBzcGVjaWZpY1xyXG4gICAgX3ZhcnMucGllQm9yZGVyID0gX3ZhcnMuV0hJVEU7XHJcbiAgICBfdmFycy5waWVCb3JkZXJXaWR0aCA9IF92YXJzLlNNQUxMX1NUUk9LRV9XSURUSDtcclxuICAgIF92YXJzLnBpZVRleHRDb2xvciA9IF92YXJzLldISVRFO1xyXG4gICAgX3ZhcnMuZW1wdHlMZWdlbmRTcXVhcmUgPSBfdmFycy5XSElURTtcclxuXHJcbiAgICAvL2xpbmUgc3BlY2lmaWNcclxuICAgIF92YXJzLmxpbmVDdXJ2ZVR5cGUgPSAnTGluZWFyJztcclxuXHJcbiAgICAvL2JhciBzcGVjaWZpY1xyXG4gICAgX3ZhcnMuZGlzcGxheVZhbHVlc1N0YWNrQXNQZXJjZW50ID0gZmFsc2U7XHJcbiAgICBfdmFycy5kaXNwbGF5VmFsdWVzU3RhY2tUb3RhbCA9IGZhbHNlO1xyXG4gICAgX3ZhcnMuZGlzcGxheVlBeGlzTGFiZWwgPSB0cnVlO1xyXG5cclxuICAgIF92YXJzLnRyYW5zaXRpb25UaW1lID0gMjAwO1xyXG5cclxuICAgIC8vc2NhdHRlciBzcGVjaWZpY1xyXG4gICAgX3ZhcnMudG9nZ2xlWiA9IHRydWU7XHJcbiAgICBfdmFycy5saW5lR3VpZGUgPSB0cnVlO1xyXG5cclxuICAgIC8vc2luZ2xlIGF4aXMgc3BlY2lmaWNcclxuICAgIF92YXJzLnNpbmdsZUF4aXNGaWxsSG92ZXJDb2xvciA9ICdyZWQnO1xyXG5cclxuICAgIE9iamVjdC5hc3NpZ24oX3ZhcnMsIHVzZXJPcHRpb25zKTtcclxuICAgIHJldHVybiBfdmFycztcclxufVxyXG4iLCIndXNlIHN0cmljdCc7XHJcbnZhciBqdkNoYXJ0cyA9IHJlcXVpcmUoJy4uL3Zpc3VhbHMvanZMaW5lLmpzJyk7XHJcblxyXG5qdkNoYXJ0cy5wcm90b3R5cGUuYXJlYSA9IHtcclxuICAgIHBhaW50OiBwYWludCxcclxuICAgIHNldERhdGE6IHNldERhdGEsXHJcbiAgICBnZXRFdmVudERhdGE6IGdldEV2ZW50RGF0YSxcclxuICAgIGhpZ2hsaWdodEZyb21FdmVudERhdGE6IGhpZ2hsaWdodEZyb21FdmVudERhdGFcclxufTtcclxuXHJcbmp2Q2hhcnRzLnByb3RvdHlwZS5maWxsQXJlYSA9IGZpbGxBcmVhO1xyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBMaW5lIGZ1bmN0aW9ucyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG4vKipzZXRMaW5lRGF0YVxyXG4gKiAgZ2V0cyBsaW5lIGRhdGEgYW5kIGFkZHMgaXQgdG8gdGhlIGNoYXJ0IG9iamVjdFxyXG4gKlxyXG4gKiBAcGFyYW1zIGRhdGEsIGRhdGFUYWJsZSwgY29sb3JzXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXREYXRhKCkge1xyXG4gICAgdmFyIGNoYXJ0ID0gdGhpcztcclxuICAgIC8vc29ydCBjaGFydCBkYXRhIGlmIHRoZXJlIGlzIGEgc29ydCB0eXBlIGFuZCBsYWJlbCBpbiB0aGUgX3ZhcnNcclxuICAgIGlmIChjaGFydC5fdmFycy5zb3J0VHlwZSkge1xyXG4gICAgICAgIGlmIChjaGFydC5fdmFycy5zb3J0TGFiZWwgJiYgY2hhcnQuX3ZhcnMuc29ydFR5cGUgIT09ICdkZWZhdWx0Jykge1xyXG4gICAgICAgICAgICBjaGFydC5vcmdhbml6ZUNoYXJ0RGF0YShjaGFydC5fdmFycy5zb3J0TGFiZWwsIGNoYXJ0Ll92YXJzLnNvcnRUeXBlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy9yZW1vdmUgaWYgd2UgYWRkIG5vbiBsaW5lYXIgdG8gYXJlYSBjaGFydFxyXG4gICAgY2hhcnQuX3ZhcnMubGluZUN1cnZlVHlwZSA9ICdMaW5lYXInO1xyXG5cclxuICAgIGNoYXJ0LmRhdGEubGVnZW5kRGF0YSA9IHNldEJhckxpbmVMZWdlbmREYXRhKGNoYXJ0LmRhdGEpO1xyXG4gICAgY2hhcnQuZGF0YS54QXhpc0RhdGEgPSBjaGFydC5zZXRBeGlzRGF0YSgneCcsIGNoYXJ0LmRhdGEpO1xyXG4gICAgY2hhcnQuZGF0YS55QXhpc0RhdGEgPSBjaGFydC5zZXRBeGlzRGF0YSgneScsIGNoYXJ0LmRhdGEpO1xyXG5cclxuICAgIGlmIChjaGFydC5fdmFycy5zZXJpZXNGbGlwcGVkKSB7XHJcbiAgICAgICAgY2hhcnQuc2V0RmxpcHBlZFNlcmllcyhjaGFydC5kYXRhLmRhdGFUYWJsZUtleXMpO1xyXG4gICAgICAgIGNoYXJ0LmZsaXBwZWREYXRhLmNvbG9yID0ganZDaGFydHMuc2V0Q2hhcnRDb2xvcnMoY2hhcnQuX3ZhcnMuY29sb3IsIGNoYXJ0LmZsaXBwZWREYXRhLmxlZ2VuZERhdGEsIGNoYXJ0LmNvbG9ycyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy9kZWZpbmUgY29sb3Igb2JqZWN0IGZvciBjaGFydERhdGFcclxuICAgIGNoYXJ0LmRhdGEuY29sb3IgPSBqdkNoYXJ0cy5zZXRDaGFydENvbG9ycyhjaGFydC5fdmFycy5jb2xvciwgY2hhcnQuZGF0YS5sZWdlbmREYXRhLCBjaGFydC5jb2xvcnMpO1xyXG59XHJcblxyXG4vKipzZXRCYXJMaW5lTGVnZW5kRGF0YVxyXG4gKiAgZ2V0cyBsZWdlbmQgaW5mbyBmcm9tIGNoYXJ0IERhdGFcclxuICpcclxuICogQHBhcmFtcyBkYXRhLCB0eXBlXHJcbiAqIEByZXR1cm5zIFtdIG9mIGxlZ2VuZCB0ZXhcclxuICovXHJcbmZ1bmN0aW9uIHNldEJhckxpbmVMZWdlbmREYXRhKGRhdGEpIHtcclxuICAgIHZhciBsZWdlbmRBcnJheSA9IFtdO1xyXG4gICAgZm9yIChsZXQgaXRlbSBpbiBkYXRhLmRhdGFUYWJsZSkge1xyXG4gICAgICAgIGlmIChkYXRhLmRhdGFUYWJsZS5oYXNPd25Qcm9wZXJ0eShpdGVtKSkge1xyXG4gICAgICAgICAgICBpZiAoaXRlbSAhPT0gJ2xhYmVsJyAmJiBpdGVtLmluZGV4T2YoJ3Rvb2x0aXAnKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIGxlZ2VuZEFycmF5LnB1c2goZGF0YS5kYXRhVGFibGVbaXRlbV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxlZ2VuZEFycmF5O1xyXG59XHJcbi8qKnBhaW50TGluZUNoYXJ0XHJcbiAqXHJcbiAqIFRoZSBpbml0aWFsIHN0YXJ0aW5nIHBvaW50IGZvciBsaW5lIGNoYXJ0LCBiZWdpbnMgdGhlIGRyYXdpbmcgcHJvY2Vzcy4gTXVzdCBhbHJlYWR5IGhhdmUgdGhlIGRhdGEgc3RvcmVkIGluIHRoZSBjaGFydFxyXG4gKiBvYmplY3RcclxuICovXHJcbmZ1bmN0aW9uIHBhaW50KCkge1xyXG4gICAgdmFyIGNoYXJ0ID0gdGhpcyxcclxuICAgICAgICAvL1VzZXMgdGhlIG9yaWdpbmFsIGRhdGEgYW5kIHRoZW4gbWFuaXB1bGF0ZXMgaXQgYmFzZWQgb24gYW55IGV4aXN0aW5nIG9wdGlvbnNcclxuICAgICAgICBkYXRhT2JqID0gY2hhcnQuZ2V0QmFyRGF0YUZyb21PcHRpb25zKCk7XHJcblxyXG4gICAgLy9hc3NpZ24gY3VycmVudCBkYXRhIHdoaWNoIGlzIHVzZWQgYnkgYWxsIGJhciBjaGFydCBvcGVyYXRpb25zXHJcbiAgICBjaGFydC5jdXJyZW50RGF0YSA9IGRhdGFPYmo7XHJcblxyXG4gICAgLy9PdmVyd3JpdGUgYW55IHByZS1leGlzdGluZyB6b29tXHJcbiAgICBjaGFydC5jb25maWcuem9vbUV2ZW50ID0gbnVsbDtcclxuXHJcbiAgICAvL2dlbmVyYXRlIHN2ZyBkeW5hbWljYWxseSBiYXNlZCBvbiBsZWdlbmQgZGF0YVxyXG4gICAgY2hhcnQuZ2VuZXJhdGVTVkcoZGF0YU9iai5sZWdlbmREYXRhKTtcclxuICAgIGNoYXJ0LmdlbmVyYXRlWEF4aXMoZGF0YU9iai54QXhpc0RhdGEpO1xyXG4gICAgY2hhcnQuZ2VuZXJhdGVZQXhpcyhkYXRhT2JqLnlBeGlzRGF0YSk7XHJcbiAgICBjaGFydC5nZW5lcmF0ZUxlZ2VuZChkYXRhT2JqLmxlZ2VuZERhdGEsICdnZW5lcmF0ZUxpbmUnKTtcclxuXHJcbiAgICBpZiAodHlwZW9mIGRhdGFPYmoueEF4aXNTY2FsZS50aWNrcyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIGNoYXJ0LmZvcm1hdFhBeGlzTGFiZWxzKGRhdGFPYmoueEF4aXNTY2FsZS50aWNrcygpLmxlbmd0aCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNoYXJ0LmZvcm1hdFhBeGlzTGFiZWxzKGRhdGFPYmoueEF4aXNTY2FsZS5kb21haW4oKS5sZW5ndGgpO1xyXG4gICAgfVxyXG5cclxuICAgIGNoYXJ0LmdlbmVyYXRlTGluZShkYXRhT2JqKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0RXZlbnREYXRhKGV2ZW50KSB7XHJcbiAgICB2YXIgY2hhcnQgPSB0aGlzO1xyXG4gICAgaWYgKGV2ZW50LnRhcmdldC5jbGFzc0xpc3QudmFsdWUuc3BsaXQoJ2Jhci1jb2wtJylbMV0pIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICAgICAgICBbY2hhcnQuY3VycmVudERhdGEuZGF0YVRhYmxlLmxhYmVsXTogW2V2ZW50LnRhcmdldC5jbGFzc0xpc3QudmFsdWUuc3BsaXQoJ2Jhci1jb2wtJylbMV0ucmVwbGFjZSgvXy9nLCAnICcpLnJlcGxhY2UoL19jb2xvbl8vZywgJzonKS5yZXBsYWNlKC9fZG90Xy9nLCAnLicpXVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBub2RlOiBldmVudC50YXJnZXRcclxuICAgICAgICB9O1xyXG4gICAgfSBlbHNlIGlmIChldmVudC50YXJnZXQuY2xhc3NMaXN0LnZhbHVlLmluZGV4T2YoJ2FyZWEtY29udGFpbmVyJykgPiAtMSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGRhdGE6IHt9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZGF0YTogZmFsc2VcclxuICAgIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhpZ2hsaWdodEZyb21FdmVudERhdGEoZXZlbnQpIHtcclxuICAgIGxldCBjaGFydCA9IHRoaXMsXHJcbiAgICAgICAgbGFiZWwgPSBldmVudC5kYXRhW2NoYXJ0LmN1cnJlbnREYXRhLmRhdGFUYWJsZS5sYWJlbF1bMF0sXHJcbiAgICAgICAgY3NzQ2xhc3MgPSAnLmhpZ2hsaWdodC1jbGFzcy0nICsgbGFiZWwucmVwbGFjZSgvXFxzL2csICdfJykucmVwbGFjZSgvXFwuL2csICdfZG90XycpLFxyXG4gICAgICAgIG5vZGUgPSBjaGFydC5zdmcuc2VsZWN0QWxsKGNzc0NsYXNzKTtcclxuXHJcbiAgICBjaGFydC5zdmcuc2VsZWN0KCcuYXJlYS1jb250YWluZXInKS5zZWxlY3RBbGwoJ2NpcmNsZScpXHJcbiAgICAgICAgLmF0dHIoJ3N0cm9rZScsIDApXHJcbiAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIDApO1xyXG4gICAgLy9oaWdobGlnaHQgbmVjZXNzYXJ5IGNpcmNsZXNcclxuICAgIG5vZGVcclxuICAgICAgICAuYXR0cignc3Ryb2tlJywgY2hhcnQuX3ZhcnMuaGlnaGxpZ2h0Qm9yZGVyQ29sb3IpXHJcbiAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIGNoYXJ0Ll92YXJzLmhpZ2hsaWdodEJvcmRlcldpZHRoKTtcclxufVxyXG5cclxuLyoqXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBmaWxsQXJlYShsaW5lRGF0YSkge1xyXG4gICAgdmFyIGNoYXJ0ID0gdGhpcyxcclxuICAgICAgICBzdmcgPSBjaGFydC5zdmcsXHJcbiAgICAgICAgeEF4aXNEYXRhID0gY2hhcnQuY3VycmVudERhdGEueEF4aXNEYXRhLFxyXG4gICAgICAgIHlBeGlzRGF0YSA9IGNoYXJ0LmN1cnJlbnREYXRhLnlBeGlzRGF0YSxcclxuICAgICAgICBsZWdlbmREYXRhID0gY2hhcnQuY3VycmVudERhdGEubGVnZW5kRGF0YSxcclxuICAgICAgICBjb250YWluZXIgPSBjaGFydC5jb25maWcuY29udGFpbmVyLFxyXG4gICAgICAgIGNvbG9ycyA9IGNoYXJ0Ll92YXJzLmNvbG9yLFxyXG4gICAgICAgIHggPSBqdkNoYXJ0cy5nZXRBeGlzU2NhbGUoJ3gnLCB4QXhpc0RhdGEsIGNvbnRhaW5lciwgY2hhcnQuX3ZhcnMsICduby1wYWRkaW5nJyksXHJcbiAgICAgICAgeSA9IGp2Q2hhcnRzLmdldEF4aXNTY2FsZSgneScsIHlBeGlzRGF0YSwgY29udGFpbmVyLCBjaGFydC5fdmFycywgJ25vLXBhZGRpbmcnKSxcclxuICAgICAgICBhcmVhLFxyXG4gICAgICAgIGRhdGEgPSB7fTtcclxuXHJcbiAgICAvL0lmIGEgbGVnZW5kIGVsZW1lbnQgaXMgdG9nZ2xlZCBvZmYsIHVzZSB0aGUgbmV3IGxpc3Qgb2YgaGVhZGVyc1xyXG4gICAgaWYgKGNoYXJ0Ll92YXJzLmhhc093blByb3BlcnR5KCdsZWdlbmRIZWFkZXJzJykpIHtcclxuICAgICAgICBsZWdlbmREYXRhID0gY2hhcnQuX3ZhcnMubGVnZW5kSGVhZGVycztcclxuICAgIH1cclxuICAgIC8vSWYgYXhpcyBhcmUgbm9ybWFsXHJcbiAgICBpZiAoIWNoYXJ0Ll92YXJzLnJvdGF0ZUF4aXMpIHtcclxuICAgICAgICBhcmVhID0gZDMuYXJlYSgpXHJcbiAgICAgICAgICAgIC54KGQgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGQueCA9PT0gJycpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geCgnRU1QVFlfU1RSSU5HJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geChkLngpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAueTAoY29udGFpbmVyLmhlaWdodClcclxuICAgICAgICAgICAgLnkxKGQgPT4geShkLnkpKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYXJlYSA9IGQzLmFyZWEoKVxyXG4gICAgICAgICAgICAueShkID0+IHkoZC55KSlcclxuICAgICAgICAgICAgLngxKDApXHJcbiAgICAgICAgICAgIC54MChkID0+IHgoZC54KSk7XHJcbiAgICB9XHJcblxyXG4gICAgZm9yIChsZXQgZGF0YUVsZSBvZiBsaW5lRGF0YSkge1xyXG4gICAgICAgIGZvciAobGV0IGxlZ2VuZEVsZSBvZiBsZWdlbmREYXRhKSB7XHJcbiAgICAgICAgICAgIGlmIChsZWdlbmRFbGUudG9nZ2xlID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgLy9Eb24ndCB3cml0ZSBhbnl0aGluZyB0byBkYXRhXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWRhdGFbbGVnZW5kRWxlXSkge1xyXG4gICAgICAgICAgICAgICAgZGF0YVtsZWdlbmRFbGVdID0gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFjaGFydC5fdmFycy5yb3RhdGVBeGlzKSB7XHJcbiAgICAgICAgICAgICAgICBkYXRhW2xlZ2VuZEVsZV0ucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgJ3gnOiBkYXRhRWxlW3hBeGlzRGF0YS5sYWJlbF0sXHJcbiAgICAgICAgICAgICAgICAgICAgJ3knOiBwYXJzZUZsb2F0KGRhdGFFbGVbbGVnZW5kRWxlXSlcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZGF0YVtsZWdlbmRFbGVdLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICd5JzogZGF0YUVsZVt5QXhpc0RhdGEubGFiZWxdLFxyXG4gICAgICAgICAgICAgICAgICAgICd4JzogcGFyc2VGbG9hdChkYXRhRWxlW2xlZ2VuZEVsZV0pXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzdmcuc2VsZWN0QWxsKCcuYXJlYScpLnJlbW92ZSgpO1xyXG4gICAgZm9yIChsZXQga2V5IGluIGRhdGEpIHtcclxuICAgICAgICBpZiAoZGF0YS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgIHN2Zy5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgICAgICAgICAgLmRhdHVtKGRhdGFba2V5XSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhcnQuX3ZhcnMuY29sb3JMaW5lID09IHRydWUgJiYgY2hhcnQuX3ZhcnMudGhyZXNob2xkcyAhPSAnbm9uZScgJiYgY2hhcnQuX3ZhcnMuY29sb3JDaGFydCAhPSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2FyZWEgYXJlYS10aHJlc2hvbGQnO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2FyZWEnO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdkJywgYXJlYSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywganZDaGFydHMuZ2V0Q29sb3JzKGNvbG9ycywgbnVsbCwga2V5KSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdvcGFjaXR5JywgMC42KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICgpID0+IGNoYXJ0Ll92YXJzLnJvdGF0ZUF4aXMgPyBgdHJhbnNsYXRlKDAsICR7Y29udGFpbmVyLmhlaWdodCAvIGxpbmVEYXRhLmxlbmd0aCAvIDJ9KWAgOiBgdHJhbnNsYXRlKCR7Y29udGFpbmVyLndpZHRoIC8gbGluZURhdGEubGVuZ3RoIC8gMn0sIDApYClcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdwb2ludGVyLWV2ZW50cycsICdub25lJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGp2Q2hhcnRzO1xyXG4iLCIndXNlIHN0cmljdCc7XHJcbnZhciBqdkNoYXJ0cyA9IHJlcXVpcmUoJy4uL2p2Q2hhcnRzLmpzJyk7XHJcblxyXG5qdkNoYXJ0cy5wcm90b3R5cGUuYmFyID0ge1xyXG4gICAgcGFpbnQ6IHBhaW50LFxyXG4gICAgc2V0RGF0YTogc2V0RGF0YSxcclxuICAgIGdldEV2ZW50RGF0YTogZ2V0RXZlbnREYXRhLFxyXG4gICAgaGlnaGxpZ2h0RnJvbUV2ZW50RGF0YTogaGlnaGxpZ2h0RnJvbUV2ZW50RGF0YVxyXG59O1xyXG5cclxuanZDaGFydHMucHJvdG90eXBlLmdlbmVyYXRlQmFyVGhyZXNob2xkID0gZ2VuZXJhdGVCYXJUaHJlc2hvbGQ7XHJcbmp2Q2hhcnRzLnByb3RvdHlwZS5nZW5lcmF0ZUJhcnMgPSBnZW5lcmF0ZUJhcnM7XHJcblxyXG5cclxuLyoqcGFpbnRcclxuICpcclxuICogVGhlIGluaXRpYWwgc3RhcnRpbmcgcG9pbnQgZm9yIGJhciBjaGFydCwgYmVnaW5zIHRoZSBkcmF3aW5nIHByb2Nlc3MuIE11c3QgYWxyZWFkeSBoYXZlIHRoZSBkYXRhIHN0b3JlZCBpbiB0aGUgY2hhcnRcclxuICogb2JqZWN0XHJcbiAqL1xyXG5mdW5jdGlvbiBwYWludCh0cmFuc2l0aW9uVGltZSA9IDgwMCkge1xyXG4gICAgbGV0IGNoYXJ0ID0gdGhpcyxcclxuICAgICAgICAvL1VzZXMgdGhlIG9yaWdpbmFsIGRhdGEgYW5kIHRoZW4gbWFuaXB1bGF0ZXMgaXQgYmFzZWQgb24gYW55IGV4aXN0aW5nIG9wdGlvbnNcclxuICAgICAgICBkYXRhT2JqID0gY2hhcnQuZ2V0QmFyRGF0YUZyb21PcHRpb25zKCk7XHJcblxyXG4gICAgaWYgKHRyYW5zaXRpb25UaW1lIHx8IHRyYW5zaXRpb25UaW1lID09PSAwKSB7XHJcbiAgICAgICAgY2hhcnQuX3ZhcnMudHJhbnNpdGlvblRpbWUgPSB0cmFuc2l0aW9uVGltZTtcclxuICAgIH1cclxuXHJcbiAgICAvL2Fzc2lnbiBjdXJyZW50IGRhdGEgd2hpY2ggaXMgdXNlZCBieSBhbGwgYmFyIGNoYXJ0IG9wZXJhdGlvbnNcclxuICAgIGNoYXJ0LmN1cnJlbnREYXRhID0gZGF0YU9iajtcclxuXHJcbiAgICAvL2dlbmVyYXRlIHN2ZyBkeW5hbWljYWxseSBiYXNlZCBvbiBsZWdlbmQgZGF0YVxyXG4gICAgY2hhcnQuZ2VuZXJhdGVTVkcoZGF0YU9iai5sZWdlbmREYXRhKTtcclxuICAgIGNoYXJ0LmdlbmVyYXRlWEF4aXMoZGF0YU9iai54QXhpc0RhdGEpO1xyXG4gICAgY2hhcnQuZ2VuZXJhdGVZQXhpcyhkYXRhT2JqLnlBeGlzRGF0YSk7XHJcbiAgICBjaGFydC5nZW5lcmF0ZUxlZ2VuZChkYXRhT2JqLmxlZ2VuZERhdGEsICdnZW5lcmF0ZUJhcnMnKTtcclxuICAgIGNoYXJ0LmdlbmVyYXRlQmFycyhkYXRhT2JqKTtcclxuXHJcbiAgICBpZiAodHlwZW9mIGRhdGFPYmoueEF4aXNTY2FsZS50aWNrcyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIGNoYXJ0LmZvcm1hdFhBeGlzTGFiZWxzKGRhdGFPYmoueEF4aXNTY2FsZS50aWNrcygpLmxlbmd0aCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNoYXJ0LmZvcm1hdFhBeGlzTGFiZWxzKGRhdGFPYmoueEF4aXNTY2FsZS5kb21haW4oKS5sZW5ndGgpO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuLyoqU2V0cyB0aGUgZGF0YSBmb3IgdGhlIGJhciBjaGFydCBwcmlvciB0byBwYWludGluZ1xyXG4gKiAgQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbXMge09iamVjdH0gZGF0YSAtIERhdGEgcGFzc2VkIGludG8gdGhlIGNoYXJ0XHJcbiAqIEBwYXJhbXMge09iamVjdH0gZGF0YVRhYmxlIC0gU2hvd3Mgd2hpY2ggZGF0YSBjb2x1bW4gaXMgYXNzb2NpYXRlZCB3aXRoIGVhY2ggZmllbGQgaW4gdmlzdWFsIHBhbmVsXHJcbiAqIEBwYXJhbXMge09iamVjdH0gZGF0YVRhYmxlS2V5cyAtIENvbnRhaW5zIHRoZSBkYXRhIHR5cGUgZm9yIGVhY2ggY29sdW1uIG9mIGRhdGFcclxuICogQHBhcmFtcyB7T2JqZWN0fSBjb2xvcnMgLSBDb2xvcnMgb2JqZWN0IHVzZWQgdG8gY29sb3IgdGhlIGJhcnNcclxuICovXHJcbmZ1bmN0aW9uIHNldERhdGEoKSB7XHJcbiAgICBsZXQgY2hhcnQgPSB0aGlzO1xyXG4gICAgLy9zb3J0IGNoYXJ0IGRhdGEgaWYgdGhlcmUgaXMgYSBzb3J0IHR5cGUgYW5kIGxhYmVsIGluIHRoZSBfdmFyc1xyXG4gICAgaWYgKGNoYXJ0Ll92YXJzLmhhc093blByb3BlcnR5KCdzb3J0VHlwZScpICYmIGNoYXJ0Ll92YXJzLnNvcnRUeXBlKSB7XHJcbiAgICAgICAgaWYgKGNoYXJ0Ll92YXJzLnNvcnRMYWJlbCAmJiBjaGFydC5fdmFycy5zb3J0VHlwZSAhPT0gJ2RlZmF1bHQnKSB7XHJcbiAgICAgICAgICAgIGNoYXJ0Lm9yZ2FuaXplQ2hhcnREYXRhKGNoYXJ0Ll92YXJzLnNvcnRMYWJlbCwgY2hhcnQuX3ZhcnMuc29ydFR5cGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNoYXJ0LmRhdGEubGVnZW5kRGF0YSA9IHNldEJhckxpbmVMZWdlbmREYXRhKGNoYXJ0LmRhdGEpO1xyXG4gICAgY2hhcnQuZGF0YS54QXhpc0RhdGEgPSBjaGFydC5zZXRBeGlzRGF0YSgneCcsIGNoYXJ0LmRhdGEpO1xyXG4gICAgY2hhcnQuZGF0YS55QXhpc0RhdGEgPSBjaGFydC5zZXRBeGlzRGF0YSgneScsIGNoYXJ0LmRhdGEpO1xyXG4gICAgaWYgKGNoYXJ0Ll92YXJzLnNlcmllc0ZsaXBwZWQpIHtcclxuICAgICAgICBjaGFydC5zZXRGbGlwcGVkU2VyaWVzKGNoYXJ0LmRhdGEuZGF0YVRhYmxlS2V5cyk7XHJcbiAgICAgICAgY2hhcnQuZmxpcHBlZERhdGEuY29sb3IgPSBqdkNoYXJ0cy5zZXRDaGFydENvbG9ycyhjaGFydC5fdmFycy5jb2xvciwgY2hhcnQuZmxpcHBlZERhdGEubGVnZW5kRGF0YSwgY2hhcnQuY29sb3JzKTtcclxuICAgIH1cclxuXHJcbiAgICAvL2RlZmluZSBjb2xvciBvYmplY3QgZm9yIGNoYXJ0RGF0YVxyXG4gICAgY2hhcnQuZGF0YS5jb2xvciA9IGp2Q2hhcnRzLnNldENoYXJ0Q29sb3JzKGNoYXJ0Ll92YXJzLmNvbG9yLCBjaGFydC5kYXRhLmxlZ2VuZERhdGEsIGNoYXJ0LmNvbG9ycyk7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBnZXRFdmVudERhdGEoZXZlbnQpIHtcclxuICAgIHZhciBjaGFydCA9IHRoaXM7XHJcbiAgICBpZiAoZXZlbnQudGFyZ2V0LmNsYXNzTGlzdC52YWx1ZS5zcGxpdCgnYmFyLWNvbC0nKVsxXSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgICAgIFtjaGFydC5jdXJyZW50RGF0YS5kYXRhVGFibGUubGFiZWxdOiBbZXZlbnQudGFyZ2V0LmNsYXNzTGlzdC52YWx1ZS5zcGxpdCgnYmFyLWNvbC0nKVsxXS5yZXBsYWNlKC9fL2csICcgJykucmVwbGFjZSgvX2RvdF8vZywgJy4nKV1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbm9kZTogZXZlbnQudGFyZ2V0XHJcbiAgICAgICAgfTtcclxuICAgIH0gZWxzZSBpZiAoZXZlbnQudGFyZ2V0LmNsYXNzTGlzdC52YWx1ZS5pbmRleE9mKCdiYXItY29udGFpbmVyJykgPiAtMSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGRhdGE6IHt9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZGF0YTogZmFsc2VcclxuICAgIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhpZ2hsaWdodEZyb21FdmVudERhdGEoZXZlbnQpIHtcclxuICAgIGxldCBjaGFydCA9IHRoaXMsXHJcbiAgICAgICAgbGFiZWxBcnJheSA9IGV2ZW50LmRhdGFbY2hhcnQuY3VycmVudERhdGEuZGF0YVRhYmxlLmxhYmVsXSxcclxuICAgICAgICBub2RlLFxyXG4gICAgICAgIGNzc0NsYXNzO1xyXG4gICAgY2hhcnQuc3ZnLnNlbGVjdCgnLmJhci1jb250YWluZXInKS5zZWxlY3RBbGwoJ3JlY3QnKVxyXG4gICAgICAgIC5hdHRyKCdzdHJva2UnLCAwKVxyXG4gICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCAwKTtcclxuXHJcbiAgICBmb3IgKGxldCBsYWJlbCBvZiBsYWJlbEFycmF5KSB7XHJcbiAgICAgICAgY3NzQ2xhc3MgPSAnLmhpZ2hsaWdodC1jbGFzcy0nICsgbGFiZWwucmVwbGFjZSgvXFxzL2csICdfJykucmVwbGFjZSgvXFwuL2csICdfZG90XycpO1xyXG4gICAgICAgIG5vZGUgPSBjaGFydC5zdmcuc2VsZWN0QWxsKGNzc0NsYXNzKTtcclxuXHJcbiAgICAgICAgLy9oaWdobGlnaHQgbmVjZXNzYXJ5IGJhcnNcclxuICAgICAgICBub2RlXHJcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCBjaGFydC5fdmFycy5oaWdobGlnaHRCb3JkZXJDb2xvcilcclxuICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIGNoYXJ0Ll92YXJzLmhpZ2hsaWdodEJvcmRlcldpZHRoKTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqc2V0QmFyTGluZUxlZ2VuZERhdGFcclxuICogIGdldHMgbGVnZW5kIGluZm8gZnJvbSBjaGFydCBEYXRhXHJcbiAqXHJcbiAqIEBwYXJhbXMgZGF0YSwgdHlwZVxyXG4gKiBAcmV0dXJucyBbXSBvZiBsZWdlbmQgdGV4dFxyXG4gKi9cclxuZnVuY3Rpb24gc2V0QmFyTGluZUxlZ2VuZERhdGEoZGF0YSkge1xyXG4gICAgdmFyIGxlZ2VuZEFycmF5ID0gW107XHJcbiAgICBmb3IgKGxldCBpdGVtIGluIGRhdGEuZGF0YVRhYmxlKSB7XHJcbiAgICAgICAgaWYgKGRhdGEuZGF0YVRhYmxlLmhhc093blByb3BlcnR5KGl0ZW0pKSB7XHJcbiAgICAgICAgICAgIGlmIChpdGVtICE9PSAnbGFiZWwnICYmIGl0ZW0uaW5kZXhPZigndG9vbHRpcCcpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgbGVnZW5kQXJyYXkucHVzaChkYXRhLmRhdGFUYWJsZVtpdGVtXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbGVnZW5kQXJyYXk7XHJcbn1cclxuXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogQmFyIGZ1bmN0aW9ucyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcbmZ1bmN0aW9uIGdlbmVyYXRlQmFyVGhyZXNob2xkKCkge1xyXG4gICAgdmFyIGNoYXJ0ID0gdGhpcyxcclxuICAgICAgICBzdmcgPSBjaGFydC5zdmcsXHJcbiAgICAgICAgd2lkdGggPSBjaGFydC5jb25maWcuY29udGFpbmVyLndpZHRoLFxyXG4gICAgICAgIGhlaWdodCA9IGNoYXJ0LmNvbmZpZy5jb250YWluZXIuaGVpZ2h0LFxyXG4gICAgICAgIHRocmVzaG9sZHMgPSBjaGFydC5fdmFycy50aHJlc2hvbGRzLFxyXG4gICAgICAgIGxlbmd0aCA9IHRocmVzaG9sZHMgIT09ICdub25lJyA/IE9iamVjdC5rZXlzKHRocmVzaG9sZHMpLmxlbmd0aCA6IDAsXHJcbiAgICAgICAgeCA9IGNoYXJ0LmN1cnJlbnREYXRhLnhBeGlzU2NhbGUsXHJcbiAgICAgICAgeSA9IGNoYXJ0LmN1cnJlbnREYXRhLnlBeGlzU2NhbGU7XHJcblxyXG4gICAgaWYgKHRocmVzaG9sZHMgIT09ICdub25lJykge1xyXG4gICAgICAgIGxldCB0aHJlc2hvbGRSZWN0cyxcclxuICAgICAgICAgICAgdGhyZXNob2xkO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhyZXNob2xkID0gdGhyZXNob2xkc1tpXTtcclxuICAgICAgICAgICAgaWYgKCFjaGFydC5fdmFycy54QXhpc1RocmVzaG9sZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoYXJ0Ll92YXJzLnJvdGF0ZUF4aXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhcnQuX3ZhcnMueU1pbiA9PT0gJ25vbmUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN2Zy5hcHBlbmQoJ2xpbmUnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UnLCB0aHJlc2hvbGQudGhyZXNob2xkQ29sb3IpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneDEnLCB4KHRocmVzaG9sZC50aHJlc2hvbGQpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MicsIHgodGhyZXNob2xkLnRocmVzaG9sZCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneTInLCBoZWlnaHQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlLWRhc2hhcnJheScsICgnMywgMycpKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRocmVzaG9sZC50aHJlc2hvbGQgPiBjaGFydC5fdmFycy55TWluKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN2Zy5hcHBlbmQoJ2xpbmUnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UnLCB0aHJlc2hvbGQudGhyZXNob2xkQ29sb3IpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneDEnLCB4KHRocmVzaG9sZC50aHJlc2hvbGQpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MicsIHgodGhyZXNob2xkLnRocmVzaG9sZCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneTInLCBoZWlnaHQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlLWRhc2hhcnJheScsICgnMywgMycpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoYXJ0Ll92YXJzLnlNaW4gPT09ICdub25lJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHN2Zy5hcHBlbmQoJ2xpbmUnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsIHRocmVzaG9sZC50aHJlc2hvbGRDb2xvcilcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gxJywgMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgeSh0aHJlc2hvbGQudGhyZXNob2xkKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgd2lkdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIHkodGhyZXNob2xkLnRocmVzaG9sZCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2UtZGFzaGFycmF5JywgKCczLCAzJykpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aHJlc2hvbGQudGhyZXNob2xkID4gY2hhcnQuX3ZhcnMueU1pbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHN2Zy5hcHBlbmQoJ2xpbmUnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsIHRocmVzaG9sZC50aHJlc2hvbGRDb2xvcilcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gxJywgMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgeSh0aHJlc2hvbGQudGhyZXNob2xkKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgd2lkdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIHkodGhyZXNob2xkLnRocmVzaG9sZCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2UtZGFzaGFycmF5JywgKCczLCAzJykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoY2hhcnQuX3ZhcnMuY29sb3JDaGFydCA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJlc2hvbGRSZWN0cyA9IGQzLnNlbGVjdEFsbCgncmVjdC5yZWN0LScgKyBpKTtcclxuICAgICAgICAgICAgICAgIHRocmVzaG9sZFJlY3RzLmF0dHIoJ2ZpbGwnLCB0aHJlc2hvbGQudGhyZXNob2xkQ29sb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG4vKipnZW5lcmF0ZUJhcnNcclxuICpcclxuICogRG9lcyB0aGUgYWN0dWFsIHBhaW50aW5nIG9mIGJhcnMgb24gdGhlIGJhciBjaGFydFxyXG4gKiBAcGFyYW1zIGJhckRhdGFcclxuICovXHJcblxyXG5mdW5jdGlvbiBnZW5lcmF0ZUJhcnMoYmFyRGF0YSkge1xyXG4gICAgdmFyIGNoYXJ0ID0gdGhpcyxcclxuICAgICAgICBzdmcgPSBjaGFydC5zdmcsXHJcblxyXG4gICAgICAgIC8vVXNlZCB0byBkcmF3IGxpbmUgdGhhdCBhcHBlYXJzIHdoZW4gdG9vbCB0aXBzIGFyZSB2aXNpYmxlXHJcbiAgICAgICAgdGlwTGluZVggPSAwLFxyXG4gICAgICAgIHRpcExpbmVXaWR0aCA9IDAsXHJcbiAgICAgICAgdGlwTGluZUhlaWdodCA9IDAsXHJcbiAgICAgICAgdGlwTGluZVkgPSAwLFxyXG4gICAgICAgIC8vQWRkIGxvZ2ljIHRvIGZpbHRlciBiYXJkYXRhXHJcbiAgICAgICAgZGF0YUhlYWRlcnMgPSBiYXJEYXRhLmxlZ2VuZERhdGEsXHJcbiAgICAgICAgYmFycyxcclxuICAgICAgICBiYXJEYXRhTmV3LFxyXG4gICAgICAgIGV2ZW50R3JvdXBzO1xyXG5cclxuICAgIC8vUmVtb3ZlcyBhbnkgZXhpc3RpbmcgYmFyIGNvbnRhaW5lcnMgYW5kIGNyZWF0ZXMgYSBuZXcgb25lXHJcbiAgICBzdmcuc2VsZWN0QWxsKCdnLmJhci1jb250YWluZXInKS5yZW1vdmUoKTtcclxuXHJcbiAgICBiYXJzID0gc3ZnLmFwcGVuZCgnZycpXHJcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2Jhci1jb250YWluZXInKVxyXG4gICAgICAgIC5zZWxlY3RBbGwoJ2cnKTtcclxuXHJcbiAgICBpZiAoY2hhcnQuX3ZhcnMuc2VyaWVzRmxpcHBlZCAmJiBjaGFydC5fdmFycy5mbGlwcGVkTGVnZW5kSGVhZGVycykge1xyXG4gICAgICAgIGRhdGFIZWFkZXJzID0gY2hhcnQuX3ZhcnMuZmxpcHBlZExlZ2VuZEhlYWRlcnM7XHJcbiAgICB9IGVsc2UgaWYgKGNoYXJ0Ll92YXJzLmxlZ2VuZEhlYWRlcnMpIHtcclxuICAgICAgICBkYXRhSGVhZGVycyA9IGNoYXJ0Ll92YXJzLmxlZ2VuZEhlYWRlcnM7XHJcbiAgICB9XHJcblxyXG4gICAgY2hhcnQuX3ZhcnMubGVnZW5kSGVhZGVycyA9IGRhdGFIZWFkZXJzO1xyXG5cclxuICAgIGJhckRhdGFOZXcgPSBqdkNoYXJ0cy5nZXRUb2dnbGVkRGF0YShiYXJEYXRhLCBkYXRhSGVhZGVycyk7XHJcblxyXG4gICAgZ2VuZXJhdGVCYXJHcm91cHMoYmFycywgYmFyRGF0YU5ldywgY2hhcnQpO1xyXG5cclxuICAgIGV2ZW50R3JvdXBzID0ganZDaGFydHMuZ2VuZXJhdGVFdmVudEdyb3VwcyhiYXJzLCBiYXJEYXRhTmV3LCBjaGFydCk7XHJcblxyXG4gICAgLy9BZGQgbGlzdGVuZXJzXHJcblxyXG4gICAgZXZlbnRHcm91cHNcclxuICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uIChkLCBpLCBqKSB7IC8vVHJhbnNpdGlvbnMgaW4gRDMgZG9uJ3Qgc3VwcG9ydCB0aGUgJ29uJyBmdW5jdGlvbiBUaGV5IG9ubHkgZXhpc3Qgb24gc2VsZWN0aW9ucy4gU28gbmVlZCB0byBtb3ZlIHRoYXQgZXZlbnQgbGlzdGVuZXIgYWJvdmUgdHJhbnNpdGlvbiBhbmQgYWZ0ZXIgYXBwZW5kXHJcbiAgICAgICAgICAgIGlmIChjaGFydC5zaG93VG9vbFRpcCkge1xyXG4gICAgICAgICAgICAgICAgLy9HZXQgdGlwIGRhdGFcclxuICAgICAgICAgICAgICAgIGxldCB0aXBEYXRhID0gY2hhcnQuc2V0VGlwRGF0YShkLCBpKSxcclxuICAgICAgICAgICAgICAgICAgICBtb3VzZUl0ZW0gPSBkMy5zZWxlY3QodGhpcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9EcmF3IHRpcCBsaW5lXHJcbiAgICAgICAgICAgICAgICBjaGFydC50aXAuZ2VuZXJhdGVTaW1wbGVUaXAodGlwRGF0YSwgY2hhcnQuZGF0YS5kYXRhVGFibGUpO1xyXG4gICAgICAgICAgICAgICAgY2hhcnQudGlwLmQgPSBkO1xyXG4gICAgICAgICAgICAgICAgY2hhcnQudGlwLmkgPSBpO1xyXG4gICAgICAgICAgICAgICAgc3ZnLnNlbGVjdEFsbCgnLnRpcC1saW5lJykucmVtb3ZlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgdGlwTGluZVggPSBtb3VzZUl0ZW0ubm9kZSgpLmdldEJCb3goKS54O1xyXG4gICAgICAgICAgICAgICAgdGlwTGluZVdpZHRoID0gbW91c2VJdGVtLm5vZGUoKS5nZXRCQm94KCkud2lkdGg7XHJcbiAgICAgICAgICAgICAgICB0aXBMaW5lSGVpZ2h0ID0gbW91c2VJdGVtLm5vZGUoKS5nZXRCQm94KCkuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgdGlwTGluZVkgPSBtb3VzZUl0ZW0ubm9kZSgpLmdldEJCb3goKS55O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vRHJhdyBsaW5lIGluIGNlbnRlciBvZiBldmVudC1yZWN0XHJcbiAgICAgICAgICAgICAgICBzdmdcclxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCdsaW5lJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAndGlwLWxpbmUnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsICgpID0+IGNoYXJ0Ll92YXJzLnJvdGF0ZUF4aXMgPyAwIDogdGlwTGluZVggKyB0aXBMaW5lV2lkdGggLyAyKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MicsICgpID0+IGNoYXJ0Ll92YXJzLnJvdGF0ZUF4aXMgPyB0aXBMaW5lV2lkdGggOiB0aXBMaW5lWCArIHRpcExpbmVXaWR0aCAvIDIpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgKCkgPT4gY2hhcnQuX3ZhcnMucm90YXRlQXhpcyA/IHRpcExpbmVZICsgdGlwTGluZUhlaWdodCAvIDIgOiAwKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsICgpID0+IGNoYXJ0Ll92YXJzLnJvdGF0ZUF4aXMgPyB0aXBMaW5lWSArIHRpcExpbmVIZWlnaHQgLyAyIDogdGlwTGluZUhlaWdodClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignZmlsbCcsICdub25lJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignc2hhcGUtcmVuZGVyaW5nJywgJ2NyaXNwRWRnZXMnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCAnYmxhY2snKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCAnMXB4Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICAgIC5vbignbW91c2Vtb3ZlJywgZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgaWYgKGNoYXJ0LnNob3dUb29sVGlwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hhcnQudGlwLmQgPT09IGQgJiYgY2hhcnQudGlwLmkgPT09IGkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGFydC50aXAuc2hvd1RpcCgpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvL0dldCB0aXAgZGF0YVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0aXBEYXRhID0gY2hhcnQuc2V0VGlwRGF0YShkLCBpKTtcclxuICAgICAgICAgICAgICAgICAgICAvL0RyYXcgdGlwIGxpbmVcclxuICAgICAgICAgICAgICAgICAgICBjaGFydC50aXAuZ2VuZXJhdGVTaW1wbGVUaXAodGlwRGF0YSwgY2hhcnQuZGF0YS5kYXRhVGFibGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoY2hhcnQuc2hvd1Rvb2xUaXApIHtcclxuICAgICAgICAgICAgICAgIGNoYXJ0LnRpcC5oaWRlVGlwKCk7XHJcbiAgICAgICAgICAgICAgICBzdmcuc2VsZWN0QWxsKCdsaW5lLnRpcC1saW5lJykucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICBjaGFydC5kaXNwbGF5VmFsdWVzKCk7XHJcbiAgICBjaGFydC5nZW5lcmF0ZUNsaXBQYXRoKCk7XHJcbiAgICBjaGFydC5nZW5lcmF0ZUJhclRocmVzaG9sZCgpO1xyXG59XHJcblxyXG4vKipnZW5lcmF0ZUJhckdyb3Vwc1xyXG4gKlxyXG4gKiBQYWludHMgdGhlIGdyb3VwcyBvZiB0aGUgYmFyc1xyXG4gKiBAcGFyYW1zIGNoYXJ0Q29udGFpbmVyLCBiYXJEYXRhLCBjaGFydFxyXG4gKi9cclxuZnVuY3Rpb24gZ2VuZXJhdGVCYXJHcm91cHMoY2hhcnRDb250YWluZXIsIGJhckRhdGEsIGNoYXJ0KSB7XHJcbiAgICB2YXIgY29udGFpbmVyID0gY2hhcnQuY29uZmlnLmNvbnRhaW5lcixcclxuICAgICAgICB4QXhpc0RhdGEgPSBjaGFydC5jdXJyZW50RGF0YS54QXhpc0RhdGEsXHJcbiAgICAgICAgeUF4aXNEYXRhID0gY2hhcnQuY3VycmVudERhdGEueUF4aXNEYXRhLFxyXG4gICAgICAgIGNvbG9ycyA9IGNoYXJ0Ll92YXJzLmNvbG9yLFxyXG4gICAgICAgIHggPSBqdkNoYXJ0cy5nZXRBeGlzU2NhbGUoJ3gnLCB4QXhpc0RhdGEsIGNvbnRhaW5lciwgY2hhcnQuX3ZhcnMpLFxyXG4gICAgICAgIHkgPSBqdkNoYXJ0cy5nZXRBeGlzU2NhbGUoJ3knLCB5QXhpc0RhdGEsIGNvbnRhaW5lciwgY2hhcnQuX3ZhcnMpLFxyXG4gICAgICAgIHBvc0NhbGMgPSBqdkNoYXJ0cy5nZXRQb3NDYWxjdWxhdGlvbnMoYmFyRGF0YSwgY2hhcnQuX3ZhcnMsIHhBeGlzRGF0YSwgeUF4aXNEYXRhLCBjb250YWluZXIsIGNoYXJ0KSxcclxuICAgICAgICBkYXRhVG9QbG90ID0ganZDaGFydHMuZ2V0UGxvdERhdGEoYmFyRGF0YSwgY2hhcnQpLFxyXG4gICAgICAgIGJhckdyb3VwcyxcclxuICAgICAgICBleHRlcm5hbENvdW50ZXJGb3JKLFxyXG4gICAgICAgIGJhcnM7XHJcblxyXG4gICAgaWYgKHhBeGlzRGF0YS5kYXRhVHlwZSA9PT0gJ1NUUklORycgfHwgIXhBeGlzRGF0YS5oYXNPd25Qcm9wZXJ0eSgnbWluJykpIHtcclxuICAgICAgICAvL0NyZWF0ZXMgYmFyIGdyb3Vwc1xyXG4gICAgICAgIGJhckdyb3VwcyA9IGNoYXJ0Q29udGFpbmVyXHJcbiAgICAgICAgICAgIC5kYXRhKGRhdGFUb1Bsb3QpXHJcbiAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnYmFyLWdyb3VwJylcclxuICAgICAgICAgICAgLy9UcmFuc2xhdGUgdGhlIGJhciBncm91cHMgYnkgKG91dGVyIHBhZGRpbmcgKiBzdGVwKSBhbmQgdGhlIHdpZHRoIG9mIHRoZSBiYXJzIChjb250YWluZXIud2lkdGggLyBiYXJEYXRhLmxlbmd0aCAqIGkpXHJcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAoZCwgaSkgPT4gYHRyYW5zbGF0ZSgke3gucGFkZGluZ091dGVyKCkgKiB4LnN0ZXAoKSArIHguc3RlcCgpICogaX0gLDApYCk7XHJcbiAgICB9IGVsc2UgaWYgKHhBeGlzRGF0YS5kYXRhVHlwZSA9PT0gJ05VTUJFUicpIHtcclxuICAgICAgICAvL0NyZWF0ZXMgYmFyIGdyb3Vwc1xyXG4gICAgICAgIGJhckdyb3VwcyA9IGNoYXJ0Q29udGFpbmVyXHJcbiAgICAgICAgICAgIC5kYXRhKGRhdGFUb1Bsb3QpXHJcbiAgICAgICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnYmFyLWdyb3VwJylcclxuICAgICAgICAgICAgLy9UcmFuc2xhdGUgdGhlIGJhciBncm91cHMgYnkgKG91dGVyIHBhZGRpbmcgKiBzdGVwKSBhbmQgdGhlIHdpZHRoIG9mIHRoZSBiYXJzIChjb250YWluZXIud2lkdGggLyBiYXJEYXRhLmxlbmd0aCAqIGkpXHJcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAoZCwgaSkgPT4gYHRyYW5zbGF0ZSgwLCAke3kucGFkZGluZ091dGVyKCkgKiB5LnN0ZXAoKSArIHkuc3RlcCgpICogaX0gKWApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vQ3JlYXRlcyBiYXJzIHdpdGhpbiBiYXIgZ3JvdXBzXHJcbiAgICBleHRlcm5hbENvdW50ZXJGb3JKID0gLTE7XHJcbiAgICBiYXJzID0gYmFyR3JvdXBzLnNlbGVjdEFsbCgncmVjdCcpXHJcbiAgICAgICAgLmRhdGEoZCA9PiBkKVxyXG4gICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgLmFwcGVuZCgncmVjdCcpXHJcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgKGQsIGkpID0+IHtcclxuICAgICAgICAgICAgbGV0IGtleXMgPSBPYmplY3Qua2V5cyhiYXJEYXRhWzBdKSxcclxuICAgICAgICAgICAgICAgIGZpbHRlcmVkS2V5cyA9IFtdLFxyXG4gICAgICAgICAgICAgICAgbGFiZWwsXHJcbiAgICAgICAgICAgICAgICBsZWdlbmRWYWwsXHJcbiAgICAgICAgICAgICAgICB0aHJlc2hvbGREaXI7XHJcblxyXG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgZXh0ZXJuYWxDb3VudGVyRm9ySisrO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgb2Yga2V5cykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGtleSAhPT0gY2hhcnQuY3VycmVudERhdGEuZGF0YVRhYmxlLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyZWRLZXlzLnB1c2goa2V5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbGFiZWwgPSBTdHJpbmcoYmFyRGF0YVtleHRlcm5hbENvdW50ZXJGb3JKXVtjaGFydC5jdXJyZW50RGF0YS5kYXRhVGFibGUubGFiZWxdKS5yZXBsYWNlKC9cXHMvZywgJ18nKS5yZXBsYWNlKC9cXC4vZywgJ19kb3RfJyk7XHJcbiAgICAgICAgICAgIGxlZ2VuZFZhbCA9IFN0cmluZyhmaWx0ZXJlZEtleXNbaV0pLnJlcGxhY2UoL1xccy9nLCAnXycpLnJlcGxhY2UoL1xcLi9nLCAnX2RvdF8nKTtcclxuICAgICAgICAgICAgdGhyZXNob2xkRGlyO1xyXG5cclxuICAgICAgICAgICAgaWYgKGNoYXJ0Ll92YXJzLnhBeGlzVGhyZXNob2xkKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJlc2hvbGREaXIgPSBjaGFydC5zZXRUaHJlc2hvbGQoYmFyRGF0YVtleHRlcm5hbENvdW50ZXJGb3JKXVtjaGFydC5jdXJyZW50RGF0YS5kYXRhVGFibGUubGFiZWxdKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocmVzaG9sZERpciA9IGNoYXJ0LnNldFRocmVzaG9sZChkKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGBlZGl0YWJsZSBlZGl0YWJsZS1iYXIgYmFyLWNvbC0ke2xhYmVsfS1pbmRleC0ke2xlZ2VuZFZhbH0gaGlnaGxpZ2h0LWNsYXNzLSR7bGFiZWx9IHJlY3QgJHt0aHJlc2hvbGREaXJ9YDtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5hdHRyKCd4JywgKGQsIGkpID0+IHBvc0NhbGMuc3RhcnR4KGQsIGkpKVxyXG4gICAgICAgIC5hdHRyKCd5JywgKGQsIGkpID0+IHBvc0NhbGMuc3RhcnR5KGQsIGkpKVxyXG4gICAgICAgIC5hdHRyKCd3aWR0aCcsIChkLCBpKSA9PiBwb3NDYWxjLnN0YXJ0d2lkdGgoZCwgaSkpXHJcbiAgICAgICAgLmF0dHIoJ2hlaWdodCcsIChkLCBpKSA9PiBwb3NDYWxjLnN0YXJ0aGVpZ2h0KGQsIGkpKVxyXG4gICAgICAgIC5hdHRyKCdmaWxsJywgKGQsIGkpID0+IHtcclxuICAgICAgICAgICAgaWYgKGNoYXJ0Ll92YXJzLnNlcmllc0ZsaXBwZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBqdkNoYXJ0cy5nZXRDb2xvcnMoY29sb3JzLCBpLCBjaGFydC5fdmFycy5mbGlwcGVkTGVnZW5kSGVhZGVyc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGp2Q2hhcnRzLmdldENvbG9ycyhjb2xvcnMsIGksIGNoYXJ0Ll92YXJzLmxlZ2VuZEhlYWRlcnNbaV0pO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmF0dHIoJ3J4JywgMClcclxuICAgICAgICAuYXR0cigncnknLCAwKVxyXG4gICAgICAgIC5hdHRyKCdvcGFjaXR5JywgMC45KVxyXG4gICAgICAgIC5hdHRyKCdjbGlwLXBhdGgnLCBkID0+IGQgPiAzMDAwMDAwMCA/ICd1cmwoI2NsaXAtYWJvdmUpJyA6ICd1cmwoI2NsaXAtYmVsb3cpJyk7XHJcbiAgICBpZiAoY2hhcnQuX3ZhcnMudHJhbnNpdGlvblRpbWUgPiAwKSB7XHJcbiAgICAgICAgYmFyc1xyXG4gICAgICAgICAgICAudHJhbnNpdGlvbigpXHJcbiAgICAgICAgICAgIC5kdXJhdGlvbihjaGFydC5fdmFycy50cmFuc2l0aW9uVGltZSlcclxuICAgICAgICAgICAgLmVhc2UoZDMuZWFzZVBvbHlPdXQpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4JywgKGQsIGksIGopID0+IHBvc0NhbGMueChkLCBpLCBqKSlcclxuICAgICAgICAgICAgLmF0dHIoJ3knLCAoZCwgaSwgaikgPT4gcG9zQ2FsYy55KGQsIGksIGopKVxyXG4gICAgICAgICAgICAuYXR0cignd2lkdGgnLCAoZCwgaSkgPT4gcG9zQ2FsYy53aWR0aChkLCBpKSlcclxuICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIChkLCBpKSA9PiBwb3NDYWxjLmhlaWdodChkLCBpKSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGJhcnNcclxuICAgICAgICAgICAgLmF0dHIoJ3gnLCAoZCwgaSwgaikgPT4gcG9zQ2FsYy54KGQsIGksIGopKVxyXG4gICAgICAgICAgICAuYXR0cigneScsIChkLCBpLCBqKSA9PiBwb3NDYWxjLnkoZCwgaSwgaikpXHJcbiAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIChkLCBpKSA9PiBwb3NDYWxjLndpZHRoKGQsIGkpKVxyXG4gICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgKGQsIGkpID0+IHBvc0NhbGMuaGVpZ2h0KGQsIGkpKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYmFyR3JvdXBzOy8vcmV0dXJucyB0aGUgYmFyIGNvbnRhaW5lcnNcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBqdkNoYXJ0cztcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIganZDaGFydHMgPSByZXF1aXJlKCcuLi9qdkNoYXJ0cy5qcycpLCBib3g7XHJcblxyXG5qdkNoYXJ0cy5wcm90b3R5cGUuYm94d2hpc2tlciA9IHtcclxuICAgIHBhaW50OiBwYWludCxcclxuICAgIHNldERhdGE6IHNldERhdGEsXHJcbiAgICBnZXRFdmVudERhdGE6IGdldEV2ZW50RGF0YVxyXG59O1xyXG5cclxuanZDaGFydHMucHJvdG90eXBlLmdlbmVyYXRlQm94ZXMgPSBnZW5lcmF0ZUJveGVzO1xyXG5cclxuLyoqc2V0Qm94RGF0YVxyXG4gKiAgZ2V0cyBjbG91ZCBkYXRhIGFuZCBhZGRzIGl0IHRvIHRoZSBjaGFydCBvYmplY3RcclxuICpcclxuICogQHBhcmFtcyBkYXRhLCBkYXRhVGFibGUsIGNvbG9yc1xyXG4gKi9cclxuZnVuY3Rpb24gc2V0RGF0YSgpIHtcclxuICAgIHZhciBjaGFydCA9IHRoaXM7XHJcbiAgICBjaGFydC5kYXRhLnhBeGlzRGF0YSA9IGNoYXJ0LnNldEF4aXNEYXRhKCd4JywgY2hhcnQuZGF0YSwgY2hhcnQuX3ZhcnMpO1xyXG4gICAgY2hhcnQuZGF0YS55QXhpc0RhdGEgPSBjaGFydC5zZXRBeGlzRGF0YSgneScsIGNoYXJ0LmRhdGEsIGNoYXJ0Ll92YXJzKTtcclxufVxyXG5cclxuLyoqIHBhaW50Qm94Q2hhcnRcclxuICpcclxuICogIEBkZXNjIFRoZSBpbml0aWFsIHN0YXJ0aW5nIHBvaW50IGZvciBiYXIgY2hhcnQsIGJlZ2lucyB0aGUgZHJhd2luZyBwcm9jZXNzLiBNdXN0IGFscmVhZHkgaGF2ZSB0aGUgZGF0YSBzdG9yZWQgaW4gdGhlIGNoYXJ0IG9iamVjdFxyXG4gKi9cclxuZnVuY3Rpb24gcGFpbnQodHJhbnNpdGlvblRpbWUpIHtcclxuICAgIHZhciBjaGFydCA9IHRoaXMsXHJcbiAgICAgICAgZGF0YU9iaixcclxuICAgICAgICBheGlzRGF0YTtcclxuXHJcbiAgICBpZiAodHJhbnNpdGlvblRpbWUgfHwgdHJhbnNpdGlvblRpbWUgPT09IDApIHtcclxuICAgICAgICBjaGFydC5fdmFycy50cmFuc2l0aW9uVGltZSA9IHRyYW5zaXRpb25UaW1lO1xyXG4gICAgfSBlbHNlIGlmICghY2hhcnQuX3ZhcnMudHJhbnNpdGlvblRpbWUpIHtcclxuICAgICAgICBjaGFydC5fdmFycy50cmFuc2l0aW9uVGltZSA9IDgwMDtcclxuICAgIH1cclxuXHJcbiAgICBkYXRhT2JqID0gZ2V0Qm94RGF0YUZyb21PcHRpb25zKGNoYXJ0KTtcclxuICAgIGF4aXNEYXRhID0gY2hhcnQuZ2V0QmFyRGF0YUZyb21PcHRpb25zKCk7XHJcbiAgICAvL2Fzc2lnbiBjdXJyZW50IGRhdGEgd2hpY2ggaXMgdXNlZCBieSBhbGwgYmFyIGNoYXJ0IG9wZXJhdGlvbnNcclxuICAgIGlmIChjaGFydC5fdmFycy5yb3RhdGVBeGlzKSB7XHJcbiAgICAgICAgY2hhcnQuY3VycmVudERhdGEgPSBkYXRhT2JqO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBjaGFydC5jdXJyZW50RGF0YSA9IGF4aXNEYXRhO1xyXG4gICAgfVxyXG4gICAgLy9PdmVyd3JpdGUgYW55IHByZS1leGlzdGluZyB6b29tXHJcbiAgICBjaGFydC5jb25maWcuem9vbUV2ZW50ID0gbnVsbDtcclxuICAgIC8vZ2VuZXJhdGUgc3ZnIGR5bmFtaWNhbGx5IGJhc2VkIG9uIGxlZ2VuZCBkYXRhXHJcbiAgICBjaGFydC5nZW5lcmF0ZVNWRygpO1xyXG4gICAgY2hhcnQuZ2VuZXJhdGVYQXhpcyhheGlzRGF0YS54QXhpc0RhdGEpO1xyXG4gICAgY2hhcnQuZ2VuZXJhdGVZQXhpcyhheGlzRGF0YS55QXhpc0RhdGEpO1xyXG5cclxuICAgIGNoYXJ0LmdlbmVyYXRlQm94ZXMoZGF0YU9iaik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEV2ZW50RGF0YSgpIHtcclxuICAgIHJldHVybiB7fTtcclxufVxyXG5cclxuLyoqIGdldEJveERhdGFGcm9tT3B0aW9uc1xyXG4gKlxyXG4gKiAgQGRlc2MgQXNzaWducyB0aGUgY29ycmVjdCBjaGFydCBkYXRhIHRvIGN1cnJlbnQgZGF0YSB1c2luZyB0aGUgY2hhcnQuX3ZhcnNcclxuICovXHJcbmZ1bmN0aW9uIGdldEJveERhdGFGcm9tT3B0aW9ucyhjaGFydCkge1xyXG4gICAgLy9jcmVhdGluZyB0aGVzZSB0d28gZGF0YSB2YXJpYWJsZXMgdG8gYXZvaWQgaGF2aW5nIHRvIHJlZmVyZW5jZSB0aGUgY2hhcnQgb2JqZWN0IGV2ZXJ5dGltZVxyXG4gICAgdmFyIGNzdiA9IGNoYXJ0LmRhdGEuY2hhcnREYXRhLFxyXG4gICAgICAgIGRhdGFUYWJsZSA9IGNoYXJ0LmRhdGEuZGF0YVRhYmxlLFxyXG4gICAgICAgIG1pbiA9IEluZmluaXR5LFxyXG4gICAgICAgIG1heCA9IC1JbmZpbml0eSxcclxuICAgICAgICB5QXhpcyA9IFtdLFxyXG4gICAgICAgIGRhdGFPYmogPSB7fSxcclxuICAgICAgICBkYXRhID0ge30sXHJcbiAgICAgICAgeUF4aXNMYWJlbCA9IGRhdGFUYWJsZS5sYWJlbCxcclxuICAgICAgICB4QXhpc0xhYmVsID0gZGF0YVRhYmxlLnZhbHVlLFxyXG4gICAgICAgIHhBeGlzRGF0YSxcclxuICAgICAgICB5QXhpc0RhdGEsXHJcblxyXG4gICAgICAgIGtleXMgPSBjc3YubWFwKGQgPT4gZFt5QXhpc0xhYmVsXSksXHJcbiAgICAgICAga2V5czIgPSBjc3YubWFwKGQgPT4gZFt4QXhpc0xhYmVsXSksXHJcbiAgICAgICAgdW5pcXVlID0ga2V5cy5maWx0ZXIoKGl0ZW0sIGksIGFyKSA9PiBhci5pbmRleE9mKGl0ZW0pID09PSBpKSxcclxuICAgICAgICB0ZW1wID0gW107XHJcblxyXG4gICAgZm9yIChsZXQgdW5pcXVlRWxlIG9mIHVuaXF1ZSkge1xyXG4gICAgICAgIGxldCB0ZW1wRGF0YSA9IGNzdi5maWx0ZXIoZCA9PiBkW3lBeGlzTGFiZWxdID09PSB1bmlxdWVFbGUpO1xyXG4gICAgICAgIHRlbXAucHVzaChbdW5pcXVlRWxlLCB0ZW1wRGF0YS5tYXAoZCA9PiBkW3hBeGlzTGFiZWxdKV0pO1xyXG4gICAgfVxyXG5cclxuICAgIG1heCA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIGtleXMyKTtcclxuICAgIG1pbiA9IE1hdGgubWluLmFwcGx5KE1hdGgsIGtleXMyKTtcclxuICAgIHlBeGlzLnB1c2gobWluKTtcclxuICAgIHlBeGlzLnB1c2gobWF4KTtcclxuXHJcbiAgICB4QXhpc0RhdGEgPSB7ICdsYWJlbCc6IHlBeGlzTGFiZWwsICdkYXRhVHlwZSc6ICdTVFJJTkcnLCAndmFsdWVzJzogdW5pcXVlIH07XHJcbiAgICB5QXhpc0RhdGEgPSB7ICdsYWJlbCc6IHhBeGlzTGFiZWwsICdkYXRhVHlwZSc6ICdOVU1CRVInLCAndmFsdWVzJzogeUF4aXMgfTtcclxuXHJcbiAgICBkYXRhT2JqLmNoYXJ0RGF0YSA9IHRlbXA7XHJcbiAgICBkYXRhT2JqLmRhdGFUYWJsZSA9IGRhdGEuZGF0YVRhYmxlO1xyXG4gICAgY2hhcnQuX3ZhcnMuY29sb3IgPSBkYXRhLmNvbG9yO1xyXG5cclxuICAgIGRhdGFPYmoueEF4aXNEYXRhID0geEF4aXNEYXRhO1xyXG4gICAgZGF0YU9iai55QXhpc0RhdGEgPSB5QXhpc0RhdGE7XHJcbiAgICBkYXRhID0ge1xyXG4gICAgICAgIHlBeGlzRGF0YTogZGF0YU9iai55QXhpc0RhdGEsXHJcbiAgICAgICAgeEF4aXNEYXRhOiBkYXRhT2JqLnhBeGlzRGF0YVxyXG4gICAgfTtcclxuXHJcbiAgICBpZiAoY2hhcnQuX3ZhcnMucm90YXRlQXhpcykge1xyXG4gICAgICAgIGRhdGFPYmoueEF4aXNEYXRhID0gZGF0YS55QXhpc0RhdGE7XHJcbiAgICAgICAgZGF0YU9iai55QXhpc0RhdGEgPSBkYXRhLnhBeGlzRGF0YTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZGF0YU9iai54QXhpc0RhdGEgPSBkYXRhLnhBeGlzRGF0YTtcclxuICAgICAgICBkYXRhT2JqLnlBeGlzRGF0YSA9IGRhdGEueUF4aXNEYXRhO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBkYXRhT2JqO1xyXG59XHJcblxyXG4vKiogZ2VuZXJhdGVCYXJzXHJcbiAqXHJcbiAqIEBkZXNjIERvZXMgdGhlIGFjdHVhbCBwYWludGluZyBvZiBiYXJzIG9uIHRoZSBiYXIgY2hhcnRcclxuICogQHBhcmFtcyBib3hEYXRhXHJcbiAqL1xyXG5mdW5jdGlvbiBnZW5lcmF0ZUJveGVzKGJveERhdGEpIHtcclxuICAgIHZhciBjaGFydCA9IHRoaXMsXHJcbiAgICAgICAgc3ZnID0gY2hhcnQuc3ZnLFxyXG4gICAgICAgIG9wdGlvbnMgPSBjaGFydC5fdmFycyxcclxuICAgICAgICBjb250YWluZXIgPSBjaGFydC5jb25maWcuY29udGFpbmVyLFxyXG4gICAgICAgIGhlaWdodCA9IGNvbnRhaW5lci5oZWlnaHQsXHJcbiAgICAgICAgd2lkdGggPSBjb250YWluZXIud2lkdGgsXHJcbiAgICAgICAgeCxcclxuICAgICAgICBib3hDaGFydCxcclxuICAgICAgICBtYXJnaW4gPSB7IHRvcDogMCwgcmlnaHQ6IDUwLCBib3R0b206IDcwLCBsZWZ0OiA1MCB9O1xyXG5cclxuICAgIGlmIChvcHRpb25zLnJvdGF0ZUF4aXMpIHtcclxuICAgICAgICB4ID0gZDMuc2NhbGVCYW5kKClcclxuICAgICAgICAgICAgLmRvbWFpbihib3hEYXRhLmNoYXJ0RGF0YS5tYXAoZCA9PiBkWzBdKSlcclxuICAgICAgICAgICAgLnJhbmdlUm91bmQoWzAsIGhlaWdodF0pXHJcbiAgICAgICAgICAgIC5wYWRkaW5nSW5uZXIoMC43KVxyXG4gICAgICAgICAgICAucGFkZGluZ091dGVyKDAuMyk7XHJcbiAgICAgICAgYm94Q2hhcnQgPSBib3goKVxyXG4gICAgICAgICAgICAud2hpc2tlcnMoaXFyKDEuNSkpXHJcbiAgICAgICAgICAgIC5oZWlnaHQod2lkdGgpXHJcbiAgICAgICAgICAgIC5kb21haW4oW2JveERhdGEueEF4aXNEYXRhLnZhbHVlc1swXSwgYm94RGF0YS54QXhpc0RhdGEudmFsdWVzWzFdXSlcclxuICAgICAgICAgICAgLnNob3dMYWJlbHMob3B0aW9ucy5kaXNwbGF5VmFsdWVzKVxyXG4gICAgICAgICAgICAuZmxpcHBlZChvcHRpb25zLnJvdGF0ZUF4aXMpXHJcbiAgICAgICAgICAgIC5kdXJhdGlvbihvcHRpb25zLnRyYW5zaXRpb25UaW1lKVxyXG4gICAgICAgICAgICAuY2hhcnQoY2hhcnQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB4ID0gZDMuc2NhbGVCYW5kKClcclxuICAgICAgICAgICAgLmRvbWFpbihib3hEYXRhLmNoYXJ0RGF0YS5tYXAoZCA9PiBkWzBdKSlcclxuICAgICAgICAgICAgLnJhbmdlUm91bmQoWzAsIHdpZHRoXSlcclxuICAgICAgICAgICAgLnBhZGRpbmdJbm5lcigwLjcpXHJcbiAgICAgICAgICAgIC5wYWRkaW5nT3V0ZXIoMC4zKTtcclxuICAgICAgICBib3hDaGFydCA9IGJveCgpXHJcbiAgICAgICAgICAgIC53aGlza2VycyhpcXIoMS41KSlcclxuICAgICAgICAgICAgLmhlaWdodChoZWlnaHQpXHJcbiAgICAgICAgICAgIC5kb21haW4oW2JveERhdGEueUF4aXNEYXRhLnZhbHVlc1swXSwgYm94RGF0YS55QXhpc0RhdGEudmFsdWVzWzFdXSlcclxuICAgICAgICAgICAgLnNob3dMYWJlbHMob3B0aW9ucy5kaXNwbGF5VmFsdWVzKVxyXG4gICAgICAgICAgICAuZmxpcHBlZChvcHRpb25zLnJvdGF0ZUF4aXMpXHJcbiAgICAgICAgICAgIC5kdXJhdGlvbihvcHRpb25zLnRyYW5zaXRpb25UaW1lKVxyXG4gICAgICAgICAgICAuY2hhcnQoY2hhcnQpO1xyXG4gICAgfVxyXG4gICAgLy9kcmF3IHRoZSBib3hwbG90c1xyXG4gICAgc3ZnLmF0dHIoJ2NsYXNzJywgJ2JveHdoaXNrZXItY29udGFpbmVyJylcclxuICAgICAgICAuc2VsZWN0QWxsKCcuYm94JylcclxuICAgICAgICAuZGF0YShib3hEYXRhLmNoYXJ0RGF0YSlcclxuICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICdib3gtY29udGFpbmVyJylcclxuICAgICAgICAuYXR0cignc3R5bGUnLCAncG9pbnRlci1ldmVudHM6IGFsbDsnKVxyXG4gICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBkID0+IG9wdGlvbnMucm90YXRlQXhpcyA/IGB0cmFuc2xhdGUoJHttYXJnaW4udG9wfSwgJHt4KGRbMF0pfSlgIDogYHRyYW5zbGF0ZSgke3goZFswXSl9LCAke21hcmdpbi50b3B9KWApXHJcbiAgICAgICAgLmNhbGwoYm94Q2hhcnQud2lkdGgoeC5iYW5kd2lkdGgoKSkpO1xyXG5cclxuICAgIGQzLnNlbGVjdEFsbCgncmVjdC5ib3gnKS5hdHRyKCdjbGFzcycsIChkLCBpKSA9PmBlZGl0YWJsZSBlZGl0YWJsZS1ib3ggYm94LSR7aX0gaGlnaGxpZ2h0LWNsYXNzLSR7aX1ib3hgKTtcclxuICAgIGhpZGVMYWJlbHNPbk92ZXJsYXAoeCwgd2lkdGgsIHN2Zyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAbmFtZSBoaWRlTGFiZWxzT25PdmVybGFwXHJcbiAqIEBkZXNjIGRldGVybWluZXMgaWYgdGV4dCBvbiBncmFwaCBzaG91bGQgYmUgZGlzcGxheWVkIG9yIG5vdFxyXG4gKi9cclxuZnVuY3Rpb24gaGlkZUxhYmVsc09uT3ZlcmxhcCh4LCB3aWR0aCwgc3ZnKSB7XHJcbiAgICB2YXIgbnVtU3BhY2VzQmV0d2VlbiA9IHguZG9tYWluKCkubGVuZ3RoIC0gMSxcclxuICAgICAgICB0b3RhbEJveFdpZHRoID0geC5iYW5kd2lkdGgoKSAqIHguZG9tYWluKCkubGVuZ3RoLFxyXG4gICAgICAgIHdpZHRoT2ZTcGFjZXMgPSAod2lkdGggLSB0b3RhbEJveFdpZHRoKSAvIG51bVNwYWNlc0JldHdlZW4sXHJcbiAgICAgICAgeEF4aXNMYWJlbExlbmd0aExpbWl0ID0geC5iYW5kd2lkdGgoKSArIHdpZHRoT2ZTcGFjZXMsXHJcbiAgICAgICAgdGlja3MgPSBzdmcuc2VsZWN0QWxsKCcueEF4aXMgdGV4dCcpO1xyXG5cclxuICAgIHRpY2tzLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmdldEJCb3goKS53aWR0aCA+IHhBeGlzTGFiZWxMZW5ndGhMaW1pdCkge1xyXG4gICAgICAgICAgICBzdmcuc2VsZWN0QWxsKCcueEF4aXMgdGV4dCcpXHJcbiAgICAgICAgICAgICAgICAuYXR0cignc3R5bGUnLCAnZGlzcGxheTpub25lJyk7XHJcbiAgICAgICAgICAgIHN2Zy5zZWxlY3RBbGwoJ3RleHQuYm94JylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdzdHlsZScsICdkaXNwbGF5Om5vbmUnKTtcclxuICAgICAgICAgICAgc3ZnLnNlbGVjdEFsbCgndGV4dC53aGlza2VyJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdzdHlsZScsICdkaXNwbGF5Om5vbmUnKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBuYW1lIGlxclxyXG4gKiBAZGVzYyBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gY29tcHV0ZSB0aGUgaW50ZXJxdWFydGlsZSByYW5nZS5cclxuICovXHJcbmZ1bmN0aW9uIGlxcihrKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICB2YXIgcTEgPSBkLnF1YXJ0aWxlc1swXSxcclxuICAgICAgICAgICAgcTMgPSBkLnF1YXJ0aWxlc1syXSxcclxuICAgICAgICAgICAgaXFyID0gKHEzIC0gcTEpICogayxcclxuICAgICAgICAgICAgaSA9IC0xLFxyXG4gICAgICAgICAgICBqID0gZC5sZW5ndGg7XHJcbiAgICAgICAgd2hpbGUgKGRbKytpXSA8IHExIC0gaXFyKTtcclxuICAgICAgICB3aGlsZSAoZFstLWpdID4gcTMgKyBpcXIpO1xyXG4gICAgICAgIHJldHVybiBbaSwgal07XHJcbiAgICB9O1xyXG59XHJcblxyXG4vL0luc3BpcmVkIGJ5IGh0dHA6Ly9pbmZvcm1hdGlvbmFuZHZpc3VhbGl6YXRpb24uZGUvYmxvZy9ib3gtcGxvdFxyXG5ib3ggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgd2lkdGggPSAxLFxyXG4gICAgICAgIGhlaWdodCA9IDEsXHJcbiAgICAgICAgZHVyYXRpb24gPSAwLFxyXG4gICAgICAgIGRvbWFpbiA9IG51bGwsXHJcbiAgICAgICAgdmFsdWUgPSBOdW1iZXIsXHJcbiAgICAgICAgd2hpc2tlcnMgPSBib3hXaGlza2VycyxcclxuICAgICAgICBxdWFydGlsZXMgPSBib3hRdWFydGlsZXMsXHJcbiAgICAgICAgc2hvd0xhYmVscyA9IHRydWUsIC8vd2hldGhlciBvciBub3QgdG8gc2hvdyB0ZXh0IGxhYmVsc1xyXG4gICAgICAgIG51bUJhcnMgPSA0LFxyXG4gICAgICAgIGN1ckJhciA9IDEsXHJcbiAgICAgICAgdGlja0Zvcm1hdCA9IG51bGwsXHJcbiAgICAgICAgY2hhcnQgPSB7fSxcclxuICAgICAgICBmbGlwcGVkID0gZmFsc2U7XHJcblxyXG4gICAgLy9Gb3IgZWFjaCBzbWFsbCBtdWx0aXBsZeKAplxyXG4gICAgZnVuY3Rpb24gYm94KGcpIHtcclxuICAgICAgICBnLmVhY2goZnVuY3Rpb24gKGRhdGEsIGkpIHtcclxuICAgICAgICAgICAgdmFyIGQgPSBkYXRhWzFdLnNvcnQoZDMuYXNjZW5kaW5nKSxcclxuICAgICAgICAgICAgICAgIGcgPSBkMy5zZWxlY3QodGhpcyksXHJcbiAgICAgICAgICAgICAgICBuID0gZC5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICBtaW4gPSBkWzBdLFxyXG4gICAgICAgICAgICAgICAgbWF4ID0gZFtuIC0gMV0sXHJcbiAgICAgICAgICAgICAgICBvdXRsaWVyTGFiZWwgPSBkYXRhWzBdO1xyXG5cclxuICAgICAgICAgICAgLy9Db21wdXRlIHF1YXJ0aWxlcy4gTXVzdCByZXR1cm4gZXhhY3RseSAzIGVsZW1lbnRzLlxyXG4gICAgICAgICAgICB2YXIgcXVhcnRpbGVEYXRhID0gZC5xdWFydGlsZXMgPSBxdWFydGlsZXMoZCk7XHJcblxyXG4gICAgICAgICAgICAvL0NvbXB1dGUgd2hpc2tlcnMuIE11c3QgcmV0dXJuIGV4YWN0bHkgMiBlbGVtZW50cywgb3IgbnVsbC5cclxuICAgICAgICAgICAgdmFyIHdoaXNrZXJJbmRpY2VzID0gd2hpc2tlcnMgJiYgd2hpc2tlcnMuY2FsbCh0aGlzLCBkLCBpKSxcclxuICAgICAgICAgICAgICAgIHdoaXNrZXJEYXRhID0gd2hpc2tlckluZGljZXMgJiYgd2hpc2tlckluZGljZXMubWFwKGZ1bmN0aW9uIChpKSB7IHJldHVybiBkW2ldOyB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vQ29tcHV0ZSBvdXRsaWVycy4gSWYgbm8gd2hpc2tlcnMgYXJlIHNwZWNpZmllZCwgYWxsIGRhdGEgYXJlICdvdXRsaWVycycuXHJcbiAgICAgICAgICAgIC8vV2UgY29tcHV0ZSB0aGUgb3V0bGllcnMgYXMgaW5kaWNlcywgc28gdGhhdCB3ZSBjYW4gam9pbiBhY3Jvc3MgdHJhbnNpdGlvbnMhXHJcbiAgICAgICAgICAgIHZhciBvdXRsaWVySW5kaWNlcyA9IHdoaXNrZXJJbmRpY2VzXHJcbiAgICAgICAgICAgICAgICA/IGQzLnJhbmdlKDAsIHdoaXNrZXJJbmRpY2VzWzBdKS5jb25jYXQoZDMucmFuZ2Uod2hpc2tlckluZGljZXNbMV0gKyAxLCBuKSlcclxuICAgICAgICAgICAgICAgIDogZDMucmFuZ2Uobik7XHJcblxyXG4gICAgICAgICAgICAvL0NvbXB1dGUgdGhlIG5ldyB4LXNjYWxlLlxyXG4gICAgICAgICAgICBpZiAoZmxpcHBlZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHgxID0gZDMuc2NhbGVMaW5lYXIoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5kb21haW4oZG9tYWluICYmIGRvbWFpbi5jYWxsKHRoaXMsIGQsIGkpIHx8IFttaW4sIG1heF0pXHJcbiAgICAgICAgICAgICAgICAgICAgLnJhbmdlKFswLCBoZWlnaHRdKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciB4MSA9IGQzLnNjYWxlTGluZWFyKClcclxuICAgICAgICAgICAgICAgICAgICAuZG9tYWluKGRvbWFpbiAmJiBkb21haW4uY2FsbCh0aGlzLCBkLCBpKSB8fCBbbWluLCBtYXhdKVxyXG4gICAgICAgICAgICAgICAgICAgIC5yYW5nZShbaGVpZ2h0LCAwXSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vUmV0cmlldmUgdGhlIG9sZCB4LXNjYWxlLCBpZiB0aGlzIGlzIGFuIHVwZGF0ZS5cclxuICAgICAgICAgICAgdmFyIHgwID0gdGhpcy5fX2NoYXJ0X18gfHwgZDMuc2NhbGVMaW5lYXIoKVxyXG4gICAgICAgICAgICAgICAgLmRvbWFpbihbMCwgSW5maW5pdHldKVxyXG4gICAgICAgICAgICAgICAgLy8uZG9tYWluKFswLCBtYXhdKVxyXG4gICAgICAgICAgICAgICAgLnJhbmdlKHgxLnJhbmdlKCkpO1xyXG5cclxuICAgICAgICAgICAgLy9TdGFzaCB0aGUgbmV3IHNjYWxlLlxyXG4gICAgICAgICAgICB0aGlzLl9fY2hhcnRfXyA9IHgxO1xyXG5cclxuICAgICAgICAgICAgLy9Ob3RlOiB0aGUgYm94LCBtZWRpYW4sIGFuZCBib3ggdGljayBlbGVtZW50cyBhcmUgZml4ZWQgaW4gbnVtYmVyLFxyXG4gICAgICAgICAgICAvL3NvIHdlIG9ubHkgaGF2ZSB0byBoYW5kbGUgZW50ZXIgYW5kIHVwZGF0ZS4gSW4gY29udHJhc3QsIHRoZSBvdXRsaWVyc1xyXG4gICAgICAgICAgICAvL2FuZCBvdGhlciBlbGVtZW50cyBhcmUgdmFyaWFibGUsIHNvIHdlIG5lZWQgdG8gZXhpdCB0aGVtISBWYXJpYWJsZVxyXG4gICAgICAgICAgICAvL2VsZW1lbnRzIGFsc28gZmFkZSBpbiBhbmQgb3V0LlxyXG5cclxuICAgICAgICAgICAgLy9VcGRhdGUgb3V0bGllcnMuXHJcbiAgICAgICAgICAgIHZhciBvdXRsaWVyID0gZy5zZWxlY3RBbGwoJ2NpcmNsZS5vdXRsaWVyJylcclxuICAgICAgICAgICAgICAgIC5kYXRhKG91dGxpZXJJbmRpY2VzLCBOdW1iZXIpO1xyXG5cclxuICAgICAgICAgICAgb3V0bGllciA9IG91dGxpZXIuZW50ZXIoKS5hcHBlbmQoJ2cnKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChmbGlwcGVkKSB7XHJcbiAgICAgICAgICAgICAgICBvdXRsaWVyLmluc2VydCgnY2lyY2xlJywgJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdvdXRsaWVyJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignZmlsbCcsICd3aGl0ZScpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3InLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3aWR0aCA+IDEwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gNTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpZHRoIC8gMjtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjeScsIHdpZHRoIC8gMilcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY3gnLCBmdW5jdGlvbiAoaSkgeyByZXR1cm4geDAoZFtpXSk7IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMWUtNilcclxuICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbigpXHJcbiAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKGR1cmF0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjeCcsIGZ1bmN0aW9uIChpKSB7IHJldHVybiB4MShkW2ldKTsgfSlcclxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAxKTtcclxuXHJcbiAgICAgICAgICAgICAgICBvdXRsaWVyLmFwcGVuZCgndGV4dCcpLnRleHQoZnVuY3Rpb24gKGkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZFtpXTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAod2lkdGggLyAyKSArIDcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBmdW5jdGlvbiAoaSkgeyByZXR1cm4geDEoZFtpXSkgKyA0OyB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdvdXRsaWVyLWxhYmVsJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignZm9udC1zaXplJywgJzEwcHgnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdzdHlsZScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzaG93TGFiZWxzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2Rpc3BsYXk6bm9uZTsnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBvdXRsaWVyLmV4aXQoKS50cmFuc2l0aW9uKClcclxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oZHVyYXRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2N4JywgZnVuY3Rpb24gKGkpIHsgcmV0dXJuIHgxKGRbaV0pOyB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDFlLTYpXHJcbiAgICAgICAgICAgICAgICAgICAgLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgb3V0bGllci5pbnNlcnQoJ2NpcmNsZScsICd0ZXh0JylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnb3V0bGllcicpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCAnd2hpdGUnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdyJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod2lkdGggPiAxMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3aWR0aCAvIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY3gnLCB3aWR0aCAvIDIpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2N5JywgZnVuY3Rpb24gKGkpIHsgcmV0dXJuIHgwKGRbaV0pOyB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDFlLTYpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxyXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbihkdXJhdGlvbilcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY3knLCBmdW5jdGlvbiAoaSkgeyByZXR1cm4geDEoZFtpXSk7IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMSk7XHJcblxyXG4gICAgICAgICAgICAgICAgb3V0bGllci5hcHBlbmQoJ3RleHQnKS50ZXh0KGZ1bmN0aW9uIChpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRbaV07XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgKHdpZHRoIC8gMikgKyA3KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgZnVuY3Rpb24gKGkpIHsgcmV0dXJuIHgxKGRbaV0pICsgNDsgfSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnb3V0bGllci1sYWJlbCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2ZvbnQtc2l6ZScsICcxMHB4JylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignc3R5bGUnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2hvd0xhYmVscykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdkaXNwbGF5Om5vbmU7JztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIG91dGxpZXIudHJhbnNpdGlvbigpXHJcbiAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKGR1cmF0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjeScsIGZ1bmN0aW9uIChpKSB7IHJldHVybiB4MShkW2ldKTsgfSlcclxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAxKTtcclxuXHJcbiAgICAgICAgICAgICAgICBvdXRsaWVyLmV4aXQoKS50cmFuc2l0aW9uKClcclxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oZHVyYXRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2N5JywgZnVuY3Rpb24gKGkpIHsgcmV0dXJuIHgxKGRbaV0pOyB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDFlLTYpXHJcbiAgICAgICAgICAgICAgICAgICAgLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBvdXRsaWVyXHJcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uIChpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJ0LnNob3dUb29sVGlwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG91dGxpZXIgPSBbZFtpXV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB7IE91dGxpZXI6IG91dGxpZXIsIExhYmVsOiBvdXRsaWVyTGFiZWwgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGlwRGF0YSA9IGNoYXJ0LnNldFRpcERhdGEoZGF0YSwgaSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFydC50aXAuZ2VuZXJhdGVTaW1wbGVUaXAodGlwRGF0YSwgZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJ0LnRpcC5kID0gZC5kYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFydC50aXAuaSA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5vbignbW91c2Vtb3ZlJywgZnVuY3Rpb24gKGkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhcnQuc2hvd1Rvb2xUaXApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3V0bGllciA9IFtkW2ldXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHsgT3V0bGllcjogb3V0bGllciwgTGFiZWw6IG91dGxpZXJMYWJlbCB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0aXBEYXRhID0gY2hhcnQuc2V0VGlwRGF0YShkYXRhLCBpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJ0LnRpcC5nZW5lcmF0ZVNpbXBsZVRpcCh0aXBEYXRhLCBkYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhcnQudGlwLmQgPSBkLmRhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJ0LnRpcC5pID0gaTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhcnQuc2hvd1Rvb2xUaXApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhcnQudGlwLmhpZGVUaXAoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vc2V0IHNlcGFyYXRlIHRvb2x0aXBzIGZvciBxdWFydGlsZXMgYW5kIHdoaXNrZXJzXHJcbiAgICAgICAgICAgIGcgPSBnLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ2lubmVyLWJveC1jb250YWluZXInKVxyXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAobGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhcnQuc2hvd1Rvb2xUaXApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFF1YXJ0aWxlczogZC5xdWFydGlsZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBXaGlza2Vyczogd2hpc2tlckRhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBMYWJlbDogbGFiZWxbMF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGlwRGF0YSA9IGNoYXJ0LnNldFRpcERhdGEoZGF0YSwgaSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFydC50aXAuZ2VuZXJhdGVTaW1wbGVUaXAodGlwRGF0YSwgZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJ0LnRpcC5kID0gZC5kYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFydC50aXAuaSA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5vbignbW91c2Vtb3ZlJywgZnVuY3Rpb24gKGxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJ0LnNob3dUb29sVGlwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBRdWFydGlsZXM6IGQucXVhcnRpbGVzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgV2hpc2tlcnM6IHdoaXNrZXJEYXRhLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTGFiZWw6IGxhYmVsWzBdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpcERhdGEgPSBjaGFydC5zZXRUaXBEYXRhKGRhdGEsIGkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhcnQudGlwLmdlbmVyYXRlU2ltcGxlVGlwKHRpcERhdGEsIGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFydC50aXAuZCA9IGQuZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhcnQudGlwLmkgPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlbGVhdmUnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJ0LnNob3dUb29sVGlwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJ0LnRpcC5oaWRlVGlwKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICAgICAgLy9VcGRhdGUgY2VudGVyIGxpbmU6IHRoZSB2ZXJ0aWNhbCBsaW5lIHNwYW5uaW5nIHRoZSB3aGlza2Vycy5cclxuICAgICAgICAgICAgdmFyIGNlbnRlciA9IGcuc2VsZWN0QWxsKCdsaW5lLmNlbnRlcicpXHJcbiAgICAgICAgICAgICAgICAuZGF0YSh3aGlza2VyRGF0YSA/IFt3aGlza2VyRGF0YV0gOiBbXSk7XHJcbiAgICAgICAgICAgIC8vdmVydGljYWwgbGluZVxyXG4gICAgICAgICAgICBpZiAoZmxpcHBlZCkge1xyXG4gICAgICAgICAgICAgICAgY2VudGVyLmVudGVyKCkuaW5zZXJ0KCdsaW5lJywgJ3JlY3QnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdjZW50ZXInKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIHdpZHRoIC8gMilcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDEnLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4geDAoZFswXSk7IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kyJywgd2lkdGggLyAyKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MicsIGZ1bmN0aW9uIChkKSB7IHJldHVybiB4MChkWzFdKTsgfSlcclxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAxZS02KVxyXG4gICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKClcclxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oZHVyYXRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDEnLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4geDEoZFswXSk7IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIHgxKGRbMV0pOyB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICBjZW50ZXIudHJhbnNpdGlvbigpXHJcbiAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKGR1cmF0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDEpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gxJywgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIHgxKGRbMF0pOyB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MicsIGZ1bmN0aW9uIChkKSB7IHJldHVybiB4MShkWzFdKTsgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgY2VudGVyLmV4aXQoKS50cmFuc2l0aW9uKClcclxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oZHVyYXRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMWUtNilcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDEnLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4geDEoZFswXSk7IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIHgxKGRbMV0pOyB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5yZW1vdmUoKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNlbnRlci5lbnRlcigpLmluc2VydCgnbGluZScsICdyZWN0JylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnY2VudGVyJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDEnLCB3aWR0aCAvIDIpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIHgwKGRbMF0pOyB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MicsIHdpZHRoIC8gMilcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneTInLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4geDAoZFsxXSk7IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMWUtNilcclxuICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbigpXHJcbiAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKGR1cmF0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDEpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIHgxKGRbMF0pOyB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIGZ1bmN0aW9uIChkKSB7IHJldHVybiB4MShkWzFdKTsgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgY2VudGVyLnRyYW5zaXRpb24oKVxyXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbihkdXJhdGlvbilcclxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAxKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIGZ1bmN0aW9uIChkKSB7IHJldHVybiB4MShkWzBdKTsgfSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneTInLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4geDEoZFsxXSk7IH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGNlbnRlci5leGl0KCkudHJhbnNpdGlvbigpXHJcbiAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKGR1cmF0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDFlLTYpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIHgxKGRbMF0pOyB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIGZ1bmN0aW9uIChkKSB7IHJldHVybiB4MShkWzFdKTsgfSlcclxuICAgICAgICAgICAgICAgICAgICAucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBob3ZlckFyZWEgPSBnLnNlbGVjdEFsbCgnbGluZS5ob3Zlci1hcmVhJylcclxuICAgICAgICAgICAgICAgIC5kYXRhKHdoaXNrZXJEYXRhID8gW3doaXNrZXJEYXRhXSA6IFtdKTtcclxuICAgICAgICAgICAgLy92ZXJ0aWNhbCBsaW5lXHJcbiAgICAgICAgICAgIGlmIChmbGlwcGVkKSB7XHJcbiAgICAgICAgICAgICAgICBob3ZlckFyZWEuZW50ZXIoKS5pbnNlcnQoJ2xpbmUnLCAncmVjdCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2hvdmVyLWFyZWEnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIHdpZHRoIC8gMilcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDEnLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4geDAoZFswXSk7IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kyJywgd2lkdGggLyAyKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MicsIGZ1bmN0aW9uIChkKSB7IHJldHVybiB4MChkWzFdKTsgfSlcclxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAwKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlLXdpZHRoJywgd2lkdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxyXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbihkdXJhdGlvbilcclxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAwKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsIGZ1bmN0aW9uIChkKSB7IHJldHVybiB4MShkWzBdKTsgfSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDInLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4geDEoZFsxXSk7IH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGhvdmVyQXJlYS50cmFuc2l0aW9uKClcclxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oZHVyYXRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDEnLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4geDEoZFswXSk7IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIHgxKGRbMV0pOyB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICBob3ZlckFyZWEuZXhpdCgpLnRyYW5zaXRpb24oKVxyXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbihkdXJhdGlvbilcclxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAwKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsIGZ1bmN0aW9uIChkKSB7IHJldHVybiB4MShkWzBdKTsgfSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDInLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4geDEoZFsxXSk7IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaG92ZXJBcmVhLmVudGVyKCkuaW5zZXJ0KCdsaW5lJywgJ3JlY3QnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdob3Zlci1hcmVhJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDEnLCB3aWR0aCAvIDIpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIHgwKGRbMF0pOyB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MicsIHdpZHRoIC8gMilcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneTInLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4geDAoZFsxXSk7IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMClcclxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZS13aWR0aCcsIHdpZHRoKVxyXG4gICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKClcclxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oZHVyYXRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneTEnLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4geDEoZFswXSk7IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kyJywgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIHgxKGRbMV0pOyB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICBob3ZlckFyZWEudHJhbnNpdGlvbigpXHJcbiAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKGR1cmF0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDApXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIHgxKGRbMF0pOyB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIGZ1bmN0aW9uIChkKSB7IHJldHVybiB4MShkWzFdKTsgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaG92ZXJBcmVhLmV4aXQoKS50cmFuc2l0aW9uKClcclxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oZHVyYXRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneTEnLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4geDEoZFswXSk7IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kyJywgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIHgxKGRbMV0pOyB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5yZW1vdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL1VwZGF0ZSBpbm5lcnF1YXJ0aWxlIGJveC5cclxuICAgICAgICAgICAgdmFyIGJveCA9IGcuc2VsZWN0QWxsKCdyZWN0LmJveCcpXHJcbiAgICAgICAgICAgICAgICAuZGF0YShbcXVhcnRpbGVEYXRhXSk7XHJcbiAgICAgICAgICAgIGlmIChmbGlwcGVkKSB7XHJcbiAgICAgICAgICAgICAgICBib3guZW50ZXIoKS5hcHBlbmQoJ3JlY3QnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgJ3N0ZWVsYmx1ZScpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2JveCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAwKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIHgwKGRbMl0pIC0gTWF0aC5hYnMoeDAoZFswXSkgLSB4MChkWzJdKSk7IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIHdpZHRoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIGZ1bmN0aW9uIChkKSB7IHJldHVybiBNYXRoLmFicyh4MChkWzBdKSAtIHgwKGRbMl0pKTsgfSlcclxuICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbigpXHJcbiAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKGR1cmF0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIHgxKGRbMl0pIC0gTWF0aC5hYnMoeDEoZFswXSkgLSB4MShkWzJdKSk7IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIE1hdGguYWJzKHgxKGRbMF0pIC0geDEoZFsyXSkpOyB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICBib3gudHJhbnNpdGlvbigpXHJcbiAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKGR1cmF0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIHgxKGRbMl0pIC0gTWF0aC5hYnMoeDEoZFswXSkgLSB4MShkWzJdKSk7IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIE1hdGguYWJzKHgxKGRbMF0pIC0geDEoZFsyXSkpOyB9KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGJveC5lbnRlcigpLmFwcGVuZCgncmVjdCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCAnc3RlZWxibHVlJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnYm94JylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIDApXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4geDAoZFsyXSk7IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgd2lkdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGZ1bmN0aW9uIChkKSB7IHJldHVybiB4MChkWzBdKSAtIHgwKGRbMl0pOyB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKClcclxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oZHVyYXRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4geDEoZFsyXSk7IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGZ1bmN0aW9uIChkKSB7IHJldHVybiB4MShkWzBdKSAtIHgxKGRbMl0pOyB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICBib3gudHJhbnNpdGlvbigpXHJcbiAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKGR1cmF0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIHgxKGRbMl0pOyB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4geDEoZFswXSkgLSB4MShkWzJdKTsgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9VcGRhdGUgbWVkaWFuIGxpbmUuXHJcbiAgICAgICAgICAgIHZhciBtZWRpYW5MaW5lID0gZy5zZWxlY3RBbGwoJ2xpbmUubWVkaWFuJylcclxuICAgICAgICAgICAgICAgIC5kYXRhKFtxdWFydGlsZURhdGFbMV1dKTtcclxuICAgICAgICAgICAgaWYgKGZsaXBwZWQpIHtcclxuICAgICAgICAgICAgICAgIG1lZGlhbkxpbmUuZW50ZXIoKS5hcHBlbmQoJ2xpbmUnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdtZWRpYW4nKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIDApXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gxJywgeDApXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kyJywgd2lkdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgeDApXHJcbiAgICAgICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxyXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbihkdXJhdGlvbilcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDEnLCB4MSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDInLCB4MSk7XHJcblxyXG4gICAgICAgICAgICAgICAgbWVkaWFuTGluZS50cmFuc2l0aW9uKClcclxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oZHVyYXRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gxJywgeDEpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgeDEpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbWVkaWFuTGluZS5lbnRlcigpLmFwcGVuZCgnbGluZScpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ21lZGlhbicpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gxJywgMClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneTEnLCB4MClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDInLCB3aWR0aClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneTInLCB4MClcclxuICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbigpXHJcbiAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKGR1cmF0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIHgxKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIHgxKTtcclxuXHJcbiAgICAgICAgICAgICAgICBtZWRpYW5MaW5lLnRyYW5zaXRpb24oKVxyXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbihkdXJhdGlvbilcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneTEnLCB4MSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneTInLCB4MSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9VcGRhdGUgd2hpc2tlcnMuXHJcbiAgICAgICAgICAgIHZhciB3aGlza2VyID0gZy5zZWxlY3RBbGwoJ2xpbmUud2hpc2tlcicpXHJcbiAgICAgICAgICAgICAgICAuZGF0YSh3aGlza2VyRGF0YSB8fCBbXSk7XHJcbiAgICAgICAgICAgIGlmIChmbGlwcGVkKSB7XHJcbiAgICAgICAgICAgICAgICB3aGlza2VyLmVudGVyKClcclxuICAgICAgICAgICAgICAgICAgICAuaW5zZXJ0KCdsaW5lJywgJ2NpcmNsZSwgdGV4dCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3doaXNrZXInKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIDApXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gxJywgeDApXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kyJywgMCArIHdpZHRoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MicsIHgwKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDFlLTYpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxyXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbihkdXJhdGlvbilcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDEnLCB4MSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDInLCB4MSlcclxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAxKTtcclxuXHJcbiAgICAgICAgICAgICAgICB3aGlza2VyLnRyYW5zaXRpb24oKVxyXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbihkdXJhdGlvbilcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDEnLCB4MSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDInLCB4MSlcclxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAxKTtcclxuXHJcbiAgICAgICAgICAgICAgICB3aGlza2VyLmV4aXQoKS50cmFuc2l0aW9uKClcclxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oZHVyYXRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gxJywgeDEpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgeDEpXHJcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMWUtNilcclxuICAgICAgICAgICAgICAgICAgICAucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB3aGlza2VyLmVudGVyKClcclxuICAgICAgICAgICAgICAgICAgICAuaW5zZXJ0KCdsaW5lJywgJ2NpcmNsZSwgdGV4dCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3doaXNrZXInKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsIDApXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgeDApXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgMCArIHdpZHRoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIHgwKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDFlLTYpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxyXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbihkdXJhdGlvbilcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneTEnLCB4MSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneTInLCB4MSlcclxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAxKTtcclxuXHJcbiAgICAgICAgICAgICAgICB3aGlza2VyLnRyYW5zaXRpb24oKVxyXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbihkdXJhdGlvbilcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneTEnLCB4MSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneTInLCB4MSlcclxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAxKTtcclxuXHJcbiAgICAgICAgICAgICAgICB3aGlza2VyLmV4aXQoKS50cmFuc2l0aW9uKClcclxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oZHVyYXRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgeDEpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kyJywgeDEpXHJcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMWUtNilcclxuICAgICAgICAgICAgICAgICAgICAucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9Db21wdXRlIHRoZSB0aWNrIGZvcm1hdC5cclxuICAgICAgICAgICAgdmFyIGZvcm1hdCA9IHRpY2tGb3JtYXQgfHwgeDEudGlja0Zvcm1hdCg4KTtcclxuXHJcbiAgICAgICAgICAgIC8vVXBkYXRlIGJveCB0aWNrcy5cclxuICAgICAgICAgICAgdmFyIGJveFRpY2sgPSBnLnNlbGVjdEFsbCgndGV4dC5ib3gnKVxyXG4gICAgICAgICAgICAgICAgLmRhdGEocXVhcnRpbGVEYXRhKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChmbGlwcGVkKSB7XHJcbiAgICAgICAgICAgICAgICBib3hUaWNrLmVudGVyKCkuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnYm94JylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignZHgnLCAnLjNlbScpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2R5JywgZnVuY3Rpb24gKGQsIGkpIHsgcmV0dXJuIGkgJiAxID8gNiA6IC02IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBmdW5jdGlvbiAoZCwgaSkgeyByZXR1cm4gaSAmIDEgPyArIHdpZHRoIDogMCB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgeDApXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgZnVuY3Rpb24gKGQsIGkpIHsgcmV0dXJuIGkgJiAxID8gJ3N0YXJ0JyA6ICdlbmQnOyB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdzdHlsZScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzaG93TGFiZWxzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2Rpc3BsYXk6IG5vbmU7JztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLnRleHQoZm9ybWF0KVxyXG4gICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKClcclxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oZHVyYXRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCB4MSk7XHJcblxyXG4gICAgICAgICAgICAgICAgYm94VGljay50cmFuc2l0aW9uKClcclxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oZHVyYXRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgLnRleHQoZm9ybWF0KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgeDEpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYm94VGljay5lbnRlcigpLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2JveCcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2R5JywgJy4zZW0nKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdkeCcsIGZ1bmN0aW9uIChkLCBpKSB7IHJldHVybiBpICYgMSA/IDYgOiAtNiB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgZnVuY3Rpb24gKGQsIGkpIHsgcmV0dXJuIGkgJiAxID8gKyB3aWR0aCA6IDAgfSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIHgwKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsIGZ1bmN0aW9uIChkLCBpKSB7IHJldHVybiBpICYgMSA/ICdzdGFydCcgOiAnZW5kJzsgfSlcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignc3R5bGUnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2hvd0xhYmVscykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdkaXNwbGF5OiBub25lOyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC50ZXh0KGZvcm1hdClcclxuICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbigpXHJcbiAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKGR1cmF0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgeDEpO1xyXG5cclxuICAgICAgICAgICAgICAgIGJveFRpY2sudHJhbnNpdGlvbigpXHJcbiAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKGR1cmF0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgIC50ZXh0KGZvcm1hdClcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIHgxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL1VwZGF0ZSB3aGlza2VyIHRpY2tzLiBUaGVzZSBhcmUgaGFuZGxlZCBzZXBhcmF0ZWx5IGZyb20gdGhlIGJveFxyXG4gICAgICAgICAgICAvL3RpY2tzIGJlY2F1c2UgdGhleSBtYXkgb3IgbWF5IG5vdCBleGlzdCwgYW5kIHdlIHdhbnQgZG9uJ3Qgd2FudFxyXG4gICAgICAgICAgICAvL3RvIGpvaW4gYm94IHRpY2tzIHByZS10cmFuc2l0aW9uIHdpdGggd2hpc2tlciB0aWNrcyBwb3N0LS5cclxuICAgICAgICAgICAgdmFyIHdoaXNrZXJUaWNrID0gZy5zZWxlY3RBbGwoJ3RleHQud2hpc2tlcicpXHJcbiAgICAgICAgICAgICAgICAuZGF0YSh3aGlza2VyRGF0YSB8fCBbXSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoZmxpcHBlZCkge1xyXG4gICAgICAgICAgICAgICAgd2hpc2tlclRpY2suZW50ZXIoKS5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICd3aGlza2VyJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignZHgnLCAnLjNlbScpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2R5JywgNilcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIHdpZHRoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgeDApXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3N0eWxlJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNob3dMYWJlbHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnZGlzcGxheTpub25lOyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC50ZXh0KGZvcm1hdClcclxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAxZS02KVxyXG4gICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKClcclxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oZHVyYXRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCB4MSlcclxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAxKTtcclxuXHJcbiAgICAgICAgICAgICAgICB3aGlza2VyVGljay50cmFuc2l0aW9uKClcclxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oZHVyYXRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgLnRleHQoZm9ybWF0KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgeDEpXHJcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMSk7XHJcblxyXG4gICAgICAgICAgICAgICAgd2hpc2tlclRpY2suZXhpdCgpLnRyYW5zaXRpb24oKVxyXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbihkdXJhdGlvbilcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIHgxKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDFlLTYpXHJcbiAgICAgICAgICAgICAgICAgICAgLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgd2hpc2tlclRpY2suZW50ZXIoKS5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICd3aGlza2VyJylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignZHknLCAnLjNlbScpXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2R4JywgNilcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIHdpZHRoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgeDApXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3N0eWxlJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNob3dMYWJlbHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnZGlzcGxheTpub25lOyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC50ZXh0KGZvcm1hdClcclxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAxZS02KVxyXG4gICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKClcclxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oZHVyYXRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCB4MSlcclxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAxKTtcclxuXHJcbiAgICAgICAgICAgICAgICB3aGlza2VyVGljay50cmFuc2l0aW9uKClcclxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oZHVyYXRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgLnRleHQoZm9ybWF0KVxyXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgeDEpXHJcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMSk7XHJcblxyXG4gICAgICAgICAgICAgICAgd2hpc2tlclRpY2suZXhpdCgpLnRyYW5zaXRpb24oKVxyXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbihkdXJhdGlvbilcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIHgxKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDFlLTYpXHJcbiAgICAgICAgICAgICAgICAgICAgLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy9kMy50aW1lci5mbHVzaCgpO1xyXG4gICAgICAgIGQzLnRpbWVyRmx1c2goKTtcclxuICAgIH1cclxuXHJcbiAgICBib3gud2lkdGggPSBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHdpZHRoO1xyXG4gICAgICAgIHdpZHRoID0geDtcclxuICAgICAgICByZXR1cm4gYm94O1xyXG4gICAgfTtcclxuXHJcbiAgICBib3guaGVpZ2h0ID0gZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBoZWlnaHQ7XHJcbiAgICAgICAgaGVpZ2h0ID0geDtcclxuICAgICAgICByZXR1cm4gYm94O1xyXG4gICAgfTtcclxuXHJcbiAgICBib3gudGlja0Zvcm1hdCA9IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGlja0Zvcm1hdDtcclxuICAgICAgICB0aWNrRm9ybWF0ID0geDtcclxuICAgICAgICByZXR1cm4gYm94O1xyXG4gICAgfTtcclxuXHJcbiAgICBib3guZHVyYXRpb24gPSBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGR1cmF0aW9uO1xyXG4gICAgICAgIGR1cmF0aW9uID0geDtcclxuICAgICAgICByZXR1cm4gYm94O1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBjb25zdGFudCh4KSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHg7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGJveC5kb21haW4gPSBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRvbWFpbjtcclxuICAgICAgICAvL2RvbWFpbiA9IHggPT0gbnVsbCA/IHggOiBkMy5mdW5jdG9yKHgpO1xyXG4gICAgICAgIGRvbWFpbiA9IHggPT0gbnVsbCA/IHggOiBjb25zdGFudCh4KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGJveDtcclxuICAgIH07XHJcblxyXG4gICAgYm94LnZhbHVlID0gZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB2YWx1ZSA9IHg7XHJcbiAgICAgICAgcmV0dXJuIGJveDtcclxuICAgIH07XHJcblxyXG4gICAgYm94LndoaXNrZXJzID0gZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB3aGlza2VycztcclxuICAgICAgICB3aGlza2VycyA9IHg7XHJcbiAgICAgICAgcmV0dXJuIGJveDtcclxuICAgIH07XHJcblxyXG4gICAgYm94LnNob3dMYWJlbHMgPSBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNob3dMYWJlbHM7XHJcbiAgICAgICAgc2hvd0xhYmVscyA9IHg7XHJcbiAgICAgICAgcmV0dXJuIGJveDtcclxuICAgIH07XHJcblxyXG4gICAgYm94LmZsaXBwZWQgPSBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGZsaXBwZWQ7XHJcbiAgICAgICAgZmxpcHBlZCA9IHg7XHJcbiAgICAgICAgcmV0dXJuIGJveDtcclxuICAgIH07XHJcblxyXG4gICAgYm94LmNoYXJ0ID0gZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjaGFydDtcclxuICAgICAgICBjaGFydCA9IHg7XHJcbiAgICAgICAgcmV0dXJuIGJveDtcclxuICAgIH07XHJcblxyXG4gICAgYm94LnF1YXJ0aWxlcyA9IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcXVhcnRpbGVzO1xyXG4gICAgICAgIHF1YXJ0aWxlcyA9IHg7XHJcbiAgICAgICAgcmV0dXJuIGJveDtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIGJveDtcclxufTtcclxuXHJcbmZ1bmN0aW9uIGJveFdoaXNrZXJzKGQpIHtcclxuICAgIHJldHVybiBbMCwgZC5sZW5ndGggLSAxXTtcclxufVxyXG5cclxuZnVuY3Rpb24gYm94UXVhcnRpbGVzKGQpIHtcclxuICAgIHJldHVybiBbXHJcbiAgICAgICAgZDMucXVhbnRpbGUoZCwgMC4yNSksXHJcbiAgICAgICAgZDMucXVhbnRpbGUoZCwgMC41KSxcclxuICAgICAgICBkMy5xdWFudGlsZShkLCAwLjc1KVxyXG4gICAgXTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBqdkNoYXJ0cztcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIganZDaGFydHMgPSByZXF1aXJlKCcuLi9qdkNoYXJ0cy5qcycpO1xyXG5cclxuanZDaGFydHMucHJvdG90eXBlLmJ1YmJsZSA9IHtcclxuICAgIHBhaW50OiBwYWludCxcclxuICAgIHNldERhdGE6IHNldERhdGEsXHJcbiAgICBnZXRFdmVudERhdGE6IGdldEV2ZW50RGF0YVxyXG59O1xyXG5cclxuanZDaGFydHMucHJvdG90eXBlLmdlbmVyYXRlQnViYmxlID0gZ2VuZXJhdGVCdWJibGU7XHJcblxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIEJ1YmJsZSBmdW5jdGlvbnMgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuZnVuY3Rpb24gcGFpbnQodHJhbnNpdGlvblRpbWUpIHtcclxuICAgIHZhciBjaGFydCA9IHRoaXMsXHJcbiAgICAgICAgYnViYmxlTWFyZ2lucyA9IHtcclxuICAgICAgICAgICAgdG9wOiAxNSxcclxuICAgICAgICAgICAgcmlnaHQ6IDE1LFxyXG4gICAgICAgICAgICBsZWZ0OiAxNSxcclxuICAgICAgICAgICAgYm90dG9tOiAxNVxyXG4gICAgICAgIH07XHJcbiAgICBpZiAodHJhbnNpdGlvblRpbWUgfHwgdHJhbnNpdGlvblRpbWUgPT09IDApIHtcclxuICAgICAgICBjaGFydC5fdmFycy50cmFuc2l0aW9uVGltZSA9IHRyYW5zaXRpb25UaW1lO1xyXG4gICAgfSBlbHNlIGlmICghY2hhcnQuX3ZhcnMudHJhbnNpdGlvblRpbWUpIHtcclxuICAgICAgICBjaGFydC5fdmFycy50cmFuc2l0aW9uVGltZSA9IDgwMDtcclxuICAgIH1cclxuICAgIGlmICghY2hhcnQuc21hbGxlckZvbnRSZXBhaW50KSB7XHJcbiAgICAgICAgY2hhcnQuX3ZhcnMuZm9udFNpemVNYXggPSA4MDtcclxuICAgICAgICBjaGFydC5jdXJyZW50RGF0YSA9IGNoYXJ0LmRhdGE7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNoYXJ0LmN1cnJlbnREYXRhID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShjaGFydC5kYXRhKSk7XHJcbiAgICB9XHJcblxyXG4gICAgY2hhcnQuX3ZhcnMuY29sb3IgPSBjaGFydC5kYXRhLmNvbG9yO1xyXG5cclxuICAgIC8vR2VuZXJhdGUgU1ZHLWxlZ2VuZCBkYXRhIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBzaXplIG9mIHRoZSBib3R0b20gbWFyZ2luIChzZXQgdG8gbnVsbCBmb3Igbm8gbGVnZW5kKVxyXG4gICAgY2hhcnQuZ2VuZXJhdGVTVkcobnVsbCwgYnViYmxlTWFyZ2lucyk7XHJcbiAgICBjaGFydC5nZW5lcmF0ZVZlcnRpY2FsTGVnZW5kKCdnZW5lcmF0ZUJ1YmJsZScpO1xyXG4gICAgY2hhcnQuZ2VuZXJhdGVCdWJibGUoY2hhcnQuY3VycmVudERhdGEpO1xyXG59XHJcblxyXG4vKipzZXREYXRhXHJcbiAqICBnZXRzIEJ1YmJsZSBkYXRhIGFuZCBhZGRzIGl0IHRvIHRoZSBjaGFydCBvYmplY3RcclxuICpcclxuICogQHBhcmFtcyBkYXRhLCBkYXRhVGFibGUsIGNvbG9yc1xyXG4gKi9cclxuZnVuY3Rpb24gc2V0RGF0YSgpIHtcclxuICAgIHZhciBjaGFydCA9IHRoaXM7XHJcbiAgICAvL2RlZmluZSBjb2xvciBvYmplY3QgZm9yIGNoYXJ0RGF0YVxyXG4gICAgY2hhcnQuZGF0YS5sZWdlbmREYXRhID0gc2V0QnViYmxlTGVnZW5kRGF0YShjaGFydC5kYXRhKTtcclxuICAgIGNoYXJ0LmRhdGEuY29sb3IgPSBqdkNoYXJ0cy5zZXRDaGFydENvbG9ycyhjaGFydC5fdmFycy5jb2xvciwgY2hhcnQuZGF0YS5sZWdlbmREYXRhLCBjaGFydC5jb2xvcnMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRFdmVudERhdGEoKSB7XHJcbiAgICByZXR1cm4ge307XHJcbn1cclxuXHJcbi8qKnNldEJ1YmJsZUxlZ2VuZERhdGFcclxuICogIGdldHMgbGVnZW5kIGluZm8gZnJvbSBjaGFydCBEYXRhXHJcbiAqXHJcbiAqIEBwYXJhbXMgZGF0YSwgdHlwZVxyXG4gKiBAcmV0dXJucyBbXSBvZiBsZWdlbmQgdGV4dFxyXG4gKi9cclxuZnVuY3Rpb24gc2V0QnViYmxlTGVnZW5kRGF0YShkYXRhKSB7XHJcbiAgICB2YXIgbGVnZW5kQXJyYXkgPSBbXSxcclxuICAgICAgICBpdGVtID0gZGF0YS5kYXRhVGFibGUubGFiZWw7XHJcblxyXG4gICAgZm9yIChsZXQgdmFsdWUgaW4gZGF0YS5jaGFydERhdGEpIHtcclxuICAgICAgICBpZiAoZGF0YS5jaGFydERhdGEuaGFzT3duUHJvcGVydHkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIGxldCBsZWdlbmRFbGVtZW50ID0gZGF0YS5jaGFydERhdGFbdmFsdWVdW2l0ZW1dO1xyXG4gICAgICAgICAgICBpZiAobGVnZW5kQXJyYXkuaW5kZXhPZihsZWdlbmRFbGVtZW50KSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIGxlZ2VuZEFycmF5LnB1c2gobGVnZW5kRWxlbWVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGxlZ2VuZEFycmF5O1xyXG59XHJcblxyXG5cclxuLyoqIGdlbmVyYXRlQnViYmxlXHJcbiAqXHJcbiAqIHBhaW50cyB0aGUgYnViYmxlICBvbiB0aGUgY2hhcnRcclxuICogQHBhcmFtcyBidWJibGUgRGF0YVxyXG4gKi9cclxuZnVuY3Rpb24gZ2VuZXJhdGVCdWJibGUoYnViYmxlRGF0YSkge1xyXG4gICAgdmFyIGNoYXJ0ID0gdGhpcyxcclxuICAgICAgICBzdmcgPSBjaGFydC5zdmcsXHJcbiAgICAgICAgY29udGFpbmVyID0gY2hhcnQuY29uZmlnLmNvbnRhaW5lcixcclxuICAgICAgICB3aWR0aCA9IGNvbnRhaW5lci53aWR0aCxcclxuICAgICAgICBoZWlnaHQgPSBjb250YWluZXIuaGVpZ2h0LFxyXG4gICAgICAgIHBhY2sgPSBkMy5wYWNrKCkuc2l6ZShbd2lkdGgsIGhlaWdodF0pLnBhZGRpbmcoMS41KSxcclxuICAgICAgICBsZWdlbmREYXRhID0gY2hhcnQuZGF0YS5sZWdlbmREYXRhLFxyXG4gICAgICAgIHZhbHVlS2V5ID0gY2hhcnQuZGF0YS5kYXRhVGFibGUudmFsdWUsXHJcbiAgICAgICAgbGFiZWxLZXkgPSBjaGFydC5kYXRhLmRhdGFUYWJsZS5sYWJlbCxcclxuICAgICAgICBjb2xvcnMgPSBjaGFydC5fdmFycy5jb2xvcixcclxuICAgICAgICBkYXRhSGVhZGVycyxcclxuICAgICAgICBidWJibGVEYXRhTmV3LFxyXG4gICAgICAgIGxlZ2VuZEVsZW1lbnRUb2dnbGVBcnJheSxcclxuICAgICAgICByb290LFxyXG4gICAgICAgIGJ1YmJsZTtcclxuXHJcbiAgICBpZiAoIWNoYXJ0Ll92YXJzLmxlZ2VuZEhlYWRlcnMpIHtcclxuICAgICAgICBjaGFydC5fdmFycy5sZWdlbmRIZWFkZXJzID0gbGVnZW5kRGF0YTtcclxuICAgIH1cclxuICAgIGRhdGFIZWFkZXJzID0gY2hhcnQuX3ZhcnMubGVnZW5kSGVhZGVycztcclxuICAgIGlmICghY2hhcnQuX3ZhcnMubGVnZW5kSGVhZGVycykge1xyXG4gICAgICAgIGNoYXJ0Ll92YXJzLmxlZ2VuZEhlYWRlcnMgPSBsZWdlbmREYXRhO1xyXG4gICAgfVxyXG4gICAgYnViYmxlRGF0YU5ldyA9IGp2Q2hhcnRzLmdldFRvZ2dsZWREYXRhKGJ1YmJsZURhdGEsIGRhdGFIZWFkZXJzKTtcclxuICAgIGxlZ2VuZEVsZW1lbnRUb2dnbGVBcnJheSA9IGp2Q2hhcnRzLmdldExlZ2VuZEVsZW1lbnRUb2dnbGVBcnJheShkYXRhSGVhZGVycywgbGVnZW5kRGF0YSk7XHJcblxyXG4gICAgaWYgKGxlZ2VuZEVsZW1lbnRUb2dnbGVBcnJheSkge1xyXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYnViYmxlRGF0YU5ldy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBsZWdlbmRFbGUgb2YgbGVnZW5kRWxlbWVudFRvZ2dsZUFycmF5KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobGVnZW5kRWxlLmVsZW1lbnQgPT09IGJ1YmJsZURhdGFOZXdbal1bbGFiZWxLZXldICYmIGxlZ2VuZEVsZS50b2dnbGUgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnViYmxlRGF0YU5ldy5zcGxpY2UoaiwgMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdmcuc2VsZWN0QWxsKCcuYnViYmxlJykucmVtb3ZlKCk7XHJcbiAgICAvL2Fzc2lnbnMgdGhlIGRhdGEgdG8gYSBoaWVyYXJjaHkgdXNpbmcgcGFyZW50LWNoaWxkIHJlbGF0aW9uc2hpcHNcclxuICAgIHJvb3QgPSBkMy5oaWVyYXJjaHkoeyBjaGlsZHJlbjogYnViYmxlRGF0YU5ldyB9KVxyXG4gICAgICAgIC5zdW0oZCA9PiBkW3ZhbHVlS2V5XSk7XHJcblxyXG4gICAgYnViYmxlID0gc3ZnLnNlbGVjdEFsbCgnLmJ1YmJsZScpXHJcbiAgICAgICAgLmRhdGEocGFjayhyb290KS5sZWF2ZXMoKSlcclxuICAgICAgICAuZW50ZXIoKS5hcHBlbmQoJ2cnKVxyXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICdidWJibGUnKVxyXG4gICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBkID0+IGB0cmFuc2xhdGUoJHtkLnh9LCR7ZC55fSlgKTtcclxuXHJcbiAgICBidWJibGUuYXBwZW5kKCdjaXJjbGUnKVxyXG4gICAgICAgIC5hdHRyKCdmaWxsJywgZCA9PiBqdkNoYXJ0cy5nZXRDb2xvcnMoY29sb3JzLCBsZWdlbmREYXRhLmluZGV4T2YoZC5kYXRhW2xhYmVsS2V5XSksIGQuZGF0YVtsYWJlbEtleV0pKVxyXG4gICAgICAgIC5hdHRyKCdjbGFzcycsIChkLCBpKSA9PiBgZWRpdGFibGUgZWRpdGFibGUtYnViYmxlIGJ1YmJsZS0ke2l9IGhpZ2hsaWdodC1jbGFzcy0ke2l9YClcclxuICAgICAgICAuYXR0cigncicsIGQgPT4gZC5yKVxyXG4gICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgaWYgKGNoYXJ0LnNob3dUb29sVGlwKSB7XHJcbiAgICAgICAgICAgICAgICAvL0dldCB0aXAgZGF0YVxyXG4gICAgICAgICAgICAgICAgdmFyIHRpcERhdGEgPSBjaGFydC5zZXRUaXBEYXRhKGQuZGF0YSwgaSk7XHJcbiAgICAgICAgICAgICAgICAvL0RyYXcgdGlwIGxpbmVcclxuICAgICAgICAgICAgICAgIHRpcERhdGEuZGF0YS5jb2xvciA9IGp2Q2hhcnRzLmdldENvbG9ycyhjb2xvcnMsIHRpcERhdGEuaW5kZXgsIGQuZGF0YVtsYWJlbEtleV0pO1xyXG4gICAgICAgICAgICAgICAgY2hhcnQudGlwLmdlbmVyYXRlU2ltcGxlVGlwKHRpcERhdGEsIGNoYXJ0LmRhdGEuZGF0YVRhYmxlKTtcclxuICAgICAgICAgICAgICAgIGNoYXJ0LnRpcC5kID0gZC5kYXRhO1xyXG4gICAgICAgICAgICAgICAgY2hhcnQudGlwLmkgPSBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICAub24oJ21vdXNlbW92ZScsIGZ1bmN0aW9uIChkLCBpKSB7XHJcbiAgICAgICAgICAgIGlmIChjaGFydC5zaG93VG9vbFRpcCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoYXJ0LnRpcC5kID09PSBkICYmIGNoYXJ0LnRpcC5pID09PSBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhcnQudGlwLnNob3dUaXAoMCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vR2V0IHRpcCBkYXRhXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpcERhdGEgPSBjaGFydC5zZXRUaXBEYXRhKGQuZGF0YSwgaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9EcmF3IHRpcCBsaW5lXHJcbiAgICAgICAgICAgICAgICAgICAgY2hhcnQudGlwLmdlbmVyYXRlU2ltcGxlVGlwKHRpcERhdGEsIGNoYXJ0LmRhdGEuZGF0YVRhYmxlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIGlmIChjaGFydC5zaG93VG9vbFRpcCkge1xyXG4gICAgICAgICAgICAgICAgY2hhcnQudGlwLmhpZGVUaXAoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIGJ1YmJsZS5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICdidWJibGUtdGV4dCcpXHJcbiAgICAgICAgLnRleHQoZCA9PiBkLmRhdGFbbGFiZWxLZXldKVxyXG4gICAgICAgIC5hdHRyKCdmaWxsJywgJ3doaXRlJylcclxuICAgICAgICAvL2hpZGUgdGV4dCBpZiBpdHMgdG9vIHdpZGVcclxuICAgICAgICAuYXR0cignc3R5bGUnLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jbGllbnRXaWR0aCA+IGQuciAqIDIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnZGlzcGxheTogbm9uZSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLy9jZW50ZXIgdGhlIHRleHQgb24gdGhlIGJ1YmJsZVxyXG4gICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICB2YXIgZGlhbWV0ZXIgPSBkLnIgKiAyLFxyXG4gICAgICAgICAgICAgICAgdGV4dFdpZHRoID0gdGhpcy5jbGllbnRXaWR0aCxcclxuICAgICAgICAgICAgICAgIGVtcHR5U3BhY2UgPSBkaWFtZXRlciAtIHRleHRXaWR0aDtcclxuXHJcbiAgICAgICAgICAgIGlmIChlbXB0eVNwYWNlIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBgdHJhbnNsYXRlKC0ke2QuciAtIChlbXB0eVNwYWNlIC8gMil9LCAwKWA7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uIChkLCBpKSB7XHJcbiAgICAgICAgICAgIGlmIChjaGFydC5zaG93VG9vbFRpcCkge1xyXG4gICAgICAgICAgICAgICAgLy9HZXQgdGlwIGRhdGFcclxuICAgICAgICAgICAgICAgIHZhciB0aXBEYXRhID0gY2hhcnQuc2V0VGlwRGF0YShkLmRhdGEsIGkpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vRHJhdyB0aXAgbGluZVxyXG4gICAgICAgICAgICAgICAgdGlwRGF0YS5kYXRhLmNvbG9yID0ganZDaGFydHMuZ2V0Q29sb3JzKGNvbG9ycywgdGlwRGF0YS5pbmRleCwgZC5kYXRhW2xhYmVsS2V5XSk7XHJcbiAgICAgICAgICAgICAgICBjaGFydC50aXAuZ2VuZXJhdGVTaW1wbGVUaXAodGlwRGF0YSwgY2hhcnQuZGF0YS5kYXRhVGFibGUpO1xyXG4gICAgICAgICAgICAgICAgY2hhcnQudGlwLmQgPSBkLmRhdGE7XHJcbiAgICAgICAgICAgICAgICBjaGFydC50aXAuaSA9IGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICAgIC5vbignbW91c2Vtb3ZlJywgZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgaWYgKGNoYXJ0LnNob3dUb29sVGlwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hhcnQudGlwLmQgPT09IGQgJiYgY2hhcnQudGlwLmkgPT09IGkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGFydC50aXAuc2hvd1RpcCgwKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9HZXQgdGlwIGRhdGFcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGlwRGF0YSA9IGNoYXJ0LnNldFRpcERhdGEoZC5kYXRhLCBpKTtcclxuICAgICAgICAgICAgICAgICAgICAvL0RyYXcgdGlwIGxpbmVcclxuICAgICAgICAgICAgICAgICAgICBjaGFydC50aXAuZ2VuZXJhdGVTaW1wbGVUaXAodGlwRGF0YSwgY2hhcnQuZGF0YS5kYXRhVGFibGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoY2hhcnQuc2hvd1Rvb2xUaXApIHtcclxuICAgICAgICAgICAgICAgIGNoYXJ0LnRpcC5oaWRlVGlwKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICBidWJibGUuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAudGV4dChkID0+IGQuZGF0YVt2YWx1ZUtleV0pXHJcbiAgICAgICAgLmF0dHIoJ2ZpbGwnLCAnd2hpdGUnKVxyXG4gICAgICAgIC8vaGlkZSB0ZXh0IGlmIGl0cyB0b28gd2lkZVxyXG4gICAgICAgIC5hdHRyKCdzdHlsZScsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNsaWVudFdpZHRoID4gZC5yICogMikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdkaXNwbGF5OiBub25lJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAvL2NlbnRlciB0aGUgdGV4dCBvbiB0aGUgYnViYmxlXHJcbiAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIHZhciBkaWFtZXRlciA9IGQuciAqIDIsXHJcbiAgICAgICAgICAgICAgICB0ZXh0V2lkdGggPSB0aGlzLmNsaWVudFdpZHRoLFxyXG4gICAgICAgICAgICAgICAgZW1wdHlTcGFjZSA9IGRpYW1ldGVyIC0gdGV4dFdpZHRoO1xyXG5cclxuICAgICAgICAgICAgaWYgKGVtcHR5U3BhY2UgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGB0cmFuc2xhdGUoLSR7ZC5yIC0gKGVtcHR5U3BhY2UgLyAyKX0sIDE1KWA7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uIChkLCBpKSB7XHJcbiAgICAgICAgICAgIGlmIChjaGFydC5zaG93VG9vbFRpcCkge1xyXG4gICAgICAgICAgICAgICAgLy9HZXQgdGlwIGRhdGFcclxuICAgICAgICAgICAgICAgIHZhciB0aXBEYXRhID0gY2hhcnQuc2V0VGlwRGF0YShkLmRhdGEsIGkpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vRHJhdyB0aXAgbGluZVxyXG4gICAgICAgICAgICAgICAgdGlwRGF0YS5kYXRhLmNvbG9yID0ganZDaGFydHMuZ2V0Q29sb3JzKGNvbG9ycywgdGlwRGF0YS5pbmRleCwgZC5kYXRhW2xhYmVsS2V5XSk7XHJcbiAgICAgICAgICAgICAgICBjaGFydC50aXAuZ2VuZXJhdGVTaW1wbGVUaXAodGlwRGF0YSwgY2hhcnQuZGF0YS5kYXRhVGFibGUpO1xyXG4gICAgICAgICAgICAgICAgY2hhcnQudGlwLmQgPSBkLmRhdGE7XHJcbiAgICAgICAgICAgICAgICBjaGFydC50aXAuaSA9IGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICAgIC5vbignbW91c2Vtb3ZlJywgZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgaWYgKGNoYXJ0LnNob3dUb29sVGlwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hhcnQudGlwLmQgPT09IGQgJiYgY2hhcnQudGlwLmkgPT09IGkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGFydC50aXAuc2hvd1RpcCgwKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9HZXQgdGlwIGRhdGFcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGlwRGF0YSA9IGNoYXJ0LnNldFRpcERhdGEoZC5kYXRhLCBpKTtcclxuICAgICAgICAgICAgICAgICAgICAvL0RyYXcgdGlwIGxpbmVcclxuICAgICAgICAgICAgICAgICAgICBjaGFydC50aXAuZ2VuZXJhdGVTaW1wbGVUaXAodGlwRGF0YSwgY2hhcnQuZGF0YS5kYXRhVGFibGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoY2hhcnQuc2hvd1Rvb2xUaXApIHtcclxuICAgICAgICAgICAgICAgIGNoYXJ0LnRpcC5oaWRlVGlwKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBqdkNoYXJ0cztcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIganZDaGFydHMgPSByZXF1aXJlKCcuLi9qdkNoYXJ0cy5qcycpO1xyXG5cclxuanZDaGFydHMucHJvdG90eXBlLmNsdXN0ZXJncmFtID0ge1xyXG4gICAgcGFpbnQ6IHBhaW50LFxyXG4gICAgc2V0RGF0YTogc2V0RGF0YSxcclxuICAgIGdldEV2ZW50RGF0YTogbnVsbFxyXG59O1xyXG5cclxuanZDaGFydHMucHJvdG90eXBlLmdlbmVyYXRlQ2x1c3RlcmdyYW0gPSBnZW5lcmF0ZUNsdXN0ZXJncmFtO1xyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBDbHVzdGVyZ3JhbSBmdW5jdGlvbnMgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuLyoqc2V0Q2x1c3RlcmdyYW1EYXRhXHJcbiAqICBnZXRzIGhlYXRtYXAgZGF0YSBhbmQgYWRkcyBpdCB0byB0aGUgY2hhcnQgb2JqZWN0XHJcbiAqXHJcbiAqIEBwYXJhbXMgZGF0YSwgZGF0YVRhYmxlLCBjb2xvcnNcclxuICovXHJcbmZ1bmN0aW9uIHNldERhdGEoKSB7XHJcbiAgICB2YXIgY2hhcnQgPSB0aGlzLFxyXG4gICAgICAgIGxlZnRUcmVlRGF0YSA9IGNoYXJ0LmRhdGEuY2hhcnREYXRhWzBdLFxyXG4gICAgICAgIHJpZ2h0VHJlZURhdGEgPSBjaGFydC5kYXRhLmNoYXJ0RGF0YVsxXTtcclxuXHJcbiAgICBjaGFydC5sZWZ0TGFiZWxzID0ge307XHJcbiAgICBjaGFydC5sZWZ0TGFiZWxzLnZhbHVlcyA9IFtdO1xyXG4gICAgZm9yIChsZXQgbGVmdEVsZSBvZiBsZWZ0VHJlZURhdGEuY2hpbGRyZW4pIHtcclxuICAgICAgICBpZiAobGVmdEVsZS5uYW1lKSB7XHJcbiAgICAgICAgICAgIGNoYXJ0LmxlZnRMYWJlbHMudmFsdWVzLnB1c2gobGVmdEVsZS5uYW1lKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY2hhcnQucmlnaHRMYWJlbHMgPSB7fTtcclxuICAgIGNoYXJ0LnJpZ2h0TGFiZWxzLnZhbHVlcyA9IFtdO1xyXG4gICAgZm9yIChsZXQgcmlnaHRFbGUgb2YgcmlnaHRUcmVlRGF0YS5jaGlsZHJlbikge1xyXG4gICAgICAgIGlmIChyaWdodEVsZS5uYW1lKSB7XHJcbiAgICAgICAgICAgIGNoYXJ0LnJpZ2h0TGFiZWxzLnZhbHVlcy5wdXNoKHJpZ2h0RWxlLm5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjaGFydC5sZWZ0TGVhdmVzID0gZ2V0TGVhZk5vZGVzKFtsZWZ0VHJlZURhdGFdKTtcclxuICAgIGNoYXJ0LnJpZ2h0TGVhdmVzID0gZ2V0TGVhZk5vZGVzKFtyaWdodFRyZWVEYXRhXSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldExlYWZOb2Rlcyhub2RlcywgcmVzdWx0ID0gW10pIHtcclxuICAgIGxldCByZXR1cm5EYXRhID0gcmVzdWx0O1xyXG4gICAgZm9yIChsZXQgbm9kZSBvZiBub2Rlcykge1xyXG4gICAgICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm5EYXRhLnB1c2gobm9kZS5uYW1lKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm5EYXRhID0gZ2V0TGVhZk5vZGVzKG5vZGUuY2hpbGRyZW4sIHJldHVybkRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXR1cm5EYXRhO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwYWludCgpIHtcclxuICAgIHZhciBjaGFydCA9IHRoaXMsXHJcbiAgICAgICAgY3VzdG9tTWFyZ2luID0ge1xyXG4gICAgICAgICAgICB0b3A6IDIwLFxyXG4gICAgICAgICAgICByaWdodDogNDAsXHJcbiAgICAgICAgICAgIGxlZnQ6IDAsXHJcbiAgICAgICAgICAgIGJvdHRvbTogMjBcclxuICAgICAgICB9O1xyXG4gICAgY2hhcnQuX3ZhcnMuY29sb3IgPSBjaGFydC5kYXRhLmNvbG9yO1xyXG4gICAgY2hhcnQuY3VycmVudERhdGEgPSBjaGFydC5kYXRhOy8vTWlnaHQgaGF2ZSB0byBtb3ZlIGludG8gbWV0aG9kIGJjIG9mIHJlZmVyZW5jZS92YWx1ZSByZWxhdGlvbnNoaXBcclxuXHJcbiAgICAvL0dlbmVyYXRlIFNWRy1sZWdlbmQgZGF0YSBpcyB1c2VkIHRvIGRldGVybWluZSB0aGUgc2l6ZSBvZiB0aGUgYm90dG9tIG1hcmdpbiAoc2V0IHRvIG51bGwgZm9yIG5vIGxlZ2VuZClcclxuICAgIGNoYXJ0LmdlbmVyYXRlU1ZHKG51bGwsIGN1c3RvbU1hcmdpbik7XHJcbiAgICAvL2NoYXJ0LmdlbmVyYXRlTGVnZW5kKGNoYXJ0LmN1cnJlbnREYXRhLmxlZ2VuZERhdGEsICdnZW5lcmF0ZUNsdXN0ZXJncmFtJyk7XHJcbiAgICBjaGFydC5nZW5lcmF0ZUNsdXN0ZXJncmFtKCk7XHJcbn1cclxuXHJcbi8qKmdlbmVyYXRlQ2x1c3RlcmdyYW1cclxuICpcclxuICogcGFpbnRzIHRoZSBDbHVzdGVyZ3JhbSBvbiB0aGUgY2hhcnRcclxuICogQHBhcmFtcyBDbHVzdGVyZ3JhbURhdGFcclxuICovXHJcbmZ1bmN0aW9uIGdlbmVyYXRlQ2x1c3RlcmdyYW0oKSB7XHJcbiAgICB2YXIgY2hhcnQgPSB0aGlzLFxyXG4gICAgICAgIHN2ZyA9IGNoYXJ0LnN2ZyxcclxuICAgICAgICBjb250YWluZXIgPSBjaGFydC5jb25maWcuY29udGFpbmVyLFxyXG4gICAgICAgIGxlZnRUcmVlRGF0YSA9IGNoYXJ0LmRhdGEuY2hhcnREYXRhWzBdLFxyXG4gICAgICAgIHJpZ2h0VHJlZURhdGEgPSBjaGFydC5kYXRhLmNoYXJ0RGF0YVsxXSxcclxuICAgICAgICBncmlkRGF0YSA9IGNoYXJ0LmRhdGEuY2hhcnREYXRhWzJdLFxyXG4gICAgICAgIHNpemVXaWR0aCA9IGNoYXJ0LnJpZ2h0TGVhdmVzLmxlbmd0aCAqIDIwLFxyXG4gICAgICAgIHNpemVIZWlnaHQgPSBjaGFydC5sZWZ0TGVhdmVzLmxlbmd0aCAqIDIwLFxyXG4gICAgICAgIHZpcyxcclxuICAgICAgICBsZWZ0RyxcclxuICAgICAgICBib3R0b21HLFxyXG4gICAgICAgIGhlYXRHLFxyXG4gICAgICAgIG5ld1dpZHRoLFxyXG4gICAgICAgIG5ld0hlaWdodCxcclxuICAgICAgICBsZWZ0Q2hpbGRDb3VudCxcclxuICAgICAgICByaWdodENoaWxkQ291bnQ7XHJcblxyXG4gICAgY2hhcnQuZGF0YS55QXhpc0RhdGEgPSBbXTtcclxuICAgIGNoYXJ0LmRhdGEueEF4aXNEYXRhID0gW107XHJcblxyXG4gICAgaWYgKHNpemVXaWR0aCA8IGNvbnRhaW5lci53aWR0aCkge1xyXG4gICAgICAgIHNpemVXaWR0aCA9IGNvbnRhaW5lci53aWR0aDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoc2l6ZUhlaWdodCA8IGNvbnRhaW5lci5oZWlnaHQpIHtcclxuICAgICAgICBzaXplSGVpZ2h0ID0gY29udGFpbmVyLmhlaWdodDtcclxuICAgIH1cclxuXHJcbiAgICAvL3JlbW92ZSBzdmcgZWxlbWVudHNcclxuICAgIHN2Zy5zZWxlY3RBbGwoJyonKS5yZW1vdmUoKTtcclxuXHJcbiAgICB2aXMgPSBzdmcuYXBwZW5kKCdnJykuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLCAwKScpLmF0dHIoJ2NsYXNzJywgJ2hlYXRtYXAnKTtcclxuICAgIGxlZnRHID0gdmlzLmFwcGVuZCgnZycpLmF0dHIoJ2lkJywgJ2xlZnQtdHJlZScpO1xyXG4gICAgYm90dG9tRyA9IHZpcy5hcHBlbmQoJ2cnKS5hdHRyKCdpZCcsICdib3R0b20tdHJlZScpO1xyXG4gICAgaGVhdEcgPSB2aXMuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnY2x1c3RlcmdyYW0tY29udGFpbmVyJykuYXR0cignaWQnLCAnaGVhdCcpO1xyXG5cclxuICAgIGQzLnNlbGVjdCgnYm9keScpLmFwcGVuZCgnZGl2JylcclxuICAgICAgICAuYXR0cignY2xhc3MnLCAndG9vbHRpcCcpXHJcbiAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMCk7XHJcbiAgICAvL2NhbGMgbmV3IHdpZHRoIGFuZCBoZWlnaHRcclxuICAgIG5ld1dpZHRoID0gc2l6ZVdpZHRoIC8gMjtcclxuICAgIG5ld0hlaWdodCA9IHNpemVIZWlnaHQgLyAyO1xyXG5cclxuICAgIGxlZnRDaGlsZENvdW50ID0gYnVpbGRUcmVlKGxlZnRUcmVlRGF0YSwgY2hhcnQuZGF0YS55QXhpc0RhdGEsIGxlZnRHLCBuZXdIZWlnaHQsIG5ld1dpZHRoLCAnbGVmdCcpO1xyXG4gICAgcmlnaHRDaGlsZENvdW50ID0gYnVpbGRUcmVlKHJpZ2h0VHJlZURhdGEsIGNoYXJ0LmRhdGEueEF4aXNEYXRhLCBib3R0b21HLCBuZXdIZWlnaHQsIG5ld1dpZHRoLCAncmlnaHQnKTtcclxuICAgIGJ1aWxkSGVhdChjaGFydCwgZ3JpZERhdGEsIGhlYXRHLCBuZXdIZWlnaHQsIG5ld1dpZHRoLCBsZWZ0Q2hpbGRDb3VudCwgcmlnaHRDaGlsZENvdW50KTtcclxuXHJcbiAgICBjaGFydC56b29tZWQgPSAoKSA9PiBzdmcuYXR0cigndHJhbnNmb3JtJywgZDMuZXZlbnQudHJhbnNmb3JtKTtcclxuICAgIGNoYXJ0LmNoYXJ0RGl2LnNlbGVjdCgnLmVkaXRhYmxlLXN2ZycpLmNhbGwoZDMuem9vbSgpXHJcbiAgICAgICAgLm9uKCd6b29tJywgY2hhcnQuem9vbWVkKSk7XHJcblxyXG4gICAgLy9hbGlnbiBHIHRhZ3NcclxuICAgIGNoYXJ0Ll92YXJzLmxlZnRUcmVlV2lkdGggPSBsZWZ0Ry5ub2RlKCkuZ2V0QkJveCgpLndpZHRoO1xyXG4gICAgY2hhcnQuX3ZhcnMudG9wVHJlZUhlaWdodCA9IGJvdHRvbUcubm9kZSgpLmdldEJCb3goKS5oZWlnaHQ7XHJcbiAgICBsZWZ0Ry5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyAwICsgJywnICsgKGNoYXJ0Ll92YXJzLnRvcFRyZWVIZWlnaHQpICsgJyknKTtcclxuICAgIGJvdHRvbUcuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgKGNoYXJ0Ll92YXJzLmxlZnRUcmVlV2lkdGgpICsgJywnICsgMCArICcpJyk7XHJcbiAgICBoZWF0Ry5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBjaGFydC5fdmFycy5sZWZ0VHJlZVdpZHRoICsgJywnICsgKGNoYXJ0Ll92YXJzLnRvcFRyZWVIZWlnaHQpICsgJyknKTtcclxuXHJcbiAgICBjaGFydC5jb25maWcuY29udGFpbmVyLmhlaWdodCA9IGhlYXRHLm5vZGUoKS5nZXRCQm94KCkuaGVpZ2h0O1xyXG4gICAgY2hhcnQuY29uZmlnLmNvbnRhaW5lci53aWR0aCA9IGhlYXRHLm5vZGUoKS5nZXRCQm94KCkud2lkdGg7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZpbmRQYXRoKGNoaWxkKSB7XHJcbiAgICB2YXIgc3RyID0gJyc7XHJcbiAgICBsZXQgY2hpbGROb2RlID0gY2hpbGQ7XHJcbiAgICB3aGlsZSAoY2hpbGROb2RlLnBhcmVudCkge1xyXG4gICAgICAgIHN0ciArPSBjaGlsZE5vZGUuZGF0YS5uYW1lICsgJy4nO1xyXG4gICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5wYXJlbnQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc3RyLnNsaWNlKDAsIC0xKTtcclxufVxyXG5cclxuZnVuY3Rpb24gYnVpbGRUcmVlKGRhdGEsIGF4aXNEYXRhLCBnRWxlLCBuZXdIZWlnaHQsIG5ld1dpZHRoLCBzaWRlT2ZUcmVlKSB7XHJcbiAgICB2YXIgbWFrZVRyZWUsXHJcbiAgICAgICAgcm9vdCxcclxuICAgICAgICBjaGlsZENvdW50ID0gMDtcclxuXHJcbiAgICBtYWtlVHJlZSA9IGQzLmNsdXN0ZXIoKVxyXG4gICAgICAgIC5zaXplKHNpZGVPZlRyZWUgPT09ICdsZWZ0JyA/IFtuZXdIZWlnaHQsIG5ld1dpZHRoXSA6IFtuZXdXaWR0aCwgbmV3SGVpZ2h0XSk7XHJcblxyXG4gICAgcm9vdCA9IGQzLmhpZXJhcmNoeShkYXRhKTtcclxuICAgIG1ha2VUcmVlKHJvb3QpO1xyXG5cclxuICAgIGdFbGUuc2VsZWN0QWxsKCcuY2x1c3Rlci1saW5rJylcclxuICAgICAgICAuZGF0YShyb290LmRlc2NlbmRhbnRzKCkuc2xpY2UoMSkpXHJcbiAgICAgICAgLmVudGVyKCkuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAuYXR0cignY2xhc3MnLCAnY2x1c3Rlci1saW5rJylcclxuICAgICAgICAuc3R5bGUoJ2ZpbGwnLCAnbm9uZScpXHJcbiAgICAgICAgLnN0eWxlKCdzdHJva2UnLCAnYmxhY2snKVxyXG4gICAgICAgIC5hdHRyKCdkJywgZCA9PiB7XHJcbiAgICAgICAgICAgIGlmIChzaWRlT2ZUcmVlID09PSAnbGVmdCcpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnTScgKyBkLnkgLyA4ICsgJywnICsgZC54ICsgJ1YnICsgZC5wYXJlbnQueCArICdIJyArIGQucGFyZW50LnkgLyA4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAnTScgKyBkLnggKyAnLCcgKyBkLnkgLyA4ICsgJ1YnICsgZC5wYXJlbnQueSAvIDggKyAnSCcgKyBkLnBhcmVudC54O1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIGdFbGUuc2VsZWN0QWxsKCcuY2x1c3Rlci1ub2RlJylcclxuICAgICAgICAuZGF0YShyb290LmRlc2NlbmRhbnRzKCkpXHJcbiAgICAgICAgLmVudGVyKCkuYXBwZW5kKCdnJylcclxuICAgICAgICAuYXR0cignY2xhc3MnLCBkID0+IGBjbHVzdGVyLW5vZGUgJHsoZC5jaGlsZHJlbiA/ICdjbHVzdGVyLW5vZGUtLWludGVybmFsJyA6ICdjbHVzdGVyLW5vZGUtLWxlYWYnKX1gKVxyXG4gICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBkID0+IHtcclxuICAgICAgICAgICAgaWYgKHNpZGVPZlRyZWUgPT09ICdsZWZ0Jykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGB0cmFuc2xhdGUoJHtkLnkgLyA4fSwgJHtkLnh9KWA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGB0cmFuc2xhdGUoJHtkLnh9LCAke2QueSAvIDh9KXJvdGF0ZSgxNSlgO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIGlmIChzaWRlT2ZUcmVlID09PSAnbGVmdCcpIHtcclxuICAgICAgICBnRWxlLnNlbGVjdEFsbCgnLmNsdXN0ZXItbm9kZScpLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdkeScsIDMpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4JywgZCA9PiBkLmNoaWxkcmVuID8gLTggOiAwKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ3RleHQtYW5jaG9yJywgJ2VuZCcpXHJcbiAgICAgICAgICAgIC50ZXh0KGQgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFkLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRDb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgICAgIGF4aXNEYXRhLnB1c2goZmluZFBhdGgoZCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy9yZXR1cm4gZC5kYXRhLm5hbWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoZC5kYXRhLm5hbWUgPT09ICdyb290Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBkLmNoaWxkcmVuID8gZC5kYXRhLm5hbWUucmVwbGFjZSgvXy9nLCAnICcpIDogJyc7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIGdFbGUuc2VsZWN0QWxsKCcuY2x1c3Rlci1ub2RlJykuYXBwZW5kKCdsaW5lJylcclxuICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UnLCAnYmxhY2snKVxyXG4gICAgICAgICAgICAuYXR0cigneDEnLCBkID0+IGQuY2hpbGRyZW4gPyAwIDogMClcclxuICAgICAgICAgICAgLmF0dHIoJ3gyJywgZCA9PiBkLmNoaWxkcmVuID8gMCA6IDE1KTtcclxuICAgIH0gZWxzZSBpZiAoc2lkZU9mVHJlZSA9PT0gJ3JpZ2h0Jykge1xyXG4gICAgICAgIGdFbGUuc2VsZWN0QWxsKCcuY2x1c3Rlci1ub2RlJykuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgLmF0dHIoJ2R5JywgOClcclxuICAgICAgICAgICAgLnN0eWxlKCd0ZXh0LWFuY2hvcicsIGQgPT4gZC5jaGlsZHJlbiA/ICdlbmQnIDogJ3N0YXJ0JylcclxuICAgICAgICAgICAgLmF0dHIoJ3knLCBkID0+IGQuY2hpbGRyZW4gPyAtOCA6IDgpXHJcbiAgICAgICAgICAgIC50ZXh0KGQgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFkLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRDb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgICAgIGF4aXNEYXRhLnB1c2goZmluZFBhdGgoZCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGQuZGF0YS5uYW1lID09PSAncm9vdCcpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZC5jaGlsZHJlbiA/IGQuZGF0YS5uYW1lLnJlcGxhY2UoL18vZywgJyAnKSA6ICcnO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBjaGlsZENvdW50O1xyXG59XHJcblxyXG5mdW5jdGlvbiBidWlsZEhlYXQoY2hhcnQsIGdyaWREYXRhLCBoZWF0RywgbmV3SGVpZ2h0LCBuZXdXaWR0aCwgbGVmdENoaWxkQ291bnQsIHJpZ2h0Q2hpbGRDb3VudCkge1xyXG4gICAgdmFyIGhlYXRTY29yZXMgPSBbXSxcclxuICAgICAgICBncmlkSGVpZ2h0LFxyXG4gICAgICAgIGdyaWRXaWR0aCxcclxuICAgICAgICBjb2xvcjtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdyaWREYXRhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbGV0IGNlbGwgPSBncmlkRGF0YVtpXTtcclxuICAgICAgICBoZWF0U2NvcmVzLnB1c2goY2VsbC52YWx1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy9oZWF0IHZhcmlhYmxlc1xyXG4gICAgY29sb3IgPSBkMy5zY2FsZVRocmVzaG9sZCgpXHJcbiAgICAgICAgLmRvbWFpbihoZWF0U2NvcmVzKVxyXG4gICAgICAgIC5yYW5nZShbJyNmYmYyZDInLCAnI2ZlZTdhMCcsICcjZmZjNjY1JywgJyNmZWE3NDMnLCAnI2ZkOGMzYycsICcjZmI0YjI5JywgJyNlYTI0MWUnLCAnI2Q2MGIyMCcsICcjYjEwMDI2JywgJyM2MjAwMjMnXSk7XHJcblxyXG4gICAgZ3JpZEhlaWdodCA9IG5ld0hlaWdodCAvIGxlZnRDaGlsZENvdW50O1xyXG4gICAgZ3JpZFdpZHRoID0gbmV3V2lkdGggLyByaWdodENoaWxkQ291bnQ7XHJcblxyXG4gICAgY2hhcnQuX3ZhcnMuY2x1c3RlcmdyYW1HcmlkV2lkdGggPSBncmlkV2lkdGg7XHJcbiAgICBjaGFydC5fdmFycy5jbHVzdGVyZ3JhbUdyaWRIZWlnaHQgPSBncmlkSGVpZ2h0O1xyXG5cclxuICAgIC8vZ3JpZFxyXG4gICAgaGVhdEcuc2VsZWN0QWxsKCcuaGVhdCcpXHJcbiAgICAgICAgLmRhdGEoZ3JpZERhdGEpXHJcbiAgICAgICAgLmVudGVyKCkuYXBwZW5kKCdyZWN0JylcclxuICAgICAgICAuYXR0cignY2xhc3MnLCAnY2x1c3Rlci1yZWN0JylcclxuICAgICAgICAuYXR0cigneCcsIGQgPT4gZC54X2luZGV4ICogZ3JpZFdpZHRoKVxyXG4gICAgICAgIC5hdHRyKCd5JywgZCA9PiBkLnlfaW5kZXggKiBncmlkSGVpZ2h0KVxyXG4gICAgICAgIC5hdHRyKCd3aWR0aCcsICgpID0+IGdyaWRXaWR0aClcclxuICAgICAgICAuYXR0cignaGVpZ2h0JywgKCkgPT4gZ3JpZEhlaWdodClcclxuICAgICAgICAuYXR0cignc3Ryb2tlJywgJyNFNkU2RTYnKVxyXG4gICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCAnMXB4JylcclxuICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBkID0+IGNvbG9yKGQudmFsdWUpKVxyXG4gICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgaWYgKGNoYXJ0LnNob3dUb29sVGlwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hhcnQudGlwLmQgPT09IGQgJiYgY2hhcnQudGlwLmkgPT09IGkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGFydC50aXAuc2hvd1RpcChkMy5ldmVudCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vR2V0IHRpcCBkYXRhXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRpcERhdGEgPSBjaGFydC5zZXRUaXBEYXRhKGQsIGkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRpcERhdGEuY29sb3IgPSBjb2xvcihkLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAvL0RyYXcgdGlwIGxpbmVcclxuICAgICAgICAgICAgICAgICAgICBjaGFydC50aXAuZ2VuZXJhdGVTaW1wbGVUaXAodGlwRGF0YSwgY2hhcnQuZGF0YS5kYXRhVGFibGUsIGQzLmV2ZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY2hhcnQudGlwLmhpZGVUaXAoKTtcclxuICAgICAgICB9KTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBqdkNoYXJ0cztcclxuXHJcblxyXG4iLCIndXNlIHN0cmljdCc7XHJcbnZhciBqdkNoYXJ0cyA9IHJlcXVpcmUoJy4uL2p2Q2hhcnRzLmpzJyk7XHJcblxyXG5qdkNoYXJ0cy5wcm90b3R5cGUuZ2FudHQgPSB7XHJcbiAgICBwYWludDogcGFpbnQsXHJcbiAgICBzZXREYXRhOiBzZXREYXRhLFxyXG4gICAgZ2V0RXZlbnREYXRhOiBnZXRFdmVudERhdGFcclxufTtcclxuXHJcbmp2Q2hhcnRzLnByb3RvdHlwZS5nZW5lcmF0ZUdhbnR0QmFycyA9IGdlbmVyYXRlR2FudHRCYXJzO1xyXG5qdkNoYXJ0cy5wcm90b3R5cGUuc2V0R2FudHRMZWdlbmREYXRhID0gc2V0R2FudHRMZWdlbmREYXRhO1xyXG5qdkNoYXJ0cy5wcm90b3R5cGUuc2V0R2FudHRBeGlzRGF0YSA9IHNldEdhbnR0QXhpc0RhdGE7XHJcblxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIEdhbnR0IGZ1bmN0aW9ucyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG4gICAgLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSBkYXRhXHJcbiAqIEBwYXJhbSBkYXRhVGFibGVcclxuICogQHBhcmFtIGNvbG9yc1xyXG4gKi9cclxuZnVuY3Rpb24gc2V0RGF0YSgpIHtcclxuICAgIHZhciBjaGFydCA9IHRoaXM7XHJcbiAgICBjaGFydC5kYXRhLmxlZ2VuZERhdGEgPSBjaGFydC5zZXRHYW50dExlZ2VuZERhdGEoY2hhcnQuZGF0YSk7XHJcbiAgICBjaGFydC5kYXRhLnhBeGlzRGF0YSA9IGNoYXJ0LnNldEdhbnR0QXhpc0RhdGEoY2hhcnQsICd4Jyk7XHJcbiAgICBjaGFydC5kYXRhLnlBeGlzRGF0YSA9IGNoYXJ0LnNldEdhbnR0QXhpc0RhdGEoY2hhcnQsICd5Jyk7XHJcbiAgICAvL2RlZmluZSBjb2xvciBvYmplY3QgZm9yIGNoYXJ0RGF0YVxyXG4gICAgY2hhcnQuZGF0YS5jb2xvciA9IGp2Q2hhcnRzLnNldENoYXJ0Q29sb3JzKGNoYXJ0Ll92YXJzLmNvbG9yLCBjaGFydC5kYXRhLmxlZ2VuZERhdGEsIGNoYXJ0LmNvbG9ycyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEV2ZW50RGF0YShldmVudCkge1xyXG4gICAgdmFyIGNoYXJ0ID0gdGhpcztcclxuICAgIHZhciBlbGUgPSBldmVudC50YXJnZXQuY2xhc3NMaXN0LnZhbHVlLnNwbGl0KCdiYXItY29sLScpWzFdO1xyXG4gICAgaWYgKGVsZSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgICAgIFtjaGFydC5jdXJyZW50RGF0YS5kYXRhVGFibGUuZ3JvdXBdOiBbZWxlLnJlcGxhY2UoL18vZywgJyAnKS5yZXBsYWNlKC9fZG90Xy9nLCAnLicpXVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBub2RlOiBldmVudC50YXJnZXRcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHt9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBzZXRHYW50dExlZ2VuZERhdGEoZGF0YSkge1xyXG4gICAgdmFyIGxlZ2VuZEFycmF5ID0gW107XHJcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBPYmplY3Qua2V5cyhkYXRhLmRhdGFUYWJsZSkubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBsZXQga2V5ID0gJyAnICsgaTtcclxuICAgICAgICBpZiAoaSA9PSAxKSB7XHJcbiAgICAgICAgICAgIGtleSA9ICcnXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZGF0YS5kYXRhVGFibGUuaGFzT3duUHJvcGVydHkoW1wic3RhcnRcIiArIGtleV0pKSB7XHJcbiAgICAgICAgICAgIC8vY2hlY2sgdG8gbWFrZSBzdXJlIGl0IGhhcyBhIG1hdGNoaW5nIGVuZCBkYXRlXHJcbiAgICAgICAgICAgIGlmIChkYXRhLmRhdGFUYWJsZS5oYXNPd25Qcm9wZXJ0eShbXCJlbmRcIiArIGtleV0pKSB7XHJcbiAgICAgICAgICAgICAgICBsZWdlbmRBcnJheS5wdXNoKGRhdGEuZGF0YVRhYmxlW1wic3RhcnRcIiArIGtleV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBcclxuXHJcbiAgICB9XHJcbiAgICByZXR1cm4gbGVnZW5kQXJyYXk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldEdhbnR0QXhpc0RhdGEoY2hhcnQsIGF4aXMpIHtcclxuICAgIHZhciBheGlzRGF0YSA9IFtdLFxyXG4gICAgICAgIGRhdGEgPSBjaGFydC5kYXRhLFxyXG4gICAgICAgIGNoYXJ0RGF0YSA9IGRhdGEuY2hhcnREYXRhLFxyXG4gICAgICAgIGRhdGFUeXBlO1xyXG5cclxuICAgIGlmIChheGlzID09PSAneCcpIHtcclxuICAgICAgICB2YXIgbGFiZWwgPSBkYXRhLmRhdGFUYWJsZS5ncm91cDtcclxuICAgICAgICBkYXRhVHlwZSA9ICdEQVRFJztcclxuXHJcbiAgICAgICAgdmFyIG51bUJhcnMgPSBkYXRhLmxlZ2VuZERhdGEubGVuZ3RoO1xyXG4gICAgICAgIC8vTG9vcCB0aHJvdWdoIGRhdGFUYWJsZSBhbmQgYXNzaWduIGxhYmVscyBiYXNlZCBvbiBob3cgbWFueSBncm91cHMgdGhlcmUgYXJlXHJcbiAgICAgICAgdmFyIHZhbHVlQ29udGFpbmVyID0gW107XHJcbiAgICAgICAgdmFsdWVDb250YWluZXIucHVzaChkYXRhLmRhdGFUYWJsZVtcInN0YXJ0XCJdKTtcclxuICAgICAgICB2YWx1ZUNvbnRhaW5lci5wdXNoKGRhdGEuZGF0YVRhYmxlW1wiZW5kXCJdKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IG51bUJhcnM7IGkrKykge1xyXG4gICAgICAgICAgICB2YWx1ZUNvbnRhaW5lci5wdXNoKGRhdGEuZGF0YVRhYmxlW1wic3RhcnQgXCIgKyAoaSArIDEpXSk7XHJcbiAgICAgICAgICAgIHZhbHVlQ29udGFpbmVyLnB1c2goZGF0YS5kYXRhVGFibGVbXCJlbmQgXCIgKyAoaSArIDEpXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL0dldCBhbGwgdGhlIHN0YXJ0IGFuZCBlbmQgZGF0ZXMgYW5kIGFkZCB0aGVtIHRvIGF4aXMgZGF0YVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVDb250YWluZXIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGNoYXJ0RGF0YS5sZW5ndGg7IGlpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChjaGFydERhdGFbaWldW3ZhbHVlQ29udGFpbmVyW2ldXSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXhpc0RhdGEucHVzaChjaGFydERhdGFbaWldW3ZhbHVlQ29udGFpbmVyW2ldXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vQWRkIGFueSBheGlzIGZvcm1hdHRpbmcgdG8gdGhpcyBvYmplY3QsIG5lZWQgdG8gdXNlIHdoZW4gcGFpbnRpbmdcclxuICAgICAgICBjaGFydC5fdmFycy54QXhpc0Zvcm1hdHRpbmcgPSB7fTtcclxuXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGRhdGFUeXBlID0gXCJTVFJJTkdcIjtcclxuICAgICAgICB2YXIgbGFiZWwgPSBkYXRhLmRhdGFUYWJsZS5ncm91cDtcclxuXHJcbiAgICAgICAgLy9BZGQgYW55IGF4aXMgZm9ybWF0dGluZyB0byB0aGlzIG9iamVjdCwgbmVlZCB0byB1c2Ugd2hlbiBwYWludGluZ1xyXG4gICAgICAgIGNoYXJ0Ll92YXJzLnlBeGlzRm9ybWF0dGluZyA9IHt9O1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJ0RGF0YS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBheGlzRGF0YS5wdXNoKGNoYXJ0RGF0YVtpXVtsYWJlbF0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgICdsYWJlbCc6IGxhYmVsLFxyXG4gICAgICAgICd2YWx1ZXMnOiBheGlzRGF0YSxcclxuICAgICAgICAnZGF0YVR5cGUnOiBkYXRhVHlwZVxyXG4gICAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gcGFpbnQoKSB7XHJcbiAgICB2YXIgY2hhcnQgPSB0aGlzO1xyXG5cclxuICAgIGNoYXJ0Ll92YXJzLmNvbG9yID0gY2hhcnQuZGF0YS5jb2xvcjtcclxuXHJcbiAgICBjaGFydC5jdXJyZW50RGF0YSA9IGNoYXJ0LmRhdGE7XHJcblxyXG4gICAgY2hhcnQuZ2VuZXJhdGVTVkcoY2hhcnQuY3VycmVudERhdGEubGVnZW5kRGF0YSk7XHJcbiAgICBjaGFydC5nZW5lcmF0ZVhBeGlzKGNoYXJ0LmN1cnJlbnREYXRhLnhBeGlzRGF0YSk7XHJcbiAgICBjaGFydC5nZW5lcmF0ZVlBeGlzKGNoYXJ0LmN1cnJlbnREYXRhLnlBeGlzRGF0YSk7XHJcbiAgICBjaGFydC5nZW5lcmF0ZUxlZ2VuZChjaGFydC5jdXJyZW50RGF0YS5sZWdlbmREYXRhLCAnZ2VuZXJhdGVHYW50dEJhcnMnKTtcclxuICAgIGNoYXJ0LmRyYXdHcmlkbGluZXMoY2hhcnQuY3VycmVudERhdGEueEF4aXNEYXRhKTtcclxuICAgIGNoYXJ0LmdlbmVyYXRlR2FudHRCYXJzKGNoYXJ0LmN1cnJlbnREYXRhKTtcclxuICAgIGlmICh0eXBlb2YgY2hhcnQuY3VycmVudERhdGEueEF4aXNTY2FsZS50aWNrcyA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgY2hhcnQuZm9ybWF0WEF4aXNMYWJlbHMoY2hhcnQuY3VycmVudERhdGEueEF4aXNTY2FsZS50aWNrcygpLmxlbmd0aCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNoYXJ0LmZvcm1hdFhBeGlzTGFiZWxzKGNoYXJ0LmN1cnJlbnREYXRhLnhBeGlzU2NhbGUuZG9tYWluKCkubGVuZ3RoKTtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZ2VuZXJhdGVHYW50dEJhcnMoZ2FudHREYXRhKSB7XHJcbiAgICB2YXIgY2hhcnQgPSB0aGlzLFxyXG4gICAgICAgIHN2ZyA9IGNoYXJ0LnN2ZyxcclxuICAgICAgICBjb2xvcnMgPSBnYW50dERhdGEuY29sb3IsXHJcbiAgICAgICAgY29udGFpbmVyID0gY2hhcnQuY29uZmlnLmNvbnRhaW5lcixcclxuICAgICAgICB5QXhpc0RhdGEgPSBnYW50dERhdGEueUF4aXNEYXRhO1xyXG5cclxuICAgIC8vUmVtb3ZlIGV4aXN0aW5nIGJhcnMgZnJvbSBwYWdlXHJcbiAgICBzdmcuc2VsZWN0QWxsKFwiZy5nYW50dC1jb250YWluZXJcIikucmVtb3ZlKCk7XHJcbiAgICB2YXIgYmFycyA9IHN2Zy5hcHBlbmQoXCJnXCIpXHJcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImdhbnR0LWNvbnRhaW5lclwiKSxcclxuICAgICAgICBkYXRhSGVhZGVycyA9IGNoYXJ0Ll92YXJzLmxlZ2VuZEhlYWRlcnMgPyBjaGFydC5fdmFycy5sZWdlbmRIZWFkZXJzIDogZ2FudHREYXRhLmxlZ2VuZERhdGEsXHJcbiAgICAgICAgZ2FudHREYXRhTmV3ID0ganZDaGFydHMuZ2V0VG9nZ2xlZERhdGEoZ2FudHREYXRhLCBkYXRhSGVhZGVycyksXHJcbiAgICAgICAgeCA9IGp2Q2hhcnRzLmdldEF4aXNTY2FsZSgneCcsIGdhbnR0RGF0YS54QXhpc0RhdGEsIGNvbnRhaW5lciwgY2hhcnQuX3ZhcnMpLFxyXG4gICAgICAgIHkgPSBqdkNoYXJ0cy5nZXRBeGlzU2NhbGUoJ3knLCBnYW50dERhdGEueUF4aXNEYXRhLCBjb250YWluZXIsIGNoYXJ0Ll92YXJzKSxcclxuICAgICAgICBzYW1wbGVEYXRhID0gZ2FudHREYXRhTmV3O1xyXG5cclxuICAgIGNoYXJ0Ll92YXJzLnJvdGF0ZUF4aXMgPSB0cnVlO1xyXG5cclxuICAgIHZhciBudW1CYXJzID0gZ2FudHREYXRhLmxlZ2VuZERhdGEubGVuZ3RoO1xyXG4gICAgdmFyIGdhbnR0QmFycyA9IFtdO1xyXG4gICAgLy9jcmVhdGUgYXJyYXkgb2Ygc3RhcnQgZGF0ZXMgYW5kIGVuZCBkYXRlcyB0byBpdGVyYXRlIHRocm91Z2hcclxuICAgIHZhciBzdGFydERhdGVzID0gW107XHJcbiAgICB2YXIgZW5kRGF0ZXMgPSBbXTtcclxuICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IG51bUJhcnM7IGkrKykge1xyXG4gICAgICAgIGxldCBrZXkgPSAnICcgKyBpO1xyXG4gICAgICAgIGlmIChpID09IDEpIHtcclxuICAgICAgICAgICAga2V5ID0gJydcclxuICAgICAgICB9XHJcbiAgICAgICAgc3RhcnREYXRlcy5wdXNoKGNoYXJ0LmN1cnJlbnREYXRhLmRhdGFUYWJsZVtcInN0YXJ0XCIgKyBrZXldKTtcclxuICAgICAgICBlbmREYXRlcy5wdXNoKGNoYXJ0LmN1cnJlbnREYXRhLmRhdGFUYWJsZVtcImVuZFwiICsga2V5XSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBudW1CYXJzOyBpaSsrKSB7XHJcbiAgICAgICAgdmFyIGV4dGVybmFsQ291bnRlckZvckogPSAtMTtcclxuICAgICAgICBnYW50dEJhcnNbaWldID0gYmFycy5zZWxlY3RBbGwoXCIuZ2FudHQtYmFyXCIgKyBpaSlcclxuICAgICAgICAgICAgLmRhdGEoc2FtcGxlRGF0YSlcclxuICAgICAgICAgICAgLmVudGVyKClcclxuICAgICAgICAgICAgLmFwcGVuZChcInJlY3RcIilcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgZnVuY3Rpb24gKGQsIGksIGopIHtcclxuICAgICAgICAgICAgICAgIGV4dGVybmFsQ291bnRlckZvckorKztcclxuICAgICAgICAgICAgICAgIHZhciBsYWJlbCA9IFN0cmluZyhzYW1wbGVEYXRhW2V4dGVybmFsQ291bnRlckZvckpdW2NoYXJ0LmN1cnJlbnREYXRhLmRhdGFUYWJsZS5ncm91cF0pLnJlcGxhY2UoL1xccy9nLCAnXycpLnJlcGxhY2UoL1xcLi9nLCAnX2RvdF8nKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2dhbnR0LWJhcicgKyBpaSArICcgZWRpdGFibGUgZWRpdGFibGUtYmFyIGJhci1jb2wtJyArIGxhYmVsICsgJy1pbmRleC0nICsgaWkgKyAnIGhpZ2hsaWdodC1jbGFzcy0nICsgbGFiZWwgKyAnIHJlY3QgJztcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCAwKVxyXG4gICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCB5LmJhbmR3aWR0aCgpIC8gbnVtQmFycylcclxuICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIGZ1bmN0aW9uIChkLCBpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZFtzdGFydERhdGVzW2lpXV0pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geChuZXcgRGF0ZShkW3N0YXJ0RGF0ZXNbaWldXSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5hdHRyKFwieVwiLCBmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHkoZFt5QXhpc0RhdGEubGFiZWxdKSArICh5LmJhbmR3aWR0aCgpIC8gbnVtQmFycyAqIGlpKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLmF0dHIoXCJyeFwiLCAzKVxyXG4gICAgICAgICAgICAuYXR0cihcInJ5XCIsIDMpXHJcbiAgICAgICAgICAgIC5hdHRyKFwiZmlsbFwiLCBmdW5jdGlvbiAoZCwgaSwgaikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHR5cGVWYWwgPSBjaGFydC5jdXJyZW50RGF0YS5kYXRhVGFibGVbXCJUeXBlXCIgKyAoaWkgKyAxKV07XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hhcnQuX3ZhcnMubGVnZW5kSGVhZGVycykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2xvciA9IGp2Q2hhcnRzLmdldENvbG9ycyhjb2xvcnMsIDAsIGNoYXJ0Ll92YXJzLmxlZ2VuZEhlYWRlcnNbaWldKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbG9yID0ganZDaGFydHMuZ2V0Q29sb3JzKGNvbG9ycywgMCwgY2hhcnQuY3VycmVudERhdGEubGVnZW5kRGF0YVtpaV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbG9yO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcblxyXG4gICAgICAgIGdhbnR0QmFyc1tpaV0udHJhbnNpdGlvbigpXHJcbiAgICAgICAgICAgIC5kdXJhdGlvbig0MDApXHJcbiAgICAgICAgICAgIC5kZWxheSgxMDApXHJcbiAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IHgobmV3IERhdGUoZFtlbmREYXRlc1tpaV1dKSkgLSB4KG5ldyBEYXRlKGRbc3RhcnREYXRlc1tpaV1dKSk7Ly8oeChkLlN0YXJ0RGF0ZSkgLSB4KGQuRW5kRGF0ZSkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHdpZHRoID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2lkdGg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB2YXIgZXh0ZXJuYWxDb3VudGVyRm9ySkogPSAtMTtcclxuICAgIHZhciBkYXRhVG9QbG90ID0ganZDaGFydHMuZ2V0UGxvdERhdGEoZ2FudHREYXRhTmV3LCBjaGFydCk7XHJcbiAgICB2YXIgZXZlbnRHcm91cHMgPSBiYXJzLnNlbGVjdEFsbChcIi5ldmVudC1yZWN0XCIpXHJcbiAgICAgICAgLmRhdGEoZGF0YVRvUGxvdClcclxuICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgIC5hcHBlbmQoJ3JlY3QnKVxyXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJldmVudC1yZWN0XCIpXHJcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgZnVuY3Rpb24gKGQsIGksIGopIHtcclxuICAgICAgICAgICAgZXh0ZXJuYWxDb3VudGVyRm9ySkorKztcclxuICAgICAgICAgICAgdmFyIGxhYmVsID0gU3RyaW5nKHNhbXBsZURhdGFbZXh0ZXJuYWxDb3VudGVyRm9ySkpdW2NoYXJ0LmN1cnJlbnREYXRhLmRhdGFUYWJsZS5ncm91cF0pLnJlcGxhY2UoL1xccy9nLCAnXycpLnJlcGxhY2UoL1xcLi9nLCAnX2RvdF8nKTtcclxuICAgICAgICAgICAgcmV0dXJuICdldmVudC1yZWN0IGJhci1jb2wtJyArIGxhYmVsO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmF0dHIoXCJ4XCIsIDApXHJcbiAgICAgICAgLmF0dHIoXCJ5XCIsIGZ1bmN0aW9uIChkLCBpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb250YWluZXIuaGVpZ2h0IC8gZ2FudHREYXRhTmV3Lmxlbmd0aCAqIGk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuYXR0cihcIndpZHRoXCIsIGNvbnRhaW5lci53aWR0aClcclxuICAgICAgICAuYXR0cihcImhlaWdodFwiLCBmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICByZXR1cm4gY29udGFpbmVyLmhlaWdodCAvIGdhbnR0RGF0YU5ldy5sZW5ndGg7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuYXR0cihcImZpbGxcIiwgXCJ0cmFuc3BhcmVudFwiKVxyXG4gICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDAsMClcIik7XHJcbiAgICBldmVudEdyb3Vwc1xyXG4gICAgICAgIC5vbihcIm1vdXNlb3ZlclwiLCBmdW5jdGlvbiAoZCwgaSwgaikgeyAvLyBUcmFuc2l0aW9ucyBpbiBEMyBkb24ndCBzdXBwb3J0IHRoZSAnb24nIGZ1bmN0aW9uIFRoZXkgb25seSBleGlzdCBvbiBzZWxlY3Rpb25zLiBTbyBuZWVkIHRvIG1vdmUgdGhhdCBldmVudCBsaXN0ZW5lciBhYm92ZSB0cmFuc2l0aW9uIGFuZCBhZnRlciBhcHBlbmRcclxuICAgICAgICAgICAgaWYgKGNoYXJ0LnNob3dUb29sVGlwKSB7XHJcbiAgICAgICAgICAgICAgICAvL0dldCB0aXAgZGF0YVxyXG4gICAgICAgICAgICAgICAgdmFyIHRpcERhdGEgPSBjaGFydC5zZXRUaXBEYXRhKGQsIGkpO1xyXG4gICAgICAgICAgICAgICAgLy9EcmF3IHRpcFxyXG4gICAgICAgICAgICAgICAgY2hhcnQudGlwLmdlbmVyYXRlU2ltcGxlVGlwKHRpcERhdGEsIGNoYXJ0LmRhdGEuZGF0YVRhYmxlKTtcclxuICAgICAgICAgICAgICAgIGNoYXJ0LnRpcC5kID0gZDtcclxuICAgICAgICAgICAgICAgIGNoYXJ0LnRpcC5pID0gaTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9KVxyXG4gICAgICAgIC5vbihcIm1vdXNlbW92ZVwiLCBmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICBpZiAoY2hhcnQuc2hvd1Rvb2xUaXApIHtcclxuICAgICAgICAgICAgICAgIGlmIChjaGFydC50aXAuZCA9PT0gZCAmJiBjaGFydC50aXAuaSA9PT0gaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0LnRpcC5zaG93VGlwKGQzLmV2ZW50KTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9HZXQgdGlwIGRhdGFcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGlwRGF0YSA9IGNoYXJ0LnNldFRpcERhdGEoZCwgaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9EcmF3IHRpcCBsaW5lXHJcbiAgICAgICAgICAgICAgICAgICAgY2hhcnQudGlwLmdlbmVyYXRlU2ltcGxlVGlwKHRpcERhdGEsIGNoYXJ0LmRhdGEuZGF0YVRhYmxlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLm9uKFwibW91c2VvdXRcIiwgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgaWYgKGNoYXJ0LnNob3dUb29sVGlwKSB7XHJcbiAgICAgICAgICAgICAgICBjaGFydC50aXAuaGlkZVRpcCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgdmFyIGN1cnJlbnREYXRlID0gbmV3IERhdGUoKTtcclxuICAgIHZhciBkYXRlRGF0YSA9IFtjdXJyZW50RGF0ZV07XHJcbiAgICAvL0RyYXdzIGEgbGluZSByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgZGF0ZVxyXG4gICAgc3ZnLnNlbGVjdEFsbChcIi5jdXJyZW50RGF0ZUxpbmVcIilcclxuICAgICAgICAuZGF0YShkYXRlRGF0YSlcclxuICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgIC5hcHBlbmQoXCJsaW5lXCIpXHJcbiAgICAgICAgLmF0dHIoXCJ4MVwiLCBmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICByZXR1cm4geChkKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5hdHRyKFwieDJcIiwgZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHgoZCk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuYXR0cihcInkxXCIsIGZ1bmN0aW9uIChkLCBpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBcIjBweFwiO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmF0dHIoXCJ5MlwiLCBmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICByZXR1cm4gY2hhcnQuY29uZmlnLmNvbnRhaW5lci5oZWlnaHQ7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiY3VycmVudERhdGVMaW5lXCIpXHJcbiAgICAgICAgLmF0dHIoXCJzdHJva2VcIiwgY2hhcnQuX3ZhcnMuYXhpc0NvbG9yKVxyXG4gICAgICAgIC5hdHRyKFwic3Ryb2tlLXdpZHRoXCIsIGNoYXJ0Ll92YXJzLlNUUk9LRV9XSURUSClcclxuICAgICAgICAuYXR0cihcInN0cm9rZS1kYXNoYXJyYXlcIiwgKFwiMywgM1wiKSk7XHJcblxyXG5cclxuICAgIHN2Zy5zZWxlY3RBbGwoXCIuY3VycmVudERhdGVMYWJlbFwiKVxyXG4gICAgICAgIC5kYXRhKGRhdGVEYXRhKVxyXG4gICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgLmFwcGVuZChcInRleHRcIilcclxuICAgICAgICAudGV4dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB0b2RheSA9IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgICAgIHZhciBkZCA9IHRvZGF5LmdldERhdGUoKTtcclxuICAgICAgICAgICAgdmFyIG1tID0gdG9kYXkuZ2V0TW9udGgoKSArIDE7IC8vSmFudWFyeSBpcyAwIVxyXG5cclxuICAgICAgICAgICAgdmFyIHl5eXkgPSB0b2RheS5nZXRGdWxsWWVhcigpO1xyXG4gICAgICAgICAgICBpZiAoZGQgPCAxMCkge1xyXG4gICAgICAgICAgICAgICAgZGQgPSAnMCcgKyBkZFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtbSA8IDEwKSB7XHJcbiAgICAgICAgICAgICAgICBtbSA9ICcwJyArIG1tXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHRvZGF5ID0gbW0gKyAnLycgKyBkZCArICcvJyArIHl5eXk7XHJcbiAgICAgICAgICAgIHJldHVybiB0b2RheTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5hdHRyKFwieFwiLCBmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICByZXR1cm4geChkKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5hdHRyKFwieVwiLCBmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICByZXR1cm4gXCItMTBweFwiO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKVxyXG4gICAgICAgIC5hdHRyKCdmaWxsJywgY2hhcnQuX3ZhcnMuZm9udENvbG9yKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBqdkNoYXJ0czsiLCIndXNlIHN0cmljdCc7XHJcbnZhciBqdkNoYXJ0cyA9IHJlcXVpcmUoJy4uL2p2Q2hhcnRzLmpzJyk7XHJcblxyXG5qdkNoYXJ0cy5wcm90b3R5cGUuaGVhdG1hcCA9IHtcclxuICAgIHBhaW50OiBwYWludCxcclxuICAgIHNldERhdGE6IHNldERhdGEsXHJcbiAgICBnZXRFdmVudERhdGE6IGdldEV2ZW50RGF0YVxyXG59O1xyXG5cclxuanZDaGFydHMucHJvdG90eXBlLmdlbmVyYXRlSGVhdE1hcCA9IGdlbmVyYXRlSGVhdE1hcDtcclxuXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogSGVhdE1hcCBmdW5jdGlvbnMgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuZnVuY3Rpb24gcXVhbnRpemVkKGNoYXJ0LCBtaW4sIG1heCkge1xyXG4gICAgbGV0IGJ1Y2tldENvdW50ID0gY2hhcnQuX3ZhcnMuYnVja2V0cyxcclxuICAgICAgICBzZWN0aW9uVmFsdWUgPSAobWF4IC0gbWluKSAvIGJ1Y2tldENvdW50LFxyXG4gICAgICAgIHF1YW50aXplZEFycmF5ID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1Y2tldENvdW50OyBpKyspIHtcclxuICAgICAgICBxdWFudGl6ZWRBcnJheVtpXSA9IG1pbiArIGkgKiBzZWN0aW9uVmFsdWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcXVhbnRpemVkQXJyYXk7XHJcbn1cclxuXHJcbi8qKnNldERhdGFcclxuICogIGdldHMgaGVhdG1hcCBkYXRhIGFuZCBhZGRzIGl0IHRvIHRoZSBjaGFydCBvYmplY3RcclxuICpcclxuICogQHBhcmFtcyBkYXRhLCBkYXRhVGFibGUsIGNvbG9yc1xyXG4gKi9cclxuZnVuY3Rpb24gc2V0RGF0YSgpIHtcclxuICAgIGxldCBjaGFydCA9IHRoaXMsXHJcbiAgICAgICAgYXhpc05hbWVzID0gc2V0SGVhdEF4aXNOYW1lcyhjaGFydC5kYXRhKTtcclxuICAgIGNoYXJ0LmRhdGEueEF4aXNEYXRhID0gYXhpc05hbWVzLnhBeGlzRGF0YTtcclxuICAgIGNoYXJ0LmRhdGEueUF4aXNEYXRhID0gYXhpc05hbWVzLnlBeGlzRGF0YTtcclxuICAgIGNoYXJ0LmRhdGEucHJvY2Vzc2VkRGF0YSA9IHNldFByb2Nlc3NlZERhdGEoY2hhcnQsIGNoYXJ0LmRhdGEsIGNoYXJ0LmRhdGEueEF4aXNEYXRhLnZhbHVlcywgY2hhcnQuZGF0YS55QXhpc0RhdGEudmFsdWVzKTtcclxuICAgIC8vZGVmaW5lIGNvbG9yIG9iamVjdCBmb3IgY2hhcnREYXRhXHJcbiAgICBjaGFydC5fdmFycy5jb2xvciA9IGp2Q2hhcnRzLnNldENoYXJ0Q29sb3JzKGNoYXJ0Ll92YXJzLmNvbG9yLCBjaGFydC5kYXRhLnhBeGlzRGF0YS52YWx1ZXMsIGNoYXJ0LmNvbG9ycyk7XHJcbiAgICBjaGFydC5kYXRhLmhlYXREYXRhID0gc2V0SGVhdG1hcExlZ2VuZERhdGEoY2hhcnQsIGNoYXJ0LmRhdGEpO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gZ2V0RXZlbnREYXRhKGV2ZW50LCBtb3VzZSkge1xyXG4gICAgbGV0IGNoYXJ0ID0gdGhpcyxcclxuICAgICAgICAvL2RldGVybWluZSBpZiB0aGUgY2xpY2sgZXZlbnQgaGFwcGVucyBpbnNpZGUgdGhlIGNvbnRhaW5lclxyXG4gICAgICAgIGJydXNoQ29udGFpbmVyID0gY2hhcnQuY2hhcnREaXYuc2VsZWN0KCcuJyArIGNoYXJ0LmNvbmZpZy50eXBlICsgJy1jb250YWluZXInKS5ub2RlKCksXHJcbiAgICAgICAgY29udGFpbmVyQm94ID0gYnJ1c2hDb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXHJcbiAgICAgICAgeCA9IG1vdXNlWzBdLFxyXG4gICAgICAgIHkgPSBtb3VzZVsxXSxcclxuICAgICAgICBpbnNpZGVDb250YWluZXIgPSBmYWxzZTtcclxuXHJcbiAgICBpZiAoeCA8IGNvbnRhaW5lckJveC5yaWdodCAmJiB5IDwgY29udGFpbmVyQm94LmJvdHRvbSAmJiB4ID4gY29udGFpbmVyQm94LmxlZnQgJiYgeSA+IGNvbnRhaW5lckJveC50b3ApIHtcclxuICAgICAgICBpbnNpZGVDb250YWluZXIgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKGluc2lkZUNvbnRhaW5lciAmJiBldmVudC50YXJnZXQuX19kYXRhX18pIHtcclxuICAgICAgICBsZXQgZGF0YSA9IGV2ZW50LnRhcmdldC5fX2RhdGFfXztcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICAgICAgICAvL1tjaGFydC5jdXJyZW50RGF0YS5kYXRhVGFibGUuaGVhdF06IFtkYXRhLnZhbHVlXSxcclxuICAgICAgICAgICAgICAgIFtjaGFydC5jdXJyZW50RGF0YS5kYXRhVGFibGUueF06IFtkYXRhLnhBeGlzTmFtZV0sXHJcbiAgICAgICAgICAgICAgICBbY2hhcnQuY3VycmVudERhdGEuZGF0YVRhYmxlLnldOiBbZGF0YS55QXhpc05hbWVdXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG5vZGU6IGV2ZW50LnRhcmdldFxyXG4gICAgICAgIH07XHJcbiAgICB9IGVsc2UgaWYgKGluc2lkZUNvbnRhaW5lcikge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGRhdGE6IHt9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZGF0YTogZmFsc2VcclxuICAgIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldEhlYXRtYXBMZWdlbmREYXRhKGNoYXJ0LCBkYXRhKSB7XHJcbiAgICBsZXQgaGVhdERhdGE7XHJcblxyXG4gICAgY2hhcnQuX3ZhcnMuY29sb3JzID0gb3JnYW5pemVDb2xvcnMoY2hhcnQpO1xyXG4gICAgZGF0YS5oZWF0U2NvcmVzLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcclxuXHJcbiAgICBjaGFydC5kYXRhLmNvbG9yU2NhbGUgPSBkMy5zY2FsZVF1YW50aWxlKClcclxuICAgICAgICAuZG9tYWluKGRhdGEuaGVhdFNjb3JlcylcclxuICAgICAgICAucmFuZ2UoY2hhcnQuX3ZhcnMuY29sb3JzKTtcclxuXHJcbiAgICBpZiAoY2hhcnQuX3ZhcnMucXVhbnRpbGVzID09PSB0cnVlKSB7XHJcbiAgICAgICAgbGV0IHRlbXAgPSBjaGFydC5kYXRhLmNvbG9yU2NhbGUucXVhbnRpbGVzKCk7XHJcbiAgICAgICAgaWYgKHRlbXBbMF0gPT09IDApIHtcclxuICAgICAgICAgICAgaGVhdERhdGEgPSBjaGFydC5kYXRhLmNvbG9yU2NhbGUucXVhbnRpbGVzKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaGVhdERhdGEgPSBbMF0uY29uY2F0KGNoYXJ0LmRhdGEuY29sb3JTY2FsZS5xdWFudGlsZXMoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBoZWF0RGF0YSA9IHF1YW50aXplZChjaGFydCwgZGF0YS5oZWF0U2NvcmVzWzBdLCBkYXRhLmhlYXRTY29yZXNbZGF0YS5oZWF0U2NvcmVzLmxlbmd0aCAtIDFdKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaGVhdERhdGE7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG9yZ2FuaXplQ29sb3JzKGNoYXJ0KSB7XHJcbiAgICBsZXQgY29sb3JTZWxlY3RlZEJ1Y2tldCA9IFtdLFxyXG4gICAgICAgIHNWYWx1ZSA9IGNoYXJ0Ll92YXJzLmJ1Y2tldHMsXHJcbiAgICAgICAgbmV3Q29sb3JzID0gW10sXHJcbiAgICAgICAgYnVja2V0TWFwcGVyID0gWzEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwXSxcclxuICAgICAgICBidWNrZXRDb3VudCA9IGJ1Y2tldE1hcHBlcltzVmFsdWUgLSAxXSxcclxuICAgICAgICBjb2xvcnM7XHJcblxyXG4gICAgZm9yIChsZXQgYyBpbiBjaGFydC5fdmFycy5jb2xvcnMpIHtcclxuICAgICAgICBpZiAoY2hhcnQuX3ZhcnMuY29sb3JzLmhhc093blByb3BlcnR5KGMpKSB7XHJcbiAgICAgICAgICAgIGNvbG9yU2VsZWN0ZWRCdWNrZXQucHVzaChjaGFydC5fdmFycy5jb2xvcnNbY10pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1Y2tldENvdW50OyBpKyspIHtcclxuICAgICAgICBpZiAoaSA+PSBidWNrZXRDb3VudCAvIDIpIHtcclxuICAgICAgICAgICAgbmV3Q29sb3JzW2ldID0gY29sb3JTZWxlY3RlZEJ1Y2tldFtNYXRoLnJvdW5kKChpICsgMSkgLyBidWNrZXRDb3VudCAqIDIwKSAtIDFdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG5ld0NvbG9yc1tpXSA9IGNvbG9yU2VsZWN0ZWRCdWNrZXRbTWF0aC5yb3VuZCgoaSkgLyBidWNrZXRDb3VudCAqIDIwKV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbG9ycyA9IG5ld0NvbG9ycy5zbGljZSgwKTtcclxuICAgIHJldHVybiBjb2xvcnM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldEhlYXRBeGlzTmFtZXMoZGF0YSkge1xyXG4gICAgdmFyIGNoYXJ0RGF0YSA9IGRhdGEuY2hhcnREYXRhLFxyXG4gICAgICAgIHhBeGlzTmFtZSA9IGRhdGEuZGF0YVRhYmxlLngsXHJcbiAgICAgICAgeUF4aXNOYW1lID0gZGF0YS5kYXRhVGFibGUueSxcclxuICAgICAgICB4QXhpc0FycmF5ID0gW10sXHJcbiAgICAgICAgeUF4aXNBcnJheSA9IFtdLFxyXG4gICAgICAgIHJldHVybk9iaiA9IHt9O1xyXG5cclxuICAgIGZvciAobGV0IGtleSBvZiBkYXRhLmRhdGFUYWJsZUtleXMpIHtcclxuICAgICAgICBpZiAoa2V5Lm1vZGVsID09PSAneCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuT2JqLnhBeGlzRGF0YSA9IHt9O1xyXG4gICAgICAgICAgICByZXR1cm5PYmoueEF4aXNEYXRhLmRhdGFUeXBlID0ga2V5LnR5cGU7XHJcbiAgICAgICAgICAgIHJldHVybk9iai54QXhpc0RhdGEubGFiZWwgPSBkYXRhLmRhdGFUYWJsZS54O1xyXG4gICAgICAgIH0gZWxzZSBpZiAoa2V5Lm1vZGVsID09PSAneScpIHtcclxuICAgICAgICAgICAgcmV0dXJuT2JqLnlBeGlzRGF0YSA9IHt9O1xyXG4gICAgICAgICAgICByZXR1cm5PYmoueUF4aXNEYXRhLmRhdGFUeXBlID0ga2V5LnR5cGU7XHJcbiAgICAgICAgICAgIHJldHVybk9iai55QXhpc0RhdGEubGFiZWwgPSBkYXRhLmRhdGFUYWJsZS55O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGxldCBlbGUgb2YgY2hhcnREYXRhKSB7XHJcbiAgICAgICAgaWYgKHhBeGlzQXJyYXkuaW5kZXhPZihlbGVbeEF4aXNOYW1lXSkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIHhBeGlzQXJyYXkucHVzaChlbGVbeEF4aXNOYW1lXSk7XHJcbiAgICAgICAgICAgIC8vVE9ETyBtYWtlIGludG8gMSBmdW5jdGlvbiBmb3IgbWluIG1heC4uLiB3YXN0ZSBvZiBzcGFjZVxyXG4gICAgICAgICAgICBpZiAocmV0dXJuT2JqLnhBeGlzRGF0YS5kYXRhVHlwZSA9PT0gJ05VTUJFUicpIHtcclxuICAgICAgICAgICAgICAgIC8vcHVzaCBtaW4gYW5kIG1heCBpbmZvXHJcbiAgICAgICAgICAgICAgICBpZiAoIXJldHVybk9iai54QXhpc0RhdGEubWluKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuT2JqLnhBeGlzRGF0YS5taW4gPSBlbGVbeEF4aXNOYW1lXTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZWxlW3hBeGlzTmFtZV0gPCByZXR1cm5PYmoueEF4aXNEYXRhLm1pbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybk9iai54QXhpc0RhdGEubWluID0gZWxlW3hBeGlzTmFtZV07XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCFyZXR1cm5PYmoueEF4aXNEYXRhLm1heCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybk9iai54QXhpc0RhdGEubWF4ID0gZWxlW3hBeGlzTmFtZV07XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVsZVt4QXhpc05hbWVdIDwgcmV0dXJuT2JqLnhBeGlzRGF0YS5tYXgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm5PYmoueEF4aXNEYXRhLm1heCA9IGVsZVt4QXhpc05hbWVdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh5QXhpc0FycmF5LmluZGV4T2YoZWxlW3lBeGlzTmFtZV0pID09PSAtMSkge1xyXG4gICAgICAgICAgICB5QXhpc0FycmF5LnB1c2goZWxlW3lBeGlzTmFtZV0pO1xyXG4gICAgICAgICAgICBpZiAocmV0dXJuT2JqLnlBeGlzRGF0YS5kYXRhVHlwZSA9PT0gJ05VTUJFUicpIHtcclxuICAgICAgICAgICAgICAgIC8vcHVzaCBtaW4gYW5kIG1heCBpbmZvXHJcbiAgICAgICAgICAgICAgICBpZiAoIXJldHVybk9iai55QXhpc0RhdGEubWluKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuT2JqLnlBeGlzRGF0YS5taW4gPSBlbGVbeUF4aXNOYW1lXTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZWxlW3lBeGlzTmFtZV0gPCByZXR1cm5PYmoueUF4aXNEYXRhLm1pbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybk9iai55QXhpc0RhdGEubWluID0gZWxlW3lBeGlzTmFtZV07XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCFyZXR1cm5PYmoueUF4aXNEYXRhLm1heCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybk9iai55QXhpc0RhdGEubWF4ID0gZWxlW3lBeGlzTmFtZV07XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVsZVt5QXhpc05hbWVdIDwgcmV0dXJuT2JqLnlBeGlzRGF0YS5tYXgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm5PYmoueUF4aXNEYXRhLm1heCA9IGVsZVt5QXhpc05hbWVdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuT2JqLnhBeGlzRGF0YS52YWx1ZXMgPSB4QXhpc0FycmF5O1xyXG4gICAgcmV0dXJuT2JqLnlBeGlzRGF0YS52YWx1ZXMgPSB5QXhpc0FycmF5O1xyXG5cclxuICAgIHJldHVybiByZXR1cm5PYmo7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldFByb2Nlc3NlZERhdGEoY2hhcnQsIGRhdGEsIHhBeGlzQXJyYXksIHlBeGlzQXJyYXkpIHtcclxuICAgIHZhciBjaGFydERhdGEgPSBkYXRhLmNoYXJ0RGF0YSxcclxuICAgICAgICB4QXhpc05hbWUgPSBkYXRhLmRhdGFUYWJsZS54LFxyXG4gICAgICAgIHlBeGlzTmFtZSA9IGRhdGEuZGF0YVRhYmxlLnksXHJcbiAgICAgICAgaGVhdCA9IGRhdGEuZGF0YVRhYmxlLmhlYXQsXHJcbiAgICAgICAgZGF0YUFycmF5ID0gW10sXHJcbiAgICAgICAga2V5cztcclxuXHJcbiAgICBkYXRhLmhlYXRTY29yZXMgPSBbXTtcclxuICAgIC8qQXNzaWduIGVhY2ggbmFtZSBhIG51bWJlciBhbmQgcGxhY2UgbWF0cml4IGNvb3JkaW5hdGVzIGluc2lkZSBvZiBkYXRhQXJyYXkgKi9cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhcnREYXRhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgZGF0YUFycmF5LnB1c2goe1xyXG4gICAgICAgICAgICB2YWx1ZTogY2hhcnREYXRhW2ldW2hlYXRdLFxyXG4gICAgICAgICAgICB4QXhpc05hbWU6IGNoYXJ0RGF0YVtpXVt4QXhpc05hbWVdLFxyXG4gICAgICAgICAgICB5QXhpc05hbWU6IGNoYXJ0RGF0YVtpXVt5QXhpc05hbWVdXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGtleXMgPSBPYmplY3Qua2V5cyhkYXRhLmRhdGFUYWJsZSk7XHJcbiAgICAgICAgZm9yIChsZXQga2V5IG9mIGtleXMpIHtcclxuICAgICAgICAgICAgaWYgKGtleS5pbmRleE9mKCd0b29sdGlwJykgPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgZGF0YUFycmF5W2ldW2tleV0gPSBjaGFydERhdGFbaV1bZGF0YS5kYXRhVGFibGVba2V5XV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vVGhpcyBhcnJheSBzdG9yZXMgdGhlIHZhbHVlcyBhcyBudW1iZXJzXHJcbiAgICAgICAgZGF0YS5oZWF0U2NvcmVzLnB1c2goY2hhcnREYXRhW2ldW2hlYXRdKTtcclxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHhBeGlzQXJyYXkubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgaWYgKHhBeGlzQXJyYXlbal0gPT09IGRhdGFBcnJheVtpXS54QXhpc05hbWUpIHtcclxuICAgICAgICAgICAgICAgIGRhdGFBcnJheVtpXS54QXhpcyA9IGo7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHlBeGlzQXJyYXkubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgaWYgKHlBeGlzQXJyYXlbal0gPT09IGRhdGFBcnJheVtpXS55QXhpc05hbWUpIHtcclxuICAgICAgICAgICAgICAgIGRhdGFBcnJheVtpXS55QXhpcyA9IGo7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZGF0YUFycmF5O1xyXG59XHJcblxyXG5mdW5jdGlvbiBwYWludCgpIHtcclxuICAgIHZhciBjaGFydCA9IHRoaXMsXHJcbiAgICAgICAgY3VzdG9tTWFyZ2luID0ge1xyXG4gICAgICAgICAgICB0b3A6IDAsXHJcbiAgICAgICAgICAgIHJpZ2h0OiA0MCxcclxuICAgICAgICAgICAgbGVmdDogMCxcclxuICAgICAgICAgICAgYm90dG9tOiAyMFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgY2hhcnQuX3ZhcnMuY29sb3IgPSBjaGFydC5kYXRhLmNvbG9yO1xyXG4gICAgY2hhcnQuY3VycmVudERhdGEgPSBjaGFydC5kYXRhOy8vTWlnaHQgaGF2ZSB0byBtb3ZlIGludG8gbWV0aG9kIGJjIG9mIHJlZmVyZW5jZS92YWx1ZSByZWxhdGlvbnNoaXBcclxuXHJcbiAgICAvL0dlbmVyYXRlIFNWRy1sZWdlbmQgZGF0YSBpcyB1c2VkIHRvIGRldGVybWluZSB0aGUgc2l6ZSBvZiB0aGUgYm90dG9tIG1hcmdpbiAoc2V0IHRvIG51bGwgZm9yIG5vIGxlZ2VuZClcclxuICAgIGNoYXJ0LmdlbmVyYXRlU1ZHKG51bGwsIGN1c3RvbU1hcmdpbik7XHJcbiAgICAvL2NoYXJ0LmdlbmVyYXRlTGVnZW5kKGNoYXJ0LmN1cnJlbnREYXRhLmxlZ2VuZERhdGEsICdnZW5lcmF0ZUhlYXRNYXAnKTtcclxuICAgIGNoYXJ0LmdlbmVyYXRlSGVhdE1hcCgpO1xyXG59XHJcblxyXG4vKipnZW5lcmF0ZUhlYXRNYXBcclxuICpcclxuICogcGFpbnRzIHRoZSBIZWF0TWFwIG9uIHRoZSBjaGFydFxyXG4gKiBAcGFyYW1zIEhlYXRNYXBEYXRhXHJcbiAqL1xyXG5mdW5jdGlvbiBnZW5lcmF0ZUhlYXRNYXAoKSB7XHJcbiAgICB2YXIgY2hhcnQgPSB0aGlzLFxyXG4gICAgICAgIHN2ZyA9IGNoYXJ0LnN2ZyxcclxuICAgICAgICBjb2xvcnMgPSBjaGFydC5fdmFycy5jb2xvcnMsXHJcbiAgICAgICAgcXVhbnRpbGVzID0gY2hhcnQuX3ZhcnMucXVhbnRpbGVzLFxyXG4gICAgICAgIGRhdGEgPSBjaGFydC5kYXRhLnByb2Nlc3NlZERhdGEsXHJcbiAgICAgICAgaGVhdE1hcERhdGEgPSBjaGFydC5jdXJyZW50RGF0YSxcclxuICAgICAgICBncmlkU2l6ZSA9IGNoYXJ0Ll92YXJzLmhlYXRHcmlkU2l6ZSxcclxuICAgICAgICBsZWdlbmRTcGFjaW5nID0gY2hhcnQuX3ZhcnMuaGVhdExlZ2VuZFNwYWNpbmcsXHJcbiAgICAgICAgdmlzLFxyXG4gICAgICAgIHlBeGlzVGl0bGU7XHJcblxyXG4gICAgZDMuc2VsZWN0KCdib2R5JykuYXBwZW5kKCdkaXYnKVxyXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICd0b29sdGlwJylcclxuICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAwKTtcclxuICAgIHZpcyA9IHN2Zy5hcHBlbmQoJ2cnKS5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsMCknKS5hdHRyKCdjbGFzcycsICdoZWF0bWFwJyk7XHJcblxyXG5cclxuICAgIHlBeGlzVGl0bGUgPSB2aXMuc2VsZWN0QWxsKCcuaGVhdG1hcCcpXHJcbiAgICAgICAgLmRhdGEoW2hlYXRNYXBEYXRhLmRhdGFUYWJsZS55XSk7XHJcblxyXG4gICAgeUF4aXNUaXRsZS5lbnRlcigpLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2F4aXNMYWJlbHMgYm9sZCcpXHJcbiAgICAgICAgLmF0dHIoJ3gnLCAtMjEpXHJcbiAgICAgICAgLmF0dHIoJ3knLCAtNSlcclxuICAgICAgICAuYXR0cigndGV4dC1hbmNob3InLCAnZW5kJylcclxuICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgKCkgPT4gJ3RyYW5zbGF0ZSgtJyArIChjaGFydC5fdmFycy5oZWF0bWFwWW1hcmdpbiArIDEwKSArICcsJyArIDAgKyAnKXJvdGF0ZSgtOTApJylcclxuICAgICAgICAudGV4dChkID0+IGQpO1xyXG5cclxuICAgIHlBeGlzVGl0bGUuZXhpdCgpLnJlbW92ZSgpO1xyXG4gICAgdmFyIGZvcm1hdFR5cGUgPSBqdkNoYXJ0cy5qdkZvcm1hdFZhbHVlVHlwZShjaGFydC5jdXJyZW50RGF0YS55QXhpc0RhdGEudmFsdWVzLCBjaGFydC5jdXJyZW50RGF0YS55QXhpc0RhdGEuZGF0YVR5cGUpO1xyXG5cclxuICAgIHZhciB5QXhpc1NlY3Rpb24gPSB2aXMuYXBwZW5kKCdzdmc6ZycpXHJcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3lBeGlzU2VjdGlvbicpO1xyXG5cclxuICAgIHZhciB5QXhpcyA9IHlBeGlzU2VjdGlvbi5zZWxlY3RBbGwoJy54QXhpcycpXHJcbiAgICAgICAgLmRhdGEoaGVhdE1hcERhdGEueUF4aXNEYXRhLnZhbHVlcylcclxuICAgICAgICAuZW50ZXIoKS5hcHBlbmQoJ3N2ZzpnJyk7XHJcblxyXG4gICAgeUF4aXMuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAudGV4dChkID0+IHtcclxuICAgICAgICAgICAgdmFyIHN0ciA9IGp2Q2hhcnRzLmp2Rm9ybWF0VmFsdWUoZCwgZm9ybWF0VHlwZSk7XHJcbiAgICAgICAgICAgIGlmIChzdHIubGVuZ3RoID4gMTUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzdHIuc3Vic3RyaW5nKDAsIDE0KSArICcuLi4nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzdHI7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuYXR0cigneCcsIDApXHJcbiAgICAgICAgLmF0dHIoJ3knLCAoZCwgaSkgPT4gaSAqIGdyaWRTaXplKVxyXG4gICAgICAgIC5zdHlsZSgndGV4dC1hbmNob3InLCAnZW5kJylcclxuICAgICAgICAuc3R5bGUoJ2ZvbnQtc2l6ZScsIGNoYXJ0Ll92YXJzLmZvbnRTaXplKVxyXG4gICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKC02LCcgKyBncmlkU2l6ZSAvIDEuNSArICcpJylcclxuICAgICAgICAuYXR0cignY2xhc3MnLCAncm93TGFiZWwgcG9pbnRlcicpXHJcbiAgICAgICAgLm9uKCdjbGljaycsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIC8vcmVtb3Zpbmcgc3R5bGluZ1xyXG4gICAgICAgICAgICBkMy5zZWxlY3RBbGwoJy5yb3dMYWJlbCcpLmNsYXNzZWQoJ3RleHQtaGlnaGxpZ2h0JywgZmFsc2UpO1xyXG4gICAgICAgICAgICBkMy5zZWxlY3RBbGwoJy5jb2xMYWJlbCcpLmNsYXNzZWQoJ3RleHQtaGlnaGxpZ2h0JywgZmFsc2UpO1xyXG4gICAgICAgICAgICBkMy5zZWxlY3RBbGwoJy5oZWF0JykuY2xhc3NlZCgncmVjdC1oaWdobGlnaHQnLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIGQzLnNlbGVjdEFsbCgnLmhlYXQnKS5jbGFzc2VkKCdyZWN0LWJvcmRlcicsIGZhbHNlKTtcclxuXHJcbiAgICAgICAgICAgIGxldCBwYWludEJvb2wgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAoZCA9PT0gY2hhcnQuX3ZhcnMuc2VsZWN0ZWRYKSB7XHJcbiAgICAgICAgICAgICAgICBjaGFydC5fdmFycy5zZWxlY3RlZFggPSAnJztcclxuICAgICAgICAgICAgICAgIHBhaW50Qm9vbCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY2hhcnQuX3ZhcnMuc2VsZWN0ZWRYID0gZDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9mYWRlIGFsbCByZWN0cyBleGNlcHQgaW4gdGhpcyByb3dcclxuICAgICAgICAgICAgZDMuc2VsZWN0QWxsKCcuaGVhdCcpLmNsYXNzZWQoJ3JlY3QtaGlnaGxpZ2h0JywgciA9PiB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJ0LmN1cnJlbnREYXRhLnlBeGlzRGF0YS52YWx1ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhcnQuY3VycmVudERhdGEueUF4aXNEYXRhLnZhbHVlc1tpXSA9PT0gZCAmJiBkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyLnlBeGlzICE9PSBpICYmIHBhaW50Qm9vbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIHlBeGlzLmFwcGVuZCgndGl0bGUnKVxyXG4gICAgICAgIC50ZXh0KGQgPT4gZCk7XHJcblxyXG5cclxuICAgIHZhciB4QXhpc1RpdGxlID0gdmlzLnNlbGVjdEFsbCgnLnhBeGlzVGl0bGUnKVxyXG4gICAgICAgIC5kYXRhKFtoZWF0TWFwRGF0YS5kYXRhVGFibGUueF0pO1xyXG5cclxuICAgIHhBeGlzVGl0bGUuZW50ZXIoKS5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICdheGlzTGFiZWxzIGJvbGQnKVxyXG4gICAgICAgIC5hdHRyKCd4JywgNilcclxuICAgICAgICAuYXR0cigneScsIDkpXHJcbiAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoMCwgLSR7Y2hhcnQuX3ZhcnMuaGVhdG1hcFhtYXJnaW4gLSAxMH0pYClcclxuICAgICAgICAudGV4dChkID0+IGQpO1xyXG5cclxuICAgIHhBeGlzVGl0bGUuZXhpdCgpLnJlbW92ZSgpO1xyXG5cclxuICAgIHZhciB4QXhpc1NlY3Rpb24gPSB2aXMuYXBwZW5kKCdzdmc6ZycpXHJcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3hBeGlzU2VjdGlvbicpO1xyXG5cclxuICAgIHZhciB4QXhpcyA9IHhBeGlzU2VjdGlvbi5zZWxlY3RBbGwoJy54QXhpcycpXHJcbiAgICAgICAgLmRhdGEoaGVhdE1hcERhdGEueEF4aXNEYXRhLnZhbHVlcylcclxuICAgICAgICAuZW50ZXIoKS5hcHBlbmQoJ3N2ZzpnJyk7XHJcblxyXG4gICAgZm9ybWF0VHlwZSA9IGp2Q2hhcnRzLmp2Rm9ybWF0VmFsdWVUeXBlKGNoYXJ0LmN1cnJlbnREYXRhLnhBeGlzRGF0YS52YWx1ZXMsIGNoYXJ0LmN1cnJlbnREYXRhLnhBeGlzRGF0YS5kYXRhVHlwZSk7XHJcblxyXG4gICAgeEF4aXMuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAudGV4dChkID0+IHtcclxuICAgICAgICAgICAgdmFyIHN0ciA9IGp2Q2hhcnRzLmp2Rm9ybWF0VmFsdWUoZCwgZm9ybWF0VHlwZSk7XHJcbiAgICAgICAgICAgIGlmIChzdHIubGVuZ3RoID4gMTUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzdHIuc3Vic3RyaW5nKDAsIDE0KSArICcuLi4nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzdHI7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuc3R5bGUoJ3RleHQtYW5jaG9yJywgJ3N0YXJ0JylcclxuICAgICAgICAuYXR0cigneCcsIDYpXHJcbiAgICAgICAgLmF0dHIoJ3knLCA3KVxyXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICdjb2xMYWJlbCBwb2ludGVyJylcclxuICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgKGQsIGkpID0+IGB0cmFuc2xhdGUoJHtpICogZ3JpZFNpemV9LCAtNilyb3RhdGUoLTQ1KWApXHJcbiAgICAgICAgLmF0dHIoJ3RpdGxlJywgZCA9PiBkKVxyXG4gICAgICAgIC5zdHlsZSgnZm9udC1zaXplJywgY2hhcnQuX3ZhcnMuZm9udFNpemUpXHJcbiAgICAgICAgLm9uKCdjbGljaycsIGQgPT4ge1xyXG4gICAgICAgICAgICAvL3JlbW92aW5nIHN0eWxpbmdcclxuICAgICAgICAgICAgZDMuc2VsZWN0QWxsKCcucm93TGFiZWwnKS5jbGFzc2VkKCd0ZXh0LWhpZ2hsaWdodCcsIGZhbHNlKTtcclxuICAgICAgICAgICAgZDMuc2VsZWN0QWxsKCcuY29sTGFiZWwnKS5jbGFzc2VkKCd0ZXh0LWhpZ2hsaWdodCcsIGZhbHNlKTtcclxuICAgICAgICAgICAgZDMuc2VsZWN0QWxsKCcuaGVhdCcpLmNsYXNzZWQoJ3JlY3QtaGlnaGxpZ2h0JywgZmFsc2UpO1xyXG4gICAgICAgICAgICBkMy5zZWxlY3RBbGwoJy5oZWF0JykuY2xhc3NlZCgncmVjdC1ib3JkZXInLCBmYWxzZSk7XHJcblxyXG4gICAgICAgICAgICBsZXQgcGFpbnRCb29sID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKGQgPT09IGNoYXJ0Ll92YXJzLnNlbGVjdGVkWCkge1xyXG4gICAgICAgICAgICAgICAgY2hhcnQuX3ZhcnMuc2VsZWN0ZWRYID0gJyc7XHJcbiAgICAgICAgICAgICAgICBwYWludEJvb2wgPSBmYWxzZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNoYXJ0Ll92YXJzLnNlbGVjdGVkWCA9IGQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9mYWRlIGFsbCByZWN0cyBleGNlcHQgaW4gdGhpcyBjb2x1bW5cclxuICAgICAgICAgICAgZDMuc2VsZWN0QWxsKCcuaGVhdCcpLmNsYXNzZWQoJ3JlY3QtaGlnaGxpZ2h0JywgciA9PiB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJ0LmN1cnJlbnREYXRhLnhBeGlzRGF0YS52YWx1ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhcnQuY3VycmVudERhdGEueEF4aXNEYXRhLnZhbHVlc1tpXSA9PT0gZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoci54QXhpcyAhPT0gaSAmJiBwYWludEJvb2wpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICB4QXhpcy5hcHBlbmQoJ3RpdGxlJylcclxuICAgICAgICAudGV4dChkID0+IGQpO1xyXG5cclxuICAgIHZhciB3aWR0aCA9IGhlYXRNYXBEYXRhLnhBeGlzRGF0YS52YWx1ZXMubGVuZ3RoICogZ3JpZFNpemU7XHJcbiAgICB2YXIgaGVpZ2h0ID0gaGVhdE1hcERhdGEueUF4aXNEYXRhLnZhbHVlcy5sZW5ndGggKiBncmlkU2l6ZTtcclxuICAgIHZhciBmb3JtYXRWYWx1ZVR5cGUgPSBqdkNoYXJ0cy5qdkZvcm1hdFZhbHVlVHlwZShjaGFydC5kYXRhLmhlYXREYXRhKTtcclxuXHJcbiAgICAvL3ZlcnRpY2FsIGxpbmVzXHJcbiAgICB2YXIgdkxpbmUgPSB2aXMuYXBwZW5kKCdzdmc6ZycpXHJcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3ZMaW5lU2VjdGlvbicpO1xyXG5cclxuICAgIHZMaW5lLnNlbGVjdEFsbCgnLnZMaW5lU2VjdGlvbicpXHJcbiAgICAgICAgLmRhdGEoZDMucmFuZ2UoaGVhdE1hcERhdGEueEF4aXNEYXRhLnZhbHVlcy5sZW5ndGggKyAxKSlcclxuICAgICAgICAuZW50ZXIoKS5hcHBlbmQoJ2xpbmUnKVxyXG4gICAgICAgIC5hdHRyKCd4MScsIGQgPT4gZCAqIGdyaWRTaXplKVxyXG4gICAgICAgIC5hdHRyKCd4MicsIGQgPT4gZCAqIGdyaWRTaXplKVxyXG4gICAgICAgIC5hdHRyKCd5MScsIDApXHJcbiAgICAgICAgLmF0dHIoJ3kyJywgaGVpZ2h0KVxyXG4gICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgY2hhcnQuX3ZhcnMuZ3JpZExpbmVDb2xvcik7XHJcblxyXG4gICAgLy9ob3Jpem9udGFsIGxpbmVzXHJcbiAgICB2YXIgaExpbmUgPSB2aXMuYXBwZW5kKCdzdmc6ZycpXHJcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2hlYXRtYXAtY29udGFpbmVyJyk7XHJcblxyXG4gICAgaExpbmUuc2VsZWN0QWxsKCcuaGVhdG1hcC1jb250YWluZXInKVxyXG4gICAgICAgIC5kYXRhKGQzLnJhbmdlKGhlYXRNYXBEYXRhLnlBeGlzRGF0YS52YWx1ZXMubGVuZ3RoICsgMSkpXHJcbiAgICAgICAgLmVudGVyKCkuYXBwZW5kKCdsaW5lJylcclxuICAgICAgICAuYXR0cigneDEnLCAwKVxyXG4gICAgICAgIC5hdHRyKCd4MicsIHdpZHRoKVxyXG4gICAgICAgIC5hdHRyKCd5MScsIGQgPT4gZCAqIGdyaWRTaXplKVxyXG4gICAgICAgIC5hdHRyKCd5MicsIGQgPT4gZCAqIGdyaWRTaXplKVxyXG4gICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgY2hhcnQuX3ZhcnMuZ3JpZExpbmVDb2xvcik7XHJcblxyXG4gICAgdmFyIGhlYXRNYXAgPSB2aXMuYXBwZW5kKCdzdmc6ZycpXHJcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2hlYXRTZWN0aW9uJyk7XHJcblxyXG4gICAgaGVhdE1hcC5zZWxlY3RBbGwoJy5oZWF0U2VjdGlvbicpXHJcbiAgICAgICAgLmRhdGEoZGF0YSlcclxuICAgICAgICAuZW50ZXIoKS5hcHBlbmQoJ3JlY3QnKVxyXG4gICAgICAgIC5hdHRyKCd4JywgZCA9PiBkLnhBeGlzICogZ3JpZFNpemUpXHJcbiAgICAgICAgLmF0dHIoJ3knLCBkID0+IGQueUF4aXMgKiBncmlkU2l6ZSlcclxuICAgICAgICAuYXR0cigncngnLCAyKVxyXG4gICAgICAgIC5hdHRyKCdyeScsIDIpXHJcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2hlYXQnKVxyXG4gICAgICAgIC5hdHRyKCd3aWR0aCcsIGdyaWRTaXplIC0gMSlcclxuICAgICAgICAuYXR0cignaGVpZ2h0JywgZ3JpZFNpemUgLSAxKVxyXG4gICAgICAgIC5zdHlsZSgnZmlsbCcsIGQgPT4ge1xyXG4gICAgICAgICAgICBpZiAocXVhbnRpbGVzID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hhcnQuX3ZhcnMuZG9tYWluQXJyYXkubGVuZ3RoID09PSAwIHx8IChkLnZhbHVlID49IGNoYXJ0Ll92YXJzLmRvbWFpbkFycmF5WzBdICYmIGQudmFsdWUgPD0gY2hhcnQuX3ZhcnMuZG9tYWluQXJyYXlbMV0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoYXJ0LmRhdGEuY29sb3JTY2FsZShkLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiAnd2hpdGUnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjaGFydC5fdmFycy5kb21haW5BcnJheS5sZW5ndGggPT09IDAgfHwgKGQudmFsdWUgPj0gY2hhcnQuX3ZhcnMuZG9tYWluQXJyYXlbMF0gJiYgZC52YWx1ZSA8PSBjaGFydC5fdmFycy5kb21haW5BcnJheVsxXSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBnZXRRdWFudGl6ZWRDb2xvcihjaGFydC5kYXRhLmhlYXREYXRhLCBkLnZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gJ3doaXRlJztcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgLy9HZXQgdGlwIGRhdGFcclxuICAgICAgICAgICAgdmFyIHRpcERhdGEgPSBjaGFydC5zZXRUaXBEYXRhKGQsIGkpO1xyXG4gICAgICAgICAgICB0aXBEYXRhLmNvbG9yID0gY2hhcnQuZGF0YS5jb2xvclNjYWxlKGQudmFsdWUpO1xyXG5cclxuICAgICAgICAgICAgLy9EcmF3IHRpcFxyXG4gICAgICAgICAgICBjaGFydC50aXAuZ2VuZXJhdGVTaW1wbGVUaXAodGlwRGF0YSwgY2hhcnQuZGF0YS5kYXRhVGFibGUpO1xyXG4gICAgICAgICAgICBjaGFydC50aXAuZCA9IGQ7XHJcbiAgICAgICAgICAgIGNoYXJ0LnRpcC5pID0gaTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5vbignbW91c2Vtb3ZlJywgZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgaWYgKGNoYXJ0LnNob3dUb29sVGlwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hhcnQudGlwLmQgPT09IGQgJiYgY2hhcnQudGlwLmkgPT09IGkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGFydC50aXAuc2hvd1RpcChkMy5ldmVudCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vR2V0IHRpcCBkYXRhXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpcERhdGEgPSBjaGFydC5zZXRUaXBEYXRhKGQsIGkpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vRHJhdyB0aXAgbGluZVxyXG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0LnRpcC5nZW5lcmF0ZVNpbXBsZVRpcCh0aXBEYXRhLCBjaGFydC5kYXRhLmRhdGFUYWJsZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGNoYXJ0LnRpcC5oaWRlVGlwKCk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAub24oJ2RibGNsaWNrJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgY2hhcnQuY2xpY2tlZCA9ICFjaGFydC5jbGlja2VkO1xyXG4gICAgICAgICAgICBpZiAoY2hhcnQuY2xpY2tlZCkge1xyXG4gICAgICAgICAgICAgICAgLy9ib3JkZXIgYXJvdW5kIHNlbGVjdGVkIHJlY3RcclxuICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5jbGFzc2VkKCdyZWN0LWJvcmRlcicsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgLy9GYWRlIHJvdyBsYWJlbHNcclxuICAgICAgICAgICAgICAgIGQzLnNlbGVjdEFsbCgnLnJvd0xhYmVsJykuY2xhc3NlZCgndGV4dC1oaWdobGlnaHQnLCAociwgcmkpID0+IHJpICE9IGQueUF4aXMpO1xyXG4gICAgICAgICAgICAgICAgLy9mYWRlIGNvbHVtbiBsYWJlbHNcclxuICAgICAgICAgICAgICAgIGQzLnNlbGVjdEFsbCgnLmNvbExhYmVsJykuY2xhc3NlZCgndGV4dC1oaWdobGlnaHQnLCAociwgcmkpID0+IHJpICE9IGQueEF4aXMpO1xyXG4gICAgICAgICAgICAgICAgLy9mYWRlIGFsbCByZWN0cyBleGNlcHQgc2VsZWN0ZWRcclxuICAgICAgICAgICAgICAgIGQzLnNlbGVjdEFsbCgnLmhlYXQnKS5jbGFzc2VkKCdyZWN0LWhpZ2hsaWdodCcsIHIgPT4gci55QXhpcyAhPSBkLnlBeGlzIHx8IHIueEF4aXMgIT0gZC54QXhpcyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvL3JlbW92aW5nIHN0eWxpbmdcclxuICAgICAgICAgICAgICAgIGQzLnNlbGVjdEFsbCgnLnJvd0xhYmVsJykuY2xhc3NlZCgndGV4dC1oaWdobGlnaHQnLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICBkMy5zZWxlY3RBbGwoJy5jb2xMYWJlbCcpLmNsYXNzZWQoJ3RleHQtaGlnaGxpZ2h0JywgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0QWxsKCcuaGVhdCcpLmNsYXNzZWQoJ3JlY3QtaGlnaGxpZ2h0JywgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0QWxsKCcuaGVhdCcpLmNsYXNzZWQoJ3JlY3QtYm9yZGVyJywgZmFsc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG5cclxuICAgIGNoYXJ0LmNoYXJ0RGl2LnNlbGVjdCgnc3ZnLmhlYXRMZWdlbmQnKS5yZW1vdmUoKTtcclxuXHJcbiAgICBpZiAoY2hhcnQuX3ZhcnMudG9nZ2xlTGVnZW5kKSB7XHJcbiAgICAgICAgdmFyIGxlZ2VuZENvbnRhaW5lciA9IGNoYXJ0LmNoYXJ0RGl2LmFwcGVuZCgnc3ZnJylcclxuICAgICAgICAgICAgLnN0eWxlKCd0b3AnLCBjaGFydC5jb25maWcubWFyZ2luLnRvcCArICdweCcpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnYmFja2dyb3VuZCcsIGNoYXJ0Ll92YXJzLmJhY2tncm91bmRDb2xvcilcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2hlYXRMZWdlbmQnKVxyXG4gICAgICAgICAgICAuYXR0cignd2lkdGgnLCBjaGFydC5jb25maWcuaGVhdFdpZHRoKTtcclxuXHJcbiAgICAgICAgdmFyIGxlZ2VuZCA9IGxlZ2VuZENvbnRhaW5lci5zZWxlY3RBbGwoJy5sZWdlbmQnKVxyXG4gICAgICAgICAgICAuZGF0YShjaGFydC5kYXRhLmhlYXREYXRhKVxyXG4gICAgICAgICAgICAuZW50ZXIoKS5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgKGQsIGkpID0+IGB0cmFuc2xhdGUoMCwgJHtncmlkU2l6ZSAqIGl9IClgKTtcclxuXHJcbiAgICAgICAgbGVnZW5kLmFwcGVuZCgncmVjdCcpXHJcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdsZWdlbmQnKVxyXG4gICAgICAgICAgICAuYXR0cignd2lkdGgnLCBncmlkU2l6ZSlcclxuICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGdyaWRTaXplKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCAoZCwgaSkgPT4gY29sb3JzW2ldKVxyXG4gICAgICAgICAgICAub24oJ2NsaWNrJywgKCkgPT4gZDMuc2VsZWN0QWxsKCcuaGVhdCcpLmNsYXNzZWQoJ3JlY3QtaGlnaGxpZ2h0JywgZmFsc2UpKVxyXG4gICAgICAgICAgICAvL3JlbW92aW5nIHN0eWxpbmdcclxuICAgICAgICAgICAgLy9mYWRlIGFsbCByZWN0cyBleGNlcHQgc2VsZWN0ZWRcclxuICAgICAgICAgICAgLm9uKCdkYmxjbGljaycsIGQgPT4gZDMuc2VsZWN0QWxsKCcuaGVhdCcpLmNsYXNzZWQoJ3JlY3QtaGlnaGxpZ2h0JywgciA9PiByLnZhbHVlIDwgZCkpO1xyXG5cclxuICAgICAgICBsZWdlbmQuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2xlZ2VuZFRleHQnKVxyXG4gICAgICAgICAgICAuYXR0cigneCcsIGdyaWRTaXplICsgbGVnZW5kU3BhY2luZylcclxuICAgICAgICAgICAgLmF0dHIoJ3knLCBncmlkU2l6ZSAtIGxlZ2VuZFNwYWNpbmcpXHJcbiAgICAgICAgICAgIC50ZXh0KGQgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKGQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ganZDaGFydHMuanZGb3JtYXRWYWx1ZShkLCBmb3JtYXRWYWx1ZVR5cGUpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBjaGFydC5fdmFycy5ibGFjayk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0UXVhbnRpemVkQ29sb3IocXVhbnRpemVkQXJyYXksIHZhbHVlKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBxdWFudGl6ZWRBcnJheS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgPCBxdWFudGl6ZWRBcnJheVtpXSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbG9yc1tpIC0gMV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvbG9yc1txdWFudGl6ZWRBcnJheS5sZW5ndGggLSAxXTtcclxuICAgIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBqdkNoYXJ0cztcclxuXHJcblxyXG4iLCIndXNlIHN0cmljdCc7XHJcbnZhciBqdkNoYXJ0cyA9IHJlcXVpcmUoJy4uL2p2Q2hhcnRzLmpzJyk7XHJcblxyXG5cclxuanZDaGFydHMucHJvdG90eXBlLmxpbmUgPSB7XHJcbiAgICBwYWludDogcGFpbnQsXHJcbiAgICBzZXREYXRhOiBzZXREYXRhLFxyXG4gICAgZ2V0RXZlbnREYXRhOiBnZXRFdmVudERhdGEsXHJcbiAgICBoaWdobGlnaHRGcm9tRXZlbnREYXRhOiBoaWdobGlnaHRGcm9tRXZlbnREYXRhXHJcbn07XHJcblxyXG5qdkNoYXJ0cy5wcm90b3R5cGUuZ2VuZXJhdGVMaW5lID0gZ2VuZXJhdGVMaW5lO1xyXG5qdkNoYXJ0cy5wcm90b3R5cGUuc2V0TGluZVRocmVzaG9sZERhdGEgPSBzZXRMaW5lVGhyZXNob2xkRGF0YTtcclxuXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogTGluZSBmdW5jdGlvbnMgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuLyoqc2V0TGluZURhdGFcclxuICogIGdldHMgbGluZSBkYXRhIGFuZCBhZGRzIGl0IHRvIHRoZSBjaGFydCBvYmplY3RcclxuICpcclxuICogQHBhcmFtcyBkYXRhLCBkYXRhVGFibGUsIGNvbG9yc1xyXG4gKi9cclxuZnVuY3Rpb24gc2V0RGF0YSgpIHtcclxuICAgIHZhciBjaGFydCA9IHRoaXM7XHJcbiAgICAvL3NvcnQgY2hhcnQgZGF0YSBpZiB0aGVyZSBpcyBhIHNvcnQgdHlwZSBhbmQgbGFiZWwgaW4gdGhlIF92YXJzXHJcbiAgICBpZiAoY2hhcnQuX3ZhcnMuc29ydFR5cGUpIHtcclxuICAgICAgICBpZiAoY2hhcnQuX3ZhcnMuc29ydExhYmVsICYmIGNoYXJ0Ll92YXJzLnNvcnRUeXBlICE9PSAnZGVmYXVsdCcpIHtcclxuICAgICAgICAgICAgY2hhcnQub3JnYW5pemVDaGFydERhdGEoY2hhcnQuX3ZhcnMuc29ydExhYmVsLCBjaGFydC5fdmFycy5zb3J0VHlwZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2hhcnQuZGF0YS5sZWdlbmREYXRhID0gc2V0QmFyTGluZUxlZ2VuZERhdGEoY2hhcnQuZGF0YSk7XHJcbiAgICBjaGFydC5kYXRhLnhBeGlzRGF0YSA9IGNoYXJ0LnNldEF4aXNEYXRhKCd4JywgY2hhcnQuZGF0YSk7XHJcbiAgICBjaGFydC5kYXRhLnlBeGlzRGF0YSA9IGNoYXJ0LnNldEF4aXNEYXRhKCd5JywgY2hhcnQuZGF0YSk7XHJcblxyXG4gICAgaWYgKGNoYXJ0Ll92YXJzLnNlcmllc0ZsaXBwZWQpIHtcclxuICAgICAgICBjaGFydC5zZXRGbGlwcGVkU2VyaWVzKGNoYXJ0LmRhdGEuZGF0YVRhYmxlS2V5cyk7XHJcbiAgICAgICAgY2hhcnQuZmxpcHBlZERhdGEuY29sb3IgPSBqdkNoYXJ0cy5zZXRDaGFydENvbG9ycyhjaGFydC5fdmFycy5jb2xvciwgY2hhcnQuZmxpcHBlZERhdGEubGVnZW5kRGF0YSwgY2hhcnQuY29sb3JzKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoY2hhcnQuZGF0YS5kYXRhVGFibGUuaGFzT3duUHJvcGVydHkoJ3NlcmllcycpKSB7XHJcbiAgICAgICAgY2hhcnQuZGF0YS5jaGFydERhdGEgPSBzZXRTZXJpZXNEYXRhKGNoYXJ0LmRhdGEuY2hhcnREYXRhLCBjaGFydC5kYXRhLmRhdGFUYWJsZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy9kZWZpbmUgY29sb3Igb2JqZWN0IGZvciBjaGFydERhdGFcclxuICAgIGNoYXJ0LmRhdGEuY29sb3IgPSBqdkNoYXJ0cy5zZXRDaGFydENvbG9ycyhjaGFydC5fdmFycy5jb2xvciwgY2hhcnQuZGF0YS5sZWdlbmREYXRhLCBjaGFydC5jb2xvcnMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRFdmVudERhdGEoZXZlbnQpIHtcclxuICAgIHZhciBjaGFydCA9IHRoaXM7XHJcbiAgICBpZiAoZXZlbnQudGFyZ2V0LmNsYXNzTGlzdC52YWx1ZS5zcGxpdCgnYmFyLWNvbC0nKVsxXSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgICAgIFtjaGFydC5jdXJyZW50RGF0YS5kYXRhVGFibGUubGFiZWxdOiBbZXZlbnQudGFyZ2V0LmNsYXNzTGlzdC52YWx1ZS5zcGxpdCgnYmFyLWNvbC0nKVsxXS5yZXBsYWNlKC9fL2csICcgJykucmVwbGFjZSgvX2NvbG9uXy9nLCAnOicpLnJlcGxhY2UoL19kb3RfL2csICcuJyldXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG5vZGU6IGV2ZW50LnRhcmdldFxyXG4gICAgICAgIH07XHJcbiAgICB9IGVsc2UgaWYgKGV2ZW50LnRhcmdldC5jbGFzc0xpc3QudmFsdWUuaW5kZXhPZignbGluZS1jb250YWluZXInKSA+IC0xKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZGF0YToge31cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBkYXRhOiBmYWxzZVxyXG4gICAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gaGlnaGxpZ2h0RnJvbUV2ZW50RGF0YShldmVudCkge1xyXG4gICAgbGV0IGNoYXJ0ID0gdGhpcyxcclxuICAgICAgICBsYWJlbCA9IGV2ZW50LmRhdGFbY2hhcnQuY3VycmVudERhdGEuZGF0YVRhYmxlLmxhYmVsXVswXSxcclxuICAgICAgICBjc3NDbGFzcyA9ICcuaGlnaGxpZ2h0LWNsYXNzLScgKyBsYWJlbC5yZXBsYWNlKC9cXHMvZywgJ18nKS5yZXBsYWNlKC9cXC4vZywgJ19kb3RfJyksXHJcbiAgICAgICAgbm9kZSA9IGNoYXJ0LnN2Zy5zZWxlY3RBbGwoY3NzQ2xhc3MpO1xyXG5cclxuICAgIGNoYXJ0LnN2Zy5zZWxlY3QoJy5saW5lLWNvbnRhaW5lcicpLnNlbGVjdEFsbCgnY2lyY2xlJylcclxuICAgICAgICAuYXR0cignc3Ryb2tlJywgMClcclxuICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgMCk7XHJcbiAgICAvL2hpZ2hsaWdodCBuZWNlc3NhcnkgY2lyY2xlc1xyXG4gICAgbm9kZVxyXG4gICAgICAgIC5hdHRyKCdzdHJva2UnLCBjaGFydC5fdmFycy5oaWdobGlnaHRCb3JkZXJDb2xvcilcclxuICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgY2hhcnQuX3ZhcnMuaGlnaGxpZ2h0Qm9yZGVyV2lkdGgpO1xyXG59XHJcblxyXG4vKipcclxuICogQG5hbWUgc2V0U2VyaWVzRGF0YVxyXG4gKiBAZGVzYyBTZXRzIGNoYXJ0RGF0YSB0byBjb250YWluIGEgc2VyaWVzIGRhdGEgaWYgdGhlIHNlcmllcyBmaWVsZCBleGlzdHMgaW4gdmlzdWFsIHBhbmVsXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRTZXJpZXNEYXRhKGRhdGEsIGRhdGFUYWJsZSkge1xyXG4gICAgdmFyIGxhYmVsTGlzdCA9IFtdLFxyXG4gICAgICAgIGFkZCxcclxuICAgICAgICBuZXdEYXRhID0gW107XHJcbiAgICAvL0dldCB1bmlxdWUgbGFiZWwgbGlzdFxyXG4gICAgZm9yIChsZXQgZGF0YUVsZSBvZiBkYXRhKSB7XHJcbiAgICAgICAgYWRkID0gdHJ1ZTtcclxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxhYmVsTGlzdC5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICBpZiAoZGF0YUVsZVtkYXRhVGFibGUubGFiZWxdID09PSBsYWJlbExpc3Rbal0pIHtcclxuICAgICAgICAgICAgICAgIGFkZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFkZCkge1xyXG4gICAgICAgICAgICBsYWJlbExpc3QucHVzaChkYXRhRWxlW2RhdGFUYWJsZS5sYWJlbF0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vSXRlcmF0ZSBvdmVyIGxhYmVsIGxpc3RcclxuICAgIHZhciBuZXdEYXRhID0gW107XHJcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgbGFiZWxMaXN0Lmxlbmd0aDsgaSsrKXtcclxuICAgICAgICB2YXIgZGF0YU9iaiA9IHt9O1xyXG4gICAgICAgIGRhdGFPYmpbZGF0YVRhYmxlLmxhYmVsXSA9IGxhYmVsTGlzdFtpXTtcclxuICAgICAgICBmb3IobGV0IGogPSAwOyBqIDwgZGF0YS5sZW5ndGg7IGorKyl7XHJcbiAgICAgICAgICAgIGlmKGRhdGFbal1bZGF0YVRhYmxlLmxhYmVsXSA9PT0gbGFiZWxMaXN0W2ldKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3RW50cnkgPSBkYXRhW2pdW2RhdGFUYWJsZS5zZXJpZXNdICsgJyAnICsgZGF0YVRhYmxlWyd2YWx1ZSAxJ107XHJcbiAgICAgICAgICAgICAgICBkYXRhT2JqW25ld0VudHJ5XSA9IGRhdGFbal1bZGF0YVRhYmxlWyd2YWx1ZSAxJ11dO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG5ld0RhdGEucHVzaChkYXRhT2JqKTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXdEYXRhO1xyXG59XHJcblxyXG4vKipzZXRCYXJMaW5lTGVnZW5kRGF0YVxyXG4gKiAgZ2V0cyBsZWdlbmQgaW5mbyBmcm9tIGNoYXJ0IERhdGFcclxuICpcclxuICogQHBhcmFtcyBkYXRhLCB0eXBlXHJcbiAqIEByZXR1cm5zIFtdIG9mIGxlZ2VuZCB0ZXhcclxuICovXHJcbmZ1bmN0aW9uIHNldEJhckxpbmVMZWdlbmREYXRhKGRhdGEpIHtcclxuICAgIHZhciBsZWdlbmRBcnJheSA9IFtdO1xyXG5cclxuICAgIGlmIChkYXRhLmRhdGFUYWJsZS5oYXNPd25Qcm9wZXJ0eSgnc2VyaWVzJykpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEuY2hhcnREYXRhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBhZGRUb0xlZ2VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbGVnZW5kQXJyYXkubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IGRhdGEuY2hhcnREYXRhW2ldW2RhdGEuZGF0YVRhYmxlLnNlcmllc10gKyAnICcgKyBkYXRhLmRhdGFUYWJsZVsndmFsdWUgMSddO1xyXG4gICAgICAgICAgICAgICAgaWYgKGVudHJ5ID09PSBsZWdlbmRBcnJheVtqXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZFRvTGVnZW5kID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGFkZFRvTGVnZW5kKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3RW50cnkgPSBkYXRhLmNoYXJ0RGF0YVtpXVtkYXRhLmRhdGFUYWJsZS5zZXJpZXNdICsgJyAnICsgZGF0YS5kYXRhVGFibGVbJ3ZhbHVlIDEnXTtcclxuICAgICAgICAgICAgICAgIGxlZ2VuZEFycmF5LnB1c2gobmV3RW50cnkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZm9yICh2YXIgaXRlbSBpbiBkYXRhLmRhdGFUYWJsZSkge1xyXG4gICAgICAgICAgICBpZiAoZGF0YS5kYXRhVGFibGUuaGFzT3duUHJvcGVydHkoaXRlbSkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpdGVtICE9PSAnbGFiZWwnICYmIGl0ZW0uaW5kZXhPZigndG9vbHRpcCcpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxlZ2VuZEFycmF5LnB1c2goZGF0YS5kYXRhVGFibGVbaXRlbV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICByZXR1cm4gbGVnZW5kQXJyYXk7XHJcbn1cclxuLyoqcGFpbnRMaW5lQ2hhcnRcclxuICpcclxuICogVGhlIGluaXRpYWwgc3RhcnRpbmcgcG9pbnQgZm9yIGxpbmUgY2hhcnQsIGJlZ2lucyB0aGUgZHJhd2luZyBwcm9jZXNzLiBNdXN0IGFscmVhZHkgaGF2ZSB0aGUgZGF0YSBzdG9yZWQgaW4gdGhlIGNoYXJ0XHJcbiAqIG9iamVjdFxyXG4gKi9cclxuZnVuY3Rpb24gcGFpbnQoKSB7XHJcbiAgICB2YXIgY2hhcnQgPSB0aGlzO1xyXG4gICAgLy9Vc2VzIHRoZSBvcmlnaW5hbCBkYXRhIGFuZCB0aGVuIG1hbmlwdWxhdGVzIGl0IGJhc2VkIG9uIGFueSBleGlzdGluZyBvcHRpb25zXHJcbiAgICB2YXIgZGF0YU9iaiA9IGNoYXJ0LmdldEJhckRhdGFGcm9tT3B0aW9ucygpO1xyXG5cclxuICAgIC8vYXNzaWduIGN1cnJlbnQgZGF0YSB3aGljaCBpcyB1c2VkIGJ5IGFsbCBiYXIgY2hhcnQgb3BlcmF0aW9uc1xyXG4gICAgY2hhcnQuY3VycmVudERhdGEgPSBkYXRhT2JqO1xyXG5cclxuICAgIC8vZ2VuZXJhdGUgc3ZnIGR5bmFtaWNhbGx5IGJhc2VkIG9uIGxlZ2VuZCBkYXRhXHJcbiAgICBjaGFydC5nZW5lcmF0ZVNWRyhkYXRhT2JqLmxlZ2VuZERhdGEpO1xyXG4gICAgY2hhcnQuZ2VuZXJhdGVYQXhpcyhkYXRhT2JqLnhBeGlzRGF0YSk7XHJcbiAgICBjaGFydC5nZW5lcmF0ZVlBeGlzKGRhdGFPYmoueUF4aXNEYXRhKTtcclxuICAgIGNoYXJ0LmdlbmVyYXRlTGVnZW5kKGRhdGFPYmoubGVnZW5kRGF0YSwgJ2dlbmVyYXRlTGluZScpO1xyXG4gICAgaWYgKGNoYXJ0Ll92YXJzLnJvdGF0ZUF4aXMpIHtcclxuICAgICAgICBjaGFydC5mb3JtYXRYQXhpc0xhYmVscyhkYXRhT2JqLnhBeGlzU2NhbGUudGlja3MoKS5sZW5ndGgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBjaGFydC5mb3JtYXRYQXhpc0xhYmVscyhkYXRhT2JqLnhBeGlzU2NhbGUuZG9tYWluKCkubGVuZ3RoKTtcclxuICAgIH1cclxuXHJcbiAgICBjaGFydC5nZW5lcmF0ZUxpbmUoZGF0YU9iaik7XHJcbn1cclxuXHJcbi8qKmdlbmVyYXRlTGluZVxyXG4gKlxyXG4gKiBQYWludHMgdGhlIGxpbmVzXHJcbiAqIEBwYXJhbXMgbGluZURhdGFcclxuICovXHJcbmZ1bmN0aW9uIGdlbmVyYXRlTGluZShsaW5lRGF0YSkge1xyXG4gICAgdmFyIGNoYXJ0ID0gdGhpcyxcclxuICAgICAgICBzdmcgPSBjaGFydC5zdmc7XHJcblxyXG4gICAgc3ZnLnNlbGVjdEFsbCgnZy4nICsgY2hhcnQuY29uZmlnLnR5cGUgKyAnLWNvbnRhaW5lcicpLnJlbW92ZSgpO1xyXG4gICAgdmFyIGxpbmVzID0gc3ZnLmFwcGVuZCgnZycpXHJcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgY2hhcnQuY29uZmlnLnR5cGUgKyAnLWNvbnRhaW5lcicpXHJcbiAgICAgICAgLnNlbGVjdEFsbCgnZycpO1xyXG5cclxuICAgIHZhciBkYXRhSGVhZGVycyA9IGxpbmVEYXRhLmxlZ2VuZERhdGE7XHJcblxyXG4gICAgaWYgKGNoYXJ0Ll92YXJzLnNlcmllc0ZsaXBwZWQgJiYgY2hhcnQuX3ZhcnMuZmxpcHBlZExlZ2VuZEhlYWRlcnMpIHtcclxuICAgICAgICBkYXRhSGVhZGVycyA9IGNoYXJ0Ll92YXJzLmZsaXBwZWRMZWdlbmRIZWFkZXJzO1xyXG4gICAgfSBlbHNlIGlmIChjaGFydC5fdmFycy5sZWdlbmRIZWFkZXJzKSB7XHJcbiAgICAgICAgZGF0YUhlYWRlcnMgPSBjaGFydC5fdmFycy5sZWdlbmRIZWFkZXJzO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBsaW5lRGF0YU5ldyA9IGp2Q2hhcnRzLmdldFRvZ2dsZWREYXRhKGxpbmVEYXRhLCBkYXRhSGVhZGVycyk7XHJcblxyXG4gICAgLy9JZiBpdCdzIGFuIGFyZWEgY2hhcnQsIGFkZCB0aGUgYXJlYVxyXG4gICAgaWYgKGNoYXJ0LmNvbmZpZy50eXBlID09PSAnYXJlYScpIHtcclxuICAgICAgICBjaGFydC5maWxsQXJlYShsaW5lRGF0YU5ldyk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2VuZXJhdGVMaW5lR3JvdXBzKGxpbmVzLCBsaW5lRGF0YU5ldywgY2hhcnQpO1xyXG4gICAgdmFyIGV2ZW50R3JvdXBzID0ganZDaGFydHMuZ2VuZXJhdGVFdmVudEdyb3VwcyhsaW5lcywgbGluZURhdGFOZXcsIGNoYXJ0KTtcclxuXHJcbiAgICBldmVudEdyb3Vwc1xyXG4gICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKGQsIGksIGopIHsgLy9UcmFuc2l0aW9ucyBpbiBEMyBkb24ndCBzdXBwb3J0IHRoZSAnb24nIGZ1bmN0aW9uIFRoZXkgb25seSBleGlzdCBvbiBzZWxlY3Rpb25zLiBTbyBuZWVkIHRvIG1vdmUgdGhhdCBldmVudCBsaXN0ZW5lciBhYm92ZSB0cmFuc2l0aW9uIGFuZCBhZnRlciBhcHBlbmRcclxuICAgICAgICAgICAgaWYgKGNoYXJ0LnNob3dUb29sVGlwKSB7XHJcbiAgICAgICAgICAgICAgICAvL0dldCB0aXAgZGF0YVxyXG4gICAgICAgICAgICAgICAgdmFyIHRpcERhdGEgPSBjaGFydC5zZXRUaXBEYXRhKGQsIGkpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vRHJhdyB0aXBcclxuICAgICAgICAgICAgICAgIGNoYXJ0LnRpcC5nZW5lcmF0ZVNpbXBsZVRpcCh0aXBEYXRhLCBjaGFydC5kYXRhLmRhdGFUYWJsZSk7XHJcbiAgICAgICAgICAgICAgICBjaGFydC50aXAuZCA9IGQ7XHJcbiAgICAgICAgICAgICAgICBjaGFydC50aXAuaSA9IGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICAgIC5vbignbW91c2Vtb3ZlJywgZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgaWYgKGNoYXJ0LnNob3dUb29sVGlwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hhcnQudGlwLmQgPT09IGQgJiYgY2hhcnQudGlwLmkgPT09IGkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGFydC50aXAuc2hvd1RpcChkMy5ldmVudCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vR2V0IHRpcCBkYXRhXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpcERhdGEgPSBjaGFydC5zZXRUaXBEYXRhKGQsIGkpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vRHJhdyB0aXAgbGluZVxyXG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0LnRpcC5nZW5lcmF0ZVNpbXBsZVRpcCh0aXBEYXRhLCBjaGFydC5kYXRhLmRhdGFUYWJsZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICBjaGFydC50aXAuaGlkZVRpcCgpO1xyXG4gICAgICAgICAgICBzdmcuc2VsZWN0QWxsKCcudGlwLWxpbmUnKS5yZW1vdmUoKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICBjaGFydC5kaXNwbGF5VmFsdWVzKCk7XHJcbiAgICBjaGFydC5nZW5lcmF0ZUNsaXBQYXRoKCk7XHJcbiAgICBjaGFydC5nZW5lcmF0ZUxpbmVUaHJlc2hvbGQoKTtcclxuXHJcbiAgICByZXR1cm4gbGluZXM7XHJcbn1cclxuXHJcbi8qKmdlbmVyYXRlTGluZUdyb3Vwc1xyXG4gKlxyXG4gKiBQYWludHMgdGhlIGdyb3VwcyBvZiB0aGUgbGluZXNcclxuICogQHBhcmFtcyBjaGFydENvbnRhaW5lciwgYmFyRGF0YSwgY2hhcnRcclxuICovXHJcbmZ1bmN0aW9uIGdlbmVyYXRlTGluZUdyb3VwcyhsaW5lQ29udGFpbmVyLCBsaW5lRGF0YSwgY2hhcnQpIHtcclxuICAgIHZhciBjb250YWluZXIgPSBjaGFydC5jb25maWcuY29udGFpbmVyLFxyXG4gICAgICAgIHhBeGlzRGF0YSA9IGNoYXJ0LmN1cnJlbnREYXRhLnhBeGlzRGF0YSxcclxuICAgICAgICB5QXhpc0RhdGEgPSBjaGFydC5jdXJyZW50RGF0YS55QXhpc0RhdGEsXHJcbiAgICAgICAgbGVnZW5kRGF0YSA9IGNoYXJ0LmN1cnJlbnREYXRhLmxlZ2VuZERhdGEsXHJcbiAgICAgICAgY29sb3JzID0gY2hhcnQuX3ZhcnMuY29sb3IsXHJcbiAgICAgICAgbGluZXMsXHJcbiAgICAgICAgbGluZUxlbmd0aCA9IGxpbmVEYXRhLmxlbmd0aCxcclxuICAgICAgICBsZWdlbmRMZW5ndGggPSBsZWdlbmREYXRhLmxlbmd0aDtcclxuXHJcbiAgICAvL0dldCBQb3NpdGlvbiBDYWxjdWxhdGlvbnNcclxuICAgIHZhciB4ID0ganZDaGFydHMuZ2V0QXhpc1NjYWxlKCd4JywgeEF4aXNEYXRhLCBjb250YWluZXIsIGNoYXJ0Ll92YXJzLCAnbm8tcGFkZGluZycpO1xyXG4gICAgdmFyIHkgPSBqdkNoYXJ0cy5nZXRBeGlzU2NhbGUoJ3knLCB5QXhpc0RhdGEsIGNvbnRhaW5lciwgY2hhcnQuX3ZhcnMsICduby1wYWRkaW5nJyk7XHJcblxyXG4gICAgdmFyIHhUcmFuc2xhdGUsXHJcbiAgICAgICAgeVRyYW5zbGF0ZTtcclxuXHJcbiAgICBpZiAoY2hhcnQuX3ZhcnMucm90YXRlQXhpcyA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIHhUcmFuc2xhdGUgPSBmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICBpZiAoZCA9PT0gJycpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB4KCdFTVBUWV9TVFJJTkcnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4geChkKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHlUcmFuc2xhdGUgPSBmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICByZXR1cm4gKHkobGluZURhdGFbaV1beUF4aXNEYXRhLmxhYmVsXSkpICsgKGNvbnRhaW5lci5oZWlnaHQgLyAobGluZUxlbmd0aCkgLyAyKTsvLysgY29udGFpbmVyLmhlaWdodCAvIChsaW5lTGVuZ3RoKSAvIDIgIC0geS5wYWRkaW5nSW5uZXIoKSk7XHJcbiAgICAgICAgfTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgeFRyYW5zbGF0ZSA9IGZ1bmN0aW9uIChkLCBpKSB7XHJcbiAgICAgICAgICAgIGlmIChsaW5lRGF0YVtpXVt4QXhpc0RhdGEubGFiZWxdID09PSAnJykge1xyXG4gICAgICAgICAgICAgICAgbGluZURhdGFbaV1beEF4aXNEYXRhLmxhYmVsXSA9ICdFTVBUWV9TVFJJTkcnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAoeChsaW5lRGF0YVtpXVt4QXhpc0RhdGEubGFiZWxdKSkgKyAoY29udGFpbmVyLndpZHRoIC8gKGxpbmVMZW5ndGgpIC8gMik7Ly8rIGNvbnRhaW5lci53aWR0aCAvIChsaW5lTGVuZ3RoKSAvIDIgLSB4LnBhZGRpbmdJbm5lcigpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHlUcmFuc2xhdGUgPSBmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICByZXR1cm4geShkKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vQXBwZW5kIGxpbmVzIGFuZCBjaXJjbGVzXHJcblxyXG4gICAgdmFyIHVuaXF1ZVhBeGlzRGF0YSA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFydC5kYXRhLnhBeGlzRGF0YS52YWx1ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgYWRkID0gdHJ1ZTtcclxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHVuaXF1ZVhBeGlzRGF0YS5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICBpZiAoY2hhcnQuZGF0YS54QXhpc0RhdGEudmFsdWVzW2ldID09PSB1bmlxdWVYQXhpc0RhdGFbal0pIHtcclxuICAgICAgICAgICAgICAgIGFkZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFkZCkge1xyXG4gICAgICAgICAgICB1bmlxdWVYQXhpc0RhdGEucHVzaChjaGFydC5kYXRhLnhBeGlzRGF0YS52YWx1ZXNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG5cclxuICAgIHZhciBkYXRhID0ge307XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVMZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgbGVnZW5kTGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGFydC5fdmFycy5sZWdlbmRPcHRpb25zICE9PSAndW5kZWZpbmVkJykgey8vQWNjb3VudGluZyBmb3IgbGVnZW5kIHRvZ2dsZXNcclxuICAgICAgICAgICAgICAgIGlmIChjaGFydC5fdmFycy5sZWdlbmRPcHRpb25zW2tdLnRvZ2dsZSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL0Rvbid0IHdyaXRlIGFueXRoaW5nIHRvIGRhdGFcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9Xcml0ZSBzb21ldGhpbmcgdG8gZGF0YVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZGF0YVtsZWdlbmREYXRhW2tdXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhW2xlZ2VuZERhdGFba11dID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFbbGVnZW5kRGF0YVtrXV0ucHVzaChwYXJzZUZsb2F0KGxpbmVEYXRhW2ldW2xlZ2VuZERhdGFba11dKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7Ly9Jbml0aWFsIGNyZWF0aW9uIG9mIHZpc3VhbGl6YXRpb24gdy9vIGxlZ2VuZCBvcHRpb25zXHJcbiAgICAgICAgICAgICAgICBpZiAoIWRhdGFbbGVnZW5kRGF0YVtrXV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhW2xlZ2VuZERhdGFba11dID0gW107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0YVtsZWdlbmREYXRhW2tdXS5sZW5ndGggPCBsaW5lTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtsZWdlbmREYXRhW2tdXS5wdXNoKHBhcnNlRmxvYXQobGluZURhdGFbaV1bbGVnZW5kRGF0YVtrXV0pKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjaGFydC5zdmcuc2VsZWN0QWxsKCcubGluZXMnKS5yZW1vdmUoKTtcclxuICAgIGNoYXJ0LnN2Zy5zZWxlY3RBbGwoJy5saW5lJykucmVtb3ZlKCk7XHJcbiAgICBjaGFydC5zdmcuc2VsZWN0QWxsKCcuY2lyY2xlJykucmVtb3ZlKCk7XHJcbiAgICBjaGFydC5zdmcuc2VsZWN0QWxsKCcjbGluZS1ncmFkaWVudCcpLnJlbW92ZSgpO1xyXG5cclxuICAgIGxpbmVzID0gY2hhcnQuc3ZnLnNlbGVjdEFsbCgnLicgKyBjaGFydC5jb25maWcudHlwZSArICctY29udGFpbmVyJyk7XHJcblxyXG4gICAgLy9jdXJ2ZXMgb2JqZWN0XHJcbiAgICB2YXIgY3VydmVzID0ge1xyXG4gICAgICAgICdMaW5lYXInOiBkMy5jdXJ2ZUxpbmVhcixcclxuICAgICAgICAnU3RlcCc6IGQzLmN1cnZlU3RlcCxcclxuICAgICAgICAnU3RlcCBCZWZvcmUnOiBkMy5jdXJ2ZVN0ZXBCZWZvcmUsXHJcbiAgICAgICAgJ1N0ZXAgQWZ0ZXInOiBkMy5jdXJ2ZVN0ZXBBZnRlcixcclxuICAgICAgICAnQmFzaXMnOiBkMy5jdXJ2ZUJhc2lzLFxyXG4gICAgICAgICdDYXJkaW5hbCc6IGQzLmN1cnZlQ2FyZGluYWwsXHJcbiAgICAgICAgJ01vbm90b25lIFgnOiBkMy5jdXJ2ZU1vbm90b25lWCxcclxuICAgICAgICAnQ2F0bXVsbCBSb20nOiBkMy5jdXJ2ZUNhdG11bGxSb21cclxuICAgIH07XHJcblxyXG4gICAgdmFyIHZhbHVlbGluZSA9IHt9O1xyXG4gICAgdmFyIGNpcmNsZXMgPSB7fTtcclxuICAgIHZhciBpbmRleCA9IDA7XHJcbiAgICB2YXIgbGluZUNvbG9ycyA9IFtdO1xyXG4gICAgdmFyIHRocmVzaG9sZGluZyA9IGZhbHNlO1xyXG4gICAgZm9yICh2YXIgayBpbiBkYXRhKSB7XHJcbiAgICAgICAgLy9DcmVhdGUgcGF0aCBnZW5lcmF0b3IgZm9yIGVhY2ggc2VyaWVzXHJcbiAgICAgICAgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkoaykpIHtcclxuICAgICAgICAgICAgaWYgKGRhdGFba10gPT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICBkYXRhW2tdID0gJ0VNUFRZX1NUUklORyc7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhbHVlbGluZVtrXSA9IGQzLmxpbmUoKS8vbGluZSBkcmF3aW5nIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAuY3VydmUoY3VydmVzW2NoYXJ0Ll92YXJzLmxpbmVDdXJ2ZVR5cGVdKVxyXG4gICAgICAgICAgICAgICAgLmRlZmluZWQoZnVuY3Rpb24oZCl7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFpc05hTihkKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAueChmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc05hTihkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB4VHJhbnNsYXRlKGQsIGkpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC55KGZ1bmN0aW9uIChkLCBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmFOKGQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHlUcmFuc2xhdGUoZCwgaSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcblxyXG4gICAgICAgICAgICAvL0FkZCBsaW5lcyB0byB0aGUgY2hhcnQuY29uZmlnLnR5cGUgKyAnLWNvbnRhaW5lcidcclxuICAgICAgICAgICAgbGluZXNcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2xpbmUgJyArIChrKSlcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3BhdGgnKS8vZHJhd3MgdGhlIGxpbmVcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCBmdW5jdGlvbiAoZCwgaSwgaikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2xvck9iaiA9IGp2Q2hhcnRzLmdldENvbG9ycyhjb2xvcnMsIGksIGspO1xyXG4gICAgICAgICAgICAgICAgICAgIGxpbmVDb2xvcnMucHVzaChjb2xvck9iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbG9yT2JqO1xyXG4gICAgICAgICAgICAgICAgfSkgICAvL2ZpbGxzIHRoZSBiYXIgd2l0aCBjb2xvclxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsICcyJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgJ25vbmUnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCBmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZWxpbmVba10oZGF0YVtrXSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vQ29sb3IgVGhyZXNob2xkaW5nIGZvciBlYWNoIHRpZXJcclxuICAgICAgICAgICAgaWYgKGNoYXJ0Ll92YXJzLnRocmVzaG9sZHMgIT0gJ25vbmUnICYmIGNoYXJ0Ll92YXJzLmNvbG9yQ2hhcnQgIT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjaGFydC5fdmFycy5jb2xvckxpbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGhyZXNob2xkUGVyY2VudHMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGhyZXNob2xkTGVuZ3RoID0gT2JqZWN0LmtleXMoY2hhcnQuX3ZhcnMudGhyZXNob2xkcykubGVuZ3RoXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJ0Ll92YXJzLnJvdGF0ZUF4aXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHplcm8gPSB7IHBlcmNlbnQ6IDAsIGNvbG9yOiBsaW5lQ29sb3JzW2luZGV4XSB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJlc2hvbGRQZXJjZW50cy5wdXNoKHplcm8pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgeiA9IDA7IHogPCB0aHJlc2hvbGRMZW5ndGg7IHorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBDZW50ID0gKChjaGFydC5fdmFycy50aHJlc2hvbGRzW3pdLnRocmVzaG9sZCkgKiAxMDApIC8gKHhBeGlzRGF0YS5tYXggLSB4QXhpc0RhdGEubWluKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wID0geyBwZXJjZW50OiBwQ2VudCwgY29sb3I6IGNoYXJ0Ll92YXJzLnRocmVzaG9sZHNbel0udGhyZXNob2xkQ29sb3IgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocmVzaG9sZFBlcmNlbnRzLnB1c2godGVtcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgemVybyA9IHsgcGVyY2VudDogMCwgY29sb3I6IGxpbmVDb2xvcnNbaW5kZXhdIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocmVzaG9sZFBlcmNlbnRzLnB1c2goemVybyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB6ID0gMDsgeiA8IHRocmVzaG9sZExlbmd0aDsgeisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcENlbnQgPSAoKGNoYXJ0Ll92YXJzLnRocmVzaG9sZHNbel0udGhyZXNob2xkKSAqIDEwMCkgLyAoeUF4aXNEYXRhLm1heCAtIHlBeGlzRGF0YS5taW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXAgPSB7IHBlcmNlbnQ6IHBDZW50LCBjb2xvcjogY2hhcnQuX3ZhcnMudGhyZXNob2xkc1t6XS50aHJlc2hvbGRDb2xvciB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyZXNob2xkUGVyY2VudHMucHVzaCh0ZW1wKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0aHJlc2hvbGREYXRhID0gY2hhcnQuc2V0TGluZVRocmVzaG9sZERhdGEoY2hhcnQsIHRocmVzaG9sZFBlcmNlbnRzLCBsaW5lQ29sb3JzW2luZGV4XSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGxpbmVzLnNlbGVjdEFsbCgncGF0aCcpLmF0dHIoJ2NsYXNzJywgJ2xpbmUtdGhyZXNob2xkJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFydC5fdmFycy5yb3RhdGVBeGlzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJ0LnN2Zy5hcHBlbmQoJ2xpbmVhckdyYWRpZW50JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsICdsaW5lLWdyYWRpZW50JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdncmFkaWVudFVuaXRzJywgJ3VzZXJTcGFjZU9uVXNlJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsIHhUcmFuc2xhdGUoeEF4aXNEYXRhLm1pbikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneTEnLCAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgeFRyYW5zbGF0ZSh4QXhpc0RhdGEubWF4KSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKCdzdG9wJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5kYXRhKHRocmVzaG9sZERhdGEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZW50ZXIoKS5hcHBlbmQoJ3N0b3AnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ29mZnNldCcsIGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLm9mZnNldDsgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdzdG9wLWNvbG9yJywgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQuY29sb3I7IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJ0LnN2Zy5hcHBlbmQoJ2xpbmVhckdyYWRpZW50JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsICdsaW5lLWdyYWRpZW50JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdncmFkaWVudFVuaXRzJywgJ3VzZXJTcGFjZU9uVXNlJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsIDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneTEnLCB5VHJhbnNsYXRlKHlBeGlzRGF0YS5taW4pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIHlUcmFuc2xhdGUoeUF4aXNEYXRhLm1heCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKCdzdG9wJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5kYXRhKHRocmVzaG9sZERhdGEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZW50ZXIoKS5hcHBlbmQoJ3N0b3AnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ29mZnNldCcsIGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLm9mZnNldDsgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdzdG9wLWNvbG9yJywgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQuY29sb3I7IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRocmVzaG9sZGluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vQWRkIGNpcmNsZXMgYXQgam9pbnRzIGluIHRoZSBsaW5lc1xyXG4gICAgICAgICAgICBjaXJjbGVzW2tdID0gbGluZXNcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2NpcmNsZSAnICsgKGspKVxyXG4gICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgnY2lyY2xlJylcclxuICAgICAgICAgICAgICAgIC5kYXRhKGRhdGFba10pXHJcbiAgICAgICAgICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgnY2lyY2xlJykvL0NpcmNsZXMgZm9yIHRoZSBqb2ludHMgaW4gdGhlIGxpbmVcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIGZ1bmN0aW9uIChkLCBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdjaXJjbGUtJyArIGNoYXJ0LmN1cnJlbnREYXRhLmNoYXJ0RGF0YVtpXVtjaGFydC5jdXJyZW50RGF0YS5kYXRhVGFibGUubGFiZWxdLnJlcGxhY2UoL1xccy9nLCAnXycpLnJlcGxhY2UoL1xcLi9nLCAnX2RvdF8nKSArICcgaGlnaGxpZ2h0LWNsYXNzLScgKyBjaGFydC5jdXJyZW50RGF0YS5jaGFydERhdGFbaV1bY2hhcnQuY3VycmVudERhdGEuZGF0YVRhYmxlLmxhYmVsXS5yZXBsYWNlKC9cXHMvZywgJ18nKS5yZXBsYWNlKC9cXC4vZywgJ19kb3RfJyk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2N4JywgZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOYU4oZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB4VHJhbnNsYXRlKGQsIGkpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdjeScsIGZ1bmN0aW9uIChkLCBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmFOKGQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geVRyYW5zbGF0ZShkLCBpKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuYXR0cignZmlsbCcsIGZ1bmN0aW9uIChkLCBpLCBqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmFOKGQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhyZXNob2xkaW5nID09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IE9iamVjdC5rZXlzKGNoYXJ0Ll92YXJzLnRocmVzaG9sZHMpLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGFydC5fdmFycy5yb3RhdGVBeGlzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB6ID0gbGVuZ3RoOyB6ID4gLTE7IHotLSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aHJlc2hvbGQgPSBjaGFydC5fdmFycy50aHJlc2hvbGRzW3pdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkID49IHRocmVzaG9sZC50aHJlc2hvbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRocmVzaG9sZC50aHJlc2hvbGRDb2xvcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB6ID0gbGVuZ3RoOyB6ID4gLTE7IHotLSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aHJlc2hvbGQgPSBjaGFydC5fdmFycy50aHJlc2hvbGRzW3pdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkID49IHRocmVzaG9sZC50aHJlc2hvbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRocmVzaG9sZC50aHJlc2hvbGRDb2xvcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBqdkNoYXJ0cy5nZXRDb2xvcnMoY29sb3JzLCBpLCBrKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuYXR0cignb3BhY2l0eScsIGZ1bmN0aW9uIChkLCBpLCBqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmFOKGQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuYXR0cigncicsIDIuNSk7XHJcblxyXG4gICAgICAgICAgICBpbmRleCsrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvL1JldHVybiBsaW5lIGdyb3Vwc1xyXG4gICAgcmV0dXJuIGxpbmVzLnNlbGVjdEFsbCgnLmNpcmNsZScpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzZXRMaW5lVGhyZXNob2xkRGF0YShjaGFydCwgdGhyZXNob2xkcykge1xyXG4gICAgdmFyIGRhdGEgPSBbXTtcclxuICAgIHZhciB0aHJlc2hvbGRMZW5ndGggPSB0aHJlc2hvbGRzLmxlbmd0aDtcclxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGhyZXNob2xkTGVuZ3RoOyBrKyspIHtcclxuICAgICAgICB2YXIgZ3JhZGllbnRPbmUgPSB7IG9mZnNldDogdGhyZXNob2xkc1trXS5wZXJjZW50ICsgJyUnLCBjb2xvcjogdGhyZXNob2xkc1trXS5jb2xvciB9O1xyXG4gICAgICAgIGRhdGEucHVzaChncmFkaWVudE9uZSk7XHJcblxyXG4gICAgICAgIGlmIChrICsgMSA8IHRocmVzaG9sZExlbmd0aCkge1xyXG4gICAgICAgICAgICB2YXIgZ3JhZGllbnRUd28gPSB7IG9mZnNldDogdGhyZXNob2xkc1trICsgMV0ucGVyY2VudCArICclJywgY29sb3I6IHRocmVzaG9sZHNba10uY29sb3IgfTtcclxuICAgICAgICAgICAgZGF0YS5wdXNoKGdyYWRpZW50VHdvKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChrID09IHRocmVzaG9sZExlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgdmFyIGxhc3QgPSB7IG9mZnNldDogJzEwMCUnLCBjb2xvcjogdGhyZXNob2xkc1trXS5jb2xvciB9O1xyXG4gICAgICAgICAgICBkYXRhLnB1c2gobGFzdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBkYXRhO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGp2Q2hhcnRzO1xyXG4iLCIndXNlIHN0cmljdCc7XHJcbnZhciBqdkNoYXJ0cyA9IHJlcXVpcmUoJy4uL2p2Q2hhcnRzLmpzJyk7XHJcblxyXG5cclxuanZDaGFydHMucHJvdG90eXBlLmNpcmNsZXBhY2sgPSB7XHJcbiAgICBwYWludDogcGFpbnQsXHJcbiAgICBzZXREYXRhOiBzZXREYXRhLFxyXG4gICAgZ2V0RXZlbnREYXRhOiBnZXRFdmVudERhdGFcclxufTtcclxuXHJcbmp2Q2hhcnRzLnByb3RvdHlwZS5nZW5lcmF0ZVBhY2sgPSBnZW5lcmF0ZVBhY2s7XHJcblxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIFBhY2sgZnVuY3Rpb25zICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcbi8qKnNldFBhY2tDaGFydERhdGFcclxuICogIGdldHMgcGFjayBkYXRhIGFuZCBhZGRzIGl0IHRvIHRoZSBjaGFydCBvYmplY3RcclxuICpcclxuICogQHBhcmFtcyBkYXRhLCBkYXRhVGFibGUsIGNvbG9yc1xyXG4gKi9cclxuZnVuY3Rpb24gc2V0RGF0YSgpIHtcclxuICAgIHZhciBjaGFydCA9IHRoaXM7XHJcbiAgICBjaGFydC5kYXRhLmxlZ2VuZERhdGEgPSBzZXRQYWNrTGVnZW5kRGF0YShjaGFydC5kYXRhLmRhdGFUYWJsZSk7XHJcbiAgICBpZiAoIWNoYXJ0LmRhdGEuY2hhcnREYXRhLmhhc093blByb3BlcnR5KCdjaGlsZHJlbicpKSB7XHJcbiAgICAgICAgY2hhcnQuZGF0YS5jaGFydERhdGEgPSBqdkNoYXJ0cy5jb252ZXJ0VGFibGVUb1RyZWUoY2hhcnQuZGF0YS5jaGFydERhdGEsIGNoYXJ0LmRhdGEuZGF0YVRhYmxlKTtcclxuICAgIH1cclxuXHJcbiAgICAvL2RlZmluZSBjb2xvciBvYmplY3QgZm9yIGNoYXJ0RGF0YVxyXG4gICAgY2hhcnQuZGF0YS5jb2xvciA9IGNoYXJ0LmNvbG9ycztcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0RXZlbnREYXRhKCkge1xyXG4gICAgcmV0dXJuIHt9O1xyXG59XHJcblxyXG4vKipzZXRQYWNrTGVnZW5kRGF0YVxyXG4gKiAgZ2V0cyBsZWdlbmQgaW5mbyBmcm9tIGNoYXJ0IERhdGFcclxuICpcclxuICogQHBhcmFtcyBkYXRhLCB0eXBlXHJcbiAqIEByZXR1cm5zIFtdIG9mIGxlZ2VuZCB0ZXh0XHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRQYWNrTGVnZW5kRGF0YShkYXRhVGFibGUpIHtcclxuICAgIHZhciBsZWdlbmRBcnJheSA9IFtdLFxyXG4gICAgICAgIGxhYmVsID0gJyc7XHJcbiAgICBmb3IgKGxldCBrZXkgaW4gZGF0YVRhYmxlKSB7XHJcbiAgICAgICAgaWYgKGRhdGFUYWJsZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICd2YWx1ZScpIHtcclxuICAgICAgICAgICAgICAgIGxhYmVsID0gZGF0YVRhYmxlW2tleV07XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5ICE9PSAndG9vbHRpcCAxJykge1xyXG4gICAgICAgICAgICAgICAgbGVnZW5kQXJyYXkucHVzaChkYXRhVGFibGVba2V5XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBsZWdlbmRBcnJheS51bnNoaWZ0KGxhYmVsKTtcclxuICAgIHJldHVybiBsZWdlbmRBcnJheTtcclxufVxyXG5cclxuZnVuY3Rpb24gcGFpbnQoKSB7XHJcbiAgICB2YXIgY2hhcnQgPSB0aGlzLFxyXG4gICAgICAgIHBhY2tNYXJnaW5zID0ge1xyXG4gICAgICAgICAgICB0b3A6IDMwLFxyXG4gICAgICAgICAgICByaWdodDogMjAsXHJcbiAgICAgICAgICAgIGJvdHRvbTogMTUsXHJcbiAgICAgICAgICAgIGxlZnQ6IDIwXHJcbiAgICAgICAgfTtcclxuICAgIGNoYXJ0Ll92YXJzLmNvbG9yID0gY2hhcnQuZGF0YS5jb2xvcjtcclxuXHJcbiAgICBjaGFydC5jdXJyZW50RGF0YSA9IGNoYXJ0LmRhdGE7Ly9NaWdodCBoYXZlIHRvIG1vdmUgaW50byBtZXRob2QgYmMgb2YgcmVmZXJlbmNlL3ZhbHVlIHJlbGF0aW9uc2hpcFxyXG5cclxuICAgIC8vR2VuZXJhdGUgU1ZHLWxlZ2VuZCBkYXRhIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBzaXplIG9mIHRoZSBib3R0b20gbWFyZ2luIChzZXQgdG8gbnVsbCBmb3Igbm8gbGVnZW5kKVxyXG4gICAgY2hhcnQuZ2VuZXJhdGVTVkcobnVsbCwgcGFja01hcmdpbnMpO1xyXG4gICAgY2hhcnQuZ2VuZXJhdGVWZXJ0aWNhbExlZ2VuZCgnZ2VuZXJhdGVQYWNrJyk7XHJcbiAgICBjaGFydC5nZW5lcmF0ZVBhY2soY2hhcnQuY3VycmVudERhdGEpO1xyXG59XHJcblxyXG4vKipnZW5lcmF0ZVBhY2tcclxuICpcclxuICogcGFpbnRzIHRoZSBwYWNrIG9uIHRoZSBjaGFydFxyXG4gKiBAcGFyYW1zIHBhY2tEYXRhXHJcbiAqL1xyXG5mdW5jdGlvbiBnZW5lcmF0ZVBhY2soKSB7XHJcbiAgICB2YXIgY2hhcnQgPSB0aGlzLFxyXG4gICAgICAgIHN2ZyA9IGNoYXJ0LnN2ZyxcclxuICAgICAgICBjb250YWluZXIgPSBjaGFydC5jb25maWcuY29udGFpbmVyLFxyXG4gICAgICAgIHcgPSBjb250YWluZXIud2lkdGgsXHJcbiAgICAgICAgaCA9IGNvbnRhaW5lci5oZWlnaHQsXHJcbiAgICAgICAgciA9IE1hdGgubWluKGggLyAyLCB3IC8gMyksXHJcbiAgICAgICAgbWFyZ2luID0gMjAsXHJcbiAgICAgICAgZGlhbWV0ZXIgPSByICogMixcclxuICAgICAgICBjb2xvcixcclxuICAgICAgICByb290LFxyXG4gICAgICAgIHBhY2ssXHJcbiAgICAgICAgdmlzLFxyXG4gICAgICAgIGNpcmNsZSxcclxuICAgICAgICBub2RlLFxyXG4gICAgICAgIHZpZXc7XHJcblxyXG4gICAgY2hhcnQuY2hpbGRyZW4gPSBjaGFydC5kYXRhLmNoYXJ0RGF0YTtcclxuXHJcbiAgICBjb2xvciA9IGQzLnNjYWxlT3JkaW5hbCgpXHJcbiAgICAgICAgLnJhbmdlKGNoYXJ0LmRhdGEuY29sb3JcclxuICAgICAgICAgICAgLm1hcChjID0+IHtcclxuICAgICAgICAgICAgICAgIGMgPSBkMy5yZ2IoYyk7XHJcbiAgICAgICAgICAgICAgICBjLm9wYWNpdHkgPSAwLjg7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYztcclxuICAgICAgICAgICAgfSkpO1xyXG5cclxuICAgIC8vYXNzaWducyB0aGUgZGF0YSB0byBhIGhpZXJhcmNoeSB1c2luZyBwYXJlbnQtY2hpbGQgcmVsYXRpb25zaGlwc1xyXG4gICAgcm9vdCA9IGQzLmhpZXJhcmNoeShjaGFydC5jaGlsZHJlbiwgZCA9PiBkLmNoaWxkcmVuKTtcclxuXHJcbiAgICBwYWNrID0gZDMucGFjaygpXHJcbiAgICAgICAgLnNpemUoW2NvbnRhaW5lci53aWR0aCwgY29udGFpbmVyLmhlaWdodF0pXHJcbiAgICAgICAgLnBhZGRpbmcoMik7XHJcblxyXG4gICAgcGFjayhyb290XHJcbiAgICAgICAgLnN1bShkID0+IGQuaGFzT3duUHJvcGVydHkoJ2NoaWxkcmVuJykgPyAwIDogZC5uYW1lKVxyXG4gICAgICAgIC5zb3J0KChhLCBiKSA9PiBiLmhlaWdodCAtIGEuaGVpZ2h0IHx8IGIudmFsdWUgLSBhLnZhbHVlKSlcclxuICAgICAgICAuZGVzY2VuZGFudHMoKTtcclxuXHJcbiAgICBzdmcuc2VsZWN0QWxsKCcucGFjaycpLnJlbW92ZSgpO1xyXG5cclxuICAgIHZpcyA9IHN2Zy5hcHBlbmQoJ2cnKVxyXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICdwYWNrJylcclxuICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgKHcgLyAyKSArICcsJyArIHIgKyAnKScpO1xyXG5cclxuICAgIGNpcmNsZSA9IHZpcy5zZWxlY3RBbGwoJ2NpcmNsZScpXHJcbiAgICAgICAgLmRhdGEocm9vdC5kZXNjZW5kYW50cygpKVxyXG4gICAgICAgIC5lbnRlcigpLmFwcGVuZCgnY2lyY2xlJylcclxuICAgICAgICAuYXR0cignY2xhc3MnLCBkID0+IGQucGFyZW50ID8gZC5jaGlsZHJlbiA/ICdub2RlJyA6ICdub2RlIG5vZGUtLWxlYWYnIDogJ25vZGUgbm9kZS0tcm9vdCcpXHJcbiAgICAgICAgLnN0eWxlKCdmaWxsJywgZCA9PiB7XHJcbiAgICAgICAgICAgIGQuY29sb3IgPSBjb2xvcihkLmRlcHRoKTtcclxuICAgICAgICAgICAgcmV0dXJuIGQuY2hpbGRyZW4gPyBjb2xvcihkLmRlcHRoKSA6IG51bGw7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAub24oJ2NsaWNrJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgaWYgKGZvY3VzICE9PSBkKSB7XHJcbiAgICAgICAgICAgICAgICB6b29tKGQpO1xyXG4gICAgICAgICAgICAgICAgZDMuZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgLy9HZXQgdGlwIGRhdGFcclxuICAgICAgICAgICAgdmFyIHRpcERhdGEgPSBjaGFydC5zZXRUaXBEYXRhKGQsIGkpO1xyXG4gICAgICAgICAgICAvL0RyYXcgdGlwIGxpbmVcclxuICAgICAgICAgICAgY2hhcnQudGlwLmdlbmVyYXRlU2ltcGxlVGlwKHRpcERhdGEsIGNoYXJ0LmRhdGEuZGF0YVRhYmxlKTtcclxuICAgICAgICAgICAgY2hhcnQudGlwLmQgPSBkO1xyXG4gICAgICAgICAgICBjaGFydC50aXAuaSA9IGk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAub24oJ21vdXNlbW92ZScsIGZ1bmN0aW9uIChkLCBpKSB7XHJcbiAgICAgICAgICAgIGlmIChjaGFydC5zaG93VG9vbFRpcCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoYXJ0LnRpcC5kID09PSBkICYmIGNoYXJ0LnRpcC5pID09PSBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhcnQudGlwLnNob3dUaXAoZDMuZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvL0dldCB0aXAgZGF0YVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0aXBEYXRhID0gY2hhcnQuc2V0VGlwRGF0YShkLCBpKTtcclxuICAgICAgICAgICAgICAgICAgICAvL0RyYXcgdGlwIGxpbmVcclxuICAgICAgICAgICAgICAgICAgICBjaGFydC50aXAuZ2VuZXJhdGVTaW1wbGVUaXAodGlwRGF0YSwgY2hhcnQuZGF0YS5kYXRhVGFibGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBjaGFydC50aXAuaGlkZVRpcCgpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIG5vZGUgPSBzdmcuc2VsZWN0QWxsKCdjaXJjbGUsdGV4dCcpO1xyXG5cclxuICAgIGQzLnNlbGVjdCgnYm9keScpXHJcbiAgICAgICAgLm9uKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgem9vbShyb290KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICB6b29tVG8oW3Jvb3QueCwgcm9vdC55LCByb290LnIgKiAyICsgbWFyZ2luXSk7XHJcblxyXG4gICAgZnVuY3Rpb24gem9vbShkKSB7XHJcbiAgICAgICAgdmFyIGZvY3VzID0gZDtcclxuICAgICAgICBkMy50cmFuc2l0aW9uKClcclxuICAgICAgICAgICAgLmR1cmF0aW9uKGQzLmV2ZW50LmFsdEtleSA/IDc1MDAgOiA3NTApXHJcbiAgICAgICAgICAgIC50d2Vlbignem9vbScsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaSA9IGQzLmludGVycG9sYXRlWm9vbSh2aWV3LCBbZm9jdXMueCwgZm9jdXMueSwgZm9jdXMuciAqIDIgKyBtYXJnaW5dKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHpvb21UbyhpKHQpKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gem9vbVRvKHYpIHtcclxuICAgICAgICB2YXIgayA9IGRpYW1ldGVyIC8gdlsyXTtcclxuXHJcbiAgICAgICAgLy9zZXQgZ2xvYmFsIHpvb21cclxuICAgICAgICB2aWV3ID0gdjtcclxuXHJcbiAgICAgICAgbm9kZS5hdHRyKCd0cmFuc2Zvcm0nLCBkID0+IHtcclxuICAgICAgICAgICAgaWYgKGQgJiYgZC54ICYmIGQueSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIChkLnggLSB2WzBdKSAqIGsgKyAnLCcgKyAoZC55IC0gdlsxXSkgKiBrICsgJyknO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY2lyY2xlLmF0dHIoJ3InLCBkID0+IGQuciAqIGspO1xyXG4gICAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGp2Q2hhcnRzO1xyXG4iLCIndXNlIHN0cmljdCc7XHJcbnZhciBqdkNoYXJ0cyA9IHJlcXVpcmUoJy4uL2p2Q2hhcnRzLmpzJyk7XHJcblxyXG5qdkNoYXJ0cy5wcm90b3R5cGUucGllID0ge1xyXG4gICAgcGFpbnQ6IHBhaW50LFxyXG4gICAgc2V0RGF0YTogc2V0RGF0YSxcclxuICAgIGdldEV2ZW50RGF0YTogZ2V0RXZlbnREYXRhLFxyXG4gICAgaGlnaGxpZ2h0RnJvbUV2ZW50RGF0YTogaGlnaGxpZ2h0RnJvbUV2ZW50RGF0YVxyXG59O1xyXG5cclxuanZDaGFydHMucHJvdG90eXBlLmdlbmVyYXRlUGllID0gZ2VuZXJhdGVQaWU7XHJcblxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIFBpZSBEYXRhIGZ1bmN0aW9ucyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG4vKipzZXRQaWVEYXRhXHJcbiAqICBnZXRzIHBpZSBkYXRhIGFuZCBhZGRzIGl0IHRvIHRoZSBjaGFydCBvYmplY3RcclxuICpcclxuICogQHBhcmFtcyBkYXRhLCBkYXRhVGFibGUsIGNvbG9yc1xyXG4gKi9cclxuZnVuY3Rpb24gc2V0RGF0YSgpIHtcclxuICAgIHZhciBjaGFydCA9IHRoaXM7XHJcblxyXG4gICAgLy9TZXQgZGF0YSBpZiBhICdidWNrZXQnIGlzIHNwZWNpZmllZC0tcGFpbnRzICMgc3BlY2lmaWVkLCBncm91cHMgcmVzdCBpbnRvIG90aGVyIGNhdGVnb3J5XHJcbiAgICBpZiAoY2hhcnQuX3ZhcnMuaGFzT3duUHJvcGVydHkoJ2J1Y2tldHMnKSAmJiBwYXJzZUludChjaGFydC5fdmFycy5idWNrZXRzLCAxMCkgIT09IDApIHtcclxuICAgICAgICAvL2J1Y2tldCB0aGUgZGF0YVxyXG4gICAgICAgIGxldCBkYXRhID0gY2hhcnQuZGF0YSxcclxuICAgICAgICAgICAgb3RoZXIgPSB7fSxcclxuICAgICAgICAgICAgY2F0ZWdvcml6ZWREYXRhID0gW10sIGk7XHJcblxyXG4gICAgICAgIGRhdGEuY2hhcnREYXRhLnNvcnQoKGEsIGIpID0+IGJbZGF0YS5kYXRhVGFibGUudmFsdWVdIC0gYVtkYXRhLmRhdGFUYWJsZS52YWx1ZV0pO1xyXG4gICAgICAgIG90aGVyW2RhdGEuZGF0YVRhYmxlLmxhYmVsXSA9ICdPdGhlcic7XHJcbiAgICAgICAgb3RoZXJbZGF0YS5kYXRhVGFibGUudmFsdWVdID0gMDtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGF0YS5jaGFydERhdGEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGkgPCBjaGFydC5fdmFycy5idWNrZXRzKSB7XHJcbiAgICAgICAgICAgICAgICBjYXRlZ29yaXplZERhdGEucHVzaChkYXRhLmNoYXJ0RGF0YVtpXSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvdGhlcltkYXRhLmRhdGFUYWJsZS52YWx1ZV0gKz0gZGF0YS5jaGFydERhdGFbaV1bZGF0YS5kYXRhVGFibGUudmFsdWVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGVnb3JpemVkRGF0YS5wdXNoKG90aGVyKTtcclxuICAgICAgICBkYXRhLmNoYXJ0RGF0YSA9IGNhdGVnb3JpemVkRGF0YTtcclxuICAgIH1cclxuICAgIC8vU2V0IGxlZ2VuZCBkYXRhIGFmdGVyIGRldGVybWluaW5nIGlmIHRoZSBkYXRhIGlzIGJ1Y2tldGVkXHJcbiAgICBjaGFydC5kYXRhLmxlZ2VuZERhdGEgPSBzZXRQaWVMZWdlbmREYXRhKGNoYXJ0LmRhdGEpO1xyXG4gICAgLy9kZWZpbmUgY29sb3Igb2JqZWN0IGZvciBjaGFydERhdGFcclxuICAgIGNoYXJ0LmRhdGEuY29sb3IgPSBqdkNoYXJ0cy5zZXRDaGFydENvbG9ycyhjaGFydC5fdmFycy5jb2xvciwgY2hhcnQuZGF0YS5sZWdlbmREYXRhLCBjaGFydC5jb2xvcnMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRFdmVudERhdGEoZXZlbnQpIHtcclxuICAgIHZhciBjaGFydCA9IHRoaXMsXHJcbiAgICAgICAgZWxlID0gZXZlbnQudGFyZ2V0LmNsYXNzTGlzdC52YWx1ZS5zcGxpdCgncGllLWRhdGEtJylbMV07XHJcbiAgICBpZiAoZWxlKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgW2NoYXJ0LmN1cnJlbnREYXRhLmRhdGFUYWJsZS5sYWJlbF06IFtlbGUucmVwbGFjZSgvXy9nLCAnICcpLnJlcGxhY2UoL19jb2xvbl8vZywgJzonKS5yZXBsYWNlKC9fZG90Xy9nLCAnLicpXVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBub2RlOiBldmVudC50YXJnZXRcclxuICAgICAgICB9O1xyXG4gICAgfSBlbHNlIGlmIChldmVudC50YXJnZXQuY2xhc3NMaXN0LnZhbHVlLmluZGV4T2YoJ3BpZS1jb250YWluZXInKSA+IC0xKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZGF0YToge31cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBkYXRhOiBmYWxzZVxyXG4gICAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gaGlnaGxpZ2h0RnJvbUV2ZW50RGF0YShldmVudCkge1xyXG4gICAgbGV0IGNoYXJ0ID0gdGhpcyxcclxuICAgICAgICBsYWJlbCA9IGV2ZW50LmRhdGFbY2hhcnQuY3VycmVudERhdGEuZGF0YVRhYmxlLmxhYmVsXVswXSxcclxuICAgICAgICBjc3NDbGFzcyA9ICcuaGlnaGxpZ2h0LWNsYXNzLScgKyBsYWJlbC5yZXBsYWNlKC9cXHMvZywgJ18nKS5yZXBsYWNlKC9cXC4vZywgJ19kb3RfJyksXHJcbiAgICAgICAgbm9kZSA9IGNoYXJ0LnN2Zy5zZWxlY3RBbGwoY3NzQ2xhc3MpO1xyXG5cclxuICAgIGNoYXJ0LnN2Zy5zZWxlY3QoJy5waWUtY29udGFpbmVyJykuc2VsZWN0QWxsKCcuc2xpY2UnKVxyXG4gICAgICAgIC5hdHRyKCdzdHJva2UnLCAwKVxyXG4gICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCAwKTtcclxuICAgIC8vaGlnaGxpZ2h0IG5lY2Vzc2FyeSBzbGljZXNcclxuICAgIG5vZGVcclxuICAgICAgICAuYXR0cignc3Ryb2tlJywgY2hhcnQuX3ZhcnMuaGlnaGxpZ2h0Qm9yZGVyQ29sb3IpXHJcbiAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIGNoYXJ0Ll92YXJzLmhpZ2hsaWdodEJvcmRlcldpZHRoKTtcclxufVxyXG5cclxuLyoqc2V0UGllTGVnZW5kRGF0YVxyXG4gKiAgZ2V0cyBsZWdlbmQgaW5mbyBmcm9tIGNoYXJ0IERhdGFcclxuICpcclxuICogQHBhcmFtcyBkYXRhLCB0eXBlXHJcbiAqIEByZXR1cm5zIFtdIG9mIGxlZ2VuZCB0ZXh0XHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRQaWVMZWdlbmREYXRhKGRhdGEpIHtcclxuICAgIHZhciBsZWdlbmRBcnJheSA9IFtdO1xyXG4gICAgZm9yICh2YXIgaSA9IGRhdGEuY2hhcnREYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgbGVnZW5kQXJyYXkucHVzaCgoZGF0YS5jaGFydERhdGFbaV1bZGF0YS5kYXRhVGFibGUubGFiZWxdKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbGVnZW5kQXJyYXk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhaW50KCkge1xyXG4gICAgdmFyIGNoYXJ0ID0gdGhpcyxcclxuICAgICAgICBjdXN0b21NYXJnaW5zID0ge1xyXG4gICAgICAgICAgICB0b3A6IDQwLFxyXG4gICAgICAgICAgICByaWdodDogMjAsXHJcbiAgICAgICAgICAgIGJvdHRvbTogMjAsXHJcbiAgICAgICAgICAgIGxlZnQ6IDIwXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICBjaGFydC5jdXJyZW50RGF0YSA9IGNoYXJ0LmRhdGE7XHJcbiAgICBjaGFydC5fdmFycy5jb2xvciA9IGNoYXJ0LmRhdGEuY29sb3I7XHJcbiAgICBjaGFydC5sZWdlbmREYXRhID0gY2hhcnQuZGF0YS5sZWdlbmREYXRhO1xyXG4gICAgY2hhcnQuZ2VuZXJhdGVTVkcoY2hhcnQuZGF0YS5sZWdlbmREYXRhLCBjdXN0b21NYXJnaW5zKTtcclxuXHJcbiAgICAvL0lmIHRoZSBjb250YWluZXIgc2l6ZSBpcyBzbWFsbCwgZG9uJ3QgZ2VuZXJhdGUgYSBsZWdlbmRcclxuICAgIGlmIChjaGFydC5jb25maWcuY29udGFpbmVyLndpZHRoID4gNTUwKSB7XHJcbiAgICAgICAgY2hhcnQuZ2VuZXJhdGVWZXJ0aWNhbExlZ2VuZCgnZ2VuZXJhdGVQaWUnKTtcclxuICAgIH1cclxuXHJcbiAgICBjaGFydC5nZW5lcmF0ZVBpZShjaGFydC5jdXJyZW50RGF0YSk7XHJcbn1cclxuXHJcbi8qKmdlbmVyYXRlUGllXHJcbiAqXHJcbiAqIGNyZWF0ZXMgYW5kIGRyYXdzIGEgcGllIGNoYXJ0IG9uIHRoZSBzdmcgZWxlbWVudFxyXG4gKiBAcGFyYW1zIHN2ZywgcGllRGF0YSwgX3ZhcnMsIGNvbnRhaW5lclxyXG4gKiBAcmV0dXJucyB7e319XHJcbiAqL1xyXG5mdW5jdGlvbiBnZW5lcmF0ZVBpZShjdXJyZW50RGF0YSkge1xyXG4gICAgdmFyIGNoYXJ0ID0gdGhpcyxcclxuICAgICAgICBzdmcgPSBjaGFydC5zdmcsXHJcbiAgICAgICAgcGllRGF0YSA9IGN1cnJlbnREYXRhLmNoYXJ0RGF0YSxcclxuICAgICAgICBjb250YWluZXIgPSBjaGFydC5jb25maWcuY29udGFpbmVyLFxyXG4gICAgICAgIGxlZ2VuZERhdGEgPSBjaGFydC5jdXJyZW50RGF0YS5sZWdlbmREYXRhLFxyXG4gICAgICAgIGNvbG9ycyA9IGNoYXJ0Ll92YXJzLmNvbG9yLFxyXG4gICAgICAgIHcgPSBjb250YWluZXIud2lkdGgsXHJcbiAgICAgICAgaCA9IGNvbnRhaW5lci5oZWlnaHQsXHJcbiAgICAgICAgciA9IE1hdGgubWluKGggLyAyLCB3IC8gMyksXHJcbiAgICAgICAgZGF0YSA9IFtdLFxyXG4gICAgICAgIHRvdGFsID0gMCxcclxuICAgICAgICBwaWVEYXRhTmV3LFxyXG4gICAgICAgIGxlZ2VuZEVsZW1lbnRUb2dnbGVBcnJheSxcclxuICAgICAgICB2aXMsXHJcbiAgICAgICAgcGllLFxyXG4gICAgICAgIGFyYyxcclxuICAgICAgICBhcmNzO1xyXG5cclxuICAgIC8vZGVmaW5lIHZhcmlhYmxlcyB0byBjaGFuZ2UgYXR0cidzXHJcbiAgICBzdmcuc2VsZWN0KCdnLnBpZS1jb250YWluZXInKS5yZW1vdmUoKTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBpZURhdGEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBsZXQgb2JqID0ge307XHJcbiAgICAgICAgZm9yIChsZXQgaiBpbiBjaGFydC5kYXRhLmRhdGFUYWJsZSkge1xyXG4gICAgICAgICAgICBpZiAoY2hhcnQuZGF0YS5kYXRhVGFibGUuaGFzT3duUHJvcGVydHkoaikpIHtcclxuICAgICAgICAgICAgICAgIG9ialtqXSA9IHBpZURhdGFbaV1bY2hhcnQuZGF0YS5kYXRhVGFibGVbal1dO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRhdGFbaV0gPSBvYmo7XHJcbiAgICB9XHJcblxyXG4gICAgcGllRGF0YU5ldyA9IGRhdGE7XHJcblxyXG4gICAgaWYgKCFjaGFydC5fdmFycy5sZWdlbmRIZWFkZXJzKSB7XHJcbiAgICAgICAgY2hhcnQuX3ZhcnMubGVnZW5kSGVhZGVycyA9IGxlZ2VuZERhdGE7XHJcbiAgICB9XHJcblxyXG4gICAgbGVnZW5kRWxlbWVudFRvZ2dsZUFycmF5ID0ganZDaGFydHMuZ2V0TGVnZW5kRWxlbWVudFRvZ2dsZUFycmF5KGNoYXJ0Ll92YXJzLmxlZ2VuZEhlYWRlcnMsIGxlZ2VuZERhdGEpO1xyXG5cclxuICAgIGlmIChsZWdlbmRFbGVtZW50VG9nZ2xlQXJyYXkpIHtcclxuICAgICAgICBmb3IgKGxldCBzbGljZSBvZiBwaWVEYXRhTmV3KSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGxlZ2VuZEVsZSBvZiBsZWdlbmRFbGVtZW50VG9nZ2xlQXJyYXkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChsZWdlbmRFbGUuZWxlbWVudCA9PT0gc2xpY2UubGFiZWwgJiYgbGVnZW5kRWxlLnRvZ2dsZSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBzbGljZS52YWx1ZSA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZvciAobGV0IHNsaWNlIG9mIHBpZURhdGFOZXcpIHtcclxuICAgICAgICB0b3RhbCArPSBwYXJzZUZsb2F0KHNsaWNlLnZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICB2aXMgPSBzdmdcclxuICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAuZGF0YShbcGllRGF0YU5ld10pXHJcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3BpZS1jb250YWluZXInKVxyXG4gICAgICAgIC5hdHRyKCdoZWlnaHQnLCAyMDApXHJcbiAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHt3IC8gMn0sICR7cn0pYCk7XHJcblxyXG4gICAgcGllID0gZDMucGllKCkudmFsdWUoZCA9PiBkLnZhbHVlKTtcclxuXHJcbiAgICAvL2RlY2xhcmUgYW4gYXJjIGdlbmVyYXRvciBmdW5jdGlvblxyXG4gICAgYXJjID0gZDMuYXJjKClcclxuICAgICAgICAuaW5uZXJSYWRpdXMoMCkvL05vcm1hbCBwaWUgY2hhcnQgd2hlbiB0aGlzID0gMCwgY2FuIGJlIGNoYW5nZWQgdG8gY3JlYXRlIGRvbnV0IGNoYXJ0XHJcbiAgICAgICAgLm91dGVyUmFkaXVzKHIpO1xyXG5cclxuICAgIC8vc2VsZWN0IHBhdGhzLCB1c2UgYXJjIGdlbmVyYXRvciB0byBkcmF3XHJcbiAgICBhcmNzID0gdmlzXHJcbiAgICAgICAgLnNlbGVjdEFsbCgnZy5zbGljZScpXHJcbiAgICAgICAgLmRhdGEocGllKVxyXG4gICAgICAgIC5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ3NsaWNlJyk7XHJcblxyXG4gICAgYXJjcy5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgIC5hdHRyKCdmaWxsJywgKGQsIGkpID0+IGp2Q2hhcnRzLmdldENvbG9ycyhjb2xvcnMsIGksIGQuZGF0YS5sYWJlbCkpXHJcbiAgICAgICAgLmF0dHIoJ2QnLCBkID0+IGFyYyhkKSlcclxuICAgICAgICAuYXR0cignY2xhc3MnLCAoZCwgaSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGQuZGF0YS5sYWJlbCAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGBlZGl0YWJsZSBlZGl0YWJsZS1waWUgcGllLXNsaWNlLSR7ZC5kYXRhLmxhYmVsLnJlcGxhY2UoL1xccy9nLCAnXycpLnJlcGxhY2UoL1xcLi9nLCAnX2RvdF8nKX0gaGlnaGxpZ2h0LWNsYXNzLSR7ZC5kYXRhLmxhYmVsLnJlcGxhY2UoL1xccy9nLCAnXycpLnJlcGxhY2UoL1xcLi9nLCAnX2RvdF8nKX0gcGllLWRhdGEtJHtkLmRhdGEubGFiZWwucmVwbGFjZSgvXFxzL2csICdfJykucmVwbGFjZSgvXFwuL2csICdfZG90XycpfWA7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuYXR0cignc3Ryb2tlJywgY2hhcnQuX3ZhcnMucGllQm9yZGVyKVxyXG4gICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCBjaGFydC5fdmFycy5waWVCb3JkZXJXaWR0aClcclxuICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uIChkLCBpKSB7XHJcbiAgICAgICAgICAgIGlmIChjaGFydC5zaG93VG9vbFRpcCkge1xyXG4gICAgICAgICAgICAgICAgLy9HZXQgdGlwIGRhdGFcclxuICAgICAgICAgICAgICAgIHZhciB0aXBEYXRhID0gY2hhcnQuc2V0VGlwRGF0YShkLmRhdGEsIGkpO1xyXG4gICAgICAgICAgICAgICAgLy8gRHJhdyB0aXAgbGluZVxyXG4gICAgICAgICAgICAgICAgY2hhcnQudGlwLmdlbmVyYXRlU2ltcGxlVGlwKHRpcERhdGEsIGNoYXJ0LmRhdGEuZGF0YVRhYmxlKTtcclxuICAgICAgICAgICAgICAgIGNoYXJ0LnRpcC5kID0gZDtcclxuICAgICAgICAgICAgICAgIGNoYXJ0LnRpcC5pID0gaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLm9uKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICBpZiAoY2hhcnQuc2hvd1Rvb2xUaXApIHtcclxuICAgICAgICAgICAgICAgIGlmIChjaGFydC50aXAuZCA9PT0gZCAmJiBjaGFydC50aXAuaSA9PT0gaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0LnRpcC5zaG93VGlwKGQzLmV2ZW50KTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9HZXQgdGlwIGRhdGFcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGlwRGF0YSA9IGNoYXJ0LnNldFRpcERhdGEoZCwgaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9EcmF3IHRpcCBsaW5lXHJcbiAgICAgICAgICAgICAgICAgICAgY2hhcnQudGlwLmdlbmVyYXRlU2ltcGxlVGlwKHRpcERhdGEsIGNoYXJ0LmRhdGEuZGF0YVRhYmxlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY2hhcnQudGlwLmhpZGVUaXAoKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICBhcmNzLmFwcGVuZCgnc3ZnOnRleHQnKVxyXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICdzbGljZUxhYmVsJylcclxuICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgKGQpID0+IHtcclxuICAgICAgICAgICAgbGV0IGNlbnRyb2lkID0gYXJjLmNlbnRyb2lkKGQpO1xyXG4gICAgICAgICAgICBjZW50cm9pZFswXSA9IGNlbnRyb2lkWzBdICogMS42O1xyXG4gICAgICAgICAgICBjZW50cm9pZFsxXSA9IGNlbnRyb2lkWzFdICogMS42O1xyXG4gICAgICAgICAgICByZXR1cm4gYHRyYW5zbGF0ZSgke2NlbnRyb2lkfSlgO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmF0dHIoJ2R5JywgJy4zNWVtJylcclxuICAgICAgICAuYXR0cigndGV4dC1hbmNob3InLCAnbWlkZGxlJylcclxuICAgICAgICAudGV4dCgoZCwgaSkgPT4ge1xyXG4gICAgICAgICAgICB2YXIgcGVyY2VudCA9IHBpZURhdGFOZXdbaV0udmFsdWUgLyB0b3RhbCAqIDEwMDtcclxuICAgICAgICAgICAgcGVyY2VudCA9IGQzLmZvcm1hdCgnLjFmJykocGVyY2VudCk7XHJcbiAgICAgICAgICAgIGlmIChwZXJjZW50ID4gMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBlcmNlbnQgKyAnJSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICAgIC5hdHRyKCdmb250LXNpemUnLCBjaGFydC5fdmFycy5mb250U2l6ZSlcclxuICAgICAgICAuYXR0cignZmlsbCcsIGNoYXJ0Ll92YXJzLnBpZVRleHRDb2xvcilcclxuICAgICAgICAuYXR0cigncG9pbnRlci1ldmVudHMnLCAnbm9uZScpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGp2Q2hhcnRzO1xyXG4iLCIndXNlIHN0cmljdCc7XHJcbnZhciBqdkNoYXJ0cyA9IHJlcXVpcmUoJy4uL2p2Q2hhcnRzLmpzJyk7XHJcblxyXG5qdkNoYXJ0cy5wcm90b3R5cGUucmFkaWFsID0ge1xyXG4gICAgcGFpbnQ6IHBhaW50LFxyXG4gICAgc2V0RGF0YTogc2V0RGF0YSxcclxuICAgIGdldEV2ZW50RGF0YTogZ2V0RXZlbnREYXRhLFxyXG4gICAgaGlnaGxpZ2h0RnJvbUV2ZW50RGF0YTogaGlnaGxpZ2h0RnJvbUV2ZW50RGF0YVxyXG59O1xyXG5cclxuanZDaGFydHMucHJvdG90eXBlLmdlbmVyYXRlUmFkaWFsID0gZ2VuZXJhdGVSYWRpYWw7XHJcblxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIFJhZGlhbCBEYXRhIGZ1bmN0aW9ucyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcbi8qKnNldFJhZGlhbENoYXJ0RGF0YVxyXG4gKiAgZ2V0cyBiYXIgZGF0YSBhbmQgYWRkcyBpdCB0byB0aGUgY2hhcnQgb2JqZWN0XHJcbiAqXHJcbiAqIEBwYXJhbXMgZGF0YSwgZGF0YVRhYmxlLCBjb2xvcnNcclxuICovXHJcbmZ1bmN0aW9uIHNldERhdGEoKSB7XHJcbiAgICBsZXQgY2hhcnQgPSB0aGlzO1xyXG4gICAgY2hhcnQuZGF0YS5sZWdlbmREYXRhID0gc2V0UmFkaWFsTGVnZW5kRGF0YShjaGFydC5kYXRhKTtcclxuICAgIC8vZGVmaW5lIGNvbG9yIG9iamVjdCBmb3IgY2hhcnREYXRhXHJcbiAgICBjaGFydC5kYXRhLmNvbG9yID0ganZDaGFydHMuc2V0Q2hhcnRDb2xvcnMoY2hhcnQuX3ZhcnMuY29sb3IsIGNoYXJ0LmRhdGEubGVnZW5kRGF0YSwgY2hhcnQuY29sb3JzKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcGFpbnQoKSB7XHJcbiAgICBsZXQgY2hhcnQgPSB0aGlzLFxyXG4gICAgICAgIHJhZGlhbE1hcmdpbnMgPSB7XHJcbiAgICAgICAgICAgIHRvcDogNDAsXHJcbiAgICAgICAgICAgIHJpZ2h0OiAyMCxcclxuICAgICAgICAgICAgYm90dG9tOiAyMCxcclxuICAgICAgICAgICAgbGVmdDogMjBcclxuICAgICAgICB9O1xyXG4gICAgY2hhcnQuX3ZhcnMuY29sb3IgPSBjaGFydC5kYXRhLmNvbG9yO1xyXG4gICAgY2hhcnQuY3VycmVudERhdGEgPSBjaGFydC5kYXRhOy8vTWlnaHQgaGF2ZSB0byBtb3ZlIGludG8gbWV0aG9kIGJjIG9mIHJlZmVyZW5jZS92YWx1ZSByZWxhdGlvbnNoaXBcclxuXHJcbiAgICAvL0dlbmVyYXRlIFNWRy1sZWdlbmQgZGF0YSBpcyB1c2VkIHRvIGRldGVybWluZSB0aGUgc2l6ZSBvZiB0aGUgYm90dG9tIG1hcmdpbiAoc2V0IHRvIG51bGwgZm9yIG5vIGxlZ2VuZClcclxuICAgIGNoYXJ0LmdlbmVyYXRlU1ZHKG51bGwsIHJhZGlhbE1hcmdpbnMpO1xyXG4gICAgY2hhcnQuZ2VuZXJhdGVWZXJ0aWNhbExlZ2VuZCgnZ2VuZXJhdGVSYWRpYWwnKTtcclxuICAgIGNoYXJ0LmdlbmVyYXRlUmFkaWFsKCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEV2ZW50RGF0YShldmVudCkge1xyXG4gICAgbGV0IGNoYXJ0ID0gdGhpcyxcclxuICAgICAgICBlbGUgPSBldmVudC50YXJnZXQuY2xhc3NMaXN0LnZhbHVlLnNwbGl0KCdyYWRpYWwtZGF0YS0nKVsxXTtcclxuICAgIGlmIChlbGUpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICAgICAgICBbY2hhcnQuY3VycmVudERhdGEuZGF0YVRhYmxlLmxhYmVsXTogW2VsZS5yZXBsYWNlKC9fL2csICcgJykucmVwbGFjZSgvX2NvbG9uXy9nLCAnOicpLnJlcGxhY2UoL19kb3RfL2csICcuJyldXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG5vZGU6IGV2ZW50LnRhcmdldFxyXG4gICAgICAgIH07XHJcbiAgICB9IGVsc2UgaWYgKGV2ZW50LnRhcmdldC5jbGFzc0xpc3QudmFsdWUuaW5kZXhPZigncmFkaWFsLWNvbnRhaW5lcicpID4gLTEpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBkYXRhOiB7fVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGRhdGE6IGZhbHNlXHJcbiAgICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBoaWdobGlnaHRGcm9tRXZlbnREYXRhKGV2ZW50KSB7XHJcbiAgICBsZXQgY2hhcnQgPSB0aGlzLFxyXG4gICAgICAgIGxhYmVsID0gZXZlbnQuZGF0YVtjaGFydC5jdXJyZW50RGF0YS5kYXRhVGFibGUubGFiZWxdWzBdLFxyXG4gICAgICAgIGNzc0NsYXNzID0gJy5oaWdobGlnaHQtY2xhc3MtJyArIGxhYmVsLnJlcGxhY2UoL1xccy9nLCAnXycpLnJlcGxhY2UoL1xcLi9nLCAnX2RvdF8nKSxcclxuICAgICAgICBub2RlID0gY2hhcnQuc3ZnLnNlbGVjdEFsbChjc3NDbGFzcyk7XHJcblxyXG4gICAgY2hhcnQuc3ZnLnNlbGVjdCgnLnJhZGlhbC1jb250YWluZXInKS5zZWxlY3RBbGwoJ3BhdGgnKVxyXG4gICAgICAgIC5hdHRyKCdzdHJva2UnLCAwKVxyXG4gICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCAwKTtcclxuICAgIC8vaGlnaGxpZ2h0IG5lY2Vzc2FyeSBzbGljZXNcclxuICAgIG5vZGVcclxuICAgICAgICAuYXR0cignc3Ryb2tlJywgY2hhcnQuX3ZhcnMuaGlnaGxpZ2h0Qm9yZGVyQ29sb3IpXHJcbiAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIGNoYXJ0Ll92YXJzLmhpZ2hsaWdodEJvcmRlcldpZHRoKTtcclxufVxyXG5cclxuLyoqc2V0UmFkaWFsTGVnZW5kRGF0YVxyXG4gKiAgZ2V0cyBsZWdlbmQgaW5mbyBmcm9tIGNoYXJ0IERhdGFcclxuICpcclxuICogQHBhcmFtcyBkYXRhLCB0eXBlXHJcbiAqIEByZXR1cm5zIFtdIG9mIGxlZ2VuZCB0ZXh0XHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRSYWRpYWxMZWdlbmREYXRhKGRhdGEpIHtcclxuICAgIHZhciBsZWdlbmRBcnJheSA9IFtdO1xyXG4gICAgZm9yIChsZXQgY2hhcnRFbGUgb2YgZGF0YS5jaGFydERhdGEpIHtcclxuICAgICAgICBpZiAobGVnZW5kQXJyYXkuaW5kZXhPZihjaGFydEVsZVtkYXRhLmRhdGFUYWJsZS5sYWJlbF0pID09PSAtMSkge1xyXG4gICAgICAgICAgICBsZWdlbmRBcnJheS5wdXNoKChjaGFydEVsZVtkYXRhLmRhdGFUYWJsZS5sYWJlbF0pKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbGVnZW5kQXJyYXk7XHJcbn1cclxuXHJcbi8qKmdlbmVyYXRlUmFkaWFsXHJcbiAqXHJcbiAqIHBhaW50cyB0aGUgcmFkaWwgYmFyIGNoYXJ0IG9uIHRoZSBjaGFydFxyXG4gKiBAcGFyYW1zIHJhZGlhbERhdGFcclxuICovXHJcblxyXG5mdW5jdGlvbiBnZW5lcmF0ZVJhZGlhbCgpIHtcclxuICAgIHZhciBjaGFydCA9IHRoaXMsXHJcbiAgICAgICAgc3ZnID0gY2hhcnQuc3ZnLFxyXG4gICAgICAgIGNvbG9ycyA9IGNoYXJ0Ll92YXJzLmNvbG9yLFxyXG4gICAgICAgIGNvbnRhaW5lciA9IGNoYXJ0LmNvbmZpZy5jb250YWluZXIsXHJcbiAgICAgICAgbGVnZW5kRGF0YSA9IGNoYXJ0LmRhdGEubGVnZW5kRGF0YSxcclxuICAgICAgICByYWRpYWxEYXRhID0gY2hhcnQuZGF0YS5jaGFydERhdGEsXHJcbiAgICAgICAgdGlja051bWJlciA9IDMsXHJcbiAgICAgICAgYmFySGVpZ2h0ID0gY29udGFpbmVyLmhlaWdodCAvIDIgLSA0MCxcclxuICAgICAgICB3aWR0aCA9IGNvbnRhaW5lci53aWR0aCxcclxuICAgICAgICBoZWlnaHQgPSBjb250YWluZXIuaGVpZ2h0LFxyXG4gICAgICAgIHIgPSBNYXRoLm1pbihoZWlnaHQgLyAyLCB3aWR0aCAvIDMpLFxyXG4gICAgICAgIGRhdGEgPSBbXSxcclxuICAgICAgICByYWRpYWxEYXRhTmV3LFxyXG4gICAgICAgIGRhdGFIZWFkZXJzLFxyXG4gICAgICAgIGxlZ2VuZEVsZW1lbnRUb2dnbGVBcnJheSA9IFtdLFxyXG4gICAgICAgIHJhZGlhbERhdGFGaWx0ZXJlZCxcclxuICAgICAgICBvYmosXHJcbiAgICAgICAgdmlzLFxyXG4gICAgICAgIGV4dGVudCxcclxuICAgICAgICBmb3JtYXROdW1iZXIsXHJcbiAgICAgICAgYmFyU2NhbGUsXHJcbiAgICAgICAga2V5cyxcclxuICAgICAgICBudW1CYXJzLFxyXG4gICAgICAgIHgsXHJcbiAgICAgICAgeEF4aXMsXHJcbiAgICAgICAgYXJjLFxyXG4gICAgICAgIHNlZ21lbnRzLFxyXG4gICAgICAgIGF4aXNHcm91cDtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gcmFkaWFsRGF0YS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgIG9iaiA9IHt9O1xyXG4gICAgICAgIGZvciAobGV0IGogaW4gY2hhcnQuZGF0YS5kYXRhVGFibGUpIHtcclxuICAgICAgICAgICAgb2JqW2pdID0gcmFkaWFsRGF0YVtpXVtjaGFydC5kYXRhLmRhdGFUYWJsZVtqXV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRhdGFbaV0gPSBvYmo7XHJcbiAgICB9XHJcblxyXG4gICAgcmFkaWFsRGF0YU5ldyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZGF0YSkpOy8vY29weSBvZiBwaWUgZGF0YVxyXG5cclxuXHJcbiAgICBpZiAoIWNoYXJ0Ll92YXJzLmxlZ2VuZEhlYWRlcnMpIHtcclxuICAgICAgICBjaGFydC5fdmFycy5sZWdlbmRIZWFkZXJzID0gbGVnZW5kRGF0YTtcclxuICAgIH1cclxuXHJcbiAgICBkYXRhSGVhZGVycyA9IGNoYXJ0Ll92YXJzLmxlZ2VuZEhlYWRlcnM7XHJcbiAgICBsZWdlbmRFbGVtZW50VG9nZ2xlQXJyYXkgPSBqdkNoYXJ0cy5nZXRMZWdlbmRFbGVtZW50VG9nZ2xlQXJyYXkoZGF0YUhlYWRlcnMsIGxlZ2VuZERhdGEpO1xyXG4gICAgcmFkaWFsRGF0YUZpbHRlcmVkID0gW107XHJcblxyXG4gICAgaWYgKGxlZ2VuZEVsZW1lbnRUb2dnbGVBcnJheSkge1xyXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcmFkaWFsRGF0YU5ldy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlZ2VuZEVsZW1lbnRUb2dnbGVBcnJheS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGxlZ2VuZEVsZW1lbnRUb2dnbGVBcnJheVtpXS5lbGVtZW50ID09PSByYWRpYWxEYXRhTmV3W2pdLmxhYmVsICYmIGxlZ2VuZEVsZW1lbnRUb2dnbGVBcnJheVtpXS50b2dnbGUgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmFkaWFsRGF0YU5ld1tqXS52YWx1ZSA9IC0xO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgcmFkaWFsRGF0YU5ldy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgIGlmIChyYWRpYWxEYXRhTmV3W2pdLnZhbHVlICE9PSAtMSkge1xyXG4gICAgICAgICAgICByYWRpYWxEYXRhRmlsdGVyZWQucHVzaChyYWRpYWxEYXRhTmV3W2pdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy9SZW1vdmUgZXhpc3RpbmcgYmFycyBmcm9tIHBhZ2VcclxuICAgIHN2Zy5zZWxlY3RBbGwoJ2cucmFkaWFsLWNvbnRhaW5lcicpLnJlbW92ZSgpO1xyXG5cclxuXHJcbiAgICB2aXMgPSBzdmdcclxuICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAuYXR0cignY2xhc3MnLCAncmFkaWFsLWNvbnRhaW5lcicpXHJcbiAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGhlaWdodClcclxuICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSggJHt3aWR0aCAvIDJ9ICwgJHtyfSApYCk7XHJcblxyXG4gICAgZXh0ZW50ID0gZDMuZXh0ZW50KHJhZGlhbERhdGFGaWx0ZXJlZCwgZCA9PiBkLnZhbHVlKTtcclxuXHJcbiAgICAvL2NvbW1hcyBhbmQgMCBkZWNpbWFsc1xyXG4gICAgZm9ybWF0TnVtYmVyID0gZDMuZm9ybWF0KCcsLjBmJyk7XHJcbiAgICBpZiAoZXh0ZW50WzFdID49IDEwMDAwMDApIHtcclxuICAgICAgICAvL21pbGxpb25zXHJcbiAgICAgICAgbGV0IHAgPSBkMy5wcmVjaXNpb25QcmVmaXgoMWU1LCAxLjNlNik7XHJcbiAgICAgICAgZm9ybWF0TnVtYmVyID0gZDMuZm9ybWF0UHJlZml4KCcuJyArIHAsIDEuM2U2KTtcclxuICAgIH0gZWxzZSBpZiAoZXh0ZW50WzFdIDw9IDEwMCkge1xyXG4gICAgICAgIC8vMiBkZWNpbWFsc1xyXG4gICAgICAgIGZvcm1hdE51bWJlciA9IGQzLmZvcm1hdCgnLC4yZicpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBpZiAoZXh0ZW50WzBdICE9PSAwKSB7XHJcbiAgICAgICAgZXh0ZW50WzBdID0gMDtcclxuICAgIH1cclxuICAgIGJhclNjYWxlID0gZDMuc2NhbGVMaW5lYXIoKVxyXG4gICAgICAgIC5kb21haW4oZXh0ZW50KVxyXG4gICAgICAgIC5yYW5nZShbMCwgYmFySGVpZ2h0XSk7XHJcblxyXG4gICAga2V5cyA9IHJhZGlhbERhdGFGaWx0ZXJlZC5tYXAoZCA9PiBkLmxhYmVsKTtcclxuICAgIG51bUJhcnMgPSBrZXlzLmxlbmd0aDtcclxuXHJcbiAgICB4ID0gZDMuc2NhbGVMaW5lYXIoKVxyXG4gICAgICAgIC5kb21haW4oZXh0ZW50KVxyXG4gICAgICAgIC5yYW5nZShbMCwgLWJhckhlaWdodF0pO1xyXG5cclxuICAgIC8vY3JlYXRlIHhBeGlzIGRyYXdpbmcgZnVuY3Rpb25cclxuICAgIHhBeGlzID0gZDMuYXhpc0xlZnQoKVxyXG4gICAgICAgIC5zY2FsZSh4KVxyXG4gICAgICAgIC50aWNrcyh0aWNrTnVtYmVyKVxyXG4gICAgICAgIC50aWNrRm9ybWF0KGZvcm1hdE51bWJlcik7XHJcblxyXG4gICAgdmlzLnNlbGVjdEFsbCgnY2lyY2xlJylcclxuICAgICAgICAuZGF0YSh4LnRpY2tzKDMpKVxyXG4gICAgICAgIC5lbnRlcigpLmFwcGVuZCgnY2lyY2xlJylcclxuICAgICAgICAuYXR0cigncicsIGQgPT4gYmFyU2NhbGUoZCkpXHJcbiAgICAgICAgLnN0eWxlKCdmaWxsJywgJ25vbmUnKVxyXG4gICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgJ2JsYWNrJylcclxuICAgICAgICAuc3R5bGUoJ3N0cm9rZS1kYXNoYXJyYXknLCAnMiwyJylcclxuICAgICAgICAuc3R5bGUoJ3N0cm9rZS13aWR0aCcsICcuNXB4Jyk7XHJcblxyXG4gICAgYXJjID0gZDMuYXJjKClcclxuICAgICAgICAuc3RhcnRBbmdsZSgoZCwgaSkgPT4gKGkgKiAyICogTWF0aC5QSSkgLyBudW1CYXJzKVxyXG4gICAgICAgIC5lbmRBbmdsZSgoZCwgaSkgPT4gKChpICsgMSkgKiAyICogTWF0aC5QSSkgLyBudW1CYXJzKVxyXG4gICAgICAgIC5pbm5lclJhZGl1cygwKTtcclxuXHJcbiAgICBzZWdtZW50cyA9IHZpcy5zZWxlY3RBbGwoJ3BhdGgnKVxyXG4gICAgICAgIC5kYXRhKHJhZGlhbERhdGFGaWx0ZXJlZClcclxuICAgICAgICAuZW50ZXIoKS5hcHBlbmQoJ2cnKVxyXG4gICAgICAgIC5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgIC5hdHRyKCdjbGFzcycsIChkKSA9PiB7XHJcbiAgICAgICAgICAgIHZhciBsYWJlbCA9IGQubGFiZWwucmVwbGFjZSgvXFxzL2csICdfJykucmVwbGFjZSgvXFwuL2csICdfZG90XycpO1xyXG4gICAgICAgICAgICByZXR1cm4gJ3JhZGlhbC1kYXRhLScgKyBsYWJlbCArICcgaGlnaGxpZ2h0LWNsYXNzLScgKyBsYWJlbDtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5lYWNoKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIGQub3V0ZXJSYWRpdXMgPSAwO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLnN0eWxlKCdmaWxsJywgKGQsIGkpID0+IGp2Q2hhcnRzLmdldENvbG9ycyhjb2xvcnMsIGksIGQubGFiZWwpKVxyXG4gICAgICAgIC5hdHRyKCdkJywgYXJjKVxyXG4gICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgaWYgKGNoYXJ0LnNob3dUb29sVGlwKSB7XHJcbiAgICAgICAgICAgICAgICAvL0dldCB0aXAgZGF0YVxyXG4gICAgICAgICAgICAgICAgdmFyIHRpcERhdGEgPSBjaGFydC5zZXRUaXBEYXRhKGQsIGkpO1xyXG4gICAgICAgICAgICAgICAgLy9EcmF3IHRpcCBsaW5lXHJcbiAgICAgICAgICAgICAgICBjaGFydC50aXAuZ2VuZXJhdGVTaW1wbGVUaXAodGlwRGF0YSwgY2hhcnQuZGF0YS5kYXRhVGFibGUpO1xyXG4gICAgICAgICAgICAgICAgY2hhcnQudGlwLmQgPSBkO1xyXG4gICAgICAgICAgICAgICAgY2hhcnQudGlwLmkgPSBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICAub24oJ21vdXNlbW92ZScsIGZ1bmN0aW9uIChkLCBpKSB7XHJcbiAgICAgICAgICAgIGlmIChjaGFydC5zaG93VG9vbFRpcCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoYXJ0LnRpcC5kID09PSBkICYmIGNoYXJ0LnRpcC5pID09PSBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhcnQudGlwLnNob3dUaXAoZDMuZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvL0dldCB0aXAgZGF0YVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0aXBEYXRhID0gY2hhcnQuc2V0VGlwRGF0YShkLCBpKTtcclxuICAgICAgICAgICAgICAgICAgICAvL0RyYXcgdGlwIGxpbmVcclxuICAgICAgICAgICAgICAgICAgICBjaGFydC50aXAuZ2VuZXJhdGVTaW1wbGVUaXAodGlwRGF0YSwgY2hhcnQuZGF0YS5kYXRhVGFibGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgaWYgKGNoYXJ0LnNob3dUb29sVGlwKSB7XHJcbiAgICAgICAgICAgICAgICBjaGFydC50aXAuaGlkZVRpcCgpO1xyXG4gICAgICAgICAgICAgICAgc3ZnLnNlbGVjdEFsbCgnbGluZS50aXAtbGluZScpLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgc2VnbWVudHNcclxuICAgICAgICAudHJhbnNpdGlvbigpXHJcbiAgICAgICAgLmR1cmF0aW9uKDgwMClcclxuICAgICAgICAuZWFzZShkMy5lYXNlRWxhc3RpYylcclxuICAgICAgICAuZGVsYXkoKGQsIGkpID0+IDc1MCAtIDUwICogaSlcclxuICAgICAgICAuYXR0clR3ZWVuKCdkJywgKGQsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgIHZhciBpID0gZDMuaW50ZXJwb2xhdGUoZC5vdXRlclJhZGl1cywgYmFyU2NhbGUoK2QudmFsdWUpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHQgPT4ge1xyXG4gICAgICAgICAgICAgICAgZC5vdXRlclJhZGl1cyA9IGkodCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJjKGQsIGluZGV4KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICB2aXMuYXBwZW5kKCdjaXJjbGUnKVxyXG4gICAgICAgIC5hdHRyKCdyJywgYmFySGVpZ2h0KVxyXG4gICAgICAgIC5jbGFzc2VkKCdvdXRlcicsIHRydWUpXHJcbiAgICAgICAgLnN0eWxlKCdmaWxsJywgJ25vbmUnKVxyXG4gICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgJ2JsYWNrJylcclxuICAgICAgICAuc3R5bGUoJ3N0cm9rZS13aWR0aCcsICcxLjVweCcpO1xyXG5cclxuICAgIHZpcy5zZWxlY3RBbGwoJ2xpbmUnKVxyXG4gICAgICAgIC5kYXRhKGtleXMpXHJcbiAgICAgICAgLmVudGVyKCkuYXBwZW5kKCdnJylcclxuICAgICAgICAuYXR0cignY2xhc3MnLCAnbGFiZWwnKVxyXG4gICAgICAgIC5hcHBlbmQoJ2xpbmUnKVxyXG4gICAgICAgIC5hdHRyKCd5MicsIC1iYXJIZWlnaHQgLSAyMClcclxuICAgICAgICAuc3R5bGUoJ3N0cm9rZScsICdibGFjaycpXHJcbiAgICAgICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLCAnLjVweCcpXHJcbiAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIChkLCBpKSA9PiBgcm90YXRlKCAke2kgKiAzNjAgLyBudW1CYXJzfSApYCk7XHJcblxyXG4gICAgYXhpc0dyb3VwID0gdmlzLmFwcGVuZCgnZycpXHJcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3hBeGlzJylcclxuICAgICAgICAuc3R5bGUoJ3BvaW50ZXItZXZlbnRzJywgJ25vbmUnKVxyXG4gICAgICAgIC5jYWxsKHhBeGlzKTtcclxuXHJcbiAgICBheGlzR3JvdXAuc2VsZWN0QWxsKCd0ZXh0JylcclxuICAgICAgICAuYXR0cignZmlsbCcsICdibGFjaycpLy9DdXN0b21pemUgdGhlIGNvbG9yIG9mIGF4aXMgbGFiZWxzXHJcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3lBeGlzTGFiZWxzIGVkaXRhYmxlIGVkaXRhYmxlLXlBeGlzIGVkaXRhYmxlLXRleHQgZWRpdGFibGUtbnVtJylcclxuICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZCA9PiB7XHJcbiAgICAgICAgICAgIGlmIChkID09PSB4QXhpcy5zY2FsZSgpLnRpY2tzKHRpY2tOdW1iZXIpW3RpY2tOdW1iZXJdKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgwLCAxMCknO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKDAsMCknO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmF0dHIoJ2ZvbnQtc2l6ZScsIGNoYXJ0Ll92YXJzLmZvbnRTaXplKVxyXG4gICAgICAgIC5hcHBlbmQoJ3N2Zzp0aXRsZScpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGp2Q2hhcnRzO1xyXG4iLCIndXNlIHN0cmljdCc7XHJcbnZhciBqdkNoYXJ0cyA9IHJlcXVpcmUoJy4uL2p2Q2hhcnRzLmpzJyk7XHJcblxyXG5qdkNoYXJ0cy5wcm90b3R5cGUuc2Fua2V5ID0ge1xyXG4gICAgcGFpbnQ6IHBhaW50LFxyXG4gICAgc2V0RGF0YTogc2V0RGF0YSxcclxuICAgIGdldEV2ZW50RGF0YTogZ2V0RXZlbnREYXRhXHJcbn07XHJcblxyXG5qdkNoYXJ0cy5wcm90b3R5cGUuZ2VuZXJhdGVTYW5rZXkgPSBnZW5lcmF0ZVNhbmtleTtcclxuXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogU2Fua2V5IGZ1bmN0aW9ucyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcbi8qKlxyXG4gKlxyXG4gKiBAcGFyYW0gZGF0YVxyXG4gKiBAcGFyYW0gZGF0YVRhYmxlXHJcbiAqIEBwYXJhbSBjb2xvcnNcclxuICovXHJcbmZ1bmN0aW9uIHNldERhdGEoKSB7XHJcbiAgICB2YXIgY2hhcnQgPSB0aGlzO1xyXG4gICAgdmFyIHNhbmtleURhdGEgPSB7fSxcclxuICAgICAgICBkYXRhID0gY2hhcnQuZGF0YS5jaGFydERhdGEsXHJcbiAgICAgICAgZGF0YVRhYmxlID0gY2hhcnQuZGF0YS5kYXRhVGFibGU7XHJcblxyXG4gICAgc2Fua2V5RGF0YS5saW5rcyA9IFtdO1xyXG4gICAgc2Fua2V5RGF0YS5ub2RlcyA9IFtdO1xyXG5cclxuICAgIC8vSXRlcmF0ZSB0aHJvdWdoIHNvdXJjZXMgYW5kIHRhcmdldHMgdG8gbWFrZSBhIG5vZGUgbGlzdFxyXG4gICAgdmFyIG5vZGVMaXN0ID0gW107XHJcbiAgICB2YXIgbm9kZUdyb3VwID0gMTtcclxuICAgIGZvciAodmFyIGl0ZW0gaW4gZGF0YVRhYmxlKSB7XHJcbiAgICAgICAgdmFyIG5vZGVMaXN0Rm9yTGFiZWwgPSBbXTtcclxuICAgICAgICBpZiAoaXRlbSA9PT0gJ3ZhbHVlJykgeyBjb250aW51ZTsgfVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgcG90ZW50aWFsTm9kZSA9IGRhdGFbaV1bZGF0YVRhYmxlW2l0ZW1dXSArICctJyArIG5vZGVHcm91cDtcclxuICAgICAgICAgICAgdmFyIGFkZFRvTGlzdCA9IHRydWU7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbm9kZUxpc3RGb3JMYWJlbC5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHBvdGVudGlhbE5vZGUgPT09IG5vZGVMaXN0Rm9yTGFiZWxbal0pIHtcclxuICAgICAgICAgICAgICAgICAgICBhZGRUb0xpc3QgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYWRkVG9MaXN0KSB7XHJcbiAgICAgICAgICAgICAgICBub2RlTGlzdEZvckxhYmVsLnB1c2gocG90ZW50aWFsTm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbm9kZUdyb3VwKys7XHJcbiAgICAgICAgbm9kZUxpc3QgPSBub2RlTGlzdC5jb25jYXQobm9kZUxpc3RGb3JMYWJlbCk7XHJcbiAgICB9XHJcbiAgICAvL0NyZWF0ZSBub2RlcyBvYmplY3RcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZUxpc3QubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBzYW5rZXlEYXRhLm5vZGVzLnB1c2goe1xyXG4gICAgICAgICAgICAnbmFtZSc6IG5vZGVMaXN0W2ldXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy9TZWUgaG93IG1hbnkgc2V0cyBvZiBsaW5rcyB5b3UgbmVlZFxyXG4gICAgdmFyIGxpbmtHcm91cHMgPSAwO1xyXG5cclxuICAgIGZvciAobGV0IGl0ZW0gaW4gZGF0YVRhYmxlKSB7XHJcbiAgICAgICAgaWYgKGl0ZW0uaW5kZXhPZignbGFiZWwnKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgbGlua0dyb3VwcysrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBsZXQgc291cmNlLFxyXG4gICAgICAgIHRhcmdldCxcclxuICAgICAgICB2YWx1ZTtcclxuXHJcbiAgICBmb3IgKGxldCBrIGluIGRhdGFUYWJsZSkge1xyXG4gICAgICAgIGlmIChrLmluZGV4T2YoJ3ZhbHVlJykgPiAtMSkge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IGRhdGFUYWJsZVtrXTtcclxuICAgICAgICB9IGVsc2UgaWYgKCFzb3VyY2UpIHtcclxuICAgICAgICAgICAgc291cmNlID0gZGF0YVRhYmxlW2tdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRhcmdldCA9IGRhdGFUYWJsZVtrXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBsaW5rR3JvdXBzOyBpKyspIHtcclxuICAgICAgICB2YXIgbGlua0dyb3VwID0gW107XHJcbiAgICAgICAgbGlua0dyb3VwID0gZGF0YS5tYXAoZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICdzb3VyY2UnOiB4W3NvdXJjZV0gKyAnLScgKyBpLFxyXG4gICAgICAgICAgICAgICAgJ3RhcmdldCc6IHhbdGFyZ2V0XSArICctJyArIChpICsgMSksXHJcbiAgICAgICAgICAgICAgICAndmFsdWUnOiB4W3ZhbHVlXVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBzYW5rZXlEYXRhLmxpbmtzID0gc2Fua2V5RGF0YS5saW5rcy5jb25jYXQobGlua0dyb3VwKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbm9kZU1hcCA9IHt9O1xyXG4gICAgZm9yIChpID0gMDsgaSA8IHNhbmtleURhdGEubm9kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBzYW5rZXlEYXRhLm5vZGVzW2ldLm5vZGUgPSBpO1xyXG4gICAgICAgIG5vZGVNYXBbc2Fua2V5RGF0YS5ub2Rlc1tpXS5uYW1lXSA9IGk7XHJcbiAgICB9XHJcbiAgICBzYW5rZXlEYXRhLmxpbmtzID0gc2Fua2V5RGF0YS5saW5rcy5tYXAoZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzb3VyY2U6IG5vZGVNYXBbeC5zb3VyY2VdLFxyXG4gICAgICAgICAgICB0YXJnZXQ6IG5vZGVNYXBbeC50YXJnZXRdLFxyXG4gICAgICAgICAgICB2YWx1ZTogeC52YWx1ZVxyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxuXHJcbiAgICAvL0dyb3VwIGNvbW1vbiBzYW5rZXkgbGlua3MgdG9nZXRoZXIgYW5kIGFkZCB0aGUgdmFsdWVzXHJcbiAgICB2YXIgYWdncmVnYXRlU2Fua2V5TGlua3MgPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2Fua2V5RGF0YS5saW5rcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciBjdXJyZW50TGluayA9IHt9O1xyXG4gICAgICAgIGN1cnJlbnRMaW5rLnNvdXJjZSA9IHNhbmtleURhdGEubGlua3NbaV0uc291cmNlO1xyXG4gICAgICAgIGN1cnJlbnRMaW5rLnRhcmdldCA9IHNhbmtleURhdGEubGlua3NbaV0udGFyZ2V0O1xyXG4gICAgICAgIGN1cnJlbnRMaW5rLnZhbHVlID0gc2Fua2V5RGF0YS5saW5rc1tpXS52YWx1ZTtcclxuXHJcbiAgICAgICAgLy9NYWtlIHN1cmUgdGhhdCBvbmx5IHVuaXF1ZSBsaW5rcyBhcmUgcHVzaGVkIHRvIHRoZSBhZ2dyZWdhdGVkIGFycmF5XHJcbiAgICAgICAgbGV0IGFkZFRvQWdncmVnYXRlID0gdHJ1ZTtcclxuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGFnZ3JlZ2F0ZVNhbmtleUxpbmtzLmxlbmd0aDsgaysrKSB7XHJcbiAgICAgICAgICAgIGlmIChhZ2dyZWdhdGVTYW5rZXlMaW5rc1trXS5zb3VyY2UgPT09IGN1cnJlbnRMaW5rLnNvdXJjZSAmJiBhZ2dyZWdhdGVTYW5rZXlMaW5rc1trXS50YXJnZXQgPT09IGN1cnJlbnRMaW5rLnRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgYWRkVG9BZ2dyZWdhdGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWFkZFRvQWdncmVnYXRlKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9TdW0gdGhlIHZhbHVlIG9mIGlkZW50aWNhbCBsaW5rc1xyXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2Fua2V5RGF0YS5saW5rcy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICBpZiAoc2Fua2V5RGF0YS5saW5rc1tpXS5zb3VyY2UgPT09IHNhbmtleURhdGEubGlua3Nbal0uc291cmNlICYmIHNhbmtleURhdGEubGlua3NbaV0udGFyZ2V0ID09PSBzYW5rZXlEYXRhLmxpbmtzW2pdLnRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudExpbmsudmFsdWUgPSBjdXJyZW50TGluay52YWx1ZSArIHNhbmtleURhdGEubGlua3Nbal0udmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGFnZ3JlZ2F0ZVNhbmtleUxpbmtzLnB1c2goY3VycmVudExpbmspO1xyXG4gICAgfVxyXG5cclxuICAgIHNhbmtleURhdGEubGlua3MgPSBhZ2dyZWdhdGVTYW5rZXlMaW5rcztcclxuXHJcbiAgICBjaGFydC5kYXRhLmNoYXJ0RGF0YSA9IHNhbmtleURhdGE7XHJcbiAgICBjaGFydC5kYXRhLmNvbG9yID0gZDMuc2NhbGVPcmRpbmFsKGQzLnNjaGVtZUNhdGVnb3J5MjApO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwYWludCgpIHtcclxuICAgIHZhciBjaGFydCA9IHRoaXM7XHJcbiAgICB2YXIgZGF0YSA9IGNoYXJ0LmRhdGEuY2hhcnREYXRhO1xyXG5cclxuICAgIC8vZ2VuZXJhdGUgU1ZHXHJcbiAgICBjaGFydC5nZW5lcmF0ZVNWRyhudWxsKTtcclxuICAgIGNoYXJ0LmdlbmVyYXRlU2Fua2V5KGRhdGEpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRFdmVudERhdGEoKSB7XHJcbiAgICByZXR1cm4ge307XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSBzYW5rZXkgY2hhcnQgd2l0aCB0aGUgZ2l2ZW4gZGF0YVxyXG4gKiBAcGFyYW0gc2Fua2V5RGF0YVxyXG4gKi9cclxuZnVuY3Rpb24gZ2VuZXJhdGVTYW5rZXkoc2Fua2V5RGF0YSkge1xyXG4gICAgdmFyIGNoYXJ0ID0gdGhpcyxcclxuICAgICAgICBzdmcgPSBjaGFydC5zdmcsXHJcbiAgICAgICAgY29sb3IgPSBjaGFydC5fdmFycy5jb2xvcjtcclxuXHJcbiAgICB2YXIgd2lkdGggPSBjaGFydC5jb25maWcuY29udGFpbmVyLndpZHRoO1xyXG4gICAgdmFyIGhlaWdodCA9IGNoYXJ0LmNvbmZpZy5jb250YWluZXIuaGVpZ2h0O1xyXG5cclxuICAgIHZhciBmb3JtYXROdW1iZXIgPSBkMy5mb3JtYXQoJywuMGYnKSwgICAgLy96ZXJvIGRlY2ltYWwgcGxhY2VzXHJcbiAgICAgICAgZm9ybWF0ID0gZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGZvcm1hdE51bWJlcihkKSArICcgJyArICdXaWRnZXRzJzsgfSxcclxuICAgICAgICBjb2xvciA9IGQzLnNjYWxlT3JkaW5hbChkMy5zY2hlbWVDYXRlZ29yeTIwKTtcclxuXHJcbiAgICB2YXIgc2Fua2V5ID0gZDMuc2Fua2V5KClcclxuICAgICAgICAubm9kZVdpZHRoKDEwKVxyXG4gICAgICAgIC5ub2RlUGFkZGluZygxNSlcclxuICAgICAgICAuc2l6ZShbd2lkdGgsIGhlaWdodF0pO1xyXG5cclxuICAgIHZhciBwYXRoID0gc2Fua2V5LmxpbmsoKTtcclxuXHJcbiAgICAvLy8vQWRkaW5nIHpvb20gdjQgYmVoYXZpb3IgdG8gc2Fua2V5XHJcbiAgICBkMy5zZWxlY3RBbGwoJ3N2ZycpXHJcbiAgICAgICAgLmNhbGwoZDMuem9vbSgpXHJcbiAgICAgICAgICAgIC5zY2FsZUV4dGVudChbMC4xLCAxMF0pXHJcbiAgICAgICAgICAgIC5vbignem9vbScsIHpvb20pKTsvL3pvb20gZXZlbnQgbGlzdGVuZXJcclxuXHJcbiAgICBzYW5rZXlcclxuICAgICAgICAubm9kZXMoc2Fua2V5RGF0YS5ub2RlcylcclxuICAgICAgICAubGlua3Moc2Fua2V5RGF0YS5saW5rcylcclxuICAgICAgICAubGF5b3V0KDMyKTtcclxuXHJcbiAgICB2YXIgbGluayA9IHN2Zy5hcHBlbmQoJ2cnKS5zZWxlY3RBbGwoJy5zYW5rZXktbGluaycpXHJcbiAgICAgICAgLmRhdGEoc2Fua2V5RGF0YS5saW5rcylcclxuICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgIC5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQudmFsdWUgPiAwOyB9KVxyXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICdzYW5rZXktbGluaycpXHJcbiAgICAgICAgLmF0dHIoJ2QnLCBwYXRoKVxyXG4gICAgICAgIC5zdHlsZSgnc3Ryb2tlLXdpZHRoJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KDEsIGQuZHkpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGIuZHkgLSBhLmR5O1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICBpZiAoY2hhcnQuc2hvd1Rvb2xUaXApIHtcclxuICAgICAgICAgICAgICAgIHZhciB0aXBEYXRhID0gY2hhcnQuc2V0VGlwRGF0YShkLCBpKTtcclxuICAgICAgICAgICAgICAgIGNoYXJ0LnRpcC5nZW5lcmF0ZVNpbXBsZVRpcCh0aXBEYXRhLCBjaGFydC5kYXRhLmRhdGFUYWJsZSk7XHJcbiAgICAgICAgICAgICAgICBjaGFydC50aXAuZCA9IGQ7XHJcbiAgICAgICAgICAgICAgICBjaGFydC50aXAuaSA9IGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICAgIC5vbignbW91c2Vtb3ZlJywgZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgaWYgKGNoYXJ0LnNob3dUb29sVGlwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hhcnQudGlwLmQgPT09IGQgJiYgY2hhcnQudGlwLmkgPT09IGkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGFydC50aXAuc2hvd1RpcChkMy5ldmVudCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vR2V0IHRpcCBkYXRhXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpcERhdGEgPSBjaGFydC5zZXRUaXBEYXRhKGQsIGkpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vRHJhdyB0aXAgbGluZVxyXG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0LnRpcC5nZW5lcmF0ZVNpbXBsZVRpcCh0aXBEYXRhLCBjaGFydC5kYXRhLmRhdGFUYWJsZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICBpZiAoY2hhcnQuc2hvd1Rvb2xUaXApIHtcclxuICAgICAgICAgICAgICAgIGNoYXJ0LnRpcC5oaWRlVGlwKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICB2YXIgbm9kZSA9IHN2Zy5hcHBlbmQoJ2cnKS5zZWxlY3RBbGwoJy5ub2RlJylcclxuICAgICAgICAuZGF0YShzYW5rZXlEYXRhLm5vZGVzKVxyXG4gICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC52YWx1ZSA+IDA7IH0pXHJcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ25vZGUnKVxyXG4gICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgZC54ICsgJywgJyArIGQueSArICcpJztcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5jYWxsKGQzLmRyYWcoKVxyXG4gICAgICAgICAgICAuc3ViamVjdChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGQ7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5vbignc3RhcnQnLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgZDMuZXZlbnQuc291cmNlRXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQodGhpcyk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5vbignZHJhZycsIGRyYWdtb3ZlKSk7XHJcblxyXG4gICAgbm9kZS5hcHBlbmQoJ3JlY3QnKVxyXG4gICAgICAgIC5hdHRyKCdoZWlnaHQnLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAvL3JldHVybiBkLmR5O1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hYnMoZC5keSk7XHJcbiAgICAgICAgICAgIC8vcmV0dXJuIE1hdGgubWF4KGQuZHksIDIpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmF0dHIoJ3dpZHRoJywgc2Fua2V5Lm5vZGVXaWR0aCgpKVxyXG4gICAgICAgIC5zdHlsZSgnZmlsbCcsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkLmNvbG9yID0gY29sb3IoZC5uYW1lKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGQzLnJnYihkLmNvbG9yKS5kYXJrZXIoMik7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgbm9kZS5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgIC5hdHRyKCd4JywgLTYpXHJcbiAgICAgICAgLmF0dHIoJ3knLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZC5keSAvIDI7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuYXR0cignZHknLCAnLjM1ZW0nKVxyXG4gICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdlbmQnKVxyXG4gICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBudWxsKVxyXG4gICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBudWxsKVxyXG4gICAgICAgIC50ZXh0KGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIC8vUmVtb3ZlIHRoZSB0aGUgbm9kZUdyb3VwIHRhZyBhbmQgaHlwaGVuIGZyb20gdGhlIGVuZCBvZiB0aGUgbGFiZWxcclxuICAgICAgICAgICAgcmV0dXJuIGQubmFtZS5zbGljZSgwLCAtMik7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkLnggPCB3aWR0aCAvIDI7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuYXR0cigneCcsIDYgKyBzYW5rZXkubm9kZVdpZHRoKCkpXHJcbiAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ3N0YXJ0Jyk7XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhZ21vdmUoZCkge1xyXG4gICAgICAgIGQzLnNlbGVjdCh0aGlzKS5hdHRyKCd0cmFuc2Zvcm0nLFxyXG4gICAgICAgICAgICAndHJhbnNsYXRlKCcgKyAoXHJcbiAgICAgICAgICAgICAgICBkLnggPSBNYXRoLm1heCgwLCBNYXRoLm1pbih3aWR0aCAtIGQuZHgsIGQzLmV2ZW50LngpKVxyXG4gICAgICAgICAgICApICsgJywnICsgKFxyXG4gICAgICAgICAgICAgICAgZC55ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oaGVpZ2h0IC0gZC5keSwgZDMuZXZlbnQueSkpXHJcbiAgICAgICAgICAgICkgKyAnKScpO1xyXG4gICAgICAgIHNhbmtleS5yZWxheW91dCgpO1xyXG4gICAgICAgIGxpbmsuYXR0cignZCcsIHBhdGgpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHpvb20oKSB7IC8vSW1wbGVtZW50aW5nIHRoZSB2NCB6b29taW5nIGZlYXR1cmVcclxuICAgICAgICBzdmcuYXR0cigndHJhbnNmb3JtJywgZDMuZXZlbnQudHJhbnNmb3JtKTtcclxuICAgIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBqdkNoYXJ0cztcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIganZDaGFydHMgPSByZXF1aXJlKCcuLi9qdkNoYXJ0cy5qcycpO1xyXG5cclxuanZDaGFydHMucHJvdG90eXBlLnNjYXR0ZXJwbG90ID0ge1xyXG4gICAgcGFpbnQ6IHBhaW50LFxyXG4gICAgc2V0RGF0YTogc2V0RGF0YSxcclxuICAgIGdldEV2ZW50RGF0YTogZ2V0RXZlbnREYXRhLFxyXG4gICAgaGlnaGxpZ2h0RnJvbUV2ZW50RGF0YTogaGlnaGxpZ2h0RnJvbUV2ZW50RGF0YVxyXG59O1xyXG5cclxuanZDaGFydHMucHJvdG90eXBlLmdlbmVyYXRlU2NhdHRlciA9IGdlbmVyYXRlU2NhdHRlcjtcclxuanZDaGFydHMucHJvdG90eXBlLmNyZWF0ZUxpbmVHdWlkZSA9IGNyZWF0ZUxpbmVHdWlkZTtcclxuXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogU2NhdHRlciBmdW5jdGlvbnMgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuLyoqc2V0U2NhdHRlckRhdGFcclxuICogIGdldHMgc2NhdHRlciBkYXRhIGFuZCBhZGRzIGl0IHRvIHRoZSBjaGFydCBvYmplY3RcclxuICpcclxuICogQHBhcmFtcyBkYXRhLCBkYXRhVGFibGUsIGNvbG9yc1xyXG4gKi9cclxuZnVuY3Rpb24gc2V0RGF0YSgpIHtcclxuICAgIHZhciBjaGFydCA9IHRoaXM7XHJcbiAgICBjaGFydC5kYXRhLmxlZ2VuZERhdGEgPSBzZXRTY2F0dGVyTGVnZW5kRGF0YShjaGFydC5kYXRhKTtcclxuICAgIGNoYXJ0LmRhdGEueEF4aXNEYXRhID0gc2V0U2NhdHRlckF4aXNEYXRhKGNoYXJ0LmRhdGEsICd4JywgY2hhcnQuX3ZhcnMpO1xyXG4gICAgY2hhcnQuZGF0YS55QXhpc0RhdGEgPSBzZXRTY2F0dGVyQXhpc0RhdGEoY2hhcnQuZGF0YSwgJ3knLCBjaGFydC5fdmFycyk7XHJcbiAgICBjaGFydC5kYXRhLnpBeGlzRGF0YSA9IGNoYXJ0LmRhdGEuZGF0YVRhYmxlLmhhc093blByb3BlcnR5KCd6JykgPyBzZXRTY2F0dGVyQXhpc0RhdGEoY2hhcnQuZGF0YSwgJ3onLCBjaGFydC5fdmFycykgOiB7fTtcclxuICAgIC8vZGVmaW5lIGNvbG9yIG9iamVjdCBmb3IgY2hhcnREYXRhXHJcbiAgICBjaGFydC5kYXRhLmNvbG9yID0ganZDaGFydHMuc2V0Q2hhcnRDb2xvcnMoY2hhcnQuX3ZhcnMuY29sb3IsIGNoYXJ0LmRhdGEubGVnZW5kRGF0YSwgY2hhcnQuY29sb3JzKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0RXZlbnREYXRhKGV2ZW50LCBtb3VzZSkge1xyXG4gICAgdmFyIGNoYXJ0ID0gdGhpcyxcclxuICAgICAgICBlbGUgPSBldmVudC50YXJnZXQuX19kYXRhX187XHJcblxyXG4gICAgLy9kZXRlcm1pbmUgaWYgdGhlIGNsaWNrIGV2ZW50IGhhcHBlbnMgaW5zaWRlIHRoZSBjb250YWluZXJcclxuICAgIGxldCBicnVzaENvbnRhaW5lciA9IGNoYXJ0LmNoYXJ0RGl2LnNlbGVjdCgnLicgKyBjaGFydC5jb25maWcudHlwZSArICctY29udGFpbmVyJykubm9kZSgpLFxyXG4gICAgICAgIGNvbnRhaW5lckJveCA9IGJydXNoQ29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxyXG4gICAgICAgIHggPSBtb3VzZVswXSxcclxuICAgICAgICB5ID0gbW91c2VbMV0sXHJcbiAgICAgICAgaW5zaWRlQ29udGFpbmVyID0gZmFsc2U7XHJcblxyXG4gICAgaWYgKHggPCBjb250YWluZXJCb3gucmlnaHQgJiYgeSA8IGNvbnRhaW5lckJveC5ib3R0b20gJiYgeCA+IGNvbnRhaW5lckJveC5sZWZ0ICYmIHkgPiBjb250YWluZXJCb3gudG9wKSB7XHJcbiAgICAgICAgaW5zaWRlQ29udGFpbmVyID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaW5zaWRlQ29udGFpbmVyICYmIGVsZSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgICAgIFtjaGFydC5jdXJyZW50RGF0YS5kYXRhVGFibGUubGFiZWxdOiBbZWxlW2NoYXJ0LmN1cnJlbnREYXRhLmRhdGFUYWJsZS5sYWJlbF0ucmVwbGFjZSgvXy9nLCAnICcpLnJlcGxhY2UoL19jb2xvbl8vZywgJzonKS5yZXBsYWNlKC9fZG90Xy9nLCAnLicpXVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBub2RlOiBldmVudC50YXJnZXRcclxuICAgICAgICB9O1xyXG4gICAgfSBlbHNlIGlmIChpbnNpZGVDb250YWluZXIpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBkYXRhOiB7fVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGRhdGE6IGZhbHNlXHJcbiAgICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBoaWdobGlnaHRGcm9tRXZlbnREYXRhKGV2ZW50KSB7XHJcbiAgICBsZXQgY2hhcnQgPSB0aGlzLFxyXG4gICAgICAgIGxhYmVsID0gZXZlbnQuZGF0YVtjaGFydC5jdXJyZW50RGF0YS5kYXRhVGFibGUubGFiZWxdWzBdLFxyXG4gICAgICAgIGNzc0NsYXNzID0gJy5oaWdobGlnaHQtY2xhc3MtJyArIGxhYmVsLnJlcGxhY2UoL1xccy9nLCAnXycpLnJlcGxhY2UoL1xcLi9nLCAnX2RvdF8nKSxcclxuICAgICAgICBub2RlID0gY2hhcnQuc3ZnLnNlbGVjdEFsbChjc3NDbGFzcyk7XHJcblxyXG4gICAgY2hhcnQuc3ZnLnNlbGVjdCgnLnNjYXR0ZXItY2lyY2xlJykuc2VsZWN0QWxsKCdjaXJjbGUnKVxyXG4gICAgICAgIC5hdHRyKCdzdHJva2UnLCAwKVxyXG4gICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCAwKTtcclxuICAgIC8vaGlnaGxpZ2h0IG5lY2Vzc2FyeSBjaXJjbGVzXHJcbiAgICBub2RlXHJcbiAgICAgICAgLmF0dHIoJ3N0cm9rZScsIGNoYXJ0Ll92YXJzLmhpZ2hsaWdodEJvcmRlckNvbG9yKVxyXG4gICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCBjaGFydC5fdmFycy5oaWdobGlnaHRCb3JkZXJXaWR0aCk7XHJcbn1cclxuXHJcbi8qKnNldFNjYXR0ZXJMZWdlbmREYXRhXHJcbiAqICBnZXRzIGxlZ2VuZCBpbmZvIGZyb20gY2hhcnQgRGF0YVxyXG4gKlxyXG4gKiBAcGFyYW1zIGRhdGEsIHR5cGVcclxuICogQHJldHVybnMgW10gb2YgbGVnZW5kIHRleHRcclxuICovXHJcbmZ1bmN0aW9uIHNldFNjYXR0ZXJMZWdlbmREYXRhKGRhdGEpIHtcclxuICAgIGxldCBsZWdlbmRBcnJheSA9IFtdO1xyXG4gICAgaWYgKGRhdGEuZGF0YVRhYmxlLmhhc093blByb3BlcnR5KCdzZXJpZXMnKSkge1xyXG4gICAgICAgIGxldCBzZXJpZXMgPSBkYXRhLmRhdGFUYWJsZS5zZXJpZXM7XHJcbiAgICAgICAgZm9yIChsZXQgY2hhcnRFbGUgb2YgZGF0YS5jaGFydERhdGEpIHtcclxuICAgICAgICAgICAgaWYgKGxlZ2VuZEFycmF5LmluZGV4T2YoY2hhcnRFbGVbc2VyaWVzXSkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBsZWdlbmRBcnJheS5wdXNoKGNoYXJ0RWxlW3Nlcmllc10pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChsZWdlbmRBcnJheS5sZW5ndGggPT09IDAgfHwgdHlwZW9mIGxlZ2VuZEFycmF5WzBdID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIGxlZ2VuZEFycmF5LnB1c2goZGF0YS5kYXRhVGFibGUubGFiZWwpO1xyXG4gICAgICAgIGRhdGEuZGF0YVRhYmxlLnNlcmllcyA9IGRhdGEuZGF0YVRhYmxlLmxhYmVsO1xyXG4gICAgfVxyXG5cclxuICAgIC8vb3JkZXIgbGVnZW5kIGRhdGEgaW4gYWxwaGFiZXRpY2FsIG9yZGVyXHJcbiAgICBsZWdlbmRBcnJheS5zb3J0KCk7XHJcbiAgICByZXR1cm4gbGVnZW5kQXJyYXk7XHJcbn1cclxuXHJcbi8qKnNldFNjYXR0ZXJBeGlzRGF0YVxyXG4gKiAgZ2V0cyB6IGF4aXMgZGF0YSBiYXNlZCBvbiB0aGUgY2hhcnREYXRhXHJcbiAqXHJcbiAqIEBwYXJhbXMgZGF0YSwgZGF0YVRhYmxlXHJcbiAqIEByZXR1cm5zIG9iamVjdCB3aXRoIGxhYmVsIGFuZCB2YWx1ZXNcclxuICovXHJcbmZ1bmN0aW9uIHNldFNjYXR0ZXJBeGlzRGF0YShkYXRhLCBheGlzLCBfdmFycykge1xyXG4gICAgLy9kZWNsYXJlIHZhcnNcclxuICAgIHZhciBheGlzRGF0YSA9IFtdLFxyXG4gICAgICAgIGNoYXJ0RGF0YSA9IGRhdGEuY2hhcnREYXRhLFxyXG4gICAgICAgIHNjYXR0ZXJMYWJlbCA9IGRhdGEuZGF0YVRhYmxlW2F4aXNdLFxyXG4gICAgICAgIG1pbiA9IHNjYXR0ZXJMYWJlbCA/IGNoYXJ0RGF0YVswXVtzY2F0dGVyTGFiZWxdIDogMCxcclxuICAgICAgICBtYXggPSBzY2F0dGVyTGFiZWwgPyBjaGFydERhdGFbMF1bc2NhdHRlckxhYmVsXSA6IDA7XHJcblxyXG4gICAgLy9sb29wIG92ZXIgZGF0YSB0byBmaW5kIG1heCBhbmQgbWluXHJcbiAgICAvL2Fsc28gZGV0ZXJtaW5lcyB0aGUgeSBheGlzIHRvdGFsIGlmIHRoZSBkYXRhIGlzIHN0YWNrZWRcclxuICAgIGZvciAobGV0IGNoYXJ0RWxlIG9mIGNoYXJ0RGF0YSkge1xyXG4gICAgICAgIGlmIChjaGFydEVsZS5oYXNPd25Qcm9wZXJ0eShzY2F0dGVyTGFiZWwpKSB7XHJcbiAgICAgICAgICAgIGxldCBudW0gPSBjaGFydEVsZVtzY2F0dGVyTGFiZWxdO1xyXG4gICAgICAgICAgICBpZiAoIWlzTmFOKG51bSkpIHtcclxuICAgICAgICAgICAgICAgIG51bSA9IHBhcnNlRmxvYXQobnVtKTtcclxuICAgICAgICAgICAgICAgIGlmIChudW0gPiBtYXgpIHtcclxuICAgICAgICAgICAgICAgICAgICBtYXggPSBudW07XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG51bSA8IG1pbikge1xyXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IG51bTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChheGlzICE9PSAneicpIHtcclxuICAgICAgICBtaW4gKj0gMC45O1xyXG4gICAgICAgIG1heCAqPSAxLjE7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKF92YXJzLnlNaW4gJiYgIWlzTmFOKF92YXJzLnlNaW4pICYmIGF4aXMgPT09ICd5Jykge1xyXG4gICAgICAgIG1pbiA9IF92YXJzLnlNaW47XHJcbiAgICB9XHJcbiAgICBpZiAoX3ZhcnMueU1heCAmJiAhaXNOYU4oX3ZhcnMueU1heCkgJiYgYXhpcyA9PT0gJ3knKSB7XHJcbiAgICAgICAgbWF4ID0gX3ZhcnMueU1heDtcclxuICAgIH1cclxuICAgIGlmIChfdmFycy54TWluICYmICFpc05hTihfdmFycy54TWluKSAmJiBheGlzID09PSAneCcpIHtcclxuICAgICAgICBtaW4gPSBfdmFycy54TWluO1xyXG4gICAgfVxyXG4gICAgaWYgKF92YXJzLnhNYXggJiYgIWlzTmFOKF92YXJzLnhNYXgpICYmIGF4aXMgPT09ICd4Jykge1xyXG4gICAgICAgIG1heCA9IF92YXJzLnhNYXg7XHJcbiAgICB9XHJcblxyXG4gICAgYXhpc0RhdGEucHVzaChtaW4pO1xyXG4gICAgYXhpc0RhdGEucHVzaChtYXgpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICAnbGFiZWwnOiBzY2F0dGVyTGFiZWwsXHJcbiAgICAgICAgJ3ZhbHVlcyc6IGF4aXNEYXRhLFxyXG4gICAgICAgICdkYXRhVHlwZSc6ICdOVU1CRVInLFxyXG4gICAgICAgICdtaW4nOiBtaW4sXHJcbiAgICAgICAgJ21heCc6IG1heFxyXG4gICAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gcGFpbnQoKSB7XHJcbiAgICB2YXIgY2hhcnQgPSB0aGlzLFxyXG4gICAgICAgIGRhdGFPYmogPSB7fTtcclxuXHJcbiAgICBkYXRhT2JqLmNoYXJ0RGF0YSA9IGNoYXJ0LmRhdGEuY2hhcnREYXRhO1xyXG4gICAgZGF0YU9iai5sZWdlbmREYXRhID0gY2hhcnQuZGF0YS5sZWdlbmREYXRhO1xyXG4gICAgZGF0YU9iai5kYXRhVGFibGUgPSBjaGFydC5kYXRhLmRhdGFUYWJsZTtcclxuICAgIGNoYXJ0Ll92YXJzLmNvbG9yID0gY2hhcnQuZGF0YS5jb2xvcjtcclxuICAgIGRhdGFPYmoueEF4aXNEYXRhID0gY2hhcnQuZGF0YS54QXhpc0RhdGE7XHJcbiAgICBkYXRhT2JqLnlBeGlzRGF0YSA9IGNoYXJ0LmRhdGEueUF4aXNEYXRhO1xyXG4gICAgZGF0YU9iai56QXhpc0RhdGEgPSBjaGFydC5kYXRhLnpBeGlzRGF0YTtcclxuICAgIGNoYXJ0LmN1cnJlbnREYXRhID0gZGF0YU9iajtcclxuXHJcblxyXG4gICAgLy9nZW5lcmF0ZSBzdmcgZHluYW1pY2FsbHkgYmFzZWQgb24gbGVnZW5kIGRhdGFcclxuICAgIGNoYXJ0LmdlbmVyYXRlU1ZHKGRhdGFPYmoubGVnZW5kRGF0YSk7XHJcblxyXG4gICAgLy9UT0RPIHJlbW92ZSB0aGVzZSBmcm9tIGRyYXcgb2JqZWN0XHJcbiAgICBjaGFydC5nZW5lcmF0ZVhBeGlzKGNoYXJ0LmN1cnJlbnREYXRhLnhBeGlzRGF0YSk7XHJcbiAgICBjaGFydC5nZW5lcmF0ZVlBeGlzKGNoYXJ0LmN1cnJlbnREYXRhLnlBeGlzRGF0YSk7XHJcbiAgICBjaGFydC5nZW5lcmF0ZUxlZ2VuZChjaGFydC5jdXJyZW50RGF0YS5sZWdlbmREYXRhLCAnZ2VuZXJhdGVTY2F0dGVyJyk7XHJcblxyXG4gICAgY2hhcnQuZ2VuZXJhdGVTY2F0dGVyKCk7XHJcblxyXG4gICAgaWYgKGNoYXJ0Ll92YXJzLmxpbmVHdWlkZSkge1xyXG4gICAgICAgIGNoYXJ0LmNyZWF0ZUxpbmVHdWlkZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlb2YgZGF0YU9iai54QXhpc1NjYWxlLnRpY2tzID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgY2hhcnQuZm9ybWF0WEF4aXNMYWJlbHMoZGF0YU9iai54QXhpc1NjYWxlLnRpY2tzKCkubGVuZ3RoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY2hhcnQuZm9ybWF0WEF4aXNMYWJlbHMoZGF0YU9iai54QXhpc1NjYWxlLmRvbWFpbigpLmxlbmd0aCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNhbGN1bGF0ZU1lYW4oZGF0YSwgdHlwZSkge1xyXG4gICAgcmV0dXJuIGQzLm1lYW4oZGF0YSwgdmFsdWUgPT4gK3ZhbHVlW3R5cGVdKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlTGluZUd1aWRlKCkge1xyXG4gICAgdmFyIGNoYXJ0ID0gdGhpcyxcclxuICAgICAgICBzdmcgPSBjaGFydC5zdmcsXHJcbiAgICAgICAgY29udGFpbmVyID0gY2hhcnQuY29uZmlnLmNvbnRhaW5lcixcclxuICAgICAgICBjaGFydERhdGEgPSBjaGFydC5jdXJyZW50RGF0YS5jaGFydERhdGEsXHJcbiAgICAgICAgZGF0YVRhYmxlID0gY2hhcnQuY3VycmVudERhdGEuZGF0YVRhYmxlLFxyXG4gICAgICAgIHhBeGlzRGF0YSA9IGNoYXJ0LmN1cnJlbnREYXRhLnhBeGlzRGF0YSxcclxuICAgICAgICB5QXhpc0RhdGEgPSBjaGFydC5jdXJyZW50RGF0YS55QXhpc0RhdGEsXHJcbiAgICAgICAgeE1lYW4gPSBjYWxjdWxhdGVNZWFuKGNoYXJ0RGF0YSwgZGF0YVRhYmxlLngpLFxyXG4gICAgICAgIHlNZWFuID0gY2FsY3VsYXRlTWVhbihjaGFydERhdGEsIGRhdGFUYWJsZS55KSxcclxuICAgICAgICB4U2NhbGUgPSBqdkNoYXJ0cy5nZXRBeGlzU2NhbGUoJ3gnLCB4QXhpc0RhdGEsIGNvbnRhaW5lciwgY2hhcnQuX3ZhcnMpLFxyXG4gICAgICAgIHlTY2FsZSA9IGp2Q2hhcnRzLmdldEF4aXNTY2FsZSgneScsIHlBeGlzRGF0YSwgY29udGFpbmVyLCBjaGFydC5fdmFycyksXHJcbiAgICAgICAgbGluZUdyb3VwO1xyXG5cclxuICAgIHN2Zy5zZWxlY3RBbGwoJ2cubGluZWd1aWRlLngnKS5yZW1vdmUoKTtcclxuICAgIHN2Zy5zZWxlY3RBbGwoJ2cubGluZWd1aWRlLnknKS5yZW1vdmUoKTtcclxuXHJcbiAgICBsaW5lR3JvdXAgPSBzdmcuYXBwZW5kKCdnJylcclxuICAgICAgICAuYXR0cignY2xhc3MnLCAnbGluZS1ncm91cCBzY2F0dGVycGxvdC1jb250YWluZXInKTtcclxuXHJcbiAgICAvL2NyZWF0ZSBjcm9zc2hhaXIgYmFzZWQgb24gbWVkaWFuIHggKHVwL2Rvd24pXHJcbiAgICBsaW5lR3JvdXAuYXBwZW5kKCdnJylcclxuICAgICAgICAuYXR0cignY2xhc3MnLCAnbGluZWd1aWRlIHgnKVxyXG4gICAgICAgIC5hcHBlbmQoJ2xpbmUnKVxyXG4gICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgJ2dyYXknKVxyXG4gICAgICAgIC5zdHlsZSgnc3Ryb2tlLWRhc2hhcnJheScsICgnMywgMycpKVxyXG4gICAgICAgIC5zdHlsZSgnZmlsbCcsICdibGFjaycpXHJcbiAgICAgICAgLmF0dHIoJ3gxJywgeFNjYWxlKHhNZWFuKSlcclxuICAgICAgICAuYXR0cigneTEnLCAwKVxyXG4gICAgICAgIC5hdHRyKCd4MicsIHhTY2FsZSh4TWVhbikpXHJcbiAgICAgICAgLmF0dHIoJ3kyJywgY29udGFpbmVyLmhlaWdodCk7XHJcblxyXG4gICAgLy9jcmVhdGUgY3Jvc3NoYWlyIGJhc2VkIG9uIG1lZGlhbiB5IChsZWZ0L3JpZ2h0KVxyXG4gICAgbGluZUdyb3VwLmFwcGVuZCgnZycpXHJcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2xpbmVndWlkZSB5JylcclxuICAgICAgICAuYXBwZW5kKCdsaW5lJylcclxuICAgICAgICAuc3R5bGUoJ3N0cm9rZScsICdncmF5JylcclxuICAgICAgICAuc3R5bGUoJ3N0cm9rZS1kYXNoYXJyYXknLCAoJzMsIDMnKSlcclxuICAgICAgICAuc3R5bGUoJ2ZpbGwnLCAnYmxhY2snKVxyXG4gICAgICAgIC5hdHRyKCd4MScsIDApXHJcbiAgICAgICAgLmF0dHIoJ3kxJywgeVNjYWxlKHlNZWFuKSlcclxuICAgICAgICAuYXR0cigneDInLCBjb250YWluZXIud2lkdGgpXHJcbiAgICAgICAgLmF0dHIoJ3kyJywgeVNjYWxlKHlNZWFuKSk7XHJcbn1cclxuXHJcbi8qKmdlbmVyYXRlU2NhdHRlclxyXG4gKlxyXG4gKiBjcmVhdGVzIGFuZCBkcmF3cyBhIHNjYXR0ZXIgcGxvdCBvbiB0aGUgc3ZnIGVsZW1lbnRcclxuICogQHBhcmFtcyBzdmcsIHNjYXR0ZXJEYXRhLCBfdmFycywgeEF4aXNEYXRhLCB5QXhpc0RhdGEsIHpBeGlzRGF0YSwgY29udGFpbmVyLCBkYXRhVGFibGUgbGVnZW5kRGF0YVxyXG4gKiBAcmV0dXJucyB7e319XHJcbiAqL1xyXG5mdW5jdGlvbiBnZW5lcmF0ZVNjYXR0ZXIoKSB7XHJcbiAgICB2YXIgY2hhcnQgPSB0aGlzLFxyXG4gICAgICAgIHN2ZyA9IGNoYXJ0LnN2ZyxcclxuICAgICAgICBjb250YWluZXIgPSBjaGFydC5jb25maWcuY29udGFpbmVyLFxyXG4gICAgICAgIHNjYXR0ZXJEYXRhID0gY2hhcnQuY3VycmVudERhdGEuY2hhcnREYXRhLFxyXG4gICAgICAgIGRhdGFUYWJsZSA9IGNoYXJ0LmN1cnJlbnREYXRhLmRhdGFUYWJsZSxcclxuICAgICAgICB4QXhpc0RhdGEgPSBjaGFydC5jdXJyZW50RGF0YS54QXhpc0RhdGEsXHJcbiAgICAgICAgeUF4aXNEYXRhID0gY2hhcnQuY3VycmVudERhdGEueUF4aXNEYXRhLFxyXG4gICAgICAgIHpBeGlzRGF0YSA9IGNoYXJ0LmN1cnJlbnREYXRhLnpBeGlzRGF0YSxcclxuICAgICAgICBsZWdlbmREYXRhID0gY2hhcnQuY3VycmVudERhdGEubGVnZW5kRGF0YSxcclxuICAgICAgICBjb2xvcnMgPSBjaGFydC5fdmFycy5jb2xvcixcclxuICAgICAgICBsZWdlbmRFbGVtZW50VG9nZ2xlQXJyYXksXHJcbiAgICAgICAgc2NhdHRlckRhdGFGaWx0ZXJlZCA9IFtdLFxyXG4gICAgICAgIHgsXHJcbiAgICAgICAgeSxcclxuICAgICAgICB6O1xyXG5cclxuICAgIGlmICghY2hhcnQuX3ZhcnMuTk9ERV9NSU5fU0laRSkge1xyXG4gICAgICAgIGNoYXJ0Ll92YXJzLk5PREVfTUlOX1NJWkUgPSA0LjU7XHJcbiAgICB9XHJcbiAgICBpZiAoIWNoYXJ0Ll92YXJzLk5PREVfTUFYX1NJWkUpIHtcclxuICAgICAgICBjaGFydC5fdmFycy5OT0RFX01BWF9TSVpFID0gMjU7XHJcbiAgICB9XHJcblxyXG4gICAgLy9zZXQgY2xpcCBwYXRoIHJlY3RhbmdsZVxyXG4gICAgc3ZnLmFwcGVuZCgnY2xpcFBhdGgnKVxyXG4gICAgICAgIC5hdHRyKCdpZCcsICdzY2F0dGVyLWFyZWEnKVxyXG4gICAgICAgIC5hcHBlbmQoJ3JlY3QnKVxyXG4gICAgICAgIC5hdHRyKCd4JywgMSlcclxuICAgICAgICAuYXR0cignd2lkdGgnLCBjb250YWluZXIud2lkdGggLSAxKVxyXG4gICAgICAgIC5hdHRyKCdoZWlnaHQnLCBjb250YWluZXIuaGVpZ2h0KVxyXG4gICAgICAgIC5hdHRyKCdmaWxsJywgY2hhcnQuX3ZhcnMuYmFja2dyb3VuZENvbG9yKTtcclxuXHJcbiAgICBzdmcuc2VsZWN0QWxsKCdnLnNjYXR0ZXJwbG90LWNvbnRhaW5lcicpLnJlbW92ZSgpO1xyXG4gICAgc3ZnLnNlbGVjdEFsbCgnZy5zY2F0dGVycGxvdC1jb250YWluZXIuZWRpdGFibGUtc2NhdHRlcicpLnJlbW92ZSgpO1xyXG5cclxuICAgIGlmICghY2hhcnQuX3ZhcnMubGVnZW5kSGVhZGVycykge1xyXG4gICAgICAgIGNoYXJ0Ll92YXJzLmxlZ2VuZEhlYWRlcnMgPSBsZWdlbmREYXRhO1xyXG4gICAgfVxyXG5cclxuICAgIGxlZ2VuZEVsZW1lbnRUb2dnbGVBcnJheSA9IGp2Q2hhcnRzLmdldExlZ2VuZEVsZW1lbnRUb2dnbGVBcnJheShjaGFydC5fdmFycy5sZWdlbmRIZWFkZXJzLCBsZWdlbmREYXRhKTtcclxuXHJcbiAgICBpZiAobGVnZW5kRWxlbWVudFRvZ2dsZUFycmF5KSB7XHJcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzY2F0dGVyRGF0YS5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBsZWdlbmRFbGUgb2YgbGVnZW5kRWxlbWVudFRvZ2dsZUFycmF5KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNjYXR0ZXJEYXRhW2pdW2RhdGFUYWJsZS5sYWJlbF0gPT09ICd1bmRlZmluZWQnIHx8IHNjYXR0ZXJEYXRhW2pdW2RhdGFUYWJsZS5sYWJlbF0gPT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlZ2VuZEVsZS50b2dnbGUgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjYXR0ZXJEYXRhRmlsdGVyZWQucHVzaChzY2F0dGVyRGF0YVtqXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsZWdlbmRFbGUuZWxlbWVudCAhPT0gc2NhdHRlckRhdGFbal1bZGF0YVRhYmxlLnNlcmllc10gfHwgbGVnZW5kRWxlLnRvZ2dsZSAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBzY2F0dGVyRGF0YUZpbHRlcmVkLnB1c2goc2NhdHRlckRhdGFbal0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHggPSBqdkNoYXJ0cy5nZXRBeGlzU2NhbGUoJ3gnLCB4QXhpc0RhdGEsIGNvbnRhaW5lciwgY2hhcnQuX3ZhcnMpO1xyXG4gICAgeSA9IGp2Q2hhcnRzLmdldEF4aXNTY2FsZSgneScsIHlBeGlzRGF0YSwgY29udGFpbmVyLCBjaGFydC5fdmFycyk7XHJcbiAgICB6O1xyXG5cclxuICAgIGlmICh6QXhpc0RhdGEgJiYgdHlwZW9mIHpBeGlzRGF0YSA9PT0gJ29iamVjdCcgJiYgT2JqZWN0LmtleXMoekF4aXNEYXRhKS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgeiA9IGp2Q2hhcnRzLmdldFpTY2FsZSh6QXhpc0RhdGEsIGNvbnRhaW5lciwgY2hhcnQuX3ZhcnMpO1xyXG4gICAgfVxyXG5cclxuICAgIHN2Zy5hcHBlbmQoJ2cnKVxyXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICdzY2F0dGVycGxvdC1jaXJjbGVzJylcclxuICAgICAgICAuc2VsZWN0QWxsKCdnJylcclxuICAgICAgICAuZGF0YShzY2F0dGVyRGF0YSlcclxuICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgIC5hcHBlbmQoJ2NpcmNsZScpXHJcbiAgICAgICAgLmF0dHIoJ2NsaXAtcGF0aCcsICd1cmwoI3NjYXR0ZXItYXJlYSknKVxyXG4gICAgICAgIC5hdHRyKCdjbGFzcycsIGZ1bmN0aW9uIChkLCBpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnZWRpdGFibGUgZWRpdGFibGUtc2NhdHRlciBzY2F0dGVyLWNpcmNsZS0nICsgY2hhcnQuY3VycmVudERhdGEuY2hhcnREYXRhW2ldW2NoYXJ0LmN1cnJlbnREYXRhLmRhdGFUYWJsZS5sYWJlbF0ucmVwbGFjZSgvXFxzL2csICdfJykucmVwbGFjZSgvXFwuL2csICdfZG90XycpICsgJyBoaWdobGlnaHQtY2xhc3MtJyArIGNoYXJ0LmN1cnJlbnREYXRhLmNoYXJ0RGF0YVtpXVtjaGFydC5jdXJyZW50RGF0YS5kYXRhVGFibGUubGFiZWxdLnJlcGxhY2UoL1xccy9nLCAnXycpLnJlcGxhY2UoL1xcLi9nLCAnX2RvdF8nKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5hdHRyKCdjeCcsIChkLCBpKSA9PiB4KHNjYXR0ZXJEYXRhW2ldW3hBeGlzRGF0YS5sYWJlbF0pKVxyXG4gICAgICAgIC5hdHRyKCdjeScsIChkLCBpKSA9PiB5KHNjYXR0ZXJEYXRhW2ldW3lBeGlzRGF0YS5sYWJlbF0pKVxyXG4gICAgICAgIC5hdHRyKCdvcGFjaXR5JywgMC44KVxyXG4gICAgICAgIC5hdHRyKCdyJywgKGQsIGkpID0+IHtcclxuICAgICAgICAgICAgaWYgKGRhdGFUYWJsZS5oYXNPd25Qcm9wZXJ0eSgneicpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hhcnQuX3ZhcnMudG9nZ2xlWiAmJiB6QXhpc0RhdGEgJiYgdHlwZW9mIHpBeGlzRGF0YSA9PT0gJ29iamVjdCcgJiYgT2JqZWN0LmtleXMoekF4aXNEYXRhKS5sZW5ndGggPiAwICYmIHNjYXR0ZXJEYXRhW2ldW2RhdGFUYWJsZS56XSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB6KHNjYXR0ZXJEYXRhW2ldW2RhdGFUYWJsZS56XSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNoYXJ0Ll92YXJzLk5PREVfTUlOX1NJWkU7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uIChkLCBpLCBqKSB7XHJcbiAgICAgICAgICAgIGlmIChjaGFydC5zaG93VG9vbFRpcCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2NsaXAtcGF0aCcsICcnKTtcclxuICAgICAgICAgICAgICAgIHZhciB0aXBEYXRhID0gY2hhcnQuc2V0VGlwRGF0YShkLCBpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL0RyYXcgdGlwIGxpbmVcclxuICAgICAgICAgICAgICAgIGNoYXJ0LnRpcC5nZW5lcmF0ZVNpbXBsZVRpcCh0aXBEYXRhLCBjaGFydC5kYXRhLmRhdGFUYWJsZSk7XHJcbiAgICAgICAgICAgICAgICBjaGFydC50aXAuZCA9IGQ7XHJcbiAgICAgICAgICAgICAgICBjaGFydC50aXAuaSA9IGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICAgIC5vbignbW91c2Vtb3ZlJywgZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgaWYgKGNoYXJ0LnNob3dUb29sVGlwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hhcnQudGlwLmQgPT09IGQgJiYgY2hhcnQudGlwLmkgPT09IGkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGFydC50aXAuc2hvd1RpcChkMy5ldmVudCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vR2V0IHRpcCBkYXRhXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpcERhdGEgPSBjaGFydC5zZXRUaXBEYXRhKGQsIGkpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vRHJhdyB0aXAgbGluZVxyXG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0LnRpcC5nZW5lcmF0ZVNpbXBsZVRpcCh0aXBEYXRhLCBjaGFydC5kYXRhLmRhdGFUYWJsZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChjaGFydC5zaG93VG9vbFRpcCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2NsaXAtcGF0aCcsICd1cmwoI3NjYXR0ZXItYXJlYSknKTtcclxuICAgICAgICAgICAgICAgIGNoYXJ0LnRpcC5oaWRlVGlwKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICAgIC5hdHRyKCdmaWxsJywgKGQsIGkpID0+IGp2Q2hhcnRzLmdldENvbG9ycyhjb2xvcnMsIGksIHNjYXR0ZXJEYXRhW2ldW2RhdGFUYWJsZS5zZXJpZXNdKSk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ganZDaGFydHM7XHJcbiIsIid1c2Ugc3RyaWN0JztcclxudmFyIGp2Q2hhcnRzID0gcmVxdWlyZSgnLi4vanZDaGFydHMuanMnKTtcclxuXHJcbmp2Q2hhcnRzLnByb3RvdHlwZS5zaW5nbGVheGlzID0ge1xyXG4gICAgcGFpbnQ6IHBhaW50LFxyXG4gICAgc2V0RGF0YTogc2V0RGF0YSxcclxuICAgIGdldEV2ZW50RGF0YTogZ2V0RXZlbnREYXRhLFxyXG4gICAgaGlnaGxpZ2h0RnJvbUV2ZW50RGF0YTogaGlnaGxpZ2h0RnJvbUV2ZW50RGF0YVxyXG59O1xyXG5cclxuanZDaGFydHMucHJvdG90eXBlLmdldFNpbmdsZUF4aXNEYXRhID0gZ2V0U2luZ2xlQXhpc0RhdGE7XHJcbmp2Q2hhcnRzLnByb3RvdHlwZS5nZXRTaW5nbGVBeGlzWiA9IGdldFNpbmdsZUF4aXNaO1xyXG5qdkNoYXJ0cy5wcm90b3R5cGUuZ2VuZXJhdGVQb2ludHMgPSBnZW5lcmF0ZVBvaW50cztcclxuXHJcbmZ1bmN0aW9uIGlzRW1wdHkodmFsdWUpIHtcclxuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnIHx8IHZhbHVlID09PSBudWxsO1xyXG59XHJcblxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIFNpbmdsZSBBeGlzIENsdXN0ZXIgZnVuY3Rpb25zICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcbmZ1bmN0aW9uIHNldERhdGEoKSB7XHJcbiAgICB2YXIgY2hhcnQgPSB0aGlzO1xyXG4gICAgY2hhcnQuY3VycmVudERhdGEgPSB7IGNoYXJ0RGF0YTogY2hhcnQuZGF0YS5jaGFydERhdGEsIGRhdGFUYWJsZTogY2hhcnQuZGF0YS5kYXRhVGFibGUgfTtcclxuXHJcbiAgICAvL1NldCB0aGUgbGVnZW5kIERhdGEgdG8gdGhlIGxhYmVsIGZyb20gZGF0YVRhYmxlIEtleXNcclxuICAgIGNoYXJ0LmN1cnJlbnREYXRhLmxlZ2VuZERhdGEgPSBbY2hhcnQuY3VycmVudERhdGEuZGF0YVRhYmxlLnhdO1xyXG4gICAgY2hhcnQuY3VycmVudERhdGEueEF4aXNEYXRhID0gY2hhcnQuZ2V0U2luZ2xlQXhpc0RhdGEoY2hhcnQuY3VycmVudERhdGEuY2hhcnREYXRhLCBjaGFydC5jdXJyZW50RGF0YS5kYXRhVGFibGUpO1xyXG5cclxuICAgIGlmIChjaGFydC5jdXJyZW50RGF0YS5kYXRhVGFibGUuaGFzT3duUHJvcGVydHkoJ3NpemUnKSkge1xyXG4gICAgICAgIGNoYXJ0LmN1cnJlbnREYXRhLnpBeGlzRGF0YSA9IGNoYXJ0LmdldFNpbmdsZUF4aXNaKGNoYXJ0LmN1cnJlbnREYXRhLmNoYXJ0RGF0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgY2hhcnQuY3VycmVudERhdGEuY29sb3IgPSAncmVkJzsvL2NoYXJ0LnNldENoYXJ0Q29sb3JzIChjaGFydC5fdmFycy5jb2xvciwgY2hhcnQuZGF0YS5sZWdlbmREYXRhLCBjb2xvcnMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRFdmVudERhdGEoZXZlbnQpIHtcclxuICAgIHZhciBjaGFydCA9IHRoaXM7XHJcbiAgICBpZiAoZXZlbnQudGFyZ2V0LmNsYXNzTGlzdC52YWx1ZS5zcGxpdCgnY2VsbC0nKVsxXSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgICAgIFtjaGFydC5jdXJyZW50RGF0YS5kYXRhVGFibGUubGFiZWxdOiBbZXZlbnQudGFyZ2V0LmNsYXNzTGlzdC52YWx1ZS5zcGxpdCgnY2VsbC0nKVsxXS5yZXBsYWNlKC9fL2csICcgJykucmVwbGFjZSgvX2NvbG9uXy9nLCAnOicpLnJlcGxhY2UoL19kb3RfL2csICcuJyldXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG5vZGU6IGV2ZW50LnRhcmdldFxyXG4gICAgICAgIH07XHJcbiAgICB9IGVsc2UgaWYgKGV2ZW50LnRhcmdldC5jbGFzc0xpc3QudmFsdWUuaW5kZXhPZignZWRpdGFibGUtc3ZnJykgPiAtMSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGRhdGE6IHt9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZGF0YTogZmFsc2VcclxuICAgIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhpZ2hsaWdodEZyb21FdmVudERhdGEoZXZlbnQpIHtcclxuICAgIGxldCBjaGFydCA9IHRoaXMsXHJcbiAgICAgICAgbGFiZWwgPSBldmVudC5kYXRhW2NoYXJ0LmN1cnJlbnREYXRhLmRhdGFUYWJsZS5sYWJlbF1bMF0sXHJcbiAgICAgICAgY3NzQ2xhc3MgPSAnLmhpZ2hsaWdodC1jbGFzcy0nICsgbGFiZWwucmVwbGFjZSgvXFxzL2csICdfJykucmVwbGFjZSgvXFwuL2csICdfZG90XycpLFxyXG4gICAgICAgIG5vZGUgPSBjaGFydC5zdmcuc2VsZWN0QWxsKGNzc0NsYXNzKTtcclxuXHJcbiAgICBjaGFydC5zdmcuc2VsZWN0KCcuc2luZ2xlYXhpcy1jb250YWluZXInKS5zZWxlY3RBbGwoJ2NpcmNsZScpXHJcbiAgICAgICAgLmF0dHIoJ3N0cm9rZScsIDApXHJcbiAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIDApO1xyXG4gICAgLy9oaWdobGlnaHQgbmVjZXNzYXJ5IGNpcmNsZXNcclxuICAgIG5vZGVcclxuICAgICAgICAuYXR0cignc3Ryb2tlJywgY2hhcnQuX3ZhcnMuaGlnaGxpZ2h0Qm9yZGVyQ29sb3IpXHJcbiAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIGNoYXJ0Ll92YXJzLmhpZ2hsaWdodEJvcmRlcldpZHRoKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcGFpbnQoKSB7XHJcbiAgICB2YXIgY2hhcnQgPSB0aGlzLFxyXG4gICAgICAgIHNwbGl0RGF0YSA9IHt9LCAvL0lmIHRoZXJlIGlzIGEgc3BsaXQsIHRoZSBkYXRhIHRoYXQgaGFzIGJlZW4gc3BsaXRcclxuICAgICAgICBudW1WaXp6ZXMsIC8vSWYgdGhlcmUgaXMgYSBzcGxpdCwgdGhlIG51bWJlciBvZiBzaW5nbGUgYXhpcyBjbHVzdGVycyB0aGF0IGFyZSBjcmVhdGVkXHJcbiAgICAgICAgY3VzdG9tU2l6ZSA9IHt9LCAvL0lmIHRoZXJlIGlzIGEgc3BsaXQsIHRoZSBzdmcgbmVlZHMgdG8gYmUgYSBjdXN0b20gcHJlZGVmaW5lZCBoZWlnaHRcclxuICAgICAgICBtYXJnaW4gPSB7XHJcbiAgICAgICAgICAgIHRvcDogNTAsXHJcbiAgICAgICAgICAgIGxlZnQ6IDEwMCxcclxuICAgICAgICAgICAgcmlnaHQ6IDEwMCxcclxuICAgICAgICAgICAgYm90dG9tOiA1MFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgLy9JZiB0aGVyZSBpcyBhIHNwbGl0IG9uIHRoZSB2aXosIHJ1biB0aHJvdWdoIHRoaXMgbG9naWNcclxuICAgIGlmIChjaGFydC5kYXRhLmRhdGFUYWJsZS5mYWNldCkge1xyXG4gICAgICAgIGxldCBzcGxpdERhdGFLZXlzID0gW10sXHJcbiAgICAgICAgICAgIHNwbGl0T3B0aW9uTmFtZSA9IGNoYXJ0LmRhdGEuZGF0YVRhYmxlLmZhY2V0LnJlcGxhY2UoL18vZywgJyAnKTtcclxuXHJcbiAgICAgICAgLy9DaGVjayB0byBzZWUgaG93IG1hbnkgdml6emVzIG5lZWQgdG8gYmUgY3JlYXRlZCBiZWNhdXNlIG9mIHRoZSBzcGxpdFxyXG4gICAgICAgIGZvciAobGV0IGVsZSBvZiBjaGFydC5jdXJyZW50RGF0YS5jaGFydERhdGEpIHtcclxuICAgICAgICAgICAgbGV0IGFkZFRvS2V5cyA9IHRydWU7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBvZiBzcGxpdERhdGFLZXlzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZWxlW3NwbGl0T3B0aW9uTmFtZV0gPT09IGtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZFRvS2V5cyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChhZGRUb0tleXMpIHtcclxuICAgICAgICAgICAgICAgIHNwbGl0RGF0YUtleXMucHVzaChlbGVbc3BsaXRPcHRpb25OYW1lXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vQ3JlYXRlIE9iamVjdCB3aXRoIGtleXMgYW5kIGFzc2lnbiBlYWNoIGVsZW1lbnQgb2YgdGhlIGRhdGEgYXJyYXkgdG8gY29ycmVzcG9uZGluZyBvYmplY3RcclxuICAgICAgICBmb3IgKGxldCBrZXkgb2Ygc3BsaXREYXRhS2V5cykge1xyXG4gICAgICAgICAgICBzcGxpdERhdGFba2V5XSA9IFtdOy8vQXNzaWduIGVtcHR5IGFycmF5IHRvIGVhY2ggbG9jYXRpb25cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vQXNzaWduIERhdGEgZWxlbWVudHMgdG8gYXBwcm9wcmlhdGUgcGxhY2UgaW4gc3BsaXREYXRhIG9iamVjdFxyXG4gICAgICAgIGZvciAobGV0IGVsZSBvZiBjaGFydC5jdXJyZW50RGF0YS5jaGFydERhdGEpIHtcclxuICAgICAgICAgICAgc3BsaXREYXRhW2VsZVtzcGxpdE9wdGlvbk5hbWVdXS5wdXNoKGVsZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBudW1WaXp6ZXMgPSBzcGxpdERhdGFLZXlzLmxlbmd0aDtcclxuICAgICAgICBjdXN0b21TaXplLmhlaWdodCA9IChudW1WaXp6ZXMpICogMzAwO1xyXG5cclxuICAgICAgICBjaGFydC5nZW5lcmF0ZVNWRyhjaGFydC5jdXJyZW50RGF0YS5sZWdlbmREYXRhLCBtYXJnaW4sIGN1c3RvbVNpemUpO1xyXG4gICAgICAgIGNoYXJ0LmdlbmVyYXRlWEF4aXMoY2hhcnQuY3VycmVudERhdGEueEF4aXNEYXRhKTtcclxuICAgICAgICBjaGFydC5kcmF3R3JpZGxpbmVzKGNoYXJ0LmN1cnJlbnREYXRhLnhBeGlzRGF0YSk7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtVml6emVzOyBpKyspIHtcclxuICAgICAgICAgICAgY2hhcnQuZ2VuZXJhdGVQb2ludHMoc3BsaXREYXRhW3NwbGl0RGF0YUtleXNbaV1dLCBpKTtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2UgeyAvL1doZW4gdGhlcmUgaXNuJ3QgYSBzcGxpdCwgdGhlIGJhc2UgY2FzZVxyXG4gICAgICAgIGNoYXJ0LmdlbmVyYXRlU1ZHKGNoYXJ0LmN1cnJlbnREYXRhLmxlZ2VuZERhdGEsIG1hcmdpbiwgY3VzdG9tU2l6ZSk7XHJcbiAgICAgICAgY2hhcnQuZ2VuZXJhdGVYQXhpcyhjaGFydC5jdXJyZW50RGF0YS54QXhpc0RhdGEpO1xyXG4gICAgICAgIGNoYXJ0LmRyYXdHcmlkbGluZXMoY2hhcnQuY3VycmVudERhdGEueEF4aXNEYXRhKTtcclxuICAgICAgICBjaGFydC5nZW5lcmF0ZVBvaW50cyhjaGFydC5jdXJyZW50RGF0YS5jaGFydERhdGEpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlb2YgY2hhcnQuY3VycmVudERhdGEueEF4aXNTY2FsZS50aWNrcyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIGNoYXJ0LmZvcm1hdFhBeGlzTGFiZWxzKGNoYXJ0LmN1cnJlbnREYXRhLnhBeGlzU2NhbGUudGlja3MoKS5sZW5ndGgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBjaGFydC5mb3JtYXRYQXhpc0xhYmVscyhjaGFydC5jdXJyZW50RGF0YS54QXhpc1NjYWxlLmRvbWFpbigpLmxlbmd0aCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFNpbmdsZUF4aXNaKGRhdGEpIHtcclxuICAgIHZhciBjaGFydCA9IHRoaXMsXHJcbiAgICAgICAgc2l6ZSA9IGNoYXJ0LmN1cnJlbnREYXRhLmRhdGFUYWJsZS5zaXplLFxyXG4gICAgICAgIG1pbiA9IGRhdGFbMF1bc2l6ZV0sXHJcbiAgICAgICAgbWF4ID0gZGF0YVswXVtzaXplXTtcclxuICAgIC8vRmluZCBtaW4gYW5kIG1heCBvZiB0aGUgZGF0YVxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbGV0IG51bSA9IGRhdGFbaV1bc2l6ZV07XHJcbiAgICAgICAgaWYgKG51bSA+IG1heCkge1xyXG4gICAgICAgICAgICBtYXggPSBudW07XHJcbiAgICAgICAgfSBlbHNlIGlmIChudW0gPCBtaW4pIHtcclxuICAgICAgICAgICAgbWluID0gbnVtO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgICdtaW4nOiBtaW4sXHJcbiAgICAgICAgJ21heCc6IG1heCxcclxuICAgICAgICAnbGFiZWwnOiBzaXplXHJcbiAgICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZW5lcmF0ZVBvaW50cyhkYXRhLCB5TGV2ZWwpIHtcclxuICAgIHZhciBjaGFydCA9IHRoaXMsXHJcbiAgICAgICAgc3ZnID0gY2hhcnQuc3ZnLFxyXG4gICAgICAgIHdpZHRoID0gY2hhcnQuY29uZmlnLmNvbnRhaW5lci53aWR0aCxcclxuICAgICAgICBoZWlnaHQgPSBjaGFydC5jb25maWcuY29udGFpbmVyLmhlaWdodCxcclxuICAgICAgICBkYXRhVGFibGUgPSBjaGFydC5jdXJyZW50RGF0YS5kYXRhVGFibGUsXHJcbiAgICAgICAgeEF4aXNEYXRhID0gY2hhcnQuY3VycmVudERhdGEueEF4aXNEYXRhLFxyXG4gICAgICAgIHpBeGlzRGF0YSA9IGNoYXJ0LmN1cnJlbnREYXRhLnpBeGlzRGF0YSxcclxuICAgICAgICBjb250YWluZXIgPSBjaGFydC5jb25maWcuY29udGFpbmVyLFxyXG4gICAgICAgIHBvaW50Q29sb3IgPSAnIzYwOWNkYicsXHJcbiAgICAgICAgY29sb3JlZFBvaW50ID0gJyNlODhhMTcnLFxyXG4gICAgICAgIHggPSBqdkNoYXJ0cy5nZXRBeGlzU2NhbGUoJ3gnLCB4QXhpc0RhdGEsIGNoYXJ0LmNvbmZpZy5jb250YWluZXIsIGNoYXJ0Ll92YXJzKSxcclxuICAgICAgICBjdXJyZW50QXhpc0hlaWdodCxcclxuICAgICAgICBzaW11bGF0aW9uLFxyXG4gICAgICAgIGNlbGw7XHJcblxyXG4gICAgY29uc3QgU1BMSVRfQ0xVU1RFUl9IRUlHSFQgPSAzMDAsXHJcbiAgICAgICAgVFJBTlNMQVRFX1NQTElUX0NMVVNURVIgPSAxNTA7XHJcblxyXG4gICAgLy9JZiB0aGVyZSdzIGEgc3BsaXQsIGFjY291bnQgZm9yIHRoZSBtdWx0aXBsZSBheGVzXHJcbiAgICBpZiAoIWlzRW1wdHkoeUxldmVsKSkge1xyXG4gICAgICAgIGN1cnJlbnRBeGlzSGVpZ2h0ID0gKHlMZXZlbCAqIFNQTElUX0NMVVNURVJfSEVJR0hUKSArIFRSQU5TTEFURV9TUExJVF9DTFVTVEVSOy8vRWFjaCBoZWlnaHQgaXMgMTAwcHhcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY3VycmVudEF4aXNIZWlnaHQgPSBoZWlnaHQgLyAyO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghY2hhcnQuX3ZhcnMuTk9ERV9NSU5fU0laRSkge1xyXG4gICAgICAgIGNoYXJ0Ll92YXJzLk5PREVfTUlOX1NJWkUgPSA0LjU7XHJcbiAgICB9XHJcbiAgICBpZiAoIWNoYXJ0Ll92YXJzLk5PREVfTUFYX1NJWkUpIHtcclxuICAgICAgICBjaGFydC5fdmFycy5OT0RFX01BWF9TSVpFID0gMjU7XHJcbiAgICB9XHJcblxyXG4gICAgY2hhcnQuY2hhcnREaXYuc2VsZWN0KCcuY29udGFpbmVyJykuYXR0cignY2xhc3MnLCAnc2luZ2xlYXhpcy1jb250YWluZXInKTtcclxuXHJcbiAgICAvL0FkZCBhIHBhdGggbGluZSB0aHJvdWdoIHRoZSBoZWlnaHQgb2YgdGhlIGF4aXNcclxuICAgIGlmICghaXNFbXB0eSh5TGV2ZWwpKSB7XHJcbiAgICAgICAgc3ZnLmFwcGVuZCgnbGluZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCd4MScsIDApXHJcbiAgICAgICAgICAgIC5hdHRyKCd4MicsIGNvbnRhaW5lci53aWR0aClcclxuICAgICAgICAgICAgLmF0dHIoJ3kxJywgY3VycmVudEF4aXNIZWlnaHQpXHJcbiAgICAgICAgICAgIC5hdHRyKCd5MicsIGN1cnJlbnRBeGlzSGVpZ2h0KVxyXG4gICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgJ3doaXRlJylcclxuICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsICcyMHB4JylcclxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwgJyArIFRSQU5TTEFURV9TUExJVF9DTFVTVEVSICsgJyknKTtcclxuXHJcbiAgICAgICAgc3ZnLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgICAgIC5kYXR1bShkYXRhKVxyXG4gICAgICAgICAgICAuYXR0cigneCcsIDApXHJcbiAgICAgICAgICAgIC5hdHRyKCd5JywgY3VycmVudEF4aXNIZWlnaHQpXHJcbiAgICAgICAgICAgIC50ZXh0KChkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hhcnQuZGF0YS5kYXRhVGFibGUuZmFjZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICBkWzBdW2NoYXJ0LmRhdGEuZGF0YVRhYmxlLmZhY2V0LnJlcGxhY2UoL18vZywgJyAnKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKC04NSwgMCknKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgc2ltdWxhdGlvbiA9IGQzLmZvcmNlU2ltdWxhdGlvbihkYXRhKVxyXG4gICAgICAgIC5hbHBoYURlY2F5KDAuMDUpXHJcbiAgICAgICAgLmZvcmNlKCd4JywgZDMuZm9yY2VYKGQgPT4geChkW2RhdGFUYWJsZS54XSkpXHJcbiAgICAgICAgICAgIC5zdHJlbmd0aCgxKSlcclxuICAgICAgICAuZm9yY2UoJ3knLCBkMy5mb3JjZVkoY3VycmVudEF4aXNIZWlnaHQpKVxyXG4gICAgICAgIC5mb3JjZSgnY29sbGlkZScsIGQzLmZvcmNlQ29sbGlkZShkID0+IHtcclxuICAgICAgICAgICAgbGV0IG5vcm0sXHJcbiAgICAgICAgICAgICAgICB2YWwgPSBjaGFydC5fdmFycy5OT0RFX01JTl9TSVpFO1xyXG4gICAgICAgICAgICAvL1NldCBjb2xsaXNpb24gcmFkaXVzIGVxdWFsIHRvIHRoZSByYWRpdXMgb2YgdGhlIGNpcmNsZVxyXG4gICAgICAgICAgICBpZiAoZGF0YVRhYmxlLmhhc093blByb3BlcnR5KCdzaXplJykpIHtcclxuICAgICAgICAgICAgICAgIG5vcm0gPSAoZFtkYXRhVGFibGUuc2l6ZV0gLSB6QXhpc0RhdGEubWluKSAvICh6QXhpc0RhdGEubWF4IC0gekF4aXNEYXRhLm1pbik7XHJcbiAgICAgICAgICAgICAgICB2YWwgPSAoY2hhcnQuX3ZhcnMuTk9ERV9NQVhfU0laRSAtIGNoYXJ0Ll92YXJzLk5PREVfTUlOX1NJWkUpICogbm9ybSArIGNoYXJ0Ll92YXJzLk5PREVfTUlOX1NJWkU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHZhbDtcclxuICAgICAgICB9KS5zdHJlbmd0aCgxKSlcclxuICAgICAgICAuZm9yY2UoJ2NoYXJnZScsIGQzLmZvcmNlTWFueUJvZHkoKS5zdHJlbmd0aCgtNikpXHJcbiAgICAgICAgLnN0b3AoKTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEyMDsgKytpKSBzaW11bGF0aW9uLnRpY2soKTtcclxuXHJcbiAgICBjZWxsID0gc3ZnLmFwcGVuZCgnZycpXHJcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2NlbGxzJylcclxuICAgICAgICAuc2VsZWN0QWxsKCdnJylcclxuICAgICAgICAuZGF0YShkMy52b3Jvbm9pKClcclxuICAgICAgICAgICAgLmV4dGVudChbWzAsIDBdLCBbd2lkdGgsIGhlaWdodF1dKVxyXG4gICAgICAgICAgICAueChkID0+IGQueClcclxuICAgICAgICAgICAgLnkoZCA9PiBkLnkpXHJcbiAgICAgICAgICAgIC5wb2x5Z29ucyhkYXRhKVxyXG4gICAgICAgIClcclxuICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgIC5hcHBlbmQoJ2cnKTtcclxuXHJcbiAgICBjZWxsXHJcbiAgICAgICAgLmFwcGVuZCgnY2lyY2xlJylcclxuICAgICAgICAuYXR0cignY2xhc3MnLCBkID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuICdjZWxsLScgKyBkLmRhdGFbY2hhcnQuY3VycmVudERhdGEuZGF0YVRhYmxlLmxhYmVsXS5yZXBsYWNlKC9cXHMvZywgJ18nKS5yZXBsYWNlKC9cXC4vZywgJ19kb3RfJykgKyAnIGhpZ2hsaWdodC1jbGFzcy0nICsgZC5kYXRhW2NoYXJ0LmN1cnJlbnREYXRhLmRhdGFUYWJsZS5sYWJlbF0ucmVwbGFjZSgvXFxzL2csICdfJykucmVwbGFjZSgvXFwuL2csICdfZG90XycpOztcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5hdHRyKCdyJywgZCA9PiB7XHJcbiAgICAgICAgICAgIGxldCB2YWwgPSBjaGFydC5fdmFycy5OT0RFX01JTl9TSVpFOy8vRGVmYXVsdCBub2RlIHNpemUgb2YgMTVcclxuICAgICAgICAgICAgaWYgKGRhdGFUYWJsZS5oYXNPd25Qcm9wZXJ0eSgnc2l6ZScpICYmICFpc0VtcHR5KGQpICYmIGQuaGFzT3duUHJvcGVydHkoJ2RhdGEnKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5vcm0gPSAoZC5kYXRhW2RhdGFUYWJsZS5zaXplXSAtIHpBeGlzRGF0YS5taW4pIC8gKHpBeGlzRGF0YS5tYXggLSB6QXhpc0RhdGEubWluKTtcclxuICAgICAgICAgICAgICAgIGlmICghaXNOYU4obm9ybSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWwgPSAoY2hhcnQuX3ZhcnMuTk9ERV9NQVhfU0laRSAtIGNoYXJ0Ll92YXJzLk5PREVfTUlOX1NJWkUpICogbm9ybSArIGNoYXJ0Ll92YXJzLk5PREVfTUlOX1NJWkU7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Ugey8vSWYgdGhlcmUgaXMgb25seSAxIG5vZGUgb24gdGhlIGNoYXJ0XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gY2hhcnQuX3ZhcnMuTk9ERV9NSU5fU0laRTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0VtcHR5KGQpKSB7XHJcbiAgICAgICAgICAgICAgICB2YWwgPSAwOy8vRG9uJ3QgZGlzcGxheSB1bmRlZmluZWQgbm9kZXNcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdmFsO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmF0dHIoJ2N4JywgZCA9PiBpc0VtcHR5KGQpID8gMCA6IGQuZGF0YS54KVxyXG4gICAgICAgIC5hdHRyKCdjeScsIGQgPT4gaXNFbXB0eShkKSA/IDAgOiBkLmRhdGEueSlcclxuICAgICAgICAuYXR0cignZmlsbCcsIGQgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIWlzRW1wdHkoZCkgJiYgZC5kYXRhW2NoYXJ0Ll92YXJzLmNvbG9yRGF0YUNhdGVnb3J5XSA9PT0gY2hhcnQuX3ZhcnMuY29sb3JEYXRhSW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb2xvcmVkUG9pbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHBvaW50Q29sb3I7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuYXR0cignb3BhY2l0eScsIDAuOClcclxuICAgICAgICAuYXR0cignc3Ryb2tlJywgJ2JsYWNrJylcclxuICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgMSlcclxuICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uIChkLCBpKSB7XHJcbiAgICAgICAgICAgIGlmIChjaGFydC5zaG93VG9vbFRpcCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRpcERhdGEgPSBjaGFydC5zZXRUaXBEYXRhKGQsIGkpO1xyXG4gICAgICAgICAgICAgICAgY2hhcnQudGlwLmdlbmVyYXRlU2ltcGxlVGlwKHRpcERhdGEsIGRhdGFUYWJsZSk7XHJcbiAgICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcylcclxuICAgICAgICAgICAgICAgICAgICAuYXR0cignZmlsbCcsIGNoYXJ0Ll92YXJzLnNpbmdsZUF4aXNGaWxsSG92ZXJDb2xvcik7XHJcbiAgICAgICAgICAgICAgICBjaGFydC50aXAuZCA9IGQ7XHJcbiAgICAgICAgICAgICAgICBjaGFydC50aXAuaSA9IGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICAgIC5vbignbW91c2Vtb3ZlJywgZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgaWYgKGNoYXJ0LnNob3dUb29sVGlwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hhcnQudGlwLmQgPT09IGQgJiYgY2hhcnQudGlwLmkgPT09IGkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGFydC50aXAuc2hvd1RpcChkMy5ldmVudCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vR2V0IHRpcCBkYXRhXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpcERhdGEgPSBjaGFydC5zZXRUaXBEYXRhKGQsIGkpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vRHJhdyB0aXAgbGluZVxyXG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0LnRpcC5nZW5lcmF0ZVNpbXBsZVRpcCh0aXBEYXRhLCBjaGFydC5kYXRhLmRhdGFUYWJsZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChjaGFydC5zaG93VG9vbFRpcCkge1xyXG4gICAgICAgICAgICAgICAgY2hhcnQudGlwLmhpZGVUaXAoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkMy5zZWxlY3QodGhpcylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgZCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0VtcHR5KGQpICYmIGQuZGF0YVtjaGFydC5fdmFycy5jb2xvckRhdGFDYXRlZ29yeV0gPT09IGNoYXJ0Ll92YXJzLmNvbG9yRGF0YUluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2xvcmVkUG9pbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwb2ludENvbG9yO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFNpbmdsZUF4aXNEYXRhKGRhdGEsIGRhdGFUYWJsZSkge1xyXG4gICAgdmFyIGNoYXJ0ID0gdGhpcyxcclxuICAgICAgICBsYWJlbCxcclxuICAgICAgICBkYXRhVHlwZSxcclxuICAgICAgICBtaW4sXHJcbiAgICAgICAgbWF4LFxyXG4gICAgICAgIHZhbHVlcyA9IFtdO1xyXG5cclxuICAgIGlmIChkYXRhVGFibGUpIHtcclxuICAgICAgICBpZiAoZGF0YVRhYmxlLmhhc093blByb3BlcnR5KCd4JykpIHtcclxuICAgICAgICAgICAgbGFiZWwgPSBkYXRhVGFibGUueDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZGF0YVR5cGUgPSAnTlVNQkVSJztcclxuXHJcbiAgICBmb3IgKGxldCBlbGUgb2YgZGF0YSkge1xyXG4gICAgICAgIHZhbHVlcy5wdXNoKGVsZVtkYXRhVGFibGUueF0pO1xyXG4gICAgfVxyXG5cclxuICAgIG1pbiA9IE1hdGgubWluLmFwcGx5KG51bGwsIHZhbHVlcyk7XHJcbiAgICBtYXggPSBNYXRoLm1heC5hcHBseShudWxsLCB2YWx1ZXMpO1xyXG5cclxuICAgIC8vQWRkIGEgMTAlIGJ1ZmZlciB0byBib3RoIHNpZGVzXHJcbiAgICBtaW4gPSBNYXRoLmZsb29yKG1pbiAtICgobWF4IC0gbWluKSAqIDAuMTApKTtcclxuICAgIG1heCA9IE1hdGguY2VpbChtYXggKyAoKG1heCAtIG1pbikgKiAwLjEwKSk7XHJcblxyXG4gICAgLy9Gb3IgYXhpcyBtaW4vbWF4IHdpZGdldFxyXG4gICAgaWYgKGNoYXJ0Ll92YXJzLmhhc093blByb3BlcnR5KCd4TWluJykgJiYgY2hhcnQuX3ZhcnMueE1pbiAhPT0gJ25vbmUnKSB7XHJcbiAgICAgICAgbWluID0gY2hhcnQub3B0aW9ucy54TWluO1xyXG4gICAgfVxyXG4gICAgaWYgKGNoYXJ0Ll92YXJzLmhhc093blByb3BlcnR5KCd4TWF4JykgJiYgY2hhcnQuX3ZhcnMueE1heCAhPT0gJ25vbmUnKSB7XHJcbiAgICAgICAgbWF4ID0gY2hhcnQuX3ZhcnMueE1heDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgICdsYWJlbCc6IGxhYmVsLFxyXG4gICAgICAgICd2YWx1ZXMnOiB2YWx1ZXMsXHJcbiAgICAgICAgJ2RhdGFUeXBlJzogZGF0YVR5cGUsXHJcbiAgICAgICAgJ21pbic6IG1pbixcclxuICAgICAgICAnbWF4JzogbWF4XHJcbiAgICB9O1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGp2Q2hhcnRzO1xyXG4iLCIndXNlIHN0cmljdCc7XHJcbnZhciBqdkNoYXJ0cyA9IHJlcXVpcmUoJy4uL2p2Q2hhcnRzLmpzJyk7XHJcblxyXG5qdkNoYXJ0cy5wcm90b3R5cGUuc3VuYnVyc3QgPSB7XHJcbiAgICBwYWludDogcGFpbnQsXHJcbiAgICBzZXREYXRhOiBzZXREYXRhLFxyXG4gICAgZ2V0RXZlbnREYXRhOiBnZXRFdmVudERhdGFcclxufTtcclxuXHJcbmp2Q2hhcnRzLnByb3RvdHlwZS5nZW5lcmF0ZVN1bmJ1cnN0ID0gZ2VuZXJhdGVTdW5idXJzdDtcclxuXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogU3VuYnVyc3QgZnVuY3Rpb25zICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcbi8qKnNldFN1bmJ1cnN0Q2hhcnREYXRhXHJcbiAqICBnZXRzIHN1bmJ1cnN0IGRhdGEgYW5kIGFkZHMgaXQgdG8gdGhlIGNoYXJ0IG9iamVjdFxyXG4gKlxyXG4gKiBAcGFyYW1zIGRhdGEsIGRhdGFUYWJsZSwgY29sb3JzXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXREYXRhKCkge1xyXG4gICAgdmFyIGNoYXJ0ID0gdGhpcztcclxuICAgIGlmICghY2hhcnQuZGF0YS5jaGFydERhdGEuaGFzT3duUHJvcGVydHkoJ2NoaWxkcmVuJykpIHtcclxuICAgICAgICBjaGFydC5kYXRhLmNoYXJ0RGF0YSA9IGp2Q2hhcnRzLmNvbnZlcnRUYWJsZVRvVHJlZShjaGFydC5kYXRhLmNoYXJ0RGF0YSwgY2hhcnQuZGF0YS5kYXRhVGFibGUsIHRydWUpO1xyXG4gICAgfVxyXG5cclxuICAgIGNoYXJ0LmRhdGEuY29sb3IgPSBjaGFydC5jb2xvcnM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEV2ZW50RGF0YSgpIHtcclxuICAgIHJldHVybiB7fTtcclxufVxyXG5cclxuZnVuY3Rpb24gcGFpbnQoKSB7XHJcbiAgICB2YXIgY2hhcnQgPSB0aGlzLFxyXG4gICAgICAgIHN1bmJ1cnN0TWFyZ2lucyA9IHtcclxuICAgICAgICAgICAgdG9wOiAxNSxcclxuICAgICAgICAgICAgcmlnaHQ6IDE1LFxyXG4gICAgICAgICAgICBib3R0b206IDE1LFxyXG4gICAgICAgICAgICBsZWZ0OiAxNVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgY2hhcnQuX3ZhcnMuY29sb3IgPSBjaGFydC5kYXRhLmNvbG9yO1xyXG4gICAgY2hhcnQuY3VycmVudERhdGEgPSBjaGFydC5kYXRhO1xyXG5cclxuICAgIC8vR2VuZXJhdGUgU1ZHLWxlZ2VuZCBkYXRhIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBzaXplIG9mIHRoZSBib3R0b20gbWFyZ2luIChzZXQgdG8gbnVsbCBmb3Igbm8gbGVnZW5kKVxyXG4gICAgY2hhcnQuZ2VuZXJhdGVTVkcobnVsbCwgc3VuYnVyc3RNYXJnaW5zKTtcclxuICAgIC8vY2hhcnQuZ2VuZXJhdGVMZWdlbmQoY2hhcnQuY3VycmVudERhdGEubGVnZW5kRGF0YSwgJ2dlbmVyYXRlU3VuYnVyc3QnKTtcclxuICAgIGNoYXJ0LmdlbmVyYXRlU3VuYnVyc3QoKTtcclxufVxyXG5cclxuLyoqZ2VuZXJhdGVTdW5idXJzdFxyXG4gKlxyXG4gKiBwYWludHMgdGhlIHN1bmJ1cnN0IG9uIHRoZSBjaGFydFxyXG4gKiBAcGFyYW1zIHN1bmJ1cnN0RGF0YVxyXG4gKi9cclxuZnVuY3Rpb24gZ2VuZXJhdGVTdW5idXJzdCgpIHtcclxuICAgIHZhciBjaGFydCA9IHRoaXMsXHJcbiAgICAgICAgc3ZnID0gY2hhcnQuc3ZnLFxyXG4gICAgICAgIHZpcyxcclxuICAgICAgICB0ZXh0LFxyXG4gICAgICAgIGNvbnRhaW5lciA9IGNoYXJ0LmNvbmZpZy5jb250YWluZXIsXHJcbiAgICAgICAgd2lkdGggPSBjb250YWluZXIud2lkdGgsXHJcbiAgICAgICAgaGVpZ2h0ID0gY29udGFpbmVyLmhlaWdodCxcclxuICAgICAgICByYWRpdXMgPSAoTWF0aC5taW4od2lkdGgsIGhlaWdodCkgLyAyKSAtIDEwLFxyXG4gICAgICAgIHggPSBkMy5zY2FsZUxpbmVhcigpXHJcbiAgICAgICAgICAgIC5yYW5nZShbMCwgMiAqIE1hdGguUEldKSxcclxuICAgICAgICB5ID0gZDMuc2NhbGVTcXJ0KClcclxuICAgICAgICAgICAgLnJhbmdlKFswLCByYWRpdXNdKSxcclxuICAgICAgICBjb2xvciA9IGQzLnNjYWxlT3JkaW5hbCgpXHJcbiAgICAgICAgICAgIC5yYW5nZShjaGFydC5kYXRhLmNvbG9yXHJcbiAgICAgICAgICAgICAgICAubWFwKGMgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGMgPSBkMy5yZ2IoYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYy5vcGFjaXR5ID0gMTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYztcclxuICAgICAgICAgICAgICAgIH0pKSxcclxuICAgICAgICBwYXJ0aXRpb24gPSBkMy5wYXJ0aXRpb24oKSxcclxuICAgICAgICBhcmMgPSBkMy5hcmMoKVxyXG4gICAgICAgICAgICAuc3RhcnRBbmdsZShkID0+IE1hdGgubWF4KDAsIE1hdGgubWluKDIgKiBNYXRoLlBJLCB4KGQueDApKSkpXHJcbiAgICAgICAgICAgIC5lbmRBbmdsZShkID0+IE1hdGgubWF4KDAsIE1hdGgubWluKDIgKiBNYXRoLlBJLCB4KGQueDEpKSkpXHJcbiAgICAgICAgICAgIC5pbm5lclJhZGl1cyhkID0+IE1hdGgubWF4KDAsIHkoZC55MCkpKVxyXG4gICAgICAgICAgICAub3V0ZXJSYWRpdXMoZCA9PiBNYXRoLm1heCgwLCB5KGQueTEpKSksXHJcblxyXG4gICAgICAgIC8vYXNzaWducyB0aGUgZGF0YSB0byBhIGhpZXJhcmNoeSB1c2luZyBwYXJlbnQtY2hpbGQgcmVsYXRpb25zaGlwc1xyXG4gICAgICAgIHJvb3QgPSBkMy5oaWVyYXJjaHkoY2hhcnQuY3VycmVudERhdGEuY2hhcnREYXRhLCBkID0+IGQuY2hpbGRyZW4pO1xyXG5cclxuICAgIHJvb3Quc3VtKGQgPT4gZC52YWx1ZSk7XHJcblxyXG4gICAgdmlzID0gc3ZnLmFwcGVuZCgnZycpXHJcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3N1bmJ1cnN0JylcclxuICAgICAgICAuYXR0cignd2lkdGgnLCB3aWR0aClcclxuICAgICAgICAuYXR0cignaGVpZ2h0JywgaGVpZ2h0KVxyXG4gICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyB3aWR0aCAvIDIgKyAnLCcgKyAoaGVpZ2h0IC8gMikgKyAnKScpO1xyXG5cclxuXHJcbiAgICB2aXMuc2VsZWN0QWxsKCdwYXRoJylcclxuICAgICAgICAuZGF0YShwYXJ0aXRpb24ocm9vdCkuZGVzY2VuZGFudHMoKSlcclxuICAgICAgICAuZW50ZXIoKS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdub2RlJyk7XHJcblxyXG4gICAgdmlzLnNlbGVjdEFsbCgnLm5vZGUnKVxyXG4gICAgICAgIC5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgIC5hdHRyKCdzdHJva2UnLCAnd2hpdGUnKVxyXG4gICAgICAgIC5hdHRyKCdkJywgYXJjKVxyXG4gICAgICAgIC5zdHlsZSgnZmlsbCcsIGQgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZC5kYXRhLm5hbWUgPT09ICdyb290Jykge1xyXG4gICAgICAgICAgICAgICAgZC5jb2xvciA9IGNoYXJ0Ll92YXJzLmJhY2tncm91bmRDb2xvcjtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjaGFydC5fdmFycy5iYWNrZ3JvdW5kQ29sb3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZC5jb2xvciA9IGNvbG9yKGQuZGF0YS5uYW1lKTtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbG9yKGQuZGF0YS5uYW1lKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgaWYgKGNoYXJ0LnNob3dUb29sVGlwKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGlwRGF0YSA9IGNoYXJ0LnNldFRpcERhdGEoZCwgaSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9EcmF3IHRpcCBsaW5lXHJcbiAgICAgICAgICAgICAgICBjaGFydC50aXAuZ2VuZXJhdGVTaW1wbGVUaXAodGlwRGF0YSwgY2hhcnQuZGF0YS5kYXRhVGFibGUpO1xyXG4gICAgICAgICAgICAgICAgY2hhcnQudGlwLmQgPSBkO1xyXG4gICAgICAgICAgICAgICAgY2hhcnQudGlwLmkgPSBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICAub24oJ21vdXNlbW92ZScsIGZ1bmN0aW9uIChkLCBpKSB7XHJcbiAgICAgICAgICAgIGlmIChjaGFydC5zaG93VG9vbFRpcCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoYXJ0LnRpcC5kID09PSBkICYmIGNoYXJ0LnRpcC5pID09PSBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhcnQudGlwLnNob3dUaXAoZDMuZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvL0dldCB0aXAgZGF0YVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0aXBEYXRhID0gY2hhcnQuc2V0VGlwRGF0YShkLCBpKTtcclxuICAgICAgICAgICAgICAgICAgICAvL0RyYXcgdGlwIGxpbmVcclxuICAgICAgICAgICAgICAgICAgICBjaGFydC50aXAuZ2VuZXJhdGVTaW1wbGVUaXAodGlwRGF0YSwgY2hhcnQuZGF0YS5kYXRhVGFibGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICAub24oJ2NsaWNrJywgY2xpY2spXHJcbiAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY2hhcnQudGlwLmhpZGVUaXAoKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICBpZiAoY2hhcnQuX3ZhcnMuZGlzcGxheVZhbHVlcykge1xyXG4gICAgICAgIHRleHQgPSB2aXMuc2VsZWN0QWxsKCcubm9kZScpXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZCA9PiBgcm90YXRlKCR7Y29tcHV0ZVRleHRSb3RhdGlvbihkKX0pYClcclxuICAgICAgICAgICAgLmF0dHIoJ3gnLCBkID0+IHkoZC55MCkpXHJcbiAgICAgICAgICAgIC5hdHRyKCdkeCcsICc2JykgLy9tYXJnaW5cclxuICAgICAgICAgICAgLmF0dHIoJ2R5JywgJy4zNWVtJykgLy92ZXJ0aWNhbC1hbGlnblxyXG4gICAgICAgICAgICAudGV4dChkID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChOdW1iZXIoZC5kYXRhLnZhbHVlKSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZC5kYXRhLm5hbWUgPT09ICdyb290JyA/ICcnIDogZC5kYXRhLm5hbWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBmdW5jdGlvbiBjbGljayhkKSB7XHJcbiAgICAgICAgLy9mYWRlIG91dCBhbGwgdGV4dCBlbGVtZW50c1xyXG4gICAgICAgIGlmIChjaGFydC5fdmFycy5kaXNwbGF5VmFsdWVzKSB7XHJcbiAgICAgICAgICAgIHRleHQudHJhbnNpdGlvbigpLmF0dHIoJ29wYWNpdHknLCAwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZpcy50cmFuc2l0aW9uKClcclxuICAgICAgICAgICAgLmR1cmF0aW9uKDc1MClcclxuICAgICAgICAgICAgLnR3ZWVuKCdzY2FsZScsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHZhciB4ZCA9IGQzLmludGVycG9sYXRlKHguZG9tYWluKCksIFtkLngwLCBkLngxXSksXHJcbiAgICAgICAgICAgICAgICAgICAgeWQgPSBkMy5pbnRlcnBvbGF0ZSh5LmRvbWFpbigpLCBbZC55MCwgMV0pLFxyXG4gICAgICAgICAgICAgICAgICAgIHlyID0gZDMuaW50ZXJwb2xhdGUoeS5yYW5nZSgpLCBbZC55MCA/IDIwIDogMCwgcmFkaXVzXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHQgPT4geyB4LmRvbWFpbih4ZCh0KSk7IHkuZG9tYWluKHlkKHQpKS5yYW5nZSh5cih0KSk7IH07XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoJ3BhdGgnKVxyXG4gICAgICAgICAgICAuYXR0clR3ZWVuKCdkJywgZWxlID0+ICgpID0+IGFyYyhlbGUpKVxyXG4gICAgICAgICAgICAub24oJ2VuZCcsIGZ1bmN0aW9uIChlLCBpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hhcnQuX3ZhcnMuZGlzcGxheVZhbHVlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY2hlY2sgaWYgdGhlIGFuaW1hdGVkIGVsZW1lbnQncyBkYXRhIGUgbGllcyB3aXRoaW4gdGhlIHZpc2libGUgYW5nbGUgc3BhbiBnaXZlbiBpbiBkXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUueDAgPiBkLngwICYmIGUueDAgPCBkLngxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZ2V0IGEgc2VsZWN0aW9uIG9mIHRoZSBhc3NvY2lhdGVkIHRleHQgZWxlbWVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJjVGV4dCA9IGQzLnNlbGVjdCh0aGlzLnBhcmVudE5vZGUpLnNlbGVjdCgndGV4dCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2ZhZGUgaW4gdGhlIHRleHQgZWxlbWVudCBhbmQgcmVjYWxjdWxhdGUgcG9zaXRpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyY1RleHQudHJhbnNpdGlvbigpLmR1cmF0aW9uKDc1MClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdvcGFjaXR5JywgMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICd2aXNpYmxlJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAoKSA9PiBgcm90YXRlKCR7Y29tcHV0ZVRleHRSb3RhdGlvbihlKX0pYClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgZWxlID0+IHkoZWxlLnkwKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50ZXh0KGVsZSA9PiBlbGUuZGF0YS5uYW1lID09PSAncm9vdCcgPyAnJyA6IGVsZS5kYXRhLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY29tcHV0ZVRleHRSb3RhdGlvbihkKSB7XHJcbiAgICAgICAgcmV0dXJuICh4KChkLngwICsgZC54MSkgLyAyKSAtIE1hdGguUEkgLyAyKSAvIE1hdGguUEkgKiAxODA7XHJcbiAgICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ganZDaGFydHM7XHJcbiIsIid1c2Ugc3RyaWN0JztcclxudmFyIGp2Q2hhcnRzID0gcmVxdWlyZSgnLi4vanZDaGFydHMuanMnKTtcclxuXHJcbmp2Q2hhcnRzLnByb3RvdHlwZS50cmVlbWFwID0ge1xyXG4gICAgcGFpbnQ6IHBhaW50LFxyXG4gICAgc2V0RGF0YTogc2V0RGF0YSxcclxuICAgIGdldEV2ZW50RGF0YTogZ2V0RXZlbnREYXRhXHJcbn07XHJcblxyXG5qdkNoYXJ0cy5wcm90b3R5cGUuZ2VuZXJhdGVUcmVlTWFwID0gZ2VuZXJhdGVUcmVlTWFwO1xyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIFRyZWVNYXAgZnVuY3Rpb25zICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcbi8qKnNldFRyZWVNYXBEYXRhXHJcbiAqICBnZXRzIHRyZWVtYXAgZGF0YSBhbmQgYWRkcyBpdCB0byB0aGUgY2hhcnQgb2JqZWN0XHJcbiAqXHJcbiAqIEBwYXJhbXMgZGF0YSwgZGF0YVRhYmxlLCBjb2xvcnNcclxuICovXHJcbmZ1bmN0aW9uIHNldERhdGEoKSB7XHJcbiAgICB2YXIgY2hhcnQgPSB0aGlzO1xyXG4gICAgaWYgKCFjaGFydC5kYXRhLmNoYXJ0RGF0YS5oYXNPd25Qcm9wZXJ0eSgnY2hpbGRyZW4nKSkge1xyXG4gICAgICAgIGNoYXJ0LmRhdGEuY2hhcnREYXRhID0ganZDaGFydHMuY29udmVydFRhYmxlVG9UcmVlbWFwKGNoYXJ0LmRhdGEuY2hhcnREYXRhLCBjaGFydC5kYXRhLmRhdGFUYWJsZSk7XHJcbiAgICB9XHJcbiAgICBjaGFydC5kYXRhLmxlZ2VuZERhdGEgPSBzZXRUcmVlTWFwTGVnZW5kRGF0YShjaGFydC5kYXRhKTtcclxuICAgIC8vZGVmaW5lIGNvbG9yIG9iamVjdCBmb3IgY2hhcnREYXRhXHJcbiAgICBjaGFydC5kYXRhLmNvbG9yID0ganZDaGFydHMuc2V0Q2hhcnRDb2xvcnMoY2hhcnQuX3ZhcnMuY29sb3IsIGNoYXJ0LmRhdGEubGVnZW5kRGF0YSwgY2hhcnQuY29sb3JzKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0RXZlbnREYXRhKCkge1xyXG4gICAgcmV0dXJuIHt9O1xyXG59XHJcblxyXG4vKipzZXRUcmVlTWFwTGVnZW5kRGF0YVxyXG4gKiAgZ2V0cyBsZWdlbmQgaW5mbyBmcm9tIGNoYXJ0IERhdGFcclxuICpcclxuICogQHBhcmFtcyBkYXRhLCB0eXBlXHJcbiAqIEByZXR1cm5zIFtdIG9mIGxlZ2VuZCB0ZXh0XHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRUcmVlTWFwTGVnZW5kRGF0YShkYXRhKSB7XHJcbiAgICB2YXIgbGVnZW5kQXJyYXkgPSBbXSxcclxuICAgICAgICBzZXJpZXMgPSBkYXRhLmRhdGFUYWJsZS5zZXJpZXM7XHJcbiAgICBmb3IgKGxldCBjaGlsZEVsZSBvZiBkYXRhLmNoYXJ0RGF0YS5jaGlsZHJlbikge1xyXG4gICAgICAgIGlmIChsZWdlbmRBcnJheS5pbmRleE9mKGNoaWxkRWxlW3Nlcmllc10pID09PSAtMSkge1xyXG4gICAgICAgICAgICBsZWdlbmRBcnJheS5wdXNoKChjaGlsZEVsZVtzZXJpZXNdKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxlZ2VuZEFycmF5O1xyXG59XHJcblxyXG5mdW5jdGlvbiBwYWludCgpIHtcclxuICAgIHZhciBjaGFydCA9IHRoaXMsXHJcbiAgICAgICAgdHJlZU1hcE1hcmdpbnMgPSB7XHJcbiAgICAgICAgICAgIHRvcDogNDUsXHJcbiAgICAgICAgICAgIHJpZ2h0OiA1MCxcclxuICAgICAgICAgICAgbGVmdDogNTAsXHJcbiAgICAgICAgICAgIGJvdHRvbTogMTMwXHJcbiAgICAgICAgfTtcclxuICAgIGNoYXJ0Ll92YXJzLmNvbG9yID0gY2hhcnQuZGF0YS5jb2xvcjtcclxuICAgIGNoYXJ0LmN1cnJlbnREYXRhID0gY2hhcnQuZGF0YTtcclxuXHJcbiAgICAvL0dlbmVyYXRlIFNWRy1sZWdlbmQgZGF0YSBpcyB1c2VkIHRvIGRldGVybWluZSB0aGUgc2l6ZSBvZiB0aGUgYm90dG9tIG1hcmdpbiAoc2V0IHRvIG51bGwgZm9yIG5vIGxlZ2VuZClcclxuICAgIGNoYXJ0LmdlbmVyYXRlU1ZHKG51bGwsIHRyZWVNYXBNYXJnaW5zKTtcclxuICAgIGNoYXJ0LmdlbmVyYXRlTGVnZW5kKGNoYXJ0LmN1cnJlbnREYXRhLmxlZ2VuZERhdGEsICdnZW5lcmF0ZVRyZWVNYXAnKTtcclxuICAgIGNoYXJ0LmdlbmVyYXRlVHJlZU1hcChjaGFydC5jdXJyZW50RGF0YSk7XHJcbn1cclxuXHJcbi8qKmdlbmVyYXRlVHJlZU1hcFxyXG4gKlxyXG4gKiBwYWludHMgdGhlIHRyZWVtYXAgb24gdGhlIGNoYXJ0XHJcbiAqIEBwYXJhbXMgdHJlZU1hcERhdGFcclxuICovXHJcbmZ1bmN0aW9uIGdlbmVyYXRlVHJlZU1hcCh0cmVlTWFwRGF0YSkge1xyXG4gICAgdmFyIGNoYXJ0ID0gdGhpcyxcclxuICAgICAgICBzdmcgPSBjaGFydC5zdmcsXHJcbiAgICAgICAgY29sb3JzID0gdHJlZU1hcERhdGEuY29sb3IsXHJcbiAgICAgICAgY29udGFpbmVyID0gY2hhcnQuY29uZmlnLmNvbnRhaW5lcixcclxuICAgICAgICByZWxhdGlvbk1hcCA9IGNoYXJ0LmRhdGEuZGF0YVRhYmxlLFxyXG4gICAgICAgIGRhdGEgPSBjaGFydC5jdXJyZW50RGF0YS5jaGFydERhdGEsXHJcbiAgICAgICAgZGF0YUhlYWRlcnMsXHJcbiAgICAgICAgbGVnZW5kRWxlbWVudFRvZ2dsZUFycmF5LFxyXG4gICAgICAgIHRyZWVNYXBEYXRhRmlsdGVyZWQsXHJcbiAgICAgICAgcm9vdCxcclxuICAgICAgICB0cmVlbWFwRnVuYyxcclxuICAgICAgICBub2RlLFxyXG4gICAgICAgIHRleHROb2RlO1xyXG5cclxuICAgIGlmICghY2hhcnQuX3ZhcnMubGVnZW5kSGVhZGVycykge1xyXG4gICAgICAgIGNoYXJ0Ll92YXJzLmxlZ2VuZEhlYWRlcnMgPSBjaGFydC5jdXJyZW50RGF0YS5sZWdlbmREYXRhO1xyXG4gICAgfVxyXG5cclxuICAgIGRhdGFIZWFkZXJzID0gY2hhcnQuX3ZhcnMubGVnZW5kSGVhZGVycztcclxuICAgIGxlZ2VuZEVsZW1lbnRUb2dnbGVBcnJheSA9IGp2Q2hhcnRzLmdldExlZ2VuZEVsZW1lbnRUb2dnbGVBcnJheShkYXRhSGVhZGVycywgY2hhcnQuZGF0YS5sZWdlbmREYXRhKTtcclxuXHJcbiAgICBpZiAobGVnZW5kRWxlbWVudFRvZ2dsZUFycmF5KSB7XHJcbiAgICAgICAgZm9yIChsZXQgY2hpbGRFbGUgb2YgZGF0YS5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBsZWdlbmRFbGUgb2YgbGVnZW5kRWxlbWVudFRvZ2dsZUFycmF5KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobGVnZW5kRWxlLmVsZW1lbnQgPT09IGNoaWxkRWxlW3JlbGF0aW9uTWFwLnNlcmllc10gJiYgbGVnZW5kRWxlLnRvZ2dsZSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZEVsZS5zaG93ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdHJlZU1hcERhdGFGaWx0ZXJlZCA9IHtcclxuICAgICAgICBQYXJlbnQ6ICdUb3AgTGV2ZWwnLFxyXG4gICAgICAgIGNoaWxkcmVuOiBbXVxyXG4gICAgfTtcclxuXHJcbiAgICBmb3IgKGxldCBjaGlsZEVsZSBvZiBkYXRhLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgaWYgKGNoaWxkRWxlLnNob3cgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHRyZWVNYXBEYXRhRmlsdGVyZWQuY2hpbGRyZW4ucHVzaChjaGlsZEVsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vYXNzaWducyB0aGUgZGF0YSB0byBhIGhpZXJhcmNoeSB1c2luZyBwYXJlbnQtY2hpbGQgcmVsYXRpb25zaGlwc1xyXG4gICAgcm9vdCA9IGQzLmhpZXJhcmNoeSh0cmVlTWFwRGF0YUZpbHRlcmVkLCBkID0+IGQuY2hpbGRyZW4pO1xyXG5cclxuICAgIHRyZWVtYXBGdW5jID0gZDMudHJlZW1hcCgpXHJcbiAgICAgICAgLnNpemUoW2NvbnRhaW5lci53aWR0aCwgY29udGFpbmVyLmhlaWdodF0pXHJcbiAgICAgICAgLnBhZGRpbmcoMik7XHJcblxyXG4gICAgdHJlZW1hcEZ1bmMocm9vdFxyXG4gICAgICAgIC5zdW0oZCA9PiBkW3JlbGF0aW9uTWFwLnNpemVdKVxyXG4gICAgICAgIC5zb3J0KChhLCBiKSA9PiBiLmhlaWdodCAtIGEuaGVpZ2h0IHx8IGIudmFsdWUgLSBhLnZhbHVlKSlcclxuICAgICAgICAuZGVzY2VuZGFudHMoKTtcclxuXHJcbiAgICAvL1JlbW92ZSBleGlzdGluZyBiYXJzIGZyb20gcGFnZVxyXG4gICAgc3ZnLnNlbGVjdEFsbCgnZy50cmVlbWFwJykucmVtb3ZlKCk7XHJcbiAgICBzdmcuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAndHJlZW1hcCcpO1xyXG5cclxuICAgIG5vZGUgPSBzdmcuc2VsZWN0KCcudHJlZW1hcCcpXHJcbiAgICAgICAgLnNlbGVjdEFsbCgnZycpXHJcbiAgICAgICAgLmRhdGEocm9vdC5sZWF2ZXMoKSlcclxuICAgICAgICAuZW50ZXIoKS5hcHBlbmQoJ2cnKVxyXG4gICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsMCknKTtcclxuXHJcbiAgICBub2RlLmFwcGVuZCgncmVjdCcpXHJcbiAgICAgICAgLmF0dHIoJ3gnLCBkID0+IGQueDAgKyAncHgnKVxyXG4gICAgICAgIC5hdHRyKCd5JywgZCA9PiBkLnkwICsgJ3B4JylcclxuICAgICAgICAuYXR0cignd2lkdGgnLCBkID0+IGQueDEgLSBkLngwICsgJ3B4JylcclxuICAgICAgICAuYXR0cignaGVpZ2h0JywgZCA9PiBkLnkxIC0gZC55MCArICdweCcpXHJcbiAgICAgICAgLmF0dHIoJ2ZpbGwnLCAoZCwgaSkgPT4ganZDaGFydHMuZ2V0Q29sb3JzKGNvbG9ycywgaSwgZC5kYXRhW3JlbGF0aW9uTWFwLnNlcmllc10pKVxyXG4gICAgICAgIC5hdHRyKCdmaWxsLW9wYWNpdHknLCAwLjgpXHJcbiAgICAgICAgLmF0dHIoJ3N0cm9rZScsIGNoYXJ0Ll92YXJzLndoaXRlKVxyXG4gICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCBjaGFydC5fdmFycy5zdHJva2VXaWR0aClcclxuICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uIChkLCBpKSB7XHJcbiAgICAgICAgICAgIC8vR2V0IHRpcCBkYXRhXHJcbiAgICAgICAgICAgIGxldCB0aXBEYXRhID0gY2hhcnQuc2V0VGlwRGF0YShkLmRhdGEsIGkpO1xyXG4gICAgICAgICAgICAvL0RyYXcgdGlwIGxpbmVcclxuICAgICAgICAgICAgY2hhcnQudGlwLmdlbmVyYXRlU2ltcGxlVGlwKHRpcERhdGEsIGNoYXJ0LmRhdGEuZGF0YVRhYmxlKTtcclxuICAgICAgICAgICAgY2hhcnQudGlwLmQgPSBkO1xyXG4gICAgICAgICAgICBjaGFydC50aXAuaSA9IGk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAub24oJ21vdXNlbW92ZScsIGZ1bmN0aW9uIChkLCBpKSB7XHJcbiAgICAgICAgICAgIGlmIChjaGFydC5zaG93VG9vbFRpcCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoYXJ0LnRpcC5kID09PSBkICYmIGNoYXJ0LnRpcC5pID09PSBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhcnQudGlwLnNob3dUaXAoZDMuZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvL0dldCB0aXAgZGF0YVxyXG4gICAgICAgICAgICAgICAgICAgIGxldCB0aXBEYXRhID0gY2hhcnQuc2V0VGlwRGF0YShkLCBpKTtcclxuICAgICAgICAgICAgICAgICAgICAvL0RyYXcgdGlwIGxpbmVcclxuICAgICAgICAgICAgICAgICAgICBjaGFydC50aXAuZ2VuZXJhdGVTaW1wbGVUaXAodGlwRGF0YSwgY2hhcnQuZGF0YS5kYXRhVGFibGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBjaGFydC50aXAuaGlkZVRpcCgpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIG5vZGUuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAuYXR0cigneCcsIGQgPT4gZC54MCArICdweCcpXHJcbiAgICAgICAgLmF0dHIoJ3knLCBkID0+IGQueTAgKyAncHgnKVxyXG4gICAgICAgIC5hdHRyKCd3aWR0aCcsIGQgPT4gZC54MSAtIGQueDAgKyAncHgnKVxyXG4gICAgICAgIC5hdHRyKCdoZWlnaHQnLCBkID0+IGQueTEgLSBkLnkwICsgJ3B4JylcclxuICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgzLCAxOCknKVxyXG4gICAgICAgIC50ZXh0KGQgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZC5keSAhPT0gMCAmJiAhZC5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGQuZGF0YVtyZWxhdGlvbk1hcC5sYWJlbF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgLypEb24ndCBkaXNwbGF5IHRleHQgaWYgdGV4dCBpcyB3aWRlciB0aGFuIHJlY3QgKi9cclxuICAgIHRleHROb2RlID0gbm9kZS5zZWxlY3RBbGwoJ3RleHQnKTtcclxuICAgIHRleHROb2RlLmF0dHIoJ3N0eWxlJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICBsZXQgYmJveCA9IHRoaXMuZ2V0QkJveCgpO1xyXG4gICAgICAgIGlmIChiYm94LndpZHRoID49IChkLngxIC0gZC54MCkgLSA1IHx8IGJib3guaGVpZ2h0ID49IChkLnkxIC0gZC55MCkgLSA1KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnZGlzcGxheTpub25lJztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgfSk7XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBqdkNoYXJ0cztcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIganZDaGFydHMgPSByZXF1aXJlKCcuLi9qdkNoYXJ0cy5qcycpO1xyXG5cclxuanZDaGFydHMucHJvdG90eXBlLmNsb3VkID0ge1xyXG4gICAgcGFpbnQ6IHBhaW50LFxyXG4gICAgc2V0RGF0YTogc2V0RGF0YSxcclxuICAgIGdldEV2ZW50RGF0YTogZ2V0RXZlbnREYXRhXHJcbn07XHJcblxyXG5qdkNoYXJ0cy5wcm90b3R5cGUuZ2VuZXJhdGVDbG91ZCA9IGdlbmVyYXRlQ2xvdWQ7XHJcblxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIENsb3VkIGZ1bmN0aW9ucyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG4vKipzZXRDbG91ZERhdGFcclxuICogIGdldHMgY2xvdWQgZGF0YSBhbmQgYWRkcyBpdCB0byB0aGUgY2hhcnQgb2JqZWN0XHJcbiAqXHJcbiAqIEBwYXJhbXMgZGF0YSwgZGF0YVRhYmxlLCBjb2xvcnNcclxuICovXHJcbmZ1bmN0aW9uIHNldERhdGEoKSB7XHJcbiAgICB2YXIgY2hhcnQgPSB0aGlzO1xyXG4gICAgLy9kZWZpbmUgY29sb3Igb2JqZWN0IGZvciBjaGFydERhdGFcclxuICAgIGNoYXJ0LmRhdGEuY29sb3IgPSBjaGFydC5jb2xvcnM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEV2ZW50RGF0YSgpIHtcclxuICAgIHJldHVybiB7fTtcclxufVxyXG5cclxuLyoqc2V0Q2xvdWRMZWdlbmREYXRhXHJcbiAqICBnZXRzIGxlZ2VuZCBpbmZvIGZyb20gY2hhcnQgRGF0YVxyXG4gKlxyXG4gKiBAcGFyYW1zIGRhdGEsIHR5cGVcclxuICogQHJldHVybnMgW10gb2YgbGVnZW5kIHRleHRcclxuICovXHJcbmZ1bmN0aW9uIHNldENsb3VkTGVnZW5kRGF0YShkYXRhKSB7XHJcbiAgICB2YXIgbGVnZW5kQXJyYXkgPSBbXTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5jaGFydERhdGEuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAobGVnZW5kQXJyYXkuaW5kZXhPZihkYXRhLmNoYXJ0RGF0YS5jaGlsZHJlbltpXVtkYXRhLmRhdGFUYWJsZS5zZXJpZXNdKSA9PSAtMSkge1xyXG4gICAgICAgICAgICBsZWdlbmRBcnJheS5wdXNoKChkYXRhLmNoYXJ0RGF0YS5jaGlsZHJlbltpXVtkYXRhLmRhdGFUYWJsZS5zZXJpZXNdKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxlZ2VuZEFycmF5O1xyXG59XHJcblxyXG5mdW5jdGlvbiBwYWludCgpIHtcclxuICAgIHZhciBjaGFydCA9IHRoaXM7XHJcbiAgICBpZiAoIWNoYXJ0LnNtYWxsZXJGb250UmVwYWludCkge1xyXG4gICAgICAgIGNoYXJ0Ll92YXJzLmZvbnRTaXplTWF4ID0gODA7XHJcbiAgICAgICAgY2hhcnQuY3VycmVudERhdGEgPSBjaGFydC5kYXRhO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBjaGFydC5jdXJyZW50RGF0YSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoY2hhcnQuZGF0YSkpO1xyXG4gICAgfVxyXG5cclxuICAgIGNoYXJ0Ll92YXJzLmNvbG9yID0gY2hhcnQuZGF0YS5jb2xvcjtcclxuXHJcbiAgICB2YXIgY2xvdWRNYXJnaW5zID0ge1xyXG4gICAgICAgIHRvcDogMTUsXHJcbiAgICAgICAgcmlnaHQ6IDE1LFxyXG4gICAgICAgIGxlZnQ6IDE1LFxyXG4gICAgICAgIGJvdHRvbTogMTVcclxuICAgIH07XHJcblxyXG4gICAgLy9HZW5lcmF0ZSBTVkctbGVnZW5kIGRhdGEgaXMgdXNlZCB0byBkZXRlcm1pbmUgdGhlIHNpemUgb2YgdGhlIGJvdHRvbSBtYXJnaW4gKHNldCB0byBudWxsIGZvciBubyBsZWdlbmQpXHJcbiAgICBjaGFydC5nZW5lcmF0ZVNWRyhudWxsLCBjbG91ZE1hcmdpbnMpO1xyXG4gICAgLy8gY2hhcnQuZ2VuZXJhdGVMZWdlbmQoY2hhcnQuY3VycmVudERhdGEubGVnZW5kRGF0YSwgJ2dlbmVyYXRlQ2xvdWQnKTtcclxuICAgIGNoYXJ0LmdlbmVyYXRlQ2xvdWQoY2hhcnQuY3VycmVudERhdGEpO1xyXG59O1xyXG5cclxuLyoqIGdlbmVyYXRlQ2xvdWRcclxuICpcclxuICogcGFpbnRzIHRoZSBjbG91ZCAgb24gdGhlIGNoYXJ0XHJcbiAqIEBwYXJhbXMgY2xvdWQgRGF0YVxyXG4gKi9cclxuZnVuY3Rpb24gZ2VuZXJhdGVDbG91ZChjbG91ZERhdGEpIHtcclxuICAgIHZhciBjaGFydCA9IHRoaXMsXHJcbiAgICAgICAgc3ZnID0gY2hhcnQuc3ZnLFxyXG4gICAgICAgIGNvbnRhaW5lciA9IGNoYXJ0LmNvbmZpZy5jb250YWluZXIsXHJcbiAgICAgICAgYWxsRmlsdGVyTGlzdCA9IFtdLFxyXG4gICAgICAgIHJlbGF0aW9uTWFwID0gY2hhcnQuZGF0YS5kYXRhVGFibGUsXHJcbiAgICAgICAgd2lkdGggPSBjb250YWluZXIud2lkdGgsXHJcbiAgICAgICAgaGVpZ2h0ID0gY29udGFpbmVyLmhlaWdodCxcclxuICAgICAgICBtYXJnaW4gPSBjaGFydC5jb25maWcubWFyZ2luLFxyXG4gICAgICAgIG1pbixcclxuICAgICAgICBtYXg7XHJcblxyXG4gICAgdmFyIGNhdGVnb3JpZXMgPSBkMy5rZXlzKGQzLm5lc3QoKS5rZXkoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICBpZiAoIW1pbiAmJiAhbWF4KSB7XHJcbiAgICAgICAgICAgIG1pbiA9IGRbcmVsYXRpb25NYXAudmFsdWVdO1xyXG4gICAgICAgICAgICBtYXggPSBkW3JlbGF0aW9uTWFwLnZhbHVlXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoZFtyZWxhdGlvbk1hcC52YWx1ZV0gPiBtYXgpIHtcclxuICAgICAgICAgICAgICAgIG1heCA9IGRbcmVsYXRpb25NYXAudmFsdWVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkW3JlbGF0aW9uTWFwLnZhbHVlXSA8IG1pbikge1xyXG4gICAgICAgICAgICAgICAgbWluID0gZFtyZWxhdGlvbk1hcC52YWx1ZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBkW3JlbGF0aW9uTWFwLnZhbHVlXTtcclxuICAgIH0pLm1hcChjbG91ZERhdGEuY2hhcnREYXRhKSk7XHJcblxyXG4gICAgaWYgKCFjaGFydC5fdmFycy5mb250U2l6ZU1heCkge1xyXG4gICAgICAgIGNoYXJ0Ll92YXJzLmZvbnRTaXplTWF4ID0gODA7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGNvbG9yID0gZDMuc2NhbGVPcmRpbmFsKClcclxuICAgICAgICAucmFuZ2UoY2hhcnQuZGF0YS5jb2xvclxyXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChjKSB7IGMgPSBkMy5yZ2IoYyk7IGMub3BhY2l0eSA9IDAuODsgcmV0dXJuIGM7IH0pKTtcclxuXHJcbiAgICB2YXIgZm9udFNpemUgPSBkMy5zY2FsZVBvdygpLmV4cG9uZW50KDUpLmRvbWFpbihbMCwgMV0pLnJhbmdlKFsxMCwgY2hhcnQuX3ZhcnMuZm9udFNpemVNYXhdKTtcclxuICAgIGNoYXJ0LnNtYWxsZXJGb250UmVwYWludCA9IGZhbHNlO1xyXG4gICAgdmFyIGxheW91dCA9IGQzLmxheW91dC5jbG91ZCgpXHJcbiAgICAgICAgLnRpbWVJbnRlcnZhbCgxMClcclxuICAgICAgICAuc2l6ZShbd2lkdGgsIGhlaWdodF0pXHJcbiAgICAgICAgLndvcmRzKGNsb3VkRGF0YS5jaGFydERhdGEpXHJcbiAgICAgICAgLnJvdGF0ZShmdW5jdGlvbiAoZCkgeyByZXR1cm4gMDsgfSlcclxuICAgICAgICAuZm9udCgnUm9ib3RvJylcclxuICAgICAgICAuZm9udFNpemUoZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZvbnRTaXplKG1heCAtIG1pbiAhPT0gMCA/IChkW3JlbGF0aW9uTWFwLnZhbHVlXSAtIG1pbikgLyAobWF4IC0gbWluKSA6IDApO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLnJlcGFpbnRXaXRoU21hbGxlckZvbnQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmIChjaGFydC5fdmFycy5mb250U2l6ZU1heCA+IDEwKSB7XHJcbiAgICAgICAgICAgICAgICBjaGFydC5fdmFycy5mb250U2l6ZU1heCAtPSA1O1xyXG4gICAgICAgICAgICAgICAgY2hhcnQuc21hbGxlckZvbnRSZXBhaW50ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHBhaW50KGNoYXJ0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLnRleHQoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGRbcmVsYXRpb25NYXAubGFiZWxdOyB9KVxyXG4gICAgICAgIC5zcGlyYWwoXCJhcmNoaW1lZGVhblwiKVxyXG4gICAgICAgIC5vbihcImVuZFwiLCBkcmF3KVxyXG4gICAgICAgIC5zdGFydCgpO1xyXG5cclxuICAgIHZhciB3b3JkY2xvdWQgPSBzdmcuYXBwZW5kKFwiZ1wiKVxyXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICd3b3JkY2xvdWQnKVxyXG4gICAgICAgIC5hdHRyKFwid2lkdGhcIiwgd2lkdGggKyBtYXJnaW4ubGVmdCArIG1hcmdpbi5yaWdodClcclxuICAgICAgICAuYXR0cihcImhlaWdodFwiLCBoZWlnaHQgKyBtYXJnaW4udG9wICsgbWFyZ2luLmJvdHRvbSlcclxuICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIHdpZHRoIC8gMiArIFwiLFwiICsgaGVpZ2h0IC8gMiArIFwiKVwiKTtcclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3KHdvcmRzKSB7XHJcbiAgICAgICAgaWYgKGNoYXJ0LnNtYWxsZXJGb250UmVwYWludCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdvcmRjbG91ZC5zZWxlY3RBbGwoXCJ0ZXh0XCIpXHJcbiAgICAgICAgICAgIC5kYXRhKGNsb3VkRGF0YS5jaGFydERhdGEpXHJcbiAgICAgICAgICAgIC5lbnRlcigpLmFwcGVuZChcInRleHRcIilcclxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3dvcmQnKVxyXG4gICAgICAgICAgICAuc3R5bGUoXCJmb250LXNpemVcIiwgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkLnNpemUgKyBcInB4XCI7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5zdHlsZShcImZvbnQtZmFtaWx5XCIsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZC5mb250O1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sb3IoZFtyZWxhdGlvbk1hcC52YWx1ZV0pO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuYXR0cihcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpXHJcbiAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLnRleHQ7IH0pXHJcbiAgICAgICAgICAgIC5vbihcIm1vdXNlb3ZlclwiLCBmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICAgICAgLy9HZXQgdGlwIGRhdGFcclxuICAgICAgICAgICAgICAgIHZhciB0aXBEYXRhID0gY2hhcnQuc2V0VGlwRGF0YShkLCBpKTtcclxuICAgICAgICAgICAgICAgIHRpcERhdGEuY29sb3IgPSBjb2xvcihkW3JlbGF0aW9uTWFwLnZhbHVlXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9EcmF3IHRpcFxyXG4gICAgICAgICAgICAgICAgY2hhcnQudGlwLmdlbmVyYXRlU2ltcGxlVGlwKHRpcERhdGEsIGNoYXJ0LmRhdGEuZGF0YVRhYmxlKTtcclxuICAgICAgICAgICAgICAgIGNoYXJ0LnRpcC5kID0gZDtcclxuICAgICAgICAgICAgICAgIGNoYXJ0LnRpcC5pID0gaTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLm9uKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoYXJ0LnNob3dUb29sVGlwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJ0LnRpcC5kID09PSBkICYmIGNoYXJ0LnRpcC5pID09PSBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJ0LnRpcC5zaG93VGlwKGQzLmV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL0dldCB0aXAgZGF0YVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGlwRGF0YSA9IGNoYXJ0LnNldFRpcERhdGEoZCwgaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vRHJhdyB0aXAgbGluZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFydC50aXAuZ2VuZXJhdGVTaW1wbGVUaXAodGlwRGF0YSwgY2hhcnQuZGF0YS5kYXRhVGFibGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLm9uKFwibW91c2VvdXRcIiwgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgIGNoYXJ0LnRpcC5oaWRlVGlwKCk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC50cmFuc2l0aW9uKCkuZHVyYXRpb24oXCIxMDAwXCIpXHJcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uIChkKSB7IHJldHVybiBcInRyYW5zbGF0ZShcIiArIFtkLngsIGQueV0gKyBcIilyb3RhdGUoXCIgKyBkLnJvdGF0ZSArIFwiKVwiOyB9KTtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGp2Q2hhcnRzO1xyXG4iXX0=
